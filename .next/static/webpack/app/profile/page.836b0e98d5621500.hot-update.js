"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/profile/page",{

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.browser.development.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.browser.development.js ***!
  \******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * @license React\n * react-dom-server-legacy.browser.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        var _s = $RefreshSig$(), _s1 = $RefreshSig$();\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        var ReactDOM = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n        var ReactVersion = \"18.3.0-canary-60a927d04-20240113\";\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        // by calls to these methods by a Babel plugin.\n        //\n        // In PROD (or in packages without access to React internals),\n        // they are left as they are instead.\n        function warn(format) {\n            {\n                {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    printWarning(\"warn\", format, args);\n                }\n            }\n        }\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // A pure JS implementation of a string hashing function. We do not use it for\n        // security or obfuscation purposes, only to create compact hashes. So we\n        // prioritize speed over collision avoidance. For example, we use this to hash\n        // the component key path used by useFormState for MPA-style submissions.\n        //\n        // In environments where built-in hashing functions are available, we prefer\n        // those instead. Like Node's crypto module, or Bun.hash. Unfortunately this\n        // does not include the web standard crypto API because those methods are all\n        // async. For our purposes, we need it to be sync because the cost of context\n        // switching is too high to be worth it.\n        //\n        // The most popular hashing algorithm that meets these requirements in the JS\n        // ecosystem is MurmurHash3, and almost all implementations I could find used\n        // some version of the implementation by Gary Court inlined below.\n        function createFastHashJS(key) {\n            return murmurhash3_32_gc(key, 0);\n        }\n        /* eslint-disable prefer-const, no-fallthrough */ /**\n * @license\n *\n * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\n *\n * Copyright (c) 2011 Gary Court\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */ function murmurhash3_32_gc(key, seed) {\n            var remainder, bytes, h1, h1b, c1, c2, k1, i;\n            remainder = key.length & 3; // key.length % 4\n            bytes = key.length - remainder;\n            h1 = seed;\n            c1 = 0xcc9e2d51;\n            c2 = 0x1b873593;\n            i = 0;\n            while(i < bytes){\n                k1 = key.charCodeAt(i) & 0xff | (key.charCodeAt(++i) & 0xff) << 8 | (key.charCodeAt(++i) & 0xff) << 16 | (key.charCodeAt(++i) & 0xff) << 24;\n                ++i;\n                k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;\n                h1 ^= k1;\n                h1 = h1 << 13 | h1 >>> 19;\n                h1b = (h1 & 0xffff) * 5 + (((h1 >>> 16) * 5 & 0xffff) << 16) & 0xffffffff;\n                h1 = (h1b & 0xffff) + 0x6b64 + (((h1b >>> 16) + 0xe654 & 0xffff) << 16);\n            }\n            k1 = 0;\n            switch(remainder){\n                case 3:\n                    k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;\n                case 2:\n                    k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;\n                case 1:\n                    k1 ^= key.charCodeAt(i) & 0xff;\n                    k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;\n                    k1 = k1 << 15 | k1 >>> 17;\n                    k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;\n                    h1 ^= k1;\n            }\n            h1 ^= key.length;\n            h1 ^= h1 >>> 16;\n            h1 = (h1 & 0xffff) * 0x85ebca6b + (((h1 >>> 16) * 0x85ebca6b & 0xffff) << 16) & 0xffffffff;\n            h1 ^= h1 >>> 13;\n            h1 = (h1 & 0xffff) * 0xc2b2ae35 + (((h1 >>> 16) * 0xc2b2ae35 & 0xffff) << 16) & 0xffffffff;\n            h1 ^= h1 >>> 16;\n            return h1 >>> 0;\n        }\n        function scheduleWork(callback) {\n            callback();\n        }\n        function beginWriting(destination) {}\n        function writeChunk(destination, chunk) {\n            writeChunkAndReturn(destination, chunk);\n        }\n        function writeChunkAndReturn(destination, chunk) {\n            return destination.push(chunk);\n        }\n        function completeWriting(destination) {}\n        function close(destination) {\n            destination.push(null);\n        }\n        function stringToChunk(content) {\n            return content;\n        }\n        function stringToPrecomputedChunk(content) {\n            return content;\n        }\n        function clonePrecomputedChunk(chunk) {\n            return chunk;\n        }\n        function closeWithError(destination, error) {\n            // $FlowFixMe[incompatible-call]: This is an Error object or the destination accepts other types.\n            destination.destroy(error);\n        }\n        var assign = Object.assign;\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkAttributeStringCoercion(value, attributeName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` attribute is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", attributeName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkOptionStringCoercion(value, propName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` option is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", propName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkCSSPropertyStringCoercion(value, propName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` CSS property is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", propName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkHtmlStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided HTML markup uses a value of unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableFloat = true; // Enables unstable_useMemoCache hook, intended as a compilation target for\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        /* eslint-disable max-len */ var ATTRIBUTE_NAME_START_CHAR = \":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n        /* eslint-enable max-len */ var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + \"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp(\"^[\" + ATTRIBUTE_NAME_START_CHAR + \"][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var illegalAttributeNameCache = {};\n        var validatedAttributeNameCache = {};\n        function isAttributeNameSafe(attributeName) {\n            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {\n                return true;\n            }\n            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {\n                return false;\n            }\n            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n                validatedAttributeNameCache[attributeName] = true;\n                return true;\n            }\n            illegalAttributeNameCache[attributeName] = true;\n            {\n                error(\"Invalid attribute name: `%s`\", attributeName);\n            }\n            return false;\n        }\n        /**\n * CSS properties which accept numbers but are not in units of \"px\".\n */ var unitlessNumbers = new Set([\n            \"animationIterationCount\",\n            \"aspectRatio\",\n            \"borderImageOutset\",\n            \"borderImageSlice\",\n            \"borderImageWidth\",\n            \"boxFlex\",\n            \"boxFlexGroup\",\n            \"boxOrdinalGroup\",\n            \"columnCount\",\n            \"columns\",\n            \"flex\",\n            \"flexGrow\",\n            \"flexPositive\",\n            \"flexShrink\",\n            \"flexNegative\",\n            \"flexOrder\",\n            \"gridArea\",\n            \"gridRow\",\n            \"gridRowEnd\",\n            \"gridRowSpan\",\n            \"gridRowStart\",\n            \"gridColumn\",\n            \"gridColumnEnd\",\n            \"gridColumnSpan\",\n            \"gridColumnStart\",\n            \"fontWeight\",\n            \"lineClamp\",\n            \"lineHeight\",\n            \"opacity\",\n            \"order\",\n            \"orphans\",\n            \"scale\",\n            \"tabSize\",\n            \"widows\",\n            \"zIndex\",\n            \"zoom\",\n            \"fillOpacity\",\n            \"floodOpacity\",\n            \"stopOpacity\",\n            \"strokeDasharray\",\n            \"strokeDashoffset\",\n            \"strokeMiterlimit\",\n            \"strokeOpacity\",\n            \"strokeWidth\",\n            \"MozAnimationIterationCount\",\n            \"MozBoxFlex\",\n            \"MozBoxFlexGroup\",\n            \"MozLineClamp\",\n            \"msAnimationIterationCount\",\n            \"msFlex\",\n            \"msZoom\",\n            \"msFlexGrow\",\n            \"msFlexNegative\",\n            \"msFlexOrder\",\n            \"msFlexPositive\",\n            \"msFlexShrink\",\n            \"msGridColumn\",\n            \"msGridColumnSpan\",\n            \"msGridRow\",\n            \"msGridRowSpan\",\n            \"WebkitAnimationIterationCount\",\n            \"WebkitBoxFlex\",\n            \"WebKitBoxFlexGroup\",\n            \"WebkitBoxOrdinalGroup\",\n            \"WebkitColumnCount\",\n            \"WebkitColumns\",\n            \"WebkitFlex\",\n            \"WebkitFlexGrow\",\n            \"WebkitFlexPositive\",\n            \"WebkitFlexShrink\",\n            \"WebkitLineClamp\"\n        ]);\n        function isUnitlessNumber(name) {\n            return unitlessNumbers.has(name);\n        }\n        var aliases = new Map([\n            [\n                \"acceptCharset\",\n                \"accept-charset\"\n            ],\n            [\n                \"htmlFor\",\n                \"for\"\n            ],\n            [\n                \"httpEquiv\",\n                \"http-equiv\"\n            ],\n            [\n                \"crossOrigin\",\n                \"crossorigin\"\n            ],\n            // Regular attributes that just accept strings.],\n            [\n                \"accentHeight\",\n                \"accent-height\"\n            ],\n            [\n                \"alignmentBaseline\",\n                \"alignment-baseline\"\n            ],\n            [\n                \"arabicForm\",\n                \"arabic-form\"\n            ],\n            [\n                \"baselineShift\",\n                \"baseline-shift\"\n            ],\n            [\n                \"capHeight\",\n                \"cap-height\"\n            ],\n            [\n                \"clipPath\",\n                \"clip-path\"\n            ],\n            [\n                \"clipRule\",\n                \"clip-rule\"\n            ],\n            [\n                \"colorInterpolation\",\n                \"color-interpolation\"\n            ],\n            [\n                \"colorInterpolationFilters\",\n                \"color-interpolation-filters\"\n            ],\n            [\n                \"colorProfile\",\n                \"color-profile\"\n            ],\n            [\n                \"colorRendering\",\n                \"color-rendering\"\n            ],\n            [\n                \"dominantBaseline\",\n                \"dominant-baseline\"\n            ],\n            [\n                \"enableBackground\",\n                \"enable-background\"\n            ],\n            [\n                \"fillOpacity\",\n                \"fill-opacity\"\n            ],\n            [\n                \"fillRule\",\n                \"fill-rule\"\n            ],\n            [\n                \"floodColor\",\n                \"flood-color\"\n            ],\n            [\n                \"floodOpacity\",\n                \"flood-opacity\"\n            ],\n            [\n                \"fontFamily\",\n                \"font-family\"\n            ],\n            [\n                \"fontSize\",\n                \"font-size\"\n            ],\n            [\n                \"fontSizeAdjust\",\n                \"font-size-adjust\"\n            ],\n            [\n                \"fontStretch\",\n                \"font-stretch\"\n            ],\n            [\n                \"fontStyle\",\n                \"font-style\"\n            ],\n            [\n                \"fontVariant\",\n                \"font-variant\"\n            ],\n            [\n                \"fontWeight\",\n                \"font-weight\"\n            ],\n            [\n                \"glyphName\",\n                \"glyph-name\"\n            ],\n            [\n                \"glyphOrientationHorizontal\",\n                \"glyph-orientation-horizontal\"\n            ],\n            [\n                \"glyphOrientationVertical\",\n                \"glyph-orientation-vertical\"\n            ],\n            [\n                \"horizAdvX\",\n                \"horiz-adv-x\"\n            ],\n            [\n                \"horizOriginX\",\n                \"horiz-origin-x\"\n            ],\n            [\n                \"imageRendering\",\n                \"image-rendering\"\n            ],\n            [\n                \"letterSpacing\",\n                \"letter-spacing\"\n            ],\n            [\n                \"lightingColor\",\n                \"lighting-color\"\n            ],\n            [\n                \"markerEnd\",\n                \"marker-end\"\n            ],\n            [\n                \"markerMid\",\n                \"marker-mid\"\n            ],\n            [\n                \"markerStart\",\n                \"marker-start\"\n            ],\n            [\n                \"overlinePosition\",\n                \"overline-position\"\n            ],\n            [\n                \"overlineThickness\",\n                \"overline-thickness\"\n            ],\n            [\n                \"paintOrder\",\n                \"paint-order\"\n            ],\n            [\n                \"panose-1\",\n                \"panose-1\"\n            ],\n            [\n                \"pointerEvents\",\n                \"pointer-events\"\n            ],\n            [\n                \"renderingIntent\",\n                \"rendering-intent\"\n            ],\n            [\n                \"shapeRendering\",\n                \"shape-rendering\"\n            ],\n            [\n                \"stopColor\",\n                \"stop-color\"\n            ],\n            [\n                \"stopOpacity\",\n                \"stop-opacity\"\n            ],\n            [\n                \"strikethroughPosition\",\n                \"strikethrough-position\"\n            ],\n            [\n                \"strikethroughThickness\",\n                \"strikethrough-thickness\"\n            ],\n            [\n                \"strokeDasharray\",\n                \"stroke-dasharray\"\n            ],\n            [\n                \"strokeDashoffset\",\n                \"stroke-dashoffset\"\n            ],\n            [\n                \"strokeLinecap\",\n                \"stroke-linecap\"\n            ],\n            [\n                \"strokeLinejoin\",\n                \"stroke-linejoin\"\n            ],\n            [\n                \"strokeMiterlimit\",\n                \"stroke-miterlimit\"\n            ],\n            [\n                \"strokeOpacity\",\n                \"stroke-opacity\"\n            ],\n            [\n                \"strokeWidth\",\n                \"stroke-width\"\n            ],\n            [\n                \"textAnchor\",\n                \"text-anchor\"\n            ],\n            [\n                \"textDecoration\",\n                \"text-decoration\"\n            ],\n            [\n                \"textRendering\",\n                \"text-rendering\"\n            ],\n            [\n                \"transformOrigin\",\n                \"transform-origin\"\n            ],\n            [\n                \"underlinePosition\",\n                \"underline-position\"\n            ],\n            [\n                \"underlineThickness\",\n                \"underline-thickness\"\n            ],\n            [\n                \"unicodeBidi\",\n                \"unicode-bidi\"\n            ],\n            [\n                \"unicodeRange\",\n                \"unicode-range\"\n            ],\n            [\n                \"unitsPerEm\",\n                \"units-per-em\"\n            ],\n            [\n                \"vAlphabetic\",\n                \"v-alphabetic\"\n            ],\n            [\n                \"vHanging\",\n                \"v-hanging\"\n            ],\n            [\n                \"vIdeographic\",\n                \"v-ideographic\"\n            ],\n            [\n                \"vMathematical\",\n                \"v-mathematical\"\n            ],\n            [\n                \"vectorEffect\",\n                \"vector-effect\"\n            ],\n            [\n                \"vertAdvY\",\n                \"vert-adv-y\"\n            ],\n            [\n                \"vertOriginX\",\n                \"vert-origin-x\"\n            ],\n            [\n                \"vertOriginY\",\n                \"vert-origin-y\"\n            ],\n            [\n                \"wordSpacing\",\n                \"word-spacing\"\n            ],\n            [\n                \"writingMode\",\n                \"writing-mode\"\n            ],\n            [\n                \"xmlnsXlink\",\n                \"xmlns:xlink\"\n            ],\n            [\n                \"xHeight\",\n                \"x-height\"\n            ]\n        ]);\n        function getAttributeAlias(name) {\n            return aliases.get(name) || name;\n        }\n        var hasReadOnlyValue = {\n            button: true,\n            checkbox: true,\n            image: true,\n            hidden: true,\n            radio: true,\n            reset: true,\n            submit: true\n        };\n        function checkControlledValueProps(tagName, props) {\n            {\n                if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {\n                    if (tagName === \"select\") {\n                        error(\"You provided a `value` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultValue`. Otherwise, set `onChange`.\");\n                    } else {\n                        error(\"You provided a `value` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.\");\n                    }\n                }\n                if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {\n                    error(\"You provided a `checked` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultChecked`. Otherwise, \" + \"set either `onChange` or `readOnly`.\");\n                }\n            }\n        }\n        var ariaProperties = {\n            \"aria-current\": 0,\n            // state\n            \"aria-description\": 0,\n            \"aria-details\": 0,\n            \"aria-disabled\": 0,\n            // state\n            \"aria-hidden\": 0,\n            // state\n            \"aria-invalid\": 0,\n            // state\n            \"aria-keyshortcuts\": 0,\n            \"aria-label\": 0,\n            \"aria-roledescription\": 0,\n            // Widget Attributes\n            \"aria-autocomplete\": 0,\n            \"aria-checked\": 0,\n            \"aria-expanded\": 0,\n            \"aria-haspopup\": 0,\n            \"aria-level\": 0,\n            \"aria-modal\": 0,\n            \"aria-multiline\": 0,\n            \"aria-multiselectable\": 0,\n            \"aria-orientation\": 0,\n            \"aria-placeholder\": 0,\n            \"aria-pressed\": 0,\n            \"aria-readonly\": 0,\n            \"aria-required\": 0,\n            \"aria-selected\": 0,\n            \"aria-sort\": 0,\n            \"aria-valuemax\": 0,\n            \"aria-valuemin\": 0,\n            \"aria-valuenow\": 0,\n            \"aria-valuetext\": 0,\n            // Live Region Attributes\n            \"aria-atomic\": 0,\n            \"aria-busy\": 0,\n            \"aria-live\": 0,\n            \"aria-relevant\": 0,\n            // Drag-and-Drop Attributes\n            \"aria-dropeffect\": 0,\n            \"aria-grabbed\": 0,\n            // Relationship Attributes\n            \"aria-activedescendant\": 0,\n            \"aria-colcount\": 0,\n            \"aria-colindex\": 0,\n            \"aria-colspan\": 0,\n            \"aria-controls\": 0,\n            \"aria-describedby\": 0,\n            \"aria-errormessage\": 0,\n            \"aria-flowto\": 0,\n            \"aria-labelledby\": 0,\n            \"aria-owns\": 0,\n            \"aria-posinset\": 0,\n            \"aria-rowcount\": 0,\n            \"aria-rowindex\": 0,\n            \"aria-rowspan\": 0,\n            \"aria-setsize\": 0\n        };\n        var warnedProperties$1 = {};\n        var rARIA$1 = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var rARIACamel$1 = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        function validateProperty$1(tagName, name) {\n            {\n                if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n                    return true;\n                }\n                if (rARIACamel$1.test(name)) {\n                    var ariaName = \"aria-\" + name.slice(4).toLowerCase();\n                    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n                    // DOM properties, then it is an invalid aria-* attribute.\n                    if (correctName == null) {\n                        error(\"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\", name);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    } // aria-* attributes should be lowercase; suggest the lowercase version.\n                    if (name !== correctName) {\n                        error(\"Invalid ARIA attribute `%s`. Did you mean `%s`?\", name, correctName);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    }\n                }\n                if (rARIA$1.test(name)) {\n                    var lowerCasedName = name.toLowerCase();\n                    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n                    // DOM properties, then it is an invalid aria-* attribute.\n                    if (standardName == null) {\n                        warnedProperties$1[name] = true;\n                        return false;\n                    } // aria-* attributes should be lowercase; suggest the lowercase version.\n                    if (name !== standardName) {\n                        error(\"Unknown ARIA attribute `%s`. Did you mean `%s`?\", name, standardName);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    }\n                }\n            }\n            return true;\n        }\n        function validateProperties$2(type, props) {\n            {\n                var invalidProps = [];\n                for(var key in props){\n                    var isValid = validateProperty$1(type, key);\n                    if (!isValid) {\n                        invalidProps.push(key);\n                    }\n                }\n                var unknownPropString = invalidProps.map(function(prop) {\n                    return \"`\" + prop + \"`\";\n                }).join(\", \");\n                if (invalidProps.length === 1) {\n                    error(\"Invalid aria prop %s on <%s> tag. \" + \"For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n                } else if (invalidProps.length > 1) {\n                    error(\"Invalid aria props %s on <%s> tag. \" + \"For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n                }\n            }\n        }\n        var didWarnValueNull = false;\n        function validateProperties$1(type, props) {\n            {\n                if (type !== \"input\" && type !== \"textarea\" && type !== \"select\") {\n                    return;\n                }\n                if (props != null && props.value === null && !didWarnValueNull) {\n                    didWarnValueNull = true;\n                    if (type === \"select\" && props.multiple) {\n                        error(\"`value` prop on `%s` should not be null. \" + \"Consider using an empty array when `multiple` is set to `true` \" + \"to clear the component or `undefined` for uncontrolled components.\", type);\n                    } else {\n                        error(\"`value` prop on `%s` should not be null. \" + \"Consider using an empty string to clear the component or `undefined` \" + \"for uncontrolled components.\", type);\n                    }\n                }\n            }\n        }\n        function isCustomElement(tagName, props) {\n            if (tagName.indexOf(\"-\") === -1) {\n                return false;\n            }\n            switch(tagName){\n                // These are reserved SVG and MathML elements.\n                // We don't mind this list too much because we expect it to never grow.\n                // The alternative is to track the namespace in a few places which is convoluted.\n                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n                case \"annotation-xml\":\n                case \"color-profile\":\n                case \"font-face\":\n                case \"font-face-src\":\n                case \"font-face-uri\":\n                case \"font-face-format\":\n                case \"font-face-name\":\n                case \"missing-glyph\":\n                    return false;\n                default:\n                    return true;\n            }\n        }\n        // When adding attributes to the HTML or SVG allowed attribute list, be sure to\n        // also add them to this module to ensure casing and incorrect name\n        // warnings.\n        var possibleStandardNames = {\n            // HTML\n            accept: \"accept\",\n            acceptcharset: \"acceptCharset\",\n            \"accept-charset\": \"acceptCharset\",\n            accesskey: \"accessKey\",\n            action: \"action\",\n            allowfullscreen: \"allowFullScreen\",\n            alt: \"alt\",\n            as: \"as\",\n            async: \"async\",\n            autocapitalize: \"autoCapitalize\",\n            autocomplete: \"autoComplete\",\n            autocorrect: \"autoCorrect\",\n            autofocus: \"autoFocus\",\n            autoplay: \"autoPlay\",\n            autosave: \"autoSave\",\n            capture: \"capture\",\n            cellpadding: \"cellPadding\",\n            cellspacing: \"cellSpacing\",\n            challenge: \"challenge\",\n            charset: \"charSet\",\n            checked: \"checked\",\n            children: \"children\",\n            cite: \"cite\",\n            class: \"className\",\n            classid: \"classID\",\n            classname: \"className\",\n            cols: \"cols\",\n            colspan: \"colSpan\",\n            content: \"content\",\n            contenteditable: \"contentEditable\",\n            contextmenu: \"contextMenu\",\n            controls: \"controls\",\n            controlslist: \"controlsList\",\n            coords: \"coords\",\n            crossorigin: \"crossOrigin\",\n            dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n            data: \"data\",\n            datetime: \"dateTime\",\n            default: \"default\",\n            defaultchecked: \"defaultChecked\",\n            defaultvalue: \"defaultValue\",\n            defer: \"defer\",\n            dir: \"dir\",\n            disabled: \"disabled\",\n            disablepictureinpicture: \"disablePictureInPicture\",\n            disableremoteplayback: \"disableRemotePlayback\",\n            download: \"download\",\n            draggable: \"draggable\",\n            enctype: \"encType\",\n            enterkeyhint: \"enterKeyHint\",\n            fetchpriority: \"fetchPriority\",\n            for: \"htmlFor\",\n            form: \"form\",\n            formmethod: \"formMethod\",\n            formaction: \"formAction\",\n            formenctype: \"formEncType\",\n            formnovalidate: \"formNoValidate\",\n            formtarget: \"formTarget\",\n            frameborder: \"frameBorder\",\n            headers: \"headers\",\n            height: \"height\",\n            hidden: \"hidden\",\n            high: \"high\",\n            href: \"href\",\n            hreflang: \"hrefLang\",\n            htmlfor: \"htmlFor\",\n            httpequiv: \"httpEquiv\",\n            \"http-equiv\": \"httpEquiv\",\n            icon: \"icon\",\n            id: \"id\",\n            imagesizes: \"imageSizes\",\n            imagesrcset: \"imageSrcSet\",\n            innerhtml: \"innerHTML\",\n            inputmode: \"inputMode\",\n            integrity: \"integrity\",\n            is: \"is\",\n            itemid: \"itemID\",\n            itemprop: \"itemProp\",\n            itemref: \"itemRef\",\n            itemscope: \"itemScope\",\n            itemtype: \"itemType\",\n            keyparams: \"keyParams\",\n            keytype: \"keyType\",\n            kind: \"kind\",\n            label: \"label\",\n            lang: \"lang\",\n            list: \"list\",\n            loop: \"loop\",\n            low: \"low\",\n            manifest: \"manifest\",\n            marginwidth: \"marginWidth\",\n            marginheight: \"marginHeight\",\n            max: \"max\",\n            maxlength: \"maxLength\",\n            media: \"media\",\n            mediagroup: \"mediaGroup\",\n            method: \"method\",\n            min: \"min\",\n            minlength: \"minLength\",\n            multiple: \"multiple\",\n            muted: \"muted\",\n            name: \"name\",\n            nomodule: \"noModule\",\n            nonce: \"nonce\",\n            novalidate: \"noValidate\",\n            open: \"open\",\n            optimum: \"optimum\",\n            pattern: \"pattern\",\n            placeholder: \"placeholder\",\n            playsinline: \"playsInline\",\n            poster: \"poster\",\n            preload: \"preload\",\n            profile: \"profile\",\n            radiogroup: \"radioGroup\",\n            readonly: \"readOnly\",\n            referrerpolicy: \"referrerPolicy\",\n            rel: \"rel\",\n            required: \"required\",\n            reversed: \"reversed\",\n            role: \"role\",\n            rows: \"rows\",\n            rowspan: \"rowSpan\",\n            sandbox: \"sandbox\",\n            scope: \"scope\",\n            scoped: \"scoped\",\n            scrolling: \"scrolling\",\n            seamless: \"seamless\",\n            selected: \"selected\",\n            shape: \"shape\",\n            size: \"size\",\n            sizes: \"sizes\",\n            span: \"span\",\n            spellcheck: \"spellCheck\",\n            src: \"src\",\n            srcdoc: \"srcDoc\",\n            srclang: \"srcLang\",\n            srcset: \"srcSet\",\n            start: \"start\",\n            step: \"step\",\n            style: \"style\",\n            summary: \"summary\",\n            tabindex: \"tabIndex\",\n            target: \"target\",\n            title: \"title\",\n            type: \"type\",\n            usemap: \"useMap\",\n            value: \"value\",\n            width: \"width\",\n            wmode: \"wmode\",\n            wrap: \"wrap\",\n            // SVG\n            about: \"about\",\n            accentheight: \"accentHeight\",\n            \"accent-height\": \"accentHeight\",\n            accumulate: \"accumulate\",\n            additive: \"additive\",\n            alignmentbaseline: \"alignmentBaseline\",\n            \"alignment-baseline\": \"alignmentBaseline\",\n            allowreorder: \"allowReorder\",\n            alphabetic: \"alphabetic\",\n            amplitude: \"amplitude\",\n            arabicform: \"arabicForm\",\n            \"arabic-form\": \"arabicForm\",\n            ascent: \"ascent\",\n            attributename: \"attributeName\",\n            attributetype: \"attributeType\",\n            autoreverse: \"autoReverse\",\n            azimuth: \"azimuth\",\n            basefrequency: \"baseFrequency\",\n            baselineshift: \"baselineShift\",\n            \"baseline-shift\": \"baselineShift\",\n            baseprofile: \"baseProfile\",\n            bbox: \"bbox\",\n            begin: \"begin\",\n            bias: \"bias\",\n            by: \"by\",\n            calcmode: \"calcMode\",\n            capheight: \"capHeight\",\n            \"cap-height\": \"capHeight\",\n            clip: \"clip\",\n            clippath: \"clipPath\",\n            \"clip-path\": \"clipPath\",\n            clippathunits: \"clipPathUnits\",\n            cliprule: \"clipRule\",\n            \"clip-rule\": \"clipRule\",\n            color: \"color\",\n            colorinterpolation: \"colorInterpolation\",\n            \"color-interpolation\": \"colorInterpolation\",\n            colorinterpolationfilters: \"colorInterpolationFilters\",\n            \"color-interpolation-filters\": \"colorInterpolationFilters\",\n            colorprofile: \"colorProfile\",\n            \"color-profile\": \"colorProfile\",\n            colorrendering: \"colorRendering\",\n            \"color-rendering\": \"colorRendering\",\n            contentscripttype: \"contentScriptType\",\n            contentstyletype: \"contentStyleType\",\n            cursor: \"cursor\",\n            cx: \"cx\",\n            cy: \"cy\",\n            d: \"d\",\n            datatype: \"datatype\",\n            decelerate: \"decelerate\",\n            descent: \"descent\",\n            diffuseconstant: \"diffuseConstant\",\n            direction: \"direction\",\n            display: \"display\",\n            divisor: \"divisor\",\n            dominantbaseline: \"dominantBaseline\",\n            \"dominant-baseline\": \"dominantBaseline\",\n            dur: \"dur\",\n            dx: \"dx\",\n            dy: \"dy\",\n            edgemode: \"edgeMode\",\n            elevation: \"elevation\",\n            enablebackground: \"enableBackground\",\n            \"enable-background\": \"enableBackground\",\n            end: \"end\",\n            exponent: \"exponent\",\n            externalresourcesrequired: \"externalResourcesRequired\",\n            fill: \"fill\",\n            fillopacity: \"fillOpacity\",\n            \"fill-opacity\": \"fillOpacity\",\n            fillrule: \"fillRule\",\n            \"fill-rule\": \"fillRule\",\n            filter: \"filter\",\n            filterres: \"filterRes\",\n            filterunits: \"filterUnits\",\n            floodopacity: \"floodOpacity\",\n            \"flood-opacity\": \"floodOpacity\",\n            floodcolor: \"floodColor\",\n            \"flood-color\": \"floodColor\",\n            focusable: \"focusable\",\n            fontfamily: \"fontFamily\",\n            \"font-family\": \"fontFamily\",\n            fontsize: \"fontSize\",\n            \"font-size\": \"fontSize\",\n            fontsizeadjust: \"fontSizeAdjust\",\n            \"font-size-adjust\": \"fontSizeAdjust\",\n            fontstretch: \"fontStretch\",\n            \"font-stretch\": \"fontStretch\",\n            fontstyle: \"fontStyle\",\n            \"font-style\": \"fontStyle\",\n            fontvariant: \"fontVariant\",\n            \"font-variant\": \"fontVariant\",\n            fontweight: \"fontWeight\",\n            \"font-weight\": \"fontWeight\",\n            format: \"format\",\n            from: \"from\",\n            fx: \"fx\",\n            fy: \"fy\",\n            g1: \"g1\",\n            g2: \"g2\",\n            glyphname: \"glyphName\",\n            \"glyph-name\": \"glyphName\",\n            glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n            \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n            glyphorientationvertical: \"glyphOrientationVertical\",\n            \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n            glyphref: \"glyphRef\",\n            gradienttransform: \"gradientTransform\",\n            gradientunits: \"gradientUnits\",\n            hanging: \"hanging\",\n            horizadvx: \"horizAdvX\",\n            \"horiz-adv-x\": \"horizAdvX\",\n            horizoriginx: \"horizOriginX\",\n            \"horiz-origin-x\": \"horizOriginX\",\n            ideographic: \"ideographic\",\n            imagerendering: \"imageRendering\",\n            \"image-rendering\": \"imageRendering\",\n            in2: \"in2\",\n            in: \"in\",\n            inlist: \"inlist\",\n            intercept: \"intercept\",\n            k1: \"k1\",\n            k2: \"k2\",\n            k3: \"k3\",\n            k4: \"k4\",\n            k: \"k\",\n            kernelmatrix: \"kernelMatrix\",\n            kernelunitlength: \"kernelUnitLength\",\n            kerning: \"kerning\",\n            keypoints: \"keyPoints\",\n            keysplines: \"keySplines\",\n            keytimes: \"keyTimes\",\n            lengthadjust: \"lengthAdjust\",\n            letterspacing: \"letterSpacing\",\n            \"letter-spacing\": \"letterSpacing\",\n            lightingcolor: \"lightingColor\",\n            \"lighting-color\": \"lightingColor\",\n            limitingconeangle: \"limitingConeAngle\",\n            local: \"local\",\n            markerend: \"markerEnd\",\n            \"marker-end\": \"markerEnd\",\n            markerheight: \"markerHeight\",\n            markermid: \"markerMid\",\n            \"marker-mid\": \"markerMid\",\n            markerstart: \"markerStart\",\n            \"marker-start\": \"markerStart\",\n            markerunits: \"markerUnits\",\n            markerwidth: \"markerWidth\",\n            mask: \"mask\",\n            maskcontentunits: \"maskContentUnits\",\n            maskunits: \"maskUnits\",\n            mathematical: \"mathematical\",\n            mode: \"mode\",\n            numoctaves: \"numOctaves\",\n            offset: \"offset\",\n            opacity: \"opacity\",\n            operator: \"operator\",\n            order: \"order\",\n            orient: \"orient\",\n            orientation: \"orientation\",\n            origin: \"origin\",\n            overflow: \"overflow\",\n            overlineposition: \"overlinePosition\",\n            \"overline-position\": \"overlinePosition\",\n            overlinethickness: \"overlineThickness\",\n            \"overline-thickness\": \"overlineThickness\",\n            paintorder: \"paintOrder\",\n            \"paint-order\": \"paintOrder\",\n            panose1: \"panose1\",\n            \"panose-1\": \"panose1\",\n            pathlength: \"pathLength\",\n            patterncontentunits: \"patternContentUnits\",\n            patterntransform: \"patternTransform\",\n            patternunits: \"patternUnits\",\n            pointerevents: \"pointerEvents\",\n            \"pointer-events\": \"pointerEvents\",\n            points: \"points\",\n            pointsatx: \"pointsAtX\",\n            pointsaty: \"pointsAtY\",\n            pointsatz: \"pointsAtZ\",\n            prefix: \"prefix\",\n            preservealpha: \"preserveAlpha\",\n            preserveaspectratio: \"preserveAspectRatio\",\n            primitiveunits: \"primitiveUnits\",\n            property: \"property\",\n            r: \"r\",\n            radius: \"radius\",\n            refx: \"refX\",\n            refy: \"refY\",\n            renderingintent: \"renderingIntent\",\n            \"rendering-intent\": \"renderingIntent\",\n            repeatcount: \"repeatCount\",\n            repeatdur: \"repeatDur\",\n            requiredextensions: \"requiredExtensions\",\n            requiredfeatures: \"requiredFeatures\",\n            resource: \"resource\",\n            restart: \"restart\",\n            result: \"result\",\n            results: \"results\",\n            rotate: \"rotate\",\n            rx: \"rx\",\n            ry: \"ry\",\n            scale: \"scale\",\n            security: \"security\",\n            seed: \"seed\",\n            shaperendering: \"shapeRendering\",\n            \"shape-rendering\": \"shapeRendering\",\n            slope: \"slope\",\n            spacing: \"spacing\",\n            specularconstant: \"specularConstant\",\n            specularexponent: \"specularExponent\",\n            speed: \"speed\",\n            spreadmethod: \"spreadMethod\",\n            startoffset: \"startOffset\",\n            stddeviation: \"stdDeviation\",\n            stemh: \"stemh\",\n            stemv: \"stemv\",\n            stitchtiles: \"stitchTiles\",\n            stopcolor: \"stopColor\",\n            \"stop-color\": \"stopColor\",\n            stopopacity: \"stopOpacity\",\n            \"stop-opacity\": \"stopOpacity\",\n            strikethroughposition: \"strikethroughPosition\",\n            \"strikethrough-position\": \"strikethroughPosition\",\n            strikethroughthickness: \"strikethroughThickness\",\n            \"strikethrough-thickness\": \"strikethroughThickness\",\n            string: \"string\",\n            stroke: \"stroke\",\n            strokedasharray: \"strokeDasharray\",\n            \"stroke-dasharray\": \"strokeDasharray\",\n            strokedashoffset: \"strokeDashoffset\",\n            \"stroke-dashoffset\": \"strokeDashoffset\",\n            strokelinecap: \"strokeLinecap\",\n            \"stroke-linecap\": \"strokeLinecap\",\n            strokelinejoin: \"strokeLinejoin\",\n            \"stroke-linejoin\": \"strokeLinejoin\",\n            strokemiterlimit: \"strokeMiterlimit\",\n            \"stroke-miterlimit\": \"strokeMiterlimit\",\n            strokewidth: \"strokeWidth\",\n            \"stroke-width\": \"strokeWidth\",\n            strokeopacity: \"strokeOpacity\",\n            \"stroke-opacity\": \"strokeOpacity\",\n            suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n            suppresshydrationwarning: \"suppressHydrationWarning\",\n            surfacescale: \"surfaceScale\",\n            systemlanguage: \"systemLanguage\",\n            tablevalues: \"tableValues\",\n            targetx: \"targetX\",\n            targety: \"targetY\",\n            textanchor: \"textAnchor\",\n            \"text-anchor\": \"textAnchor\",\n            textdecoration: \"textDecoration\",\n            \"text-decoration\": \"textDecoration\",\n            textlength: \"textLength\",\n            textrendering: \"textRendering\",\n            \"text-rendering\": \"textRendering\",\n            to: \"to\",\n            transform: \"transform\",\n            transformorigin: \"transformOrigin\",\n            \"transform-origin\": \"transformOrigin\",\n            typeof: \"typeof\",\n            u1: \"u1\",\n            u2: \"u2\",\n            underlineposition: \"underlinePosition\",\n            \"underline-position\": \"underlinePosition\",\n            underlinethickness: \"underlineThickness\",\n            \"underline-thickness\": \"underlineThickness\",\n            unicode: \"unicode\",\n            unicodebidi: \"unicodeBidi\",\n            \"unicode-bidi\": \"unicodeBidi\",\n            unicoderange: \"unicodeRange\",\n            \"unicode-range\": \"unicodeRange\",\n            unitsperem: \"unitsPerEm\",\n            \"units-per-em\": \"unitsPerEm\",\n            unselectable: \"unselectable\",\n            valphabetic: \"vAlphabetic\",\n            \"v-alphabetic\": \"vAlphabetic\",\n            values: \"values\",\n            vectoreffect: \"vectorEffect\",\n            \"vector-effect\": \"vectorEffect\",\n            version: \"version\",\n            vertadvy: \"vertAdvY\",\n            \"vert-adv-y\": \"vertAdvY\",\n            vertoriginx: \"vertOriginX\",\n            \"vert-origin-x\": \"vertOriginX\",\n            vertoriginy: \"vertOriginY\",\n            \"vert-origin-y\": \"vertOriginY\",\n            vhanging: \"vHanging\",\n            \"v-hanging\": \"vHanging\",\n            videographic: \"vIdeographic\",\n            \"v-ideographic\": \"vIdeographic\",\n            viewbox: \"viewBox\",\n            viewtarget: \"viewTarget\",\n            visibility: \"visibility\",\n            vmathematical: \"vMathematical\",\n            \"v-mathematical\": \"vMathematical\",\n            vocab: \"vocab\",\n            widths: \"widths\",\n            wordspacing: \"wordSpacing\",\n            \"word-spacing\": \"wordSpacing\",\n            writingmode: \"writingMode\",\n            \"writing-mode\": \"writingMode\",\n            x1: \"x1\",\n            x2: \"x2\",\n            x: \"x\",\n            xchannelselector: \"xChannelSelector\",\n            xheight: \"xHeight\",\n            \"x-height\": \"xHeight\",\n            xlinkactuate: \"xlinkActuate\",\n            \"xlink:actuate\": \"xlinkActuate\",\n            xlinkarcrole: \"xlinkArcrole\",\n            \"xlink:arcrole\": \"xlinkArcrole\",\n            xlinkhref: \"xlinkHref\",\n            \"xlink:href\": \"xlinkHref\",\n            xlinkrole: \"xlinkRole\",\n            \"xlink:role\": \"xlinkRole\",\n            xlinkshow: \"xlinkShow\",\n            \"xlink:show\": \"xlinkShow\",\n            xlinktitle: \"xlinkTitle\",\n            \"xlink:title\": \"xlinkTitle\",\n            xlinktype: \"xlinkType\",\n            \"xlink:type\": \"xlinkType\",\n            xmlbase: \"xmlBase\",\n            \"xml:base\": \"xmlBase\",\n            xmllang: \"xmlLang\",\n            \"xml:lang\": \"xmlLang\",\n            xmlns: \"xmlns\",\n            \"xml:space\": \"xmlSpace\",\n            xmlnsxlink: \"xmlnsXlink\",\n            \"xmlns:xlink\": \"xmlnsXlink\",\n            xmlspace: \"xmlSpace\",\n            y1: \"y1\",\n            y2: \"y2\",\n            y: \"y\",\n            ychannelselector: \"yChannelSelector\",\n            z: \"z\",\n            zoomandpan: \"zoomAndPan\"\n        };\n        var warnedProperties = {};\n        var EVENT_NAME_REGEX = /^on./;\n        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\n        var rARIA = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var rARIACamel = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        function validateProperty(tagName, name, value, eventRegistry) {\n            {\n                if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n                    return true;\n                }\n                var lowerCasedName = name.toLowerCase();\n                if (lowerCasedName === \"onfocusin\" || lowerCasedName === \"onfocusout\") {\n                    error(\"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. \" + \"All React events are normalized to bubble, so onFocusIn and onFocusOut \" + \"are not needed/supported by React.\");\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                {\n                    // Actions are special because unlike events they can have other value types.\n                    if (typeof value === \"function\") {\n                        if (tagName === \"form\" && name === \"action\") {\n                            return true;\n                        }\n                        if (tagName === \"input\" && name === \"formAction\") {\n                            return true;\n                        }\n                        if (tagName === \"button\" && name === \"formAction\") {\n                            return true;\n                        }\n                    }\n                }\n                if (eventRegistry != null) {\n                    var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;\n                    if (registrationNameDependencies.hasOwnProperty(name)) {\n                        return true;\n                    }\n                    var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\n                    if (registrationName != null) {\n                        error(\"Invalid event handler property `%s`. Did you mean `%s`?\", name, registrationName);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                    if (EVENT_NAME_REGEX.test(name)) {\n                        error(\"Unknown event handler property `%s`. It will be ignored.\", name);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                } else if (EVENT_NAME_REGEX.test(name)) {\n                    // If no event plugins have been injected, we are in a server environment.\n                    // So we can't tell if the event name is correct for sure, but we can filter\n                    // out known bad ones like `onclick`. We can't suggest a specific replacement though.\n                    if (INVALID_EVENT_NAME_REGEX.test(name)) {\n                        error(\"Invalid event handler property `%s`. \" + \"React events use the camelCase naming convention, for example `onClick`.\", name);\n                    }\n                    warnedProperties[name] = true;\n                    return true;\n                } // Let the ARIA attribute hook validate ARIA attributes\n                if (rARIA.test(name) || rARIACamel.test(name)) {\n                    return true;\n                }\n                if (lowerCasedName === \"innerhtml\") {\n                    error(\"Directly setting property `innerHTML` is not permitted. \" + \"For more information, lookup documentation on `dangerouslySetInnerHTML`.\");\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (lowerCasedName === \"aria\") {\n                    error(\"The `aria` attribute is reserved for future use in React. \" + \"Pass individual `aria-` attributes instead.\");\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (lowerCasedName === \"is\" && value !== null && value !== undefined && typeof value !== \"string\") {\n                    error(\"Received a `%s` for a string attribute `is`. If this is expected, cast \" + \"the value to a string.\", typeof value);\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (typeof value === \"number\" && isNaN(value)) {\n                    error(\"Received NaN for the `%s` attribute. If this is expected, cast \" + \"the value to a string.\", name);\n                    warnedProperties[name] = true;\n                    return true;\n                } // Known attributes should match the casing specified in the property config.\n                if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n                    var standardName = possibleStandardNames[lowerCasedName];\n                    if (standardName !== name) {\n                        error(\"Invalid DOM property `%s`. Did you mean `%s`?\", name, standardName);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                } else if (name !== lowerCasedName) {\n                    // Unknown attributes should have lowercase casing since that's how they\n                    // will be cased anyway with server rendering.\n                    error(\"React does not recognize the `%s` prop on a DOM element. If you \" + \"intentionally want it to appear in the DOM as a custom \" + \"attribute, spell it as lowercase `%s` instead. \" + \"If you accidentally passed it from a parent component, remove \" + \"it from the DOM element.\", name, lowerCasedName);\n                    warnedProperties[name] = true;\n                    return true;\n                } // Now that we've validated casing, do not validate\n                // data types for reserved props\n                switch(name){\n                    case \"dangerouslySetInnerHTML\":\n                    case \"children\":\n                    case \"style\":\n                    case \"suppressContentEditableWarning\":\n                    case \"suppressHydrationWarning\":\n                    case \"defaultValue\":\n                    case \"defaultChecked\":\n                    case \"innerHTML\":\n                        {\n                            return true;\n                        }\n                }\n                switch(typeof value){\n                    case \"boolean\":\n                        {\n                            switch(name){\n                                case \"autoFocus\":\n                                case \"checked\":\n                                case \"multiple\":\n                                case \"muted\":\n                                case \"selected\":\n                                case \"contentEditable\":\n                                case \"spellCheck\":\n                                case \"draggable\":\n                                case \"value\":\n                                case \"autoReverse\":\n                                case \"externalResourcesRequired\":\n                                case \"focusable\":\n                                case \"preserveAlpha\":\n                                case \"allowFullScreen\":\n                                case \"async\":\n                                case \"autoPlay\":\n                                case \"controls\":\n                                case \"default\":\n                                case \"defer\":\n                                case \"disabled\":\n                                case \"disablePictureInPicture\":\n                                case \"disableRemotePlayback\":\n                                case \"formNoValidate\":\n                                case \"hidden\":\n                                case \"loop\":\n                                case \"noModule\":\n                                case \"noValidate\":\n                                case \"open\":\n                                case \"playsInline\":\n                                case \"readOnly\":\n                                case \"required\":\n                                case \"reversed\":\n                                case \"scoped\":\n                                case \"seamless\":\n                                case \"itemScope\":\n                                case \"capture\":\n                                case \"download\":\n                                    {\n                                        // Boolean properties can accept boolean values\n                                        return true;\n                                    }\n                                default:\n                                    {\n                                        var prefix = name.toLowerCase().slice(0, 5);\n                                        if (prefix === \"data-\" || prefix === \"aria-\") {\n                                            return true;\n                                        }\n                                        if (value) {\n                                            error(\"Received `%s` for a non-boolean attribute `%s`.\\n\\n\" + \"If you want to write it to the DOM, pass a string instead: \" + '%s=\"%s\" or %s={value.toString()}.', value, name, name, value, name);\n                                        } else {\n                                            error(\"Received `%s` for a non-boolean attribute `%s`.\\n\\n\" + \"If you want to write it to the DOM, pass a string instead: \" + '%s=\"%s\" or %s={value.toString()}.\\n\\n' + \"If you used to conditionally omit it with %s={condition && value}, \" + \"pass %s={condition ? value : undefined} instead.\", value, name, name, value, name, name, name);\n                                        }\n                                        warnedProperties[name] = true;\n                                        return true;\n                                    }\n                            }\n                        }\n                    case \"function\":\n                    case \"symbol\":\n                        // eslint-disable-line\n                        // Warn when a known attribute is a bad type\n                        warnedProperties[name] = true;\n                        return false;\n                    case \"string\":\n                        {\n                            // Warn when passing the strings 'false' or 'true' into a boolean prop\n                            if (value === \"false\" || value === \"true\") {\n                                switch(name){\n                                    case \"checked\":\n                                    case \"selected\":\n                                    case \"multiple\":\n                                    case \"muted\":\n                                    case \"allowFullScreen\":\n                                    case \"async\":\n                                    case \"autoPlay\":\n                                    case \"controls\":\n                                    case \"default\":\n                                    case \"defer\":\n                                    case \"disabled\":\n                                    case \"disablePictureInPicture\":\n                                    case \"disableRemotePlayback\":\n                                    case \"formNoValidate\":\n                                    case \"hidden\":\n                                    case \"loop\":\n                                    case \"noModule\":\n                                    case \"noValidate\":\n                                    case \"open\":\n                                    case \"playsInline\":\n                                    case \"readOnly\":\n                                    case \"required\":\n                                    case \"reversed\":\n                                    case \"scoped\":\n                                    case \"seamless\":\n                                    case \"itemScope\":\n                                        {\n                                            break;\n                                        }\n                                    default:\n                                        {\n                                            return true;\n                                        }\n                                }\n                                error(\"Received the string `%s` for the boolean attribute `%s`. \" + \"%s \" + \"Did you mean %s={%s}?\", value, name, value === \"false\" ? \"The browser will interpret it as a truthy value.\" : 'Although this works, it will not work as expected if you pass the string \"false\".', name, value);\n                                warnedProperties[name] = true;\n                                return true;\n                            }\n                        }\n                }\n                return true;\n            }\n        }\n        function warnUnknownProperties(type, props, eventRegistry) {\n            {\n                var unknownProps = [];\n                for(var key in props){\n                    var isValid = validateProperty(type, key, props[key], eventRegistry);\n                    if (!isValid) {\n                        unknownProps.push(key);\n                    }\n                }\n                var unknownPropString = unknownProps.map(function(prop) {\n                    return \"`\" + prop + \"`\";\n                }).join(\", \");\n                if (unknownProps.length === 1) {\n                    error(\"Invalid value for prop %s on <%s> tag. Either remove it from the element, \" + \"or pass a string or number value to keep it in the DOM. \" + \"For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n                } else if (unknownProps.length > 1) {\n                    error(\"Invalid values for props %s on <%s> tag. Either remove them from the element, \" + \"or pass a string or number value to keep them in the DOM. \" + \"For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n                }\n            }\n        }\n        function validateProperties(type, props, eventRegistry) {\n            if (isCustomElement(type) || typeof props.is === \"string\") {\n                return;\n            }\n            warnUnknownProperties(type, props, eventRegistry);\n        }\n        // 'msTransform' is correct, but the other prefixes should be capitalized\n        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n        var msPattern$1 = /^-ms-/;\n        var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon\n        var badStyleValueWithSemicolonPattern = /;\\s*$/;\n        var warnedStyleNames = {};\n        var warnedStyleValues = {};\n        var warnedForNaNValue = false;\n        var warnedForInfinityValue = false;\n        function camelize(string) {\n            return string.replace(hyphenPattern, function(_, character) {\n                return character.toUpperCase();\n            });\n        }\n        function warnHyphenatedStyleName(name) {\n            {\n                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n                    return;\n                }\n                warnedStyleNames[name] = true;\n                error(\"Unsupported style property %s. Did you mean %s?\", name, // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n                // is converted to lowercase `ms`.\n                camelize(name.replace(msPattern$1, \"ms-\")));\n            }\n        }\n        function warnBadVendoredStyleName(name) {\n            {\n                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n                    return;\n                }\n                warnedStyleNames[name] = true;\n                error(\"Unsupported vendor-prefixed style property %s. Did you mean %s?\", name, name.charAt(0).toUpperCase() + name.slice(1));\n            }\n        }\n        function warnStyleValueWithSemicolon(name, value) {\n            {\n                if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n                    return;\n                }\n                warnedStyleValues[value] = true;\n                error(\"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.', name, value.replace(badStyleValueWithSemicolonPattern, \"\"));\n            }\n        }\n        function warnStyleValueIsNaN(name, value) {\n            {\n                if (warnedForNaNValue) {\n                    return;\n                }\n                warnedForNaNValue = true;\n                error(\"`NaN` is an invalid value for the `%s` css style property.\", name);\n            }\n        }\n        function warnStyleValueIsInfinity(name, value) {\n            {\n                if (warnedForInfinityValue) {\n                    return;\n                }\n                warnedForInfinityValue = true;\n                error(\"`Infinity` is an invalid value for the `%s` css style property.\", name);\n            }\n        }\n        function warnValidStyle(name, value) {\n            {\n                if (name.indexOf(\"-\") > -1) {\n                    warnHyphenatedStyleName(name);\n                } else if (badVendoredStyleNamePattern.test(name)) {\n                    warnBadVendoredStyleName(name);\n                } else if (badStyleValueWithSemicolonPattern.test(value)) {\n                    warnStyleValueWithSemicolon(name, value);\n                }\n                if (typeof value === \"number\") {\n                    if (isNaN(value)) {\n                        warnStyleValueIsNaN(name);\n                    } else if (!isFinite(value)) {\n                        warnStyleValueIsInfinity(name);\n                    }\n                }\n            }\n        }\n        function getCrossOriginString(input) {\n            if (typeof input === \"string\") {\n                return input === \"use-credentials\" ? input : \"\";\n            }\n            return undefined;\n        }\n        // code copied and modified from escape-html\n        var matchHtmlRegExp = /[\"'&<>]/;\n        /**\n * Escapes special characters and HTML entities in a given html string.\n *\n * @param  {string} string HTML string to escape for later insertion\n * @return {string}\n * @public\n */ function escapeHtml(string) {\n            {\n                checkHtmlStringCoercion(string);\n            }\n            var str = \"\" + string;\n            var match = matchHtmlRegExp.exec(str);\n            if (!match) {\n                return str;\n            }\n            var escape;\n            var html = \"\";\n            var index;\n            var lastIndex = 0;\n            for(index = match.index; index < str.length; index++){\n                switch(str.charCodeAt(index)){\n                    case 34:\n                        // \"\n                        escape = \"&quot;\";\n                        break;\n                    case 38:\n                        // &\n                        escape = \"&amp;\";\n                        break;\n                    case 39:\n                        // '\n                        escape = \"&#x27;\"; // modified from escape-html; used to be '&#39'\n                        break;\n                    case 60:\n                        // <\n                        escape = \"&lt;\";\n                        break;\n                    case 62:\n                        // >\n                        escape = \"&gt;\";\n                        break;\n                    default:\n                        continue;\n                }\n                if (lastIndex !== index) {\n                    html += str.slice(lastIndex, index);\n                }\n                lastIndex = index + 1;\n                html += escape;\n            }\n            return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n        } // end code copied and modified from escape-html\n        /**\n * Escapes text to prevent scripting attacks.\n *\n * @param {*} text Text value to escape.\n * @return {string} An escaped string.\n */ function escapeTextForBrowser(text) {\n            if (typeof text === \"boolean\" || typeof text === \"number\") {\n                // this shortcircuit helps perf for types that we know will never have\n                // special characters, especially given that this function is used often\n                // for numeric dom ids.\n                return \"\" + text;\n            }\n            return escapeHtml(text);\n        }\n        var uppercasePattern = /([A-Z])/g;\n        var msPattern = /^ms-/;\n        /**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n */ function hyphenateStyleName(name) {\n            return name.replace(uppercasePattern, \"-$1\").toLowerCase().replace(msPattern, \"-ms-\");\n        }\n        // and any newline or tab are filtered out as if they're not part of the URL.\n        // https://url.spec.whatwg.org/#url-parsing\n        // Tab or newline are defined as \\r\\n\\t:\n        // https://infra.spec.whatwg.org/#ascii-tab-or-newline\n        // A C0 control is a code point in the range \\u0000 NULL to \\u001F\n        // INFORMATION SEPARATOR ONE, inclusive:\n        // https://infra.spec.whatwg.org/#c0-control-or-space\n        /* eslint-disable max-len */ var isJavaScriptProtocol = /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;\n        var didWarn = false;\n        function sanitizeURL(url) {\n            // We should never have symbols here because they get filtered out elsewhere.\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            var stringifiedURL = \"\" + url;\n            {\n                if (!didWarn && isJavaScriptProtocol.test(stringifiedURL)) {\n                    didWarn = true;\n                    error(\"A future version of React will block javascript: URLs as a security precaution. \" + \"Use event handlers instead if you can. If you need to generate unsafe HTML try \" + \"using dangerouslySetInnerHTML instead. React was passed %s.\", JSON.stringify(stringifiedURL));\n                }\n            }\n            return url;\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        // The build script is at scripts/rollup/generate-inline-fizz-runtime.js.\n        // Run `yarn generate-inline-fizz-runtime` to generate.\n        var clientRenderBoundary = '$RX=function(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};';\n        var completeBoundary = '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};';\n        var completeBoundaryWithStyles = '$RM=new Map;\\n$RR=function(r,t,w){for(var u=$RC,n=$RM,p=new Map,q=document,g,b,h=q.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),v=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?v.push(b):(\"LINK\"===b.tagName&&n.set(b.getAttribute(\"href\"),b),p.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var f=w[b++];if(!f){k=!1;b=0;continue}var c=!1,m=0;var d=f[m++];if(a=n.get(d)){var e=a._p;c=!0}else{a=q.createElement(\"link\");a.href=d;a.rel=\"stylesheet\";for(a.dataset.precedence=\\nl=f[m++];e=f[m++];)a.setAttribute(e,f[m++]);e=a._p=new Promise(function(x,y){a.onload=x;a.onerror=y});n.set(d,a)}d=a.getAttribute(\"media\");!e||\"l\"===e.s||d&&!matchMedia(d).matches||h.push(e);if(c)continue}else{a=v[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=p.get(l)||g;c===g&&(g=a);p.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=q.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(u.bind(null,r,t,\"\"),u.bind(null,r,t,\"Resource failed to load\"))};';\n        var completeSegment = \"$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};\";\n        var formReplaying = 'addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error(\\'A React form was unexpectedly submitted.\\')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.getRootNode(),(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,\\nd,b))}});';\n        function getValueDescriptorExpectingObjectForWarning(thing) {\n            return thing === null ? \"`null`\" : thing === undefined ? \"`undefined`\" : thing === \"\" ? \"an empty string\" : 'something with type \"' + typeof thing + '\"';\n        }\n        // same object across all transitions.\n        var sharedNotPendingObject = {\n            pending: false,\n            data: null,\n            method: null,\n            action: null\n        };\n        var NotPending = Object.freeze(sharedNotPendingObject);\n        var ReactDOMSharedInternals = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        var ReactDOMCurrentDispatcher = ReactDOMSharedInternals.Dispatcher;\n        var ReactDOMServerDispatcher = {\n            prefetchDNS: prefetchDNS,\n            preconnect: preconnect,\n            preload: preload,\n            preloadModule: preloadModule,\n            preinitStyle: preinitStyle,\n            preinitScript: preinitScript,\n            preinitModuleScript: preinitModuleScript\n        };\n        function prepareHostDispatcher() {\n            ReactDOMCurrentDispatcher.current = ReactDOMServerDispatcher;\n        } // We make every property of the descriptor optional because it is not a contract that\n        var ScriptStreamingFormat = 0;\n        var DataStreamingFormat = 1;\n        var NothingSent = 0;\n        var SentCompleteSegmentFunction = 1;\n        var SentCompleteBoundaryFunction = 2;\n        var SentClientRenderFunction = 4;\n        var SentStyleInsertionFunction = 8;\n        var SentFormReplayingRuntime = 16; // Per request, global state that is not contextual to the rendering subtree.\n        // This cannot be resumed and therefore should only contain things that are\n        // temporary working state or are never used in the prerender pass.\n        // Credentials here are things that affect whether a browser will make a request\n        // as well as things that affect which connection the browser will use for that request.\n        // We want these to be aligned across preloads and resources because otherwise the preload\n        // will be wasted.\n        // We investigated whether referrerPolicy should be included here but from experimentation\n        // it seems that browsers do not treat this as part of the http cache key and does not affect\n        // which connection is used.\n        var EXISTS = null; // This constant is to mark preloads that have no unique credentials\n        // to convey. It should never be checked by identity and we should not\n        // assume Preload values in ResumableState equal this value because they\n        // will have come from some parsed input.\n        var PRELOAD_NO_CREDS = [];\n        {\n            Object.freeze(PRELOAD_NO_CREDS);\n        }\n        // This is resumable and therefore should be serializable.\n        var dataElementQuotedEnd = stringToPrecomputedChunk('\"></template>');\n        var startInlineScript = stringToPrecomputedChunk(\"<script>\");\n        var endInlineScript = stringToPrecomputedChunk(\"</script>\");\n        var startScriptSrc = stringToPrecomputedChunk('<script src=\"');\n        var startModuleSrc = stringToPrecomputedChunk('<script type=\"module\" src=\"');\n        var scriptNonce = stringToPrecomputedChunk('\" nonce=\"');\n        var scriptIntegirty = stringToPrecomputedChunk('\" integrity=\"');\n        var scriptCrossOrigin = stringToPrecomputedChunk('\" crossorigin=\"');\n        var endAsyncScript = stringToPrecomputedChunk('\" async=\"\"></script>');\n        /**\n * This escaping function is designed to work with bootstrapScriptContent and importMap only.\n * because we know we are escaping the entire script. We can avoid for instance\n * escaping html comment string sequences that are valid javascript as well because\n * if there are no sebsequent <script sequences the html parser will never enter\n * script data double escaped state (see: https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state)\n *\n * While untrusted script content should be made safe before using this api it will\n * ensure that the script cannot be early terminated or never terminated state\n */ function escapeBootstrapAndImportMapScriptContent(scriptText) {\n            {\n                checkHtmlStringCoercion(scriptText);\n            }\n            return (\"\" + scriptText).replace(scriptRegex, scriptReplacer);\n        }\n        var scriptRegex = /(<\\/|<)(s)(cript)/gi;\n        var scriptReplacer = function(match, prefix, s, suffix) {\n            return \"\" + prefix + (s === \"s\" ? \"\\\\u0073\" : \"\\\\u0053\") + suffix;\n        };\n        var importMapScriptStart = stringToPrecomputedChunk('<script type=\"importmap\">');\n        var importMapScriptEnd = stringToPrecomputedChunk(\"</script>\"); // Since we store headers as strings we deal with their length in utf16 code units\n        // rather than visual characters or the utf8 encoding that is used for most binary\n        // serialization. Some common HTTP servers only allow for headers to be 4kB in length.\n        // We choose a default length that is likely to be well under this already limited length however\n        // pathological cases may still cause the utf-8 encoding of the headers to approach this limit.\n        // It should also be noted that this maximum is a soft maximum. we have not reached the limit we will\n        // allow one more header to be captured which means in practice if the limit is approached it will be exceeded\n        var DEFAULT_HEADERS_CAPACITY_IN_UTF16_CODE_UNITS = 2000; // Allows us to keep track of what we've already written so we can refer back to it.\n        // if passed externalRuntimeConfig and the enableFizzExternalRuntime feature flag\n        // is set, the server will send instructions via data attributes (instead of inline scripts)\n        function createRenderState$1(resumableState, nonce, externalRuntimeConfig, importMap, onHeaders, maxHeadersLength) {\n            var inlineScriptWithNonce = nonce === undefined ? startInlineScript : stringToPrecomputedChunk('<script nonce=\"' + escapeTextForBrowser(nonce) + '\">');\n            var idPrefix = resumableState.idPrefix;\n            var bootstrapChunks = [];\n            var externalRuntimeScript = null;\n            var bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;\n            if (bootstrapScriptContent !== undefined) {\n                bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapAndImportMapScriptContent(bootstrapScriptContent)), endInlineScript);\n            }\n            {\n                if (externalRuntimeConfig !== undefined) {\n                    if (typeof externalRuntimeConfig === \"string\") {\n                        externalRuntimeScript = {\n                            src: externalRuntimeConfig,\n                            chunks: []\n                        };\n                        pushScriptImpl(externalRuntimeScript.chunks, {\n                            src: externalRuntimeConfig,\n                            async: true,\n                            integrity: undefined,\n                            nonce: nonce\n                        });\n                    } else {\n                        externalRuntimeScript = {\n                            src: externalRuntimeConfig.src,\n                            chunks: []\n                        };\n                        pushScriptImpl(externalRuntimeScript.chunks, {\n                            src: externalRuntimeConfig.src,\n                            async: true,\n                            integrity: externalRuntimeConfig.integrity,\n                            nonce: nonce\n                        });\n                    }\n                }\n            }\n            var importMapChunks = [];\n            if (importMap !== undefined) {\n                var map = importMap;\n                importMapChunks.push(importMapScriptStart);\n                importMapChunks.push(stringToChunk(escapeBootstrapAndImportMapScriptContent(JSON.stringify(map))));\n                importMapChunks.push(importMapScriptEnd);\n            }\n            {\n                if (onHeaders && typeof maxHeadersLength === \"number\") {\n                    if (maxHeadersLength <= 0) {\n                        error(\"React expected a positive non-zero `maxHeadersLength` option but found %s instead. When using the `onHeaders` option you may supply an optional `maxHeadersLength` option as well however, when setting this value to zero or less no headers will be captured.\", maxHeadersLength === 0 ? \"zero\" : maxHeadersLength);\n                    }\n                }\n            }\n            var headers = onHeaders ? {\n                preconnects: \"\",\n                fontPreloads: \"\",\n                highImagePreloads: \"\",\n                remainingCapacity: typeof maxHeadersLength === \"number\" ? maxHeadersLength : DEFAULT_HEADERS_CAPACITY_IN_UTF16_CODE_UNITS\n            } : null;\n            var renderState = {\n                placeholderPrefix: stringToPrecomputedChunk(idPrefix + \"P:\"),\n                segmentPrefix: stringToPrecomputedChunk(idPrefix + \"S:\"),\n                boundaryPrefix: stringToPrecomputedChunk(idPrefix + \"B:\"),\n                startInlineScript: inlineScriptWithNonce,\n                htmlChunks: null,\n                headChunks: null,\n                externalRuntimeScript: externalRuntimeScript,\n                bootstrapChunks: bootstrapChunks,\n                onHeaders: onHeaders,\n                headers: headers,\n                resets: {\n                    font: {},\n                    dns: {},\n                    connect: {\n                        default: {},\n                        anonymous: {},\n                        credentials: {}\n                    },\n                    image: {},\n                    style: {}\n                },\n                charsetChunks: [],\n                preconnectChunks: [],\n                importMapChunks: importMapChunks,\n                preloadChunks: [],\n                hoistableChunks: [],\n                // cleared on flush\n                preconnects: new Set(),\n                fontPreloads: new Set(),\n                highImagePreloads: new Set(),\n                // usedImagePreloads: new Set(),\n                styles: new Map(),\n                bootstrapScripts: new Set(),\n                scripts: new Set(),\n                bulkPreloads: new Set(),\n                preloads: {\n                    images: new Map(),\n                    stylesheets: new Map(),\n                    scripts: new Map(),\n                    moduleScripts: new Map()\n                },\n                nonce: nonce,\n                // like a module global for currently rendering boundary\n                boundaryResources: null,\n                stylesToHoist: false\n            };\n            if (bootstrapScripts !== undefined) {\n                for(var i = 0; i < bootstrapScripts.length; i++){\n                    var scriptConfig = bootstrapScripts[i];\n                    var src = void 0, crossOrigin = void 0, integrity = void 0;\n                    var props = {\n                        rel: \"preload\",\n                        as: \"script\",\n                        fetchPriority: \"low\",\n                        nonce: nonce\n                    };\n                    if (typeof scriptConfig === \"string\") {\n                        props.href = src = scriptConfig;\n                    } else {\n                        props.href = src = scriptConfig.src;\n                        props.integrity = integrity = typeof scriptConfig.integrity === \"string\" ? scriptConfig.integrity : undefined;\n                        props.crossOrigin = crossOrigin = typeof scriptConfig === \"string\" || scriptConfig.crossOrigin == null ? undefined : scriptConfig.crossOrigin === \"use-credentials\" ? \"use-credentials\" : \"\";\n                    }\n                    preloadBootstrapScriptOrModule(resumableState, renderState, src, props);\n                    bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(src)));\n                    if (nonce) {\n                        bootstrapChunks.push(scriptNonce, stringToChunk(escapeTextForBrowser(nonce)));\n                    }\n                    if (typeof integrity === \"string\") {\n                        bootstrapChunks.push(scriptIntegirty, stringToChunk(escapeTextForBrowser(integrity)));\n                    }\n                    if (typeof crossOrigin === \"string\") {\n                        bootstrapChunks.push(scriptCrossOrigin, stringToChunk(escapeTextForBrowser(crossOrigin)));\n                    }\n                    bootstrapChunks.push(endAsyncScript);\n                }\n            }\n            if (bootstrapModules !== undefined) {\n                for(var _i = 0; _i < bootstrapModules.length; _i++){\n                    var _scriptConfig = bootstrapModules[_i];\n                    var _src = void 0, _crossOrigin = void 0, _integrity = void 0;\n                    var _props = {\n                        rel: \"modulepreload\",\n                        fetchPriority: \"low\",\n                        nonce: nonce\n                    };\n                    if (typeof _scriptConfig === \"string\") {\n                        _props.href = _src = _scriptConfig;\n                    } else {\n                        _props.href = _src = _scriptConfig.src;\n                        _props.integrity = _integrity = typeof _scriptConfig.integrity === \"string\" ? _scriptConfig.integrity : undefined;\n                        _props.crossOrigin = _crossOrigin = typeof _scriptConfig === \"string\" || _scriptConfig.crossOrigin == null ? undefined : _scriptConfig.crossOrigin === \"use-credentials\" ? \"use-credentials\" : \"\";\n                    }\n                    preloadBootstrapScriptOrModule(resumableState, renderState, _src, _props);\n                    bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(_src)));\n                    if (nonce) {\n                        bootstrapChunks.push(scriptNonce, stringToChunk(escapeTextForBrowser(nonce)));\n                    }\n                    if (typeof _integrity === \"string\") {\n                        bootstrapChunks.push(scriptIntegirty, stringToChunk(escapeTextForBrowser(_integrity)));\n                    }\n                    if (typeof _crossOrigin === \"string\") {\n                        bootstrapChunks.push(scriptCrossOrigin, stringToChunk(escapeTextForBrowser(_crossOrigin)));\n                    }\n                    bootstrapChunks.push(endAsyncScript);\n                }\n            }\n            return renderState;\n        }\n        function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {\n            var idPrefix = identifierPrefix === undefined ? \"\" : identifierPrefix;\n            var streamingFormat = ScriptStreamingFormat;\n            {\n                if (externalRuntimeConfig !== undefined) {\n                    streamingFormat = DataStreamingFormat;\n                }\n            }\n            return {\n                idPrefix: idPrefix,\n                nextFormID: 0,\n                streamingFormat: streamingFormat,\n                bootstrapScriptContent: bootstrapScriptContent,\n                bootstrapScripts: bootstrapScripts,\n                bootstrapModules: bootstrapModules,\n                instructions: NothingSent,\n                hasBody: false,\n                hasHtml: false,\n                // @TODO add bootstrap script to implicit preloads\n                // persistent\n                unknownResources: {},\n                dnsResources: {},\n                connectResources: {\n                    default: {},\n                    anonymous: {},\n                    credentials: {}\n                },\n                imageResources: {},\n                styleResources: {},\n                scriptResources: {},\n                moduleUnknownResources: {},\n                moduleScriptResources: {}\n            };\n        }\n        // modes. We only include the variants as they matter for the sake of our purposes.\n        // We don't actually provide the namespace therefore we use constants instead of the string.\n        var ROOT_HTML_MODE = 0; // Used for the root most element tag.\n        // We have a less than HTML_HTML_MODE check elsewhere. If you add more cases here, make sure it\n        // still makes sense\n        var HTML_HTML_MODE = 1; // Used for the <html> if it is at the top level.\n        var HTML_MODE = 2;\n        var SVG_MODE = 3;\n        var MATHML_MODE = 4;\n        var HTML_TABLE_MODE = 5;\n        var HTML_TABLE_BODY_MODE = 6;\n        var HTML_TABLE_ROW_MODE = 7;\n        var HTML_COLGROUP_MODE = 8; // We have a greater than HTML_TABLE_MODE check elsewhere. If you add more cases here, make sure it\n        // still makes sense\n        var NO_SCOPE = /*         */ 0;\n        var NOSCRIPT_SCOPE = /*   */ 1;\n        var PICTURE_SCOPE = /*    */ 2; // Lets us keep track of contextual state and pick it back up after suspending.\n        function createFormatContext(insertionMode, selectedValue, tagScope) {\n            return {\n                insertionMode: insertionMode,\n                selectedValue: selectedValue,\n                tagScope: tagScope\n            };\n        }\n        function createRootFormatContext(namespaceURI) {\n            var insertionMode = namespaceURI === \"http://www.w3.org/2000/svg\" ? SVG_MODE : namespaceURI === \"http://www.w3.org/1998/Math/MathML\" ? MATHML_MODE : ROOT_HTML_MODE;\n            return createFormatContext(insertionMode, null, NO_SCOPE);\n        }\n        function getChildFormatContext(parentContext, type, props) {\n            switch(type){\n                case \"noscript\":\n                    return createFormatContext(HTML_MODE, null, parentContext.tagScope | NOSCRIPT_SCOPE);\n                case \"select\":\n                    return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue, parentContext.tagScope);\n                case \"svg\":\n                    return createFormatContext(SVG_MODE, null, parentContext.tagScope);\n                case \"picture\":\n                    return createFormatContext(HTML_MODE, null, parentContext.tagScope | PICTURE_SCOPE);\n                case \"math\":\n                    return createFormatContext(MATHML_MODE, null, parentContext.tagScope);\n                case \"foreignObject\":\n                    return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n                // Table parents are special in that their children can only be created at all if they're\n                // wrapped in a table parent. So we need to encode that we're entering this mode.\n                case \"table\":\n                    return createFormatContext(HTML_TABLE_MODE, null, parentContext.tagScope);\n                case \"thead\":\n                case \"tbody\":\n                case \"tfoot\":\n                    return createFormatContext(HTML_TABLE_BODY_MODE, null, parentContext.tagScope);\n                case \"colgroup\":\n                    return createFormatContext(HTML_COLGROUP_MODE, null, parentContext.tagScope);\n                case \"tr\":\n                    return createFormatContext(HTML_TABLE_ROW_MODE, null, parentContext.tagScope);\n            }\n            if (parentContext.insertionMode >= HTML_TABLE_MODE) {\n                // Whatever tag this was, it wasn't a table parent or other special parent, so we must have\n                // entered plain HTML again.\n                return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n            }\n            if (parentContext.insertionMode === ROOT_HTML_MODE) {\n                if (type === \"html\") {\n                    // We've emitted the root and is now in <html> mode.\n                    return createFormatContext(HTML_HTML_MODE, null, parentContext.tagScope);\n                } else {\n                    // We've emitted the root and is now in plain HTML mode.\n                    return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n                }\n            } else if (parentContext.insertionMode === HTML_HTML_MODE) {\n                // We've emitted the document element and is now in plain HTML mode.\n                return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n            }\n            return parentContext;\n        }\n        function makeId(resumableState, treeId, localId) {\n            var idPrefix = resumableState.idPrefix;\n            var id = \":\" + idPrefix + \"R\" + treeId; // Unless this is the first id at this level, append a number at the end\n            // that represents the position of this useId hook among all the useId\n            // hooks for this fiber.\n            if (localId > 0) {\n                id += \"H\" + localId.toString(32);\n            }\n            return id + \":\";\n        }\n        function encodeHTMLTextNode(text) {\n            return escapeTextForBrowser(text);\n        }\n        var textSeparator = stringToPrecomputedChunk(\"<!-- -->\");\n        function pushTextInstance$1(target, text, renderState, textEmbedded) {\n            if (text === \"\") {\n                // Empty text doesn't have a DOM node representation and the hydration is aware of this.\n                return textEmbedded;\n            }\n            if (textEmbedded) {\n                target.push(textSeparator);\n            }\n            target.push(stringToChunk(encodeHTMLTextNode(text)));\n            return true;\n        } // Called when Fizz is done with a Segment. Currently the only purpose is to conditionally\n        // emit a text separator when we don't know for sure it is safe to omit\n        function pushSegmentFinale$1(target, renderState, lastPushedText, textEmbedded) {\n            if (lastPushedText && textEmbedded) {\n                target.push(textSeparator);\n            }\n        }\n        var styleNameCache = new Map();\n        function processStyleName(styleName) {\n            var chunk = styleNameCache.get(styleName);\n            if (chunk !== undefined) {\n                return chunk;\n            }\n            var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));\n            styleNameCache.set(styleName, result);\n            return result;\n        }\n        var styleAttributeStart = stringToPrecomputedChunk(' style=\"');\n        var styleAssign = stringToPrecomputedChunk(\":\");\n        var styleSeparator = stringToPrecomputedChunk(\";\");\n        function pushStyleAttribute(target, style) {\n            if (typeof style !== \"object\") {\n                throw new Error(\"The `style` prop expects a mapping from style properties to values, \" + \"not a string. For example, style={{marginRight: spacing + 'em'}} when \" + \"using JSX.\");\n            }\n            var isFirst = true;\n            for(var styleName in style){\n                if (!hasOwnProperty.call(style, styleName)) {\n                    continue;\n                } // If you provide unsafe user data here they can inject arbitrary CSS\n                // which may be problematic (I couldn't repro this):\n                // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n                // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n                // This is not an XSS hole but instead a potential CSS injection issue\n                // which has lead to a greater discussion about how we're going to\n                // trust URLs moving forward. See #2115901\n                var styleValue = style[styleName];\n                if (styleValue == null || typeof styleValue === \"boolean\" || styleValue === \"\") {\n                    continue;\n                }\n                var nameChunk = void 0;\n                var valueChunk = void 0;\n                var isCustomProperty = styleName.indexOf(\"--\") === 0;\n                if (isCustomProperty) {\n                    nameChunk = stringToChunk(escapeTextForBrowser(styleName));\n                    {\n                        checkCSSPropertyStringCoercion(styleValue, styleName);\n                    }\n                    valueChunk = stringToChunk(escapeTextForBrowser((\"\" + styleValue).trim()));\n                } else {\n                    {\n                        warnValidStyle(styleName, styleValue);\n                    }\n                    nameChunk = processStyleName(styleName);\n                    if (typeof styleValue === \"number\") {\n                        if (styleValue !== 0 && !isUnitlessNumber(styleName)) {\n                            valueChunk = stringToChunk(styleValue + \"px\"); // Presumes implicit 'px' suffix for unitless numbers\n                        } else {\n                            valueChunk = stringToChunk(\"\" + styleValue);\n                        }\n                    } else {\n                        {\n                            checkCSSPropertyStringCoercion(styleValue, styleName);\n                        }\n                        valueChunk = stringToChunk(escapeTextForBrowser((\"\" + styleValue).trim()));\n                    }\n                }\n                if (isFirst) {\n                    isFirst = false; // If it's first, we don't need any separators prefixed.\n                    target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);\n                } else {\n                    target.push(styleSeparator, nameChunk, styleAssign, valueChunk);\n                }\n            }\n            if (!isFirst) {\n                target.push(attributeEnd);\n            }\n        }\n        var attributeSeparator = stringToPrecomputedChunk(\" \");\n        var attributeAssign = stringToPrecomputedChunk('=\"');\n        var attributeEnd = stringToPrecomputedChunk('\"');\n        var attributeEmptyString = stringToPrecomputedChunk('=\"\"');\n        function pushBooleanAttribute(target, name, value) {\n            if (value && typeof value !== \"function\" && typeof value !== \"symbol\") {\n                target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n            }\n        }\n        function pushStringAttribute(target, name, value) {\n            if (typeof value !== \"function\" && typeof value !== \"symbol\" && typeof value !== \"boolean\") {\n                target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n            }\n        }\n        function makeFormFieldPrefix(resumableState) {\n            var id = resumableState.nextFormID++;\n            return resumableState.idPrefix + id;\n        } // Since this will likely be repeated a lot in the HTML, we use a more concise message\n        // than on the client and hopefully it's googleable.\n        var actionJavaScriptURL = stringToPrecomputedChunk(escapeTextForBrowser(\"javascript:throw new Error('A React form was unexpectedly submitted.')\"));\n        var startHiddenInputChunk = stringToPrecomputedChunk('<input type=\"hidden\"');\n        function pushAdditionalFormField(value, key) {\n            var target = this;\n            target.push(startHiddenInputChunk);\n            if (typeof value !== \"string\") {\n                throw new Error(\"File/Blob fields are not yet supported in progressive forms. \" + \"It probably means you are closing over binary data or FormData in a Server Action.\");\n            }\n            pushStringAttribute(target, \"name\", key);\n            pushStringAttribute(target, \"value\", value);\n            target.push(endOfStartTagSelfClosing);\n        }\n        function pushAdditionalFormFields(target, formData) {\n            if (formData !== null) {\n                // $FlowFixMe[prop-missing]: FormData has forEach.\n                formData.forEach(pushAdditionalFormField, target);\n            }\n        }\n        function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {\n            var formData = null;\n            if (typeof formAction === \"function\") {\n                // Function form actions cannot control the form properties\n                {\n                    if (name !== null && !didWarnFormActionName) {\n                        didWarnFormActionName = true;\n                        error('Cannot specify a \"name\" prop for a button that specifies a function as a formAction. ' + \"React needs it to encode which action should be invoked. It will get overridden.\");\n                    }\n                    if ((formEncType !== null || formMethod !== null) && !didWarnFormActionMethod) {\n                        didWarnFormActionMethod = true;\n                        error(\"Cannot specify a formEncType or formMethod for a button that specifies a \" + \"function as a formAction. React provides those automatically. They will get overridden.\");\n                    }\n                    if (formTarget !== null && !didWarnFormActionTarget) {\n                        didWarnFormActionTarget = true;\n                        error(\"Cannot specify a formTarget for a button that specifies a function as a formAction. \" + \"The function will always be executed in the same window.\");\n                    }\n                }\n                var customAction = formAction.$$FORM_ACTION;\n                if (typeof customAction === \"function\") {\n                    // This action has a custom progressive enhancement form that can submit the form\n                    // back to the server if it's invoked before hydration. Such as a Server Action.\n                    var prefix = makeFormFieldPrefix(resumableState);\n                    var customFields = formAction.$$FORM_ACTION(prefix);\n                    name = customFields.name;\n                    formAction = customFields.action || \"\";\n                    formEncType = customFields.encType;\n                    formMethod = customFields.method;\n                    formTarget = customFields.target;\n                    formData = customFields.data;\n                } else {\n                    // Set a javascript URL that doesn't do anything. We don't expect this to be invoked\n                    // because we'll preventDefault in the Fizz runtime, but it can happen if a form is\n                    // manually submitted or if someone calls stopPropagation before React gets the event.\n                    // If CSP is used to block javascript: URLs that's fine too. It just won't show this\n                    // error message but the URL will be logged.\n                    target.push(attributeSeparator, stringToChunk(\"formAction\"), attributeAssign, actionJavaScriptURL, attributeEnd);\n                    name = null;\n                    formAction = null;\n                    formEncType = null;\n                    formMethod = null;\n                    formTarget = null;\n                    injectFormReplayingRuntime(resumableState, renderState);\n                }\n            }\n            if (name != null) {\n                pushAttribute(target, \"name\", name);\n            }\n            if (formAction != null) {\n                pushAttribute(target, \"formAction\", formAction);\n            }\n            if (formEncType != null) {\n                pushAttribute(target, \"formEncType\", formEncType);\n            }\n            if (formMethod != null) {\n                pushAttribute(target, \"formMethod\", formMethod);\n            }\n            if (formTarget != null) {\n                pushAttribute(target, \"formTarget\", formTarget);\n            }\n            return formData;\n        }\n        function pushAttribute(target, name, value) {\n            switch(name){\n                // These are very common props and therefore are in the beginning of the switch.\n                // TODO: aria-label is a very common prop but allows booleans so is not like the others\n                // but should ideally go in this list too.\n                case \"className\":\n                    {\n                        pushStringAttribute(target, \"class\", value);\n                        break;\n                    }\n                case \"tabIndex\":\n                    {\n                        pushStringAttribute(target, \"tabindex\", value);\n                        break;\n                    }\n                case \"dir\":\n                case \"role\":\n                case \"viewBox\":\n                case \"width\":\n                case \"height\":\n                    {\n                        pushStringAttribute(target, name, value);\n                        break;\n                    }\n                case \"style\":\n                    {\n                        pushStyleAttribute(target, value);\n                        return;\n                    }\n                case \"src\":\n                case \"href\":\n                // Fall through to the last case which shouldn't remove empty strings.\n                case \"action\":\n                case \"formAction\":\n                    {\n                        // TODO: Consider only special casing these for each tag.\n                        if (value == null || typeof value === \"function\" || typeof value === \"symbol\" || typeof value === \"boolean\") {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, name);\n                        }\n                        var sanitizedValue = sanitizeURL(\"\" + value);\n                        target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(sanitizedValue)), attributeEnd);\n                        return;\n                    }\n                case \"defaultValue\":\n                case \"defaultChecked\":\n                case \"innerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                    // Ignored. These are built-in to React on the client.\n                    return;\n                case \"autoFocus\":\n                case \"multiple\":\n                case \"muted\":\n                    {\n                        pushBooleanAttribute(target, name.toLowerCase(), value);\n                        return;\n                    }\n                case \"xlinkHref\":\n                    {\n                        if (typeof value === \"function\" || typeof value === \"symbol\" || typeof value === \"boolean\") {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, name);\n                        }\n                        var _sanitizedValue = sanitizeURL(\"\" + value);\n                        target.push(attributeSeparator, stringToChunk(\"xlink:href\"), attributeAssign, stringToChunk(escapeTextForBrowser(_sanitizedValue)), attributeEnd);\n                        return;\n                    }\n                case \"contentEditable\":\n                case \"spellCheck\":\n                case \"draggable\":\n                case \"value\":\n                case \"autoReverse\":\n                case \"externalResourcesRequired\":\n                case \"focusable\":\n                case \"preserveAlpha\":\n                    {\n                        // Booleanish String\n                        // These are \"enumerated\" attributes that accept \"true\" and \"false\".\n                        // In React, we let users pass `true` and `false` even though technically\n                        // these aren't boolean attributes (they are coerced to strings).\n                        if (typeof value !== \"function\" && typeof value !== \"symbol\") {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"allowFullScreen\":\n                case \"async\":\n                case \"autoPlay\":\n                case \"controls\":\n                case \"default\":\n                case \"defer\":\n                case \"disabled\":\n                case \"disablePictureInPicture\":\n                case \"disableRemotePlayback\":\n                case \"formNoValidate\":\n                case \"hidden\":\n                case \"loop\":\n                case \"noModule\":\n                case \"noValidate\":\n                case \"open\":\n                case \"playsInline\":\n                case \"readOnly\":\n                case \"required\":\n                case \"reversed\":\n                case \"scoped\":\n                case \"seamless\":\n                case \"itemScope\":\n                    {\n                        // Boolean\n                        if (value && typeof value !== \"function\" && typeof value !== \"symbol\") {\n                            target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n                        }\n                        return;\n                    }\n                case \"capture\":\n                case \"download\":\n                    {\n                        // Overloaded Boolean\n                        if (value === true) {\n                            target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n                        } else if (value === false) ;\n                        else if (typeof value !== \"function\" && typeof value !== \"symbol\") {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"cols\":\n                case \"rows\":\n                case \"size\":\n                case \"span\":\n                    {\n                        // These are HTML attributes that must be positive numbers.\n                        if (typeof value !== \"function\" && typeof value !== \"symbol\" && !isNaN(value) && value >= 1) {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"rowSpan\":\n                case \"start\":\n                    {\n                        // These are HTML attributes that must be numbers.\n                        if (typeof value !== \"function\" && typeof value !== \"symbol\" && !isNaN(value)) {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"xlinkActuate\":\n                    pushStringAttribute(target, \"xlink:actuate\", value);\n                    return;\n                case \"xlinkArcrole\":\n                    pushStringAttribute(target, \"xlink:arcrole\", value);\n                    return;\n                case \"xlinkRole\":\n                    pushStringAttribute(target, \"xlink:role\", value);\n                    return;\n                case \"xlinkShow\":\n                    pushStringAttribute(target, \"xlink:show\", value);\n                    return;\n                case \"xlinkTitle\":\n                    pushStringAttribute(target, \"xlink:title\", value);\n                    return;\n                case \"xlinkType\":\n                    pushStringAttribute(target, \"xlink:type\", value);\n                    return;\n                case \"xmlBase\":\n                    pushStringAttribute(target, \"xml:base\", value);\n                    return;\n                case \"xmlLang\":\n                    pushStringAttribute(target, \"xml:lang\", value);\n                    return;\n                case \"xmlSpace\":\n                    pushStringAttribute(target, \"xml:space\", value);\n                    return;\n                default:\n                    if (// We have already filtered out null/undefined and reserved words.\n                    name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                        return;\n                    }\n                    var attributeName = getAttributeAlias(name);\n                    if (isAttributeNameSafe(attributeName)) {\n                        // shouldRemoveAttribute\n                        switch(typeof value){\n                            case \"function\":\n                            case \"symbol\":\n                                // eslint-disable-line\n                                return;\n                            case \"boolean\":\n                                {\n                                    var prefix = attributeName.toLowerCase().slice(0, 5);\n                                    if (prefix !== \"data-\" && prefix !== \"aria-\") {\n                                        return;\n                                    }\n                                }\n                        }\n                        target.push(attributeSeparator, stringToChunk(attributeName), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                    }\n            }\n        }\n        var endOfStartTag = stringToPrecomputedChunk(\">\");\n        var endOfStartTagSelfClosing = stringToPrecomputedChunk(\"/>\");\n        function pushInnerHTML(target, innerHTML, children) {\n            if (innerHTML != null) {\n                if (children != null) {\n                    throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n                }\n                if (typeof innerHTML !== \"object\" || !(\"__html\" in innerHTML)) {\n                    throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. \" + \"Please visit https://reactjs.org/link/dangerously-set-inner-html \" + \"for more information.\");\n                }\n                var html = innerHTML.__html;\n                if (html !== null && html !== undefined) {\n                    {\n                        checkHtmlStringCoercion(html);\n                    }\n                    target.push(stringToChunk(\"\" + html));\n                }\n            }\n        } // TODO: Move these to RenderState so that we warn for every request.\n        // It would help debugging in stateful servers (e.g. service worker).\n        var didWarnDefaultInputValue = false;\n        var didWarnDefaultChecked = false;\n        var didWarnDefaultSelectValue = false;\n        var didWarnDefaultTextareaValue = false;\n        var didWarnInvalidOptionChildren = false;\n        var didWarnInvalidOptionInnerHTML = false;\n        var didWarnSelectedSetOnOption = false;\n        var didWarnFormActionType = false;\n        var didWarnFormActionName = false;\n        var didWarnFormActionTarget = false;\n        var didWarnFormActionMethod = false;\n        function checkSelectProp(props, propName) {\n            {\n                var value = props[propName];\n                if (value != null) {\n                    var array = isArray(value);\n                    if (props.multiple && !array) {\n                        error(\"The `%s` prop supplied to <select> must be an array if \" + \"`multiple` is true.\", propName);\n                    } else if (!props.multiple && array) {\n                        error(\"The `%s` prop supplied to <select> must be a scalar \" + \"value if `multiple` is false.\", propName);\n                    }\n                }\n            }\n        }\n        function pushStartSelect(target, props) {\n            {\n                checkControlledValueProps(\"select\", props);\n                checkSelectProp(props, \"value\");\n                checkSelectProp(props, \"defaultValue\");\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {\n                    error(\"Select elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled select \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\");\n                    didWarnDefaultSelectValue = true;\n                }\n            }\n            target.push(startChunkForTag(\"select\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            // TODO: This doesn't really make sense for select since it can't use the controlled\n                            // value in the innerHTML.\n                            innerHTML = propValue;\n                            break;\n                        case \"defaultValue\":\n                        case \"value\":\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        function flattenOptionChildren(children) {\n            var content = \"\"; // Flatten children and warn if they aren't strings or numbers;\n            // invalid types are ignored.\n            React.Children.forEach(children, function(child) {\n                if (child == null) {\n                    return;\n                }\n                content += child;\n                {\n                    if (!didWarnInvalidOptionChildren && typeof child !== \"string\" && typeof child !== \"number\") {\n                        didWarnInvalidOptionChildren = true;\n                        error(\"Cannot infer the option value of complex children. \" + \"Pass a `value` prop or use a plain string as children to <option>.\");\n                    }\n                }\n            });\n            return content;\n        }\n        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=\"\"');\n        function pushStartOption(target, props, formatContext) {\n            var selectedValue = formatContext.selectedValue;\n            target.push(startChunkForTag(\"option\"));\n            var children = null;\n            var value = null;\n            var selected = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"selected\":\n                            // ignore\n                            selected = propValue;\n                            {\n                                // TODO: Remove support for `selected` in <option>.\n                                if (!didWarnSelectedSetOnOption) {\n                                    error(\"Use the `defaultValue` or `value` props on <select> instead of \" + \"setting `selected` on <option>.\");\n                                    didWarnSelectedSetOnOption = true;\n                                }\n                            }\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                        // We intentionally fallthrough to also set the attribute on the node.\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (selectedValue != null) {\n                var stringValue;\n                if (value !== null) {\n                    {\n                        checkAttributeStringCoercion(value, \"value\");\n                    }\n                    stringValue = \"\" + value;\n                } else {\n                    {\n                        if (innerHTML !== null) {\n                            if (!didWarnInvalidOptionInnerHTML) {\n                                didWarnInvalidOptionInnerHTML = true;\n                                error(\"Pass a `value` prop if you set dangerouslyInnerHTML so React knows \" + \"which value should be selected.\");\n                            }\n                        }\n                    }\n                    stringValue = flattenOptionChildren(children);\n                }\n                if (isArray(selectedValue)) {\n                    // multiple\n                    for(var i = 0; i < selectedValue.length; i++){\n                        {\n                            checkAttributeStringCoercion(selectedValue[i], \"value\");\n                        }\n                        var v = \"\" + selectedValue[i];\n                        if (v === stringValue) {\n                            target.push(selectedMarkerAttribute);\n                            break;\n                        }\n                    }\n                } else {\n                    {\n                        checkAttributeStringCoercion(selectedValue, \"select.value\");\n                    }\n                    if (\"\" + selectedValue === stringValue) {\n                        target.push(selectedMarkerAttribute);\n                    }\n                }\n            } else if (selected) {\n                target.push(selectedMarkerAttribute);\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        var formReplayingRuntimeScript = stringToPrecomputedChunk(formReplaying);\n        function injectFormReplayingRuntime(resumableState, renderState) {\n            // If we haven't sent it yet, inject the runtime that tracks submitted JS actions\n            // for later replaying by Fiber. If we use an external runtime, we don't need\n            // to emit anything. It's always used.\n            if ((resumableState.instructions & SentFormReplayingRuntime) === NothingSent && !renderState.externalRuntimeScript) {\n                resumableState.instructions |= SentFormReplayingRuntime;\n                renderState.bootstrapChunks.unshift(renderState.startInlineScript, formReplayingRuntimeScript, endInlineScript);\n            }\n        }\n        var formStateMarkerIsMatching = stringToPrecomputedChunk(\"<!--F!-->\");\n        var formStateMarkerIsNotMatching = stringToPrecomputedChunk(\"<!--F-->\");\n        function pushFormStateMarkerIsMatching(target) {\n            target.push(formStateMarkerIsMatching);\n        }\n        function pushFormStateMarkerIsNotMatching(target) {\n            target.push(formStateMarkerIsNotMatching);\n        }\n        function pushStartForm(target, props, resumableState, renderState) {\n            target.push(startChunkForTag(\"form\"));\n            var children = null;\n            var innerHTML = null;\n            var formAction = null;\n            var formEncType = null;\n            var formMethod = null;\n            var formTarget = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"action\":\n                            formAction = propValue;\n                            break;\n                        case \"encType\":\n                            formEncType = propValue;\n                            break;\n                        case \"method\":\n                            formMethod = propValue;\n                            break;\n                        case \"target\":\n                            formTarget = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            var formData = null;\n            var formActionName = null;\n            if (typeof formAction === \"function\") {\n                // Function form actions cannot control the form properties\n                {\n                    if ((formEncType !== null || formMethod !== null) && !didWarnFormActionMethod) {\n                        didWarnFormActionMethod = true;\n                        error(\"Cannot specify a encType or method for a form that specifies a \" + \"function as the action. React provides those automatically. \" + \"They will get overridden.\");\n                    }\n                    if (formTarget !== null && !didWarnFormActionTarget) {\n                        didWarnFormActionTarget = true;\n                        error(\"Cannot specify a target for a form that specifies a function as the action. \" + \"The function will always be executed in the same window.\");\n                    }\n                }\n                var customAction = formAction.$$FORM_ACTION;\n                if (typeof customAction === \"function\") {\n                    // This action has a custom progressive enhancement form that can submit the form\n                    // back to the server if it's invoked before hydration. Such as a Server Action.\n                    var prefix = makeFormFieldPrefix(resumableState);\n                    var customFields = formAction.$$FORM_ACTION(prefix);\n                    formAction = customFields.action || \"\";\n                    formEncType = customFields.encType;\n                    formMethod = customFields.method;\n                    formTarget = customFields.target;\n                    formData = customFields.data;\n                    formActionName = customFields.name;\n                } else {\n                    // Set a javascript URL that doesn't do anything. We don't expect this to be invoked\n                    // because we'll preventDefault in the Fizz runtime, but it can happen if a form is\n                    // manually submitted or if someone calls stopPropagation before React gets the event.\n                    // If CSP is used to block javascript: URLs that's fine too. It just won't show this\n                    // error message but the URL will be logged.\n                    target.push(attributeSeparator, stringToChunk(\"action\"), attributeAssign, actionJavaScriptURL, attributeEnd);\n                    formAction = null;\n                    formEncType = null;\n                    formMethod = null;\n                    formTarget = null;\n                    injectFormReplayingRuntime(resumableState, renderState);\n                }\n            }\n            if (formAction != null) {\n                pushAttribute(target, \"action\", formAction);\n            }\n            if (formEncType != null) {\n                pushAttribute(target, \"encType\", formEncType);\n            }\n            if (formMethod != null) {\n                pushAttribute(target, \"method\", formMethod);\n            }\n            if (formTarget != null) {\n                pushAttribute(target, \"target\", formTarget);\n            }\n            target.push(endOfStartTag);\n            if (formActionName !== null) {\n                target.push(startHiddenInputChunk);\n                pushStringAttribute(target, \"name\", formActionName);\n                target.push(endOfStartTagSelfClosing);\n                pushAdditionalFormFields(target, formData);\n            }\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushInput(target, props, resumableState, renderState) {\n            {\n                checkControlledValueProps(\"input\", props);\n            }\n            target.push(startChunkForTag(\"input\"));\n            var name = null;\n            var formAction = null;\n            var formEncType = null;\n            var formMethod = null;\n            var formTarget = null;\n            var value = null;\n            var defaultValue = null;\n            var checked = null;\n            var defaultChecked = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"input\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        case \"name\":\n                            name = propValue;\n                            break;\n                        case \"formAction\":\n                            formAction = propValue;\n                            break;\n                        case \"formEncType\":\n                            formEncType = propValue;\n                            break;\n                        case \"formMethod\":\n                            formMethod = propValue;\n                            break;\n                        case \"formTarget\":\n                            formTarget = propValue;\n                            break;\n                        case \"defaultChecked\":\n                            defaultChecked = propValue;\n                            break;\n                        case \"defaultValue\":\n                            defaultValue = propValue;\n                            break;\n                        case \"checked\":\n                            checked = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            {\n                if (formAction !== null && props.type !== \"image\" && props.type !== \"submit\" && !didWarnFormActionType) {\n                    didWarnFormActionType = true;\n                    error('An input can only specify a formAction along with type=\"submit\" or type=\"image\".');\n                }\n            }\n            var formData = pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name);\n            {\n                if (checked !== null && defaultChecked !== null && !didWarnDefaultChecked) {\n                    error(\"%s contains an input of type %s with both checked and defaultChecked props. \" + \"Input elements must be either controlled or uncontrolled \" + \"(specify either the checked prop, or the defaultChecked prop, but not \" + \"both). Decide between using a controlled or uncontrolled input \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", \"A component\", props.type);\n                    didWarnDefaultChecked = true;\n                }\n                if (value !== null && defaultValue !== null && !didWarnDefaultInputValue) {\n                    error(\"%s contains an input of type %s with both value and defaultValue props. \" + \"Input elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled input \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", \"A component\", props.type);\n                    didWarnDefaultInputValue = true;\n                }\n            }\n            if (checked !== null) {\n                pushBooleanAttribute(target, \"checked\", checked);\n            } else if (defaultChecked !== null) {\n                pushBooleanAttribute(target, \"checked\", defaultChecked);\n            }\n            if (value !== null) {\n                pushAttribute(target, \"value\", value);\n            } else if (defaultValue !== null) {\n                pushAttribute(target, \"value\", defaultValue);\n            }\n            target.push(endOfStartTagSelfClosing); // We place any additional hidden form fields after the input.\n            pushAdditionalFormFields(target, formData);\n            return null;\n        }\n        function pushStartButton(target, props, resumableState, renderState) {\n            target.push(startChunkForTag(\"button\"));\n            var children = null;\n            var innerHTML = null;\n            var name = null;\n            var formAction = null;\n            var formEncType = null;\n            var formMethod = null;\n            var formTarget = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"name\":\n                            name = propValue;\n                            break;\n                        case \"formAction\":\n                            formAction = propValue;\n                            break;\n                        case \"formEncType\":\n                            formEncType = propValue;\n                            break;\n                        case \"formMethod\":\n                            formMethod = propValue;\n                            break;\n                        case \"formTarget\":\n                            formTarget = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            {\n                if (formAction !== null && props.type != null && props.type !== \"submit\" && !didWarnFormActionType) {\n                    didWarnFormActionType = true;\n                    error('A button can only specify a formAction along with type=\"submit\" or no type.');\n                }\n            }\n            var formData = pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name);\n            target.push(endOfStartTag); // We place any additional hidden form fields we need to include inside the button itself.\n            pushAdditionalFormFields(target, formData);\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushStartTextArea(target, props) {\n            {\n                checkControlledValueProps(\"textarea\", props);\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {\n                    error(\"Textarea elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled textarea \" + \"and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\");\n                    didWarnDefaultTextareaValue = true;\n                }\n            }\n            target.push(startChunkForTag(\"textarea\"));\n            var value = null;\n            var defaultValue = null;\n            var children = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                            break;\n                        case \"defaultValue\":\n                            defaultValue = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"`dangerouslySetInnerHTML` does not make sense on <textarea>.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (value === null && defaultValue !== null) {\n                value = defaultValue;\n            }\n            target.push(endOfStartTag); // TODO (yungsters): Remove support for children content in <textarea>.\n            if (children != null) {\n                {\n                    error(\"Use the `defaultValue` or `value` props instead of setting \" + \"children on <textarea>.\");\n                }\n                if (value != null) {\n                    throw new Error(\"If you supply `defaultValue` on a <textarea>, do not pass children.\");\n                }\n                if (isArray(children)) {\n                    if (children.length > 1) {\n                        throw new Error(\"<textarea> can only have at most one child.\");\n                    } // TODO: remove the coercion and the DEV check below because it will\n                    // always be overwritten by the coercion several lines below it. #22309\n                    {\n                        checkHtmlStringCoercion(children[0]);\n                    }\n                    value = \"\" + children[0];\n                }\n                {\n                    checkHtmlStringCoercion(children);\n                }\n                value = \"\" + children;\n            }\n            if (typeof value === \"string\" && value[0] === \"\\n\") {\n                // text/html ignores the first character in these tags if it's a newline\n                // Prefer to break application/xml over text/html (for now) by adding\n                // a newline specifically to get eaten by the parser. (Alternately for\n                // textareas, replacing \"^\\n\" with \"\\r\\n\" doesn't get eaten, and the first\n                // \\r is normalized out by HTMLTextAreaElement#value.)\n                // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>\n                // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>\n                // See: <http://www.w3.org/TR/html5/syntax.html#newlines>\n                // See: Parsing of \"textarea\" \"listing\" and \"pre\" elements\n                //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>\n                target.push(leadingNewline);\n            } // ToString and push directly instead of recurse over children.\n            // We don't really support complex children in the value anyway.\n            // This also currently avoids a trailing comment node which breaks textarea.\n            if (value !== null) {\n                {\n                    checkAttributeStringCoercion(value, \"value\");\n                }\n                target.push(stringToChunk(encodeHTMLTextNode(\"\" + value)));\n            }\n            return null;\n        }\n        function pushMeta(target, props, renderState, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null) {\n                    return pushSelfClosing(target, props, \"meta\");\n                } else {\n                    if (textEmbedded) {\n                        // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                        // to be safe and assume text will follow by inserting a textSeparator\n                        target.push(textSeparator);\n                    }\n                    if (typeof props.charSet === \"string\") {\n                        return pushSelfClosing(renderState.charsetChunks, props, \"meta\");\n                    } else if (props.name === \"viewport\") {\n                        // \"viewport\" isn't related to preconnect but it has the right priority\n                        return pushSelfClosing(renderState.preconnectChunks, props, \"meta\");\n                    } else {\n                        return pushSelfClosing(renderState.hoistableChunks, props, \"meta\");\n                    }\n                }\n            }\n        }\n        function pushLink(target, props, resumableState, renderState, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                var rel = props.rel;\n                var href = props.href;\n                var precedence = props.precedence;\n                if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null || typeof rel !== \"string\" || typeof href !== \"string\" || href === \"\") {\n                    {\n                        if (rel === \"stylesheet\" && typeof props.precedence === \"string\") {\n                            if (typeof href !== \"string\" || !href) {\n                                error('React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.', getValueDescriptorExpectingObjectForWarning(href));\n                            }\n                        }\n                    }\n                    pushLinkImpl(target, props);\n                    return null;\n                }\n                if (props.rel === \"stylesheet\") {\n                    // This <link> may hoistable as a Stylesheet Resource, otherwise it will emit in place\n                    var key = getResourceKey(href);\n                    if (typeof precedence !== \"string\" || props.disabled != null || props.onLoad || props.onError) {\n                        // This stylesheet is either not opted into Resource semantics or has conflicting properties which\n                        // disqualify it for such. We can still create a preload resource to help it load faster on the\n                        // client\n                        {\n                            if (typeof precedence === \"string\") {\n                                if (props.disabled != null) {\n                                    error('React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.');\n                                } else if (props.onLoad || props.onError) {\n                                    var propDescription = props.onLoad && props.onError ? \"`onLoad` and `onError` props\" : props.onLoad ? \"`onLoad` prop\" : \"`onError` prop\";\n                                    error('React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.', propDescription, propDescription);\n                                }\n                            }\n                        }\n                        return pushLinkImpl(target, props);\n                    } else {\n                        // This stylesheet refers to a Resource and we create a new one if necessary\n                        var styleQueue = renderState.styles.get(precedence);\n                        var hasKey = resumableState.styleResources.hasOwnProperty(key);\n                        var resourceState = hasKey ? resumableState.styleResources[key] : undefined;\n                        if (resourceState !== EXISTS) {\n                            // We are going to create this resource now so it is marked as Exists\n                            resumableState.styleResources[key] = EXISTS; // If this is the first time we've encountered this precedence we need\n                            // to create a StyleQueue\n                            if (!styleQueue) {\n                                styleQueue = {\n                                    precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                                    rules: [],\n                                    hrefs: [],\n                                    sheets: new Map()\n                                };\n                                renderState.styles.set(precedence, styleQueue);\n                            }\n                            var resource = {\n                                state: PENDING$1,\n                                props: stylesheetPropsFromRawProps(props)\n                            };\n                            if (resourceState) {\n                                // When resourceState is truty it is a Preload state. We cast it for clarity\n                                var preloadState = resourceState;\n                                if (preloadState.length === 2) {\n                                    adoptPreloadCredentials(resource.props, preloadState);\n                                }\n                                var preloadResource = renderState.preloads.stylesheets.get(key);\n                                if (preloadResource && preloadResource.length > 0) {\n                                    // The Preload for this resource was created in this render pass and has not flushed yet so\n                                    // we need to clear it to avoid it flushing.\n                                    preloadResource.length = 0;\n                                } else {\n                                    // Either the preload resource from this render already flushed in this render pass\n                                    // or the preload flushed in a prior pass (prerender). In either case we need to mark\n                                    // this resource as already having been preloaded.\n                                    resource.state = PRELOADED;\n                                }\n                            } // We add the newly created resource to our StyleQueue and if necessary\n                            // track the resource with the currently rendering boundary\n                            styleQueue.sheets.set(key, resource);\n                            if (renderState.boundaryResources) {\n                                renderState.boundaryResources.stylesheets.add(resource);\n                            }\n                        } else {\n                            // We need to track whether this boundary should wait on this resource or not.\n                            // Typically this resource should always exist since we either had it or just created\n                            // it. However, it's possible when you resume that the style has already been emitted\n                            // and then it wouldn't be recreated in the RenderState and there's no need to track\n                            // it again since we should've hoisted it to the shell already.\n                            if (styleQueue) {\n                                var _resource = styleQueue.sheets.get(key);\n                                if (_resource) {\n                                    if (renderState.boundaryResources) {\n                                        renderState.boundaryResources.stylesheets.add(_resource);\n                                    }\n                                }\n                            }\n                        }\n                        if (textEmbedded) {\n                            // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                            // to be safe and assume text will follow by inserting a textSeparator\n                            target.push(textSeparator);\n                        }\n                        return null;\n                    }\n                } else if (props.onLoad || props.onError) {\n                    // When using load handlers we cannot hoist and need to emit links in place\n                    return pushLinkImpl(target, props);\n                } else {\n                    // We can hoist this link so we may need to emit a text separator.\n                    // @TODO refactor text separators so we don't have to defensively add\n                    // them when we don't end up emitting a tag as a result of pushStartInstance\n                    if (textEmbedded) {\n                        // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                        // to be safe and assume text will follow by inserting a textSeparator\n                        target.push(textSeparator);\n                    }\n                    switch(props.rel){\n                        case \"preconnect\":\n                        case \"dns-prefetch\":\n                            return pushLinkImpl(renderState.preconnectChunks, props);\n                        case \"preload\":\n                            return pushLinkImpl(renderState.preloadChunks, props);\n                        default:\n                            return pushLinkImpl(renderState.hoistableChunks, props);\n                    }\n                }\n            }\n        }\n        function pushLinkImpl(target, props) {\n            target.push(startChunkForTag(\"link\"));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"link\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTagSelfClosing);\n            return null;\n        }\n        function pushStyle(target, props, resumableState, renderState, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                if (hasOwnProperty.call(props, \"children\")) {\n                    var children = props.children;\n                    var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n                    if (typeof child === \"function\" || typeof child === \"symbol\" || Array.isArray(child)) {\n                        var childType = typeof child === \"function\" ? \"a Function\" : typeof child === \"symbol\" ? \"a Sybmol\" : \"an Array\";\n                        error(\"React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. \" + \"In browsers style Elements can only have `Text` Nodes as children.\", childType);\n                    }\n                }\n            }\n            {\n                var precedence = props.precedence;\n                var href = props.href;\n                if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null || typeof precedence !== \"string\" || typeof href !== \"string\" || href === \"\") {\n                    // This style tag is not able to be turned into a Style Resource\n                    return pushStyleImpl(target, props);\n                }\n                {\n                    if (href.includes(\" \")) {\n                        error('React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is \"%s\".', href);\n                    }\n                }\n                var key = getResourceKey(href);\n                var styleQueue = renderState.styles.get(precedence);\n                var hasKey = resumableState.styleResources.hasOwnProperty(key);\n                var resourceState = hasKey ? resumableState.styleResources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resumableState.styleResources[key] = EXISTS;\n                    {\n                        if (resourceState) {\n                            error('React encountered a hoistable style tag for the same href as a preload: \"%s\". When using a style tag to inline styles you should not also preload it as a stylsheet.', href);\n                        }\n                    }\n                    if (!styleQueue) {\n                        // This is the first time we've encountered this precedence we need\n                        // to create a StyleQueue.\n                        styleQueue = {\n                            precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                            rules: [],\n                            hrefs: [\n                                stringToChunk(escapeTextForBrowser(href))\n                            ],\n                            sheets: new Map()\n                        };\n                        renderState.styles.set(precedence, styleQueue);\n                    } else {\n                        // We have seen this precedence before and need to track this href\n                        styleQueue.hrefs.push(stringToChunk(escapeTextForBrowser(href)));\n                    }\n                    pushStyleContents(styleQueue.rules, props);\n                }\n                if (styleQueue) {\n                    // We need to track whether this boundary should wait on this resource or not.\n                    // Typically this resource should always exist since we either had it or just created\n                    // it. However, it's possible when you resume that the style has already been emitted\n                    // and then it wouldn't be recreated in the RenderState and there's no need to track\n                    // it again since we should've hoisted it to the shell already.\n                    if (renderState.boundaryResources) {\n                        renderState.boundaryResources.styles.add(styleQueue);\n                    }\n                }\n                if (textEmbedded) {\n                    // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                    // to be safe and assume text will follow by inserting a textSeparator\n                    target.push(textSeparator);\n                }\n            }\n        }\n        function pushStyleImpl(target, props) {\n            target.push(startChunkForTag(\"style\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n            if (typeof child !== \"function\" && typeof child !== \"symbol\" && child !== null && child !== undefined) {\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                target.push(stringToChunk(escapeTextForBrowser(\"\" + child)));\n            }\n            pushInnerHTML(target, innerHTML, children);\n            target.push(endChunkForTag(\"style\"));\n            return null;\n        }\n        function pushStyleContents(target, props) {\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                    }\n                }\n            }\n            var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n            if (typeof child !== \"function\" && typeof child !== \"symbol\" && child !== null && child !== undefined) {\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                target.push(stringToChunk(escapeTextForBrowser(\"\" + child)));\n            }\n            pushInnerHTML(target, innerHTML, children);\n            return;\n        }\n        function pushImg(target, props, resumableState, renderState, pictureTagInScope) {\n            var src = props.src, srcSet = props.srcSet;\n            if (props.loading !== \"lazy\" && (src || srcSet) && (typeof src === \"string\" || src == null) && (typeof srcSet === \"string\" || srcSet == null) && props.fetchPriority !== \"low\" && pictureTagInScope === false && // We exclude data URIs in src and srcSet since these should not be preloaded\n            !(typeof src === \"string\" && src[4] === \":\" && (src[0] === \"d\" || src[0] === \"D\") && (src[1] === \"a\" || src[1] === \"A\") && (src[2] === \"t\" || src[2] === \"T\") && (src[3] === \"a\" || src[3] === \"A\")) && !(typeof srcSet === \"string\" && srcSet[4] === \":\" && (srcSet[0] === \"d\" || srcSet[0] === \"D\") && (srcSet[1] === \"a\" || srcSet[1] === \"A\") && (srcSet[2] === \"t\" || srcSet[2] === \"T\") && (srcSet[3] === \"a\" || srcSet[3] === \"A\"))) {\n                // We have a suspensey image and ought to preload it to optimize the loading of display blocking\n                // resumableState.\n                var sizes = typeof props.sizes === \"string\" ? props.sizes : undefined;\n                var key = getImageResourceKey(src, srcSet, sizes);\n                var promotablePreloads = renderState.preloads.images;\n                var resource = promotablePreloads.get(key);\n                if (resource) {\n                    // We consider whether this preload can be promoted to higher priority flushing queue.\n                    // The only time a resource will exist here is if it was created during this render\n                    // and was not already in the high priority queue.\n                    if (props.fetchPriority === \"high\" || renderState.highImagePreloads.size < 10) {\n                        // Delete the resource from the map since we are promoting it and don't want to\n                        // reenter this branch in a second pass for duplicate img hrefs.\n                        promotablePreloads.delete(key); // $FlowFixMe - Flow should understand that this is a Resource if the condition was true\n                        renderState.highImagePreloads.add(resource);\n                    }\n                } else if (!resumableState.imageResources.hasOwnProperty(key)) {\n                    // We must construct a new preload resource\n                    resumableState.imageResources[key] = PRELOAD_NO_CREDS;\n                    var crossOrigin = getCrossOriginString(props.crossOrigin);\n                    var headers = renderState.headers;\n                    var header;\n                    if (headers && headers.remainingCapacity > 0 && // fetchPriority=\"high\". We use length here which means it will fit fewer images when\n                    // the urls are long and more when short. arguably byte size is a better hueristic because\n                    // it directly translates to how much we send down before content is actually seen.\n                    // We could unify the counts and also make it so the total is tracked regardless of\n                    // flushing output but since the headers are likely to be go earlier than content\n                    // they don't really conflict so for now I've kept them separate\n                    (props.fetchPriority === \"high\" || headers.highImagePreloads.length < 500) && // the params list with arbitrary props and if we copied everything over as it we might get\n                    // coercion errors. We have checks for this in Dev but it seems safer to just only accept values\n                    // that are strings\n                    (header = getPreloadAsHeader(src, \"image\", {\n                        imageSrcSet: props.srcSet,\n                        imageSizes: props.sizes,\n                        crossOrigin: crossOrigin,\n                        integrity: props.integrity,\n                        nonce: props.nonce,\n                        type: props.type,\n                        fetchPriority: props.fetchPriority,\n                        referrerPolicy: props.refererPolicy\n                    }), // we assume all the rest won't as well. This is to avoid getting into a situation\n                    // where we have a very small remaining capacity but no headers will ever fit and we end\n                    // up constantly trying to see if the next resource might make it. In the future we can\n                    // make this behavior different between render and prerender since in the latter case\n                    // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                    // headers.\n                    (headers.remainingCapacity -= header.length) >= 2)) {\n                        // If we postpone in the shell we will still emit this preload so we track\n                        // it to make sure we don't reset it.\n                        renderState.resets.image[key] = PRELOAD_NO_CREDS;\n                        if (headers.highImagePreloads) {\n                            headers.highImagePreloads += \", \";\n                        } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                        headers.highImagePreloads += header;\n                    } else {\n                        resource = [];\n                        pushLinkImpl(resource, {\n                            rel: \"preload\",\n                            as: \"image\",\n                            // There is a bug in Safari where imageSrcSet is not respected on preload links\n                            // so we omit the href here if we have imageSrcSet b/c safari will load the wrong image.\n                            // This harms older browers that do not support imageSrcSet by making their preloads not work\n                            // but this population is shrinking fast and is already small so we accept this tradeoff.\n                            href: srcSet ? undefined : src,\n                            imageSrcSet: srcSet,\n                            imageSizes: sizes,\n                            crossOrigin: crossOrigin,\n                            integrity: props.integrity,\n                            type: props.type,\n                            fetchPriority: props.fetchPriority,\n                            referrerPolicy: props.referrerPolicy\n                        });\n                        if (props.fetchPriority === \"high\" || renderState.highImagePreloads.size < 10) {\n                            renderState.highImagePreloads.add(resource);\n                        } else {\n                            renderState.bulkPreloads.add(resource); // We can bump the priority up if the same img is rendered later\n                            // with fetchPriority=\"high\"\n                            promotablePreloads.set(key, resource);\n                        }\n                    }\n                }\n            }\n            return pushSelfClosing(target, props, \"img\");\n        }\n        function pushSelfClosing(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(tag + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTagSelfClosing);\n            return null;\n        }\n        function pushStartMenuItem(target, props) {\n            target.push(startChunkForTag(\"menuitem\"));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"menuitems cannot have `children` nor `dangerouslySetInnerHTML`.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            return null;\n        }\n        function pushTitle(target, props, renderState, insertionMode, noscriptTagInScope) {\n            {\n                if (hasOwnProperty.call(props, \"children\")) {\n                    var children = props.children;\n                    var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n                    if (Array.isArray(children) && children.length > 1) {\n                        error(\"React expects the `children` prop of <title> tags to be a string, number, or object with a novel `toString` method but found an Array with length %s instead.\" + \" Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value\" + \" which is why Arrays of length greater than 1 are not supported. When using JSX it can be commong to combine text nodes and value nodes.\" + \" For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop\" + \" is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.\", children.length);\n                    } else if (typeof child === \"function\" || typeof child === \"symbol\") {\n                        var childType = typeof child === \"function\" ? \"a Function\" : \"a Sybmol\";\n                        error(\"React expect children of <title> tags to be a string, number, or object with a novel `toString` method but found %s instead.\" + \" Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title>\" + \" tags to a single string value.\", childType);\n                    } else if (child && child.toString === ({}).toString) {\n                        if (child.$$typeof != null) {\n                            error(\"React expects the `children` prop of <title> tags to be a string, number, or object with a novel `toString` method but found an object that appears to be\" + \" a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to\" + \" be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is\" + \" a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.\");\n                        } else {\n                            error(\"React expects the `children` prop of <title> tags to be a string, number, or object with a novel `toString` method but found an object that does not implement\" + \" a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags\" + \" to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title>\" + \" is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>.\");\n                        }\n                    }\n                }\n            }\n            {\n                if (insertionMode !== SVG_MODE && !noscriptTagInScope && props.itemProp == null) {\n                    pushTitleImpl(renderState.hoistableChunks, props);\n                    return null;\n                } else {\n                    return pushTitleImpl(target, props);\n                }\n            }\n        }\n        function pushTitleImpl(target, props) {\n            target.push(startChunkForTag(\"title\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n            if (typeof child !== \"function\" && typeof child !== \"symbol\" && child !== null && child !== undefined) {\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                target.push(stringToChunk(escapeTextForBrowser(\"\" + child)));\n            }\n            pushInnerHTML(target, innerHTML, children);\n            target.push(endChunkForTag(\"title\"));\n            return null;\n        }\n        function pushStartHead(target, props, renderState, insertionMode) {\n            {\n                if (insertionMode < HTML_MODE && renderState.headChunks === null) {\n                    // This <head> is the Document.head and should be part of the preamble\n                    renderState.headChunks = [];\n                    return pushStartGenericElement(renderState.headChunks, props, \"head\");\n                } else {\n                    // This <head> is deep and is likely just an error. we emit it inline though.\n                    // Validation should warn that this tag is the the wrong spot.\n                    return pushStartGenericElement(target, props, \"head\");\n                }\n            }\n        }\n        function pushStartHtml(target, props, renderState, insertionMode) {\n            {\n                if (insertionMode === ROOT_HTML_MODE && renderState.htmlChunks === null) {\n                    // This <html> is the Document.documentElement and should be part of the preamble\n                    renderState.htmlChunks = [\n                        doctypeChunk\n                    ];\n                    return pushStartGenericElement(renderState.htmlChunks, props, \"html\");\n                } else {\n                    // This <html> is deep and is likely just an error. we emit it inline though.\n                    // Validation should warn that this tag is the the wrong spot.\n                    return pushStartGenericElement(target, props, \"html\");\n                }\n            }\n        }\n        function pushScript(target, props, resumableState, renderState, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                var asyncProp = props.async;\n                if (typeof props.src !== \"string\" || !props.src || !(asyncProp && typeof asyncProp !== \"function\" && typeof asyncProp !== \"symbol\") || props.onLoad || props.onError || insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null) {\n                    // This script will not be a resource, we bailout early and emit it in place.\n                    return pushScriptImpl(target, props);\n                }\n                var src = props.src;\n                var key = getResourceKey(src); // We can make this <script> into a ScriptResource\n                var resources, preloads;\n                if (props.type === \"module\") {\n                    resources = resumableState.moduleScriptResources;\n                    preloads = renderState.preloads.moduleScripts;\n                } else {\n                    resources = resumableState.scriptResources;\n                    preloads = renderState.preloads.scripts;\n                }\n                var hasKey = resources.hasOwnProperty(key);\n                var resourceState = hasKey ? resources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resources[key] = EXISTS;\n                    var scriptProps = props;\n                    if (resourceState) {\n                        // When resourceState is truty it is a Preload state. We cast it for clarity\n                        var preloadState = resourceState;\n                        if (preloadState.length === 2) {\n                            scriptProps = assign({}, props);\n                            adoptPreloadCredentials(scriptProps, preloadState);\n                        }\n                        var preloadResource = preloads.get(key);\n                        if (preloadResource) {\n                            // the preload resource exists was created in this render. Now that we have\n                            // a script resource which will emit earlier than a preload would if it\n                            // hasn't already flushed we prevent it from flushing by zeroing the length\n                            preloadResource.length = 0;\n                        }\n                    }\n                    var resource = []; // Add to the script flushing queue\n                    renderState.scripts.add(resource); // encode the tag as Chunks\n                    pushScriptImpl(resource, scriptProps);\n                }\n                if (textEmbedded) {\n                    // This script follows text but we aren't writing a tag. while not as efficient as possible we need\n                    // to be safe and assume text will follow by inserting a textSeparator\n                    target.push(textSeparator);\n                }\n                return null;\n            }\n        }\n        function pushScriptImpl(target, props) {\n            target.push(startChunkForTag(\"script\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            {\n                if (children != null && typeof children !== \"string\") {\n                    var descriptiveStatement = typeof children === \"number\" ? \"a number for children\" : Array.isArray(children) ? \"an array for children\" : \"something unexpected for children\";\n                    error(\"A script element was rendered with %s. If script element has children it must be a single string.\" + \" Consider using dangerouslySetInnerHTML or passing a plain string as children.\", descriptiveStatement);\n                }\n            }\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n            }\n            target.push(endChunkForTag(\"script\"));\n            return null;\n        }\n        function pushStartGenericElement(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushStartCustomElement(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    var attributeName = propKey;\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"style\":\n                            pushStyleAttribute(target, propValue);\n                            break;\n                        case \"suppressContentEditableWarning\":\n                        case \"suppressHydrationWarning\":\n                            break;\n                        case \"className\":\n                        // intentional fallthrough\n                        default:\n                            if (isAttributeNameSafe(propKey) && typeof propValue !== \"function\" && typeof propValue !== \"symbol\") {\n                                target.push(attributeSeparator, stringToChunk(attributeName), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);\n                            }\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        var leadingNewline = stringToPrecomputedChunk(\"\\n\");\n        function pushStartPreformattedElement(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag); // text/html ignores the first character in these tags if it's a newline\n            // Prefer to break application/xml over text/html (for now) by adding\n            // a newline specifically to get eaten by the parser. (Alternately for\n            // textareas, replacing \"^\\n\" with \"\\r\\n\" doesn't get eaten, and the first\n            // \\r is normalized out by HTMLTextAreaElement#value.)\n            // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>\n            // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>\n            // See: <http://www.w3.org/TR/html5/syntax.html#newlines>\n            // See: Parsing of \"textarea\" \"listing\" and \"pre\" elements\n            //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>\n            // TODO: This doesn't deal with the case where the child is an array\n            // or component that returns a string.\n            if (innerHTML != null) {\n                if (children != null) {\n                    throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n                }\n                if (typeof innerHTML !== \"object\" || !(\"__html\" in innerHTML)) {\n                    throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. \" + \"Please visit https://reactjs.org/link/dangerously-set-inner-html \" + \"for more information.\");\n                }\n                var html = innerHTML.__html;\n                if (html !== null && html !== undefined) {\n                    if (typeof html === \"string\" && html.length > 0 && html[0] === \"\\n\") {\n                        target.push(leadingNewline, stringToChunk(html));\n                    } else {\n                        {\n                            checkHtmlStringCoercion(html);\n                        }\n                        target.push(stringToChunk(\"\" + html));\n                    }\n                }\n            }\n            if (typeof children === \"string\" && children[0] === \"\\n\") {\n                target.push(leadingNewline);\n            }\n            return children;\n        } // We accept any tag to be rendered but since this gets injected into arbitrary\n        // HTML, we want to make sure that it's a safe tag.\n        // http://www.w3.org/TR/REC-xml/#NT-Name\n        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/; // Simplified subset\n        var validatedTagCache = new Map();\n        function startChunkForTag(tag) {\n            var tagStartChunk = validatedTagCache.get(tag);\n            if (tagStartChunk === undefined) {\n                if (!VALID_TAG_REGEX.test(tag)) {\n                    throw new Error(\"Invalid tag: \" + tag);\n                }\n                tagStartChunk = stringToPrecomputedChunk(\"<\" + tag);\n                validatedTagCache.set(tag, tagStartChunk);\n            }\n            return tagStartChunk;\n        }\n        function pushStartInstance(target, type, props, resumableState, renderState, formatContext, textEmbedded) {\n            {\n                validateProperties$2(type, props);\n                validateProperties$1(type, props);\n                validateProperties(type, props, null);\n                if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {\n                    error(\"A component is `contentEditable` and contains `children` managed by \" + \"React. It is now your responsibility to guarantee that none of \" + \"those nodes are unexpectedly modified or duplicated. This is \" + \"probably not intentional.\");\n                }\n                if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {\n                    if (type.indexOf(\"-\") === -1 && type.toLowerCase() !== type) {\n                        error(\"<%s /> is using incorrect casing. \" + \"Use PascalCase for React components, \" + \"or lowercase for HTML elements.\", type);\n                    }\n                }\n            }\n            switch(type){\n                case \"div\":\n                case \"span\":\n                case \"svg\":\n                case \"path\":\n                case \"a\":\n                case \"g\":\n                case \"p\":\n                case \"li\":\n                    break;\n                // Special tags\n                case \"select\":\n                    return pushStartSelect(target, props);\n                case \"option\":\n                    return pushStartOption(target, props, formatContext);\n                case \"textarea\":\n                    return pushStartTextArea(target, props);\n                case \"input\":\n                    return pushInput(target, props, resumableState, renderState);\n                case \"button\":\n                    return pushStartButton(target, props, resumableState, renderState);\n                case \"form\":\n                    return pushStartForm(target, props, resumableState, renderState);\n                case \"menuitem\":\n                    return pushStartMenuItem(target, props);\n                case \"title\":\n                    return pushTitle(target, props, renderState, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                case \"link\":\n                    return pushLink(target, props, resumableState, renderState, textEmbedded, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                case \"script\":\n                    return pushScript(target, props, resumableState, renderState, textEmbedded, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                case \"style\":\n                    return pushStyle(target, props, resumableState, renderState, textEmbedded, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                case \"meta\":\n                    return pushMeta(target, props, renderState, textEmbedded, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                // Newline eating tags\n                case \"listing\":\n                case \"pre\":\n                    {\n                        return pushStartPreformattedElement(target, props, type);\n                    }\n                case \"img\":\n                    {\n                        return pushImg(target, props, resumableState, renderState, !!(formatContext.tagScope & PICTURE_SCOPE));\n                    }\n                // Omitted close tags\n                case \"base\":\n                case \"area\":\n                case \"br\":\n                case \"col\":\n                case \"embed\":\n                case \"hr\":\n                case \"keygen\":\n                case \"param\":\n                case \"source\":\n                case \"track\":\n                case \"wbr\":\n                    {\n                        return pushSelfClosing(target, props, type);\n                    }\n                // These are reserved SVG and MathML elements, that are never custom elements.\n                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n                case \"annotation-xml\":\n                case \"color-profile\":\n                case \"font-face\":\n                case \"font-face-src\":\n                case \"font-face-uri\":\n                case \"font-face-format\":\n                case \"font-face-name\":\n                case \"missing-glyph\":\n                    {\n                        break;\n                    }\n                // Preamble start tags\n                case \"head\":\n                    return pushStartHead(target, props, renderState, formatContext.insertionMode);\n                case \"html\":\n                    {\n                        return pushStartHtml(target, props, renderState, formatContext.insertionMode);\n                    }\n                default:\n                    {\n                        if (type.indexOf(\"-\") !== -1) {\n                            // Custom element\n                            return pushStartCustomElement(target, props, type);\n                        }\n                    }\n            } // Generic element\n            return pushStartGenericElement(target, props, type);\n        }\n        var endTagCache = new Map();\n        function endChunkForTag(tag) {\n            var chunk = endTagCache.get(tag);\n            if (chunk === undefined) {\n                chunk = stringToPrecomputedChunk(\"</\" + tag + \">\");\n                endTagCache.set(tag, chunk);\n            }\n            return chunk;\n        }\n        function pushEndInstance(target, type, props, resumableState, formatContext) {\n            switch(type){\n                // When float is on we expect title and script tags to always be pushed in\n                // a unit and never return children. when we end up pushing the end tag we\n                // want to ensure there is no extra closing tag pushed\n                case \"title\":\n                case \"style\":\n                case \"script\":\n                // Omitted close tags\n                // TODO: Instead of repeating this switch we could try to pass a flag from above.\n                // That would require returning a tuple. Which might be ok if it gets inlined.\n                case \"area\":\n                case \"base\":\n                case \"br\":\n                case \"col\":\n                case \"embed\":\n                case \"hr\":\n                case \"img\":\n                case \"input\":\n                case \"keygen\":\n                case \"link\":\n                case \"meta\":\n                case \"param\":\n                case \"source\":\n                case \"track\":\n                case \"wbr\":\n                    {\n                        // No close tag needed.\n                        return;\n                    }\n                // Postamble end tags\n                // When float is enabled we omit the end tags for body and html when\n                // they represent the Document.body and Document.documentElement Nodes.\n                // This is so we can withhold them until the postamble when we know\n                // we won't emit any more tags\n                case \"body\":\n                    {\n                        if (formatContext.insertionMode <= HTML_HTML_MODE) {\n                            resumableState.hasBody = true;\n                            return;\n                        }\n                        break;\n                    }\n                case \"html\":\n                    if (formatContext.insertionMode === ROOT_HTML_MODE) {\n                        resumableState.hasHtml = true;\n                        return;\n                    }\n                    break;\n            }\n            target.push(endChunkForTag(type));\n        }\n        function writeBootstrap(destination, renderState) {\n            var bootstrapChunks = renderState.bootstrapChunks;\n            var i = 0;\n            for(; i < bootstrapChunks.length - 1; i++){\n                writeChunk(destination, bootstrapChunks[i]);\n            }\n            if (i < bootstrapChunks.length) {\n                var lastChunk = bootstrapChunks[i];\n                bootstrapChunks.length = 0;\n                return writeChunkAndReturn(destination, lastChunk);\n            }\n            return true;\n        }\n        function writeCompletedRoot(destination, renderState) {\n            return writeBootstrap(destination, renderState);\n        } // Structural Nodes\n        // A placeholder is a node inside a hidden partial tree that can be filled in later, but before\n        // display. It's never visible to users. We use the template tag because it can be used in every\n        // type of parent. <script> tags also work in every other tag except <colgroup>.\n        var placeholder1 = stringToPrecomputedChunk('<template id=\"');\n        var placeholder2 = stringToPrecomputedChunk('\"></template>');\n        function writePlaceholder(destination, renderState, id) {\n            writeChunk(destination, placeholder1);\n            writeChunk(destination, renderState.placeholderPrefix);\n            var formattedID = stringToChunk(id.toString(16));\n            writeChunk(destination, formattedID);\n            return writeChunkAndReturn(destination, placeholder2);\n        } // Suspense boundaries are encoded as comments.\n        var startCompletedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$-->\");\n        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id=\"');\n        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('\"></template>');\n        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$!-->\");\n        var endSuspenseBoundary = stringToPrecomputedChunk(\"<!--/$-->\");\n        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk(\"<template\");\n        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('\"');\n        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst=\"');\n        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg=\"');\n        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck=\"');\n        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk(\"></template>\");\n        function writeStartCompletedSuspenseBoundary$1(destination, renderState) {\n            return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);\n        }\n        function writeStartPendingSuspenseBoundary(destination, renderState, id) {\n            writeChunk(destination, startPendingSuspenseBoundary1);\n            if (id === null) {\n                throw new Error(\"An ID must have been assigned before we can complete the boundary.\");\n            }\n            writeChunk(destination, renderState.boundaryPrefix);\n            writeChunk(destination, stringToChunk(id.toString(16)));\n            return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);\n        }\n        function writeStartClientRenderedSuspenseBoundary$1(destination, renderState, errorDigest, errorMesssage, errorComponentStack) {\n            var result;\n            result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);\n            writeChunk(destination, clientRenderedSuspenseBoundaryError1);\n            if (errorDigest) {\n                writeChunk(destination, clientRenderedSuspenseBoundaryError1A);\n                writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));\n                writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n            }\n            {\n                if (errorMesssage) {\n                    writeChunk(destination, clientRenderedSuspenseBoundaryError1B);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));\n                    writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n                }\n                if (errorComponentStack) {\n                    writeChunk(destination, clientRenderedSuspenseBoundaryError1C);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));\n                    writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n                }\n            }\n            result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);\n            return result;\n        }\n        function writeEndCompletedSuspenseBoundary$1(destination, renderState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        function writeEndPendingSuspenseBoundary(destination, renderState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        function writeEndClientRenderedSuspenseBoundary$1(destination, renderState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id=\"');\n        var startSegmentHTML2 = stringToPrecomputedChunk('\">');\n        var endSegmentHTML = stringToPrecomputedChunk(\"</div>\");\n        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden=\"true\" style=\"display:none\" id=\"');\n        var startSegmentSVG2 = stringToPrecomputedChunk('\">');\n        var endSegmentSVG = stringToPrecomputedChunk(\"</svg>\");\n        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden=\"true\" style=\"display:none\" id=\"');\n        var startSegmentMathML2 = stringToPrecomputedChunk('\">');\n        var endSegmentMathML = stringToPrecomputedChunk(\"</math>\");\n        var startSegmentTable = stringToPrecomputedChunk('<table hidden id=\"');\n        var startSegmentTable2 = stringToPrecomputedChunk('\">');\n        var endSegmentTable = stringToPrecomputedChunk(\"</table>\");\n        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id=\"');\n        var startSegmentTableBody2 = stringToPrecomputedChunk('\">');\n        var endSegmentTableBody = stringToPrecomputedChunk(\"</tbody></table>\");\n        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id=\"');\n        var startSegmentTableRow2 = stringToPrecomputedChunk('\">');\n        var endSegmentTableRow = stringToPrecomputedChunk(\"</tr></table>\");\n        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id=\"');\n        var startSegmentColGroup2 = stringToPrecomputedChunk('\">');\n        var endSegmentColGroup = stringToPrecomputedChunk(\"</colgroup></table>\");\n        function writeStartSegment(destination, renderState, formatContext, id) {\n            switch(formatContext.insertionMode){\n                case ROOT_HTML_MODE:\n                case HTML_HTML_MODE:\n                case HTML_MODE:\n                    {\n                        writeChunk(destination, startSegmentHTML);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentHTML2);\n                    }\n                case SVG_MODE:\n                    {\n                        writeChunk(destination, startSegmentSVG);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentSVG2);\n                    }\n                case MATHML_MODE:\n                    {\n                        writeChunk(destination, startSegmentMathML);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentMathML2);\n                    }\n                case HTML_TABLE_MODE:\n                    {\n                        writeChunk(destination, startSegmentTable);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTable2);\n                    }\n                // TODO: For the rest of these, there will be extra wrapper nodes that never\n                // get deleted from the document. We need to delete the table too as part\n                // of the injected scripts. They are invisible though so it's not too terrible\n                // and it's kind of an edge case to suspend in a table. Totally supported though.\n                case HTML_TABLE_BODY_MODE:\n                    {\n                        writeChunk(destination, startSegmentTableBody);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTableBody2);\n                    }\n                case HTML_TABLE_ROW_MODE:\n                    {\n                        writeChunk(destination, startSegmentTableRow);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTableRow2);\n                    }\n                case HTML_COLGROUP_MODE:\n                    {\n                        writeChunk(destination, startSegmentColGroup);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentColGroup2);\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown insertion mode. This is a bug in React.\");\n                    }\n            }\n        }\n        function writeEndSegment(destination, formatContext) {\n            switch(formatContext.insertionMode){\n                case ROOT_HTML_MODE:\n                case HTML_HTML_MODE:\n                case HTML_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentHTML);\n                    }\n                case SVG_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentSVG);\n                    }\n                case MATHML_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentMathML);\n                    }\n                case HTML_TABLE_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTable);\n                    }\n                case HTML_TABLE_BODY_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTableBody);\n                    }\n                case HTML_TABLE_ROW_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTableRow);\n                    }\n                case HTML_COLGROUP_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentColGroup);\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown insertion mode. This is a bug in React.\");\n                    }\n            }\n        }\n        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegment + '$RS(\"');\n        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS(\"');\n        var completeSegmentScript2 = stringToPrecomputedChunk('\",\"');\n        var completeSegmentScriptEnd = stringToPrecomputedChunk('\")</script>');\n        var completeSegmentData1 = stringToPrecomputedChunk('<template data-rsi=\"\" data-sid=\"');\n        var completeSegmentData2 = stringToPrecomputedChunk('\" data-pid=\"');\n        var completeSegmentDataEnd = dataElementQuotedEnd;\n        function writeCompletedSegmentInstruction(destination, resumableState, renderState, contentSegmentID) {\n            var scriptFormat = resumableState.streamingFormat === ScriptStreamingFormat;\n            if (scriptFormat) {\n                writeChunk(destination, renderState.startInlineScript);\n                if ((resumableState.instructions & SentCompleteSegmentFunction) === NothingSent) {\n                    // The first time we write this, we'll need to include the full implementation.\n                    resumableState.instructions |= SentCompleteSegmentFunction;\n                    writeChunk(destination, completeSegmentScript1Full);\n                } else {\n                    // Future calls can just reuse the same function.\n                    writeChunk(destination, completeSegmentScript1Partial);\n                }\n            } else {\n                writeChunk(destination, completeSegmentData1);\n            } // Write function arguments, which are string literals\n            writeChunk(destination, renderState.segmentPrefix);\n            var formattedID = stringToChunk(contentSegmentID.toString(16));\n            writeChunk(destination, formattedID);\n            if (scriptFormat) {\n                writeChunk(destination, completeSegmentScript2);\n            } else {\n                writeChunk(destination, completeSegmentData2);\n            }\n            writeChunk(destination, renderState.placeholderPrefix);\n            writeChunk(destination, formattedID);\n            if (scriptFormat) {\n                return writeChunkAndReturn(destination, completeSegmentScriptEnd);\n            } else {\n                return writeChunkAndReturn(destination, completeSegmentDataEnd);\n            }\n        }\n        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundary + '$RC(\"');\n        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC(\"');\n        var completeBoundaryWithStylesScript1FullBoth = stringToPrecomputedChunk(completeBoundary + completeBoundaryWithStyles + '$RR(\"');\n        var completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(completeBoundaryWithStyles + '$RR(\"');\n        var completeBoundaryWithStylesScript1Partial = stringToPrecomputedChunk('$RR(\"');\n        var completeBoundaryScript2 = stringToPrecomputedChunk('\",\"');\n        var completeBoundaryScript3a = stringToPrecomputedChunk('\",');\n        var completeBoundaryScript3b = stringToPrecomputedChunk('\"');\n        var completeBoundaryScriptEnd = stringToPrecomputedChunk(\")</script>\");\n        var completeBoundaryData1 = stringToPrecomputedChunk('<template data-rci=\"\" data-bid=\"');\n        var completeBoundaryWithStylesData1 = stringToPrecomputedChunk('<template data-rri=\"\" data-bid=\"');\n        var completeBoundaryData2 = stringToPrecomputedChunk('\" data-sid=\"');\n        var completeBoundaryData3a = stringToPrecomputedChunk('\" data-sty=\"');\n        var completeBoundaryDataEnd = dataElementQuotedEnd;\n        function writeCompletedBoundaryInstruction(destination, resumableState, renderState, id, boundaryResources) {\n            var requiresStyleInsertion;\n            {\n                requiresStyleInsertion = renderState.stylesToHoist; // If necessary stylesheets will be flushed with this instruction.\n                // Any style tags not yet hoisted in the Document will also be hoisted.\n                // We reset this state since after this instruction executes all styles\n                // up to this point will have been hoisted\n                renderState.stylesToHoist = false;\n            }\n            var scriptFormat = resumableState.streamingFormat === ScriptStreamingFormat;\n            if (scriptFormat) {\n                writeChunk(destination, renderState.startInlineScript);\n                if (requiresStyleInsertion) {\n                    if ((resumableState.instructions & SentCompleteBoundaryFunction) === NothingSent) {\n                        resumableState.instructions |= SentStyleInsertionFunction | SentCompleteBoundaryFunction;\n                        writeChunk(destination, clonePrecomputedChunk(completeBoundaryWithStylesScript1FullBoth));\n                    } else if ((resumableState.instructions & SentStyleInsertionFunction) === NothingSent) {\n                        resumableState.instructions |= SentStyleInsertionFunction;\n                        writeChunk(destination, completeBoundaryWithStylesScript1FullPartial);\n                    } else {\n                        writeChunk(destination, completeBoundaryWithStylesScript1Partial);\n                    }\n                } else {\n                    if ((resumableState.instructions & SentCompleteBoundaryFunction) === NothingSent) {\n                        resumableState.instructions |= SentCompleteBoundaryFunction;\n                        writeChunk(destination, completeBoundaryScript1Full);\n                    } else {\n                        writeChunk(destination, completeBoundaryScript1Partial);\n                    }\n                }\n            } else {\n                if (requiresStyleInsertion) {\n                    writeChunk(destination, completeBoundaryWithStylesData1);\n                } else {\n                    writeChunk(destination, completeBoundaryData1);\n                }\n            }\n            var idChunk = stringToChunk(id.toString(16));\n            writeChunk(destination, renderState.boundaryPrefix);\n            writeChunk(destination, idChunk); // Write function arguments, which are string and array literals\n            if (scriptFormat) {\n                writeChunk(destination, completeBoundaryScript2);\n            } else {\n                writeChunk(destination, completeBoundaryData2);\n            }\n            writeChunk(destination, renderState.segmentPrefix);\n            writeChunk(destination, idChunk);\n            if (requiresStyleInsertion) {\n                // Script and data writers must format this differently:\n                //  - script writer emits an array literal, whose string elements are\n                //    escaped for javascript  e.g. [\"A\", \"B\"]\n                //  - data writer emits a string literal, which is escaped as html\n                //    e.g. [&#34;A&#34;, &#34;B&#34;]\n                if (scriptFormat) {\n                    writeChunk(destination, completeBoundaryScript3a); // boundaryResources encodes an array literal\n                    writeStyleResourceDependenciesInJS(destination, boundaryResources);\n                } else {\n                    writeChunk(destination, completeBoundaryData3a);\n                    writeStyleResourceDependenciesInAttr(destination, boundaryResources);\n                }\n            } else {\n                if (scriptFormat) {\n                    writeChunk(destination, completeBoundaryScript3b);\n                }\n            }\n            var writeMore;\n            if (scriptFormat) {\n                writeMore = writeChunkAndReturn(destination, completeBoundaryScriptEnd);\n            } else {\n                writeMore = writeChunkAndReturn(destination, completeBoundaryDataEnd);\n            }\n            return writeBootstrap(destination, renderState) && writeMore;\n        }\n        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderBoundary + ';$RX(\"');\n        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX(\"');\n        var clientRenderScript1A = stringToPrecomputedChunk('\"');\n        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(\",\");\n        var clientRenderScriptEnd = stringToPrecomputedChunk(\")</script>\");\n        var clientRenderData1 = stringToPrecomputedChunk('<template data-rxi=\"\" data-bid=\"');\n        var clientRenderData2 = stringToPrecomputedChunk('\" data-dgst=\"');\n        var clientRenderData3 = stringToPrecomputedChunk('\" data-msg=\"');\n        var clientRenderData4 = stringToPrecomputedChunk('\" data-stck=\"');\n        var clientRenderDataEnd = dataElementQuotedEnd;\n        function writeClientRenderBoundaryInstruction(destination, resumableState, renderState, id, errorDigest, errorMessage, errorComponentStack) {\n            var scriptFormat = resumableState.streamingFormat === ScriptStreamingFormat;\n            if (scriptFormat) {\n                writeChunk(destination, renderState.startInlineScript);\n                if ((resumableState.instructions & SentClientRenderFunction) === NothingSent) {\n                    // The first time we write this, we'll need to include the full implementation.\n                    resumableState.instructions |= SentClientRenderFunction;\n                    writeChunk(destination, clientRenderScript1Full);\n                } else {\n                    // Future calls can just reuse the same function.\n                    writeChunk(destination, clientRenderScript1Partial);\n                }\n            } else {\n                // <template data-rxi=\"\" data-bid=\"\n                writeChunk(destination, clientRenderData1);\n            }\n            writeChunk(destination, renderState.boundaryPrefix);\n            writeChunk(destination, stringToChunk(id.toString(16)));\n            if (scriptFormat) {\n                // \" needs to be inserted for scripts, since ArgInterstitual does not contain\n                // leading or trailing quotes\n                writeChunk(destination, clientRenderScript1A);\n            }\n            if (errorDigest || errorMessage || errorComponentStack) {\n                if (scriptFormat) {\n                    // ,\"JSONString\"\n                    writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                    writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || \"\")));\n                } else {\n                    // \" data-dgst=\"HTMLString\n                    writeChunk(destination, clientRenderData2);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest || \"\")));\n                }\n            }\n            if (errorMessage || errorComponentStack) {\n                if (scriptFormat) {\n                    // ,\"JSONString\"\n                    writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                    writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || \"\")));\n                } else {\n                    // \" data-msg=\"HTMLString\n                    writeChunk(destination, clientRenderData3);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMessage || \"\")));\n                }\n            }\n            if (errorComponentStack) {\n                // ,\"JSONString\"\n                if (scriptFormat) {\n                    writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                    writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));\n                } else {\n                    // \" data-stck=\"HTMLString\n                    writeChunk(destination, clientRenderData4);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));\n                }\n            }\n            if (scriptFormat) {\n                // ></script>\n                return writeChunkAndReturn(destination, clientRenderScriptEnd);\n            } else {\n                // \"></template>\n                return writeChunkAndReturn(destination, clientRenderDataEnd);\n            }\n        }\n        var regexForJSStringsInInstructionScripts = /[<\\u2028\\u2029]/g;\n        function escapeJSStringsForInstructionScripts(input) {\n            var escaped = JSON.stringify(input);\n            return escaped.replace(regexForJSStringsInInstructionScripts, function(match) {\n                switch(match){\n                    // santizing breaking out of strings and script tags\n                    case \"<\":\n                        return \"\\\\u003c\";\n                    case \"\\u2028\":\n                        return \"\\\\u2028\";\n                    case \"\\u2029\":\n                        return \"\\\\u2029\";\n                    default:\n                        {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error(\"escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                        }\n                }\n            });\n        }\n        var regexForJSStringsInScripts = /[&><\\u2028\\u2029]/g;\n        function escapeJSObjectForInstructionScripts(input) {\n            var escaped = JSON.stringify(input);\n            return escaped.replace(regexForJSStringsInScripts, function(match) {\n                switch(match){\n                    // santizing breaking out of strings and script tags\n                    case \"&\":\n                        return \"\\\\u0026\";\n                    case \">\":\n                        return \"\\\\u003e\";\n                    case \"<\":\n                        return \"\\\\u003c\";\n                    case \"\\u2028\":\n                        return \"\\\\u2028\";\n                    case \"\\u2029\":\n                        return \"\\\\u2029\";\n                    default:\n                        {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error(\"escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                        }\n                }\n            });\n        }\n        var lateStyleTagResourceOpen1 = stringToPrecomputedChunk('<style media=\"not all\" data-precedence=\"');\n        var lateStyleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"');\n        var lateStyleTagResourceOpen3 = stringToPrecomputedChunk('\">');\n        var lateStyleTagTemplateClose = stringToPrecomputedChunk(\"</style>\"); // Tracks whether the boundary currently flushing is flushign style tags or has any\n        // stylesheet dependencies not flushed in the Preamble.\n        var currentlyRenderingBoundaryHasStylesToHoist = false; // Acts as a return value for the forEach execution of style tag flushing.\n        var destinationHasCapacity = true;\n        function flushStyleTagsLateForBoundary(styleQueue) {\n            var rules = styleQueue.rules;\n            var hrefs = styleQueue.hrefs;\n            {\n                if (rules.length > 0 && hrefs.length === 0) {\n                    error(\"React expected to have at least one href for an a hoistable style but found none. This is a bug in React.\");\n                }\n            }\n            var i = 0;\n            if (hrefs.length) {\n                writeChunk(this, lateStyleTagResourceOpen1);\n                writeChunk(this, styleQueue.precedence);\n                writeChunk(this, lateStyleTagResourceOpen2);\n                for(; i < hrefs.length - 1; i++){\n                    writeChunk(this, hrefs[i]);\n                    writeChunk(this, spaceSeparator);\n                }\n                writeChunk(this, hrefs[i]);\n                writeChunk(this, lateStyleTagResourceOpen3);\n                for(i = 0; i < rules.length; i++){\n                    writeChunk(this, rules[i]);\n                }\n                destinationHasCapacity = writeChunkAndReturn(this, lateStyleTagTemplateClose); // We wrote style tags for this boundary and we may need to emit a script\n                // to hoist them.\n                currentlyRenderingBoundaryHasStylesToHoist = true; // style resources can flush continuously since more rules may be written into\n                // them with new hrefs. Instead of marking it flushed, we simply reset the chunks\n                // and hrefs\n                rules.length = 0;\n                hrefs.length = 0;\n            }\n        }\n        function hasStylesToHoist(stylesheet) {\n            // We need to reveal boundaries with styles whenever a stylesheet it depends on is either\n            // not flushed or flushed after the preamble (shell).\n            if (stylesheet.state !== PREAMBLE) {\n                currentlyRenderingBoundaryHasStylesToHoist = true;\n                return true;\n            }\n            return false;\n        }\n        function writeResourcesForBoundary(destination, boundaryResources, renderState) {\n            // Reset these on each invocation, they are only safe to read in this function\n            currentlyRenderingBoundaryHasStylesToHoist = false;\n            destinationHasCapacity = true; // Flush style tags for each precedence this boundary depends on\n            boundaryResources.styles.forEach(flushStyleTagsLateForBoundary, destination); // Determine if this boundary has stylesheets that need to be awaited upon completion\n            boundaryResources.stylesheets.forEach(hasStylesToHoist);\n            if (currentlyRenderingBoundaryHasStylesToHoist) {\n                renderState.stylesToHoist = true;\n            }\n            return destinationHasCapacity;\n        }\n        function flushResource(resource) {\n            for(var i = 0; i < resource.length; i++){\n                writeChunk(this, resource[i]);\n            }\n            resource.length = 0;\n        }\n        var stylesheetFlushingQueue = [];\n        function flushStyleInPreamble(stylesheet, key, map) {\n            // We still need to encode stylesheet chunks\n            // because unlike most Hoistables and Resources we do not eagerly encode\n            // them during render. This is because if we flush late we have to send a\n            // different encoding and we don't want to encode multiple times\n            pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);\n            for(var i = 0; i < stylesheetFlushingQueue.length; i++){\n                writeChunk(this, stylesheetFlushingQueue[i]);\n            }\n            stylesheetFlushingQueue.length = 0;\n            stylesheet.state = PREAMBLE;\n        }\n        var styleTagResourceOpen1 = stringToPrecomputedChunk('<style data-precedence=\"');\n        var styleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"');\n        var spaceSeparator = stringToPrecomputedChunk(\" \");\n        var styleTagResourceOpen3 = stringToPrecomputedChunk('\">');\n        var styleTagResourceClose = stringToPrecomputedChunk(\"</style>\");\n        function flushStylesInPreamble(styleQueue, precedence) {\n            var hasStylesheets = styleQueue.sheets.size > 0;\n            styleQueue.sheets.forEach(flushStyleInPreamble, this);\n            styleQueue.sheets.clear();\n            var rules = styleQueue.rules;\n            var hrefs = styleQueue.hrefs; // If we don't emit any stylesheets at this precedence we still need to maintain the precedence\n            // order so even if there are no rules for style tags at this precedence we emit an empty style\n            // tag with the data-precedence attribute\n            if (!hasStylesheets || hrefs.length) {\n                writeChunk(this, styleTagResourceOpen1);\n                writeChunk(this, styleQueue.precedence);\n                var i = 0;\n                if (hrefs.length) {\n                    writeChunk(this, styleTagResourceOpen2);\n                    for(; i < hrefs.length - 1; i++){\n                        writeChunk(this, hrefs[i]);\n                        writeChunk(this, spaceSeparator);\n                    }\n                    writeChunk(this, hrefs[i]);\n                }\n                writeChunk(this, styleTagResourceOpen3);\n                for(i = 0; i < rules.length; i++){\n                    writeChunk(this, rules[i]);\n                }\n                writeChunk(this, styleTagResourceClose); // style resources can flush continuously since more rules may be written into\n                // them with new hrefs. Instead of marking it flushed, we simply reset the chunks\n                // and hrefs\n                rules.length = 0;\n                hrefs.length = 0;\n            }\n        }\n        function preloadLateStyle(stylesheet) {\n            if (stylesheet.state === PENDING$1) {\n                stylesheet.state = PRELOADED;\n                var preloadProps = preloadAsStylePropsFromProps(stylesheet.props.href, stylesheet.props);\n                pushLinkImpl(stylesheetFlushingQueue, preloadProps);\n                for(var i = 0; i < stylesheetFlushingQueue.length; i++){\n                    writeChunk(this, stylesheetFlushingQueue[i]);\n                }\n                stylesheetFlushingQueue.length = 0;\n            }\n        }\n        function preloadLateStyles(styleQueue) {\n            styleQueue.sheets.forEach(preloadLateStyle, this);\n            styleQueue.sheets.clear();\n        } // We don't bother reporting backpressure at the moment because we expect to\n        // flush the entire preamble in a single pass. This probably should be modified\n        // in the future to be backpressure sensitive but that requires a larger refactor\n        // of the flushing code in Fizz.\n        function writePreamble(destination, resumableState, renderState, willFlushAllSegments) {\n            // This function must be called exactly once on every request\n            if (!willFlushAllSegments && renderState.externalRuntimeScript) {\n                // If the root segment is incomplete due to suspended tasks\n                // (e.g. willFlushAllSegments = false) and we are using data\n                // streaming format, ensure the external runtime is sent.\n                // (User code could choose to send this even earlier by calling\n                //  preinit(...), if they know they will suspend).\n                var _renderState$external = renderState.externalRuntimeScript, src = _renderState$external.src, chunks = _renderState$external.chunks;\n                internalPreinitScript(resumableState, renderState, src, chunks);\n            }\n            var htmlChunks = renderState.htmlChunks;\n            var headChunks = renderState.headChunks;\n            var i = 0; // Emit open tags before Hoistables and Resources\n            if (htmlChunks) {\n                // We have an <html> to emit as part of the preamble\n                for(i = 0; i < htmlChunks.length; i++){\n                    writeChunk(destination, htmlChunks[i]);\n                }\n                if (headChunks) {\n                    for(i = 0; i < headChunks.length; i++){\n                        writeChunk(destination, headChunks[i]);\n                    }\n                } else {\n                    // We did not render a head but we emitted an <html> so we emit one now\n                    writeChunk(destination, startChunkForTag(\"head\"));\n                    writeChunk(destination, endOfStartTag);\n                }\n            } else if (headChunks) {\n                // We do not have an <html> but we do have a <head>\n                for(i = 0; i < headChunks.length; i++){\n                    writeChunk(destination, headChunks[i]);\n                }\n            } // Emit high priority Hoistables\n            var charsetChunks = renderState.charsetChunks;\n            for(i = 0; i < charsetChunks.length; i++){\n                writeChunk(destination, charsetChunks[i]);\n            }\n            charsetChunks.length = 0; // emit preconnect resources\n            renderState.preconnects.forEach(flushResource, destination);\n            renderState.preconnects.clear();\n            var preconnectChunks = renderState.preconnectChunks;\n            for(i = 0; i < preconnectChunks.length; i++){\n                writeChunk(destination, preconnectChunks[i]);\n            }\n            preconnectChunks.length = 0;\n            renderState.fontPreloads.forEach(flushResource, destination);\n            renderState.fontPreloads.clear();\n            renderState.highImagePreloads.forEach(flushResource, destination);\n            renderState.highImagePreloads.clear(); // Flush unblocked stylesheets by precedence\n            renderState.styles.forEach(flushStylesInPreamble, destination);\n            var importMapChunks = renderState.importMapChunks;\n            for(i = 0; i < importMapChunks.length; i++){\n                writeChunk(destination, importMapChunks[i]);\n            }\n            importMapChunks.length = 0;\n            renderState.bootstrapScripts.forEach(flushResource, destination);\n            renderState.scripts.forEach(flushResource, destination);\n            renderState.scripts.clear();\n            renderState.bulkPreloads.forEach(flushResource, destination);\n            renderState.bulkPreloads.clear(); // Write embedding preloadChunks\n            var preloadChunks = renderState.preloadChunks;\n            for(i = 0; i < preloadChunks.length; i++){\n                writeChunk(destination, preloadChunks[i]);\n            }\n            preloadChunks.length = 0; // Write embedding hoistableChunks\n            var hoistableChunks = renderState.hoistableChunks;\n            for(i = 0; i < hoistableChunks.length; i++){\n                writeChunk(destination, hoistableChunks[i]);\n            }\n            hoistableChunks.length = 0; // Flush closing head if necessary\n            if (htmlChunks && headChunks === null) {\n                // We have an <html> rendered but no <head> rendered. We however inserted\n                // a <head> up above so we need to emit the </head> now. This is safe because\n                // if the main content contained the </head> it would also have provided a\n                // <head>. This means that all the content inside <html> is either <body> or\n                // invalid HTML\n                writeChunk(destination, endChunkForTag(\"head\"));\n            }\n        } // We don't bother reporting backpressure at the moment because we expect to\n        // flush the entire preamble in a single pass. This probably should be modified\n        // in the future to be backpressure sensitive but that requires a larger refactor\n        // of the flushing code in Fizz.\n        function writeHoistables(destination, resumableState, renderState) {\n            var i = 0; // Emit high priority Hoistables\n            // We omit charsetChunks because we have already sent the shell and if it wasn't\n            // already sent it is too late now.\n            renderState.preconnects.forEach(flushResource, destination);\n            renderState.preconnects.clear();\n            var preconnectChunks = renderState.preconnectChunks;\n            for(i = 0; i < preconnectChunks.length; i++){\n                writeChunk(destination, preconnectChunks[i]);\n            }\n            preconnectChunks.length = 0;\n            renderState.fontPreloads.forEach(flushResource, destination);\n            renderState.fontPreloads.clear();\n            renderState.highImagePreloads.forEach(flushResource, destination);\n            renderState.highImagePreloads.clear(); // Preload any stylesheets. these will emit in a render instruction that follows this\n            // but we want to kick off preloading as soon as possible\n            renderState.styles.forEach(preloadLateStyles, destination); // We only hoist importmaps that are configured through createResponse and that will\n            // always flush in the preamble. Generally we don't expect people to render them as\n            // tags when using React but if you do they are going to be treated like regular inline\n            // scripts and flush after other hoistables which is problematic\n            // bootstrap scripts should flush above script priority but these can only flush in the preamble\n            // so we elide the code here for performance\n            renderState.scripts.forEach(flushResource, destination);\n            renderState.scripts.clear();\n            renderState.bulkPreloads.forEach(flushResource, destination);\n            renderState.bulkPreloads.clear(); // Write embedding preloadChunks\n            var preloadChunks = renderState.preloadChunks;\n            for(i = 0; i < preloadChunks.length; i++){\n                writeChunk(destination, preloadChunks[i]);\n            }\n            preloadChunks.length = 0; // Write embedding hoistableChunks\n            var hoistableChunks = renderState.hoistableChunks;\n            for(i = 0; i < hoistableChunks.length; i++){\n                writeChunk(destination, hoistableChunks[i]);\n            }\n            hoistableChunks.length = 0;\n        }\n        function writePostamble(destination, resumableState) {\n            if (resumableState.hasBody) {\n                writeChunk(destination, endChunkForTag(\"body\"));\n            }\n            if (resumableState.hasHtml) {\n                writeChunk(destination, endChunkForTag(\"html\"));\n            }\n        }\n        var arrayFirstOpenBracket = stringToPrecomputedChunk(\"[\");\n        var arraySubsequentOpenBracket = stringToPrecomputedChunk(\",[\");\n        var arrayInterstitial = stringToPrecomputedChunk(\",\");\n        var arrayCloseBracket = stringToPrecomputedChunk(\"]\"); // This function writes a 2D array of strings to be embedded in javascript.\n        // E.g.\n        //  [[\"JS_escaped_string1\", \"JS_escaped_string2\"]]\n        function writeStyleResourceDependenciesInJS(destination, boundaryResources) {\n            writeChunk(destination, arrayFirstOpenBracket);\n            var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n            boundaryResources.stylesheets.forEach(function(resource) {\n                if (resource.state === PREAMBLE) ;\n                else if (resource.state === LATE) {\n                    // We only need to emit the href because this resource flushed in an earlier\n                    // boundary already which encoded the attributes necessary to construct\n                    // the resource instance on the client.\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyHrefOnlyInJS(destination, resource.props.href);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                } else {\n                    // We need to emit the whole resource for insertion on the client\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyInJS(destination, resource.props.href, resource.props[\"data-precedence\"], resource.props);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                    resource.state = LATE;\n                }\n            });\n            writeChunk(destination, arrayCloseBracket);\n        }\n        /* Helper functions */ function writeStyleResourceDependencyHrefOnlyInJS(destination, href) {\n            // We should actually enforce this earlier when the resource is created but for\n            // now we make sure we are actually dealing with a string here.\n            {\n                checkAttributeStringCoercion(href, \"href\");\n            }\n            var coercedHref = \"\" + href;\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(coercedHref)));\n        }\n        function writeStyleResourceDependencyInJS(destination, href, precedence, props) {\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            var coercedHref = sanitizeURL(\"\" + href);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(coercedHref)));\n            {\n                checkAttributeStringCoercion(precedence, \"precedence\");\n            }\n            var coercedPrecedence = \"\" + precedence;\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(coercedPrecedence)));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"href\":\n                        case \"rel\":\n                        case \"precedence\":\n                        case \"data-precedence\":\n                            {\n                                break;\n                            }\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"link\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            writeStyleResourceAttributeInJS(destination, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            return null;\n        }\n        function writeStyleResourceAttributeInJS(destination, name, value) {\n            var attributeName = name.toLowerCase();\n            var attributeValue;\n            switch(typeof value){\n                case \"function\":\n                case \"symbol\":\n                    return;\n            }\n            switch(name){\n                // Reserved names\n                case \"innerHTML\":\n                case \"dangerouslySetInnerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                case \"style\":\n                    // Ignored\n                    return;\n                // Attribute renames\n                case \"className\":\n                    {\n                        attributeName = \"class\";\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                // Booleans\n                case \"hidden\":\n                    {\n                        if (value === false) {\n                            return;\n                        }\n                        attributeValue = \"\";\n                        break;\n                    }\n                // Santized URLs\n                case \"src\":\n                case \"href\":\n                    {\n                        value = sanitizeURL(value);\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                default:\n                    {\n                        if (// use on* as hueristic for these handler props\n                        name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                            return;\n                        }\n                        if (!isAttributeNameSafe(name)) {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                    }\n            }\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(attributeName)));\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(attributeValue)));\n        } // This function writes a 2D array of strings to be embedded in an attribute\n        // value and read with JSON.parse in ReactDOMServerExternalRuntime.js\n        // E.g.\n        //  [[&quot;JSON_escaped_string1&quot;, &quot;JSON_escaped_string2&quot;]]\n        function writeStyleResourceDependenciesInAttr(destination, boundaryResources) {\n            writeChunk(destination, arrayFirstOpenBracket);\n            var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n            boundaryResources.stylesheets.forEach(function(resource) {\n                if (resource.state === PREAMBLE) ;\n                else if (resource.state === LATE) {\n                    // We only need to emit the href because this resource flushed in an earlier\n                    // boundary already which encoded the attributes necessary to construct\n                    // the resource instance on the client.\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyHrefOnlyInAttr(destination, resource.props.href);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                } else {\n                    // We need to emit the whole resource for insertion on the client\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyInAttr(destination, resource.props.href, resource.props[\"data-precedence\"], resource.props);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                    resource.state = LATE;\n                }\n            });\n            writeChunk(destination, arrayCloseBracket);\n        }\n        /* Helper functions */ function writeStyleResourceDependencyHrefOnlyInAttr(destination, href) {\n            // We should actually enforce this earlier when the resource is created but for\n            // now we make sure we are actually dealing with a string here.\n            {\n                checkAttributeStringCoercion(href, \"href\");\n            }\n            var coercedHref = \"\" + href;\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(coercedHref))));\n        }\n        function writeStyleResourceDependencyInAttr(destination, href, precedence, props) {\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            var coercedHref = sanitizeURL(\"\" + href);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(coercedHref))));\n            {\n                checkAttributeStringCoercion(precedence, \"precedence\");\n            }\n            var coercedPrecedence = \"\" + precedence;\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(coercedPrecedence))));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"href\":\n                        case \"rel\":\n                        case \"precedence\":\n                        case \"data-precedence\":\n                            {\n                                break;\n                            }\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"link\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            writeStyleResourceAttributeInAttr(destination, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            return null;\n        }\n        function writeStyleResourceAttributeInAttr(destination, name, value) {\n            var attributeName = name.toLowerCase();\n            var attributeValue;\n            switch(typeof value){\n                case \"function\":\n                case \"symbol\":\n                    return;\n            }\n            switch(name){\n                // Reserved names\n                case \"innerHTML\":\n                case \"dangerouslySetInnerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                case \"style\":\n                    // Ignored\n                    return;\n                // Attribute renames\n                case \"className\":\n                    {\n                        attributeName = \"class\";\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                // Booleans\n                case \"hidden\":\n                    {\n                        if (value === false) {\n                            return;\n                        }\n                        attributeValue = \"\";\n                        break;\n                    }\n                // Santized URLs\n                case \"src\":\n                case \"href\":\n                    {\n                        value = sanitizeURL(value);\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                default:\n                    {\n                        if (// use on* as hueristic for these handler props\n                        name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                            return;\n                        }\n                        if (!isAttributeNameSafe(name)) {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                    }\n            }\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(attributeName))));\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(attributeValue))));\n        }\n        /**\n * Resources\n */ var PENDING$1 = 0;\n        var PRELOADED = 1;\n        var PREAMBLE = 2;\n        var LATE = 3;\n        function createBoundaryResources() {\n            return {\n                styles: new Set(),\n                stylesheets: new Set()\n            };\n        }\n        function setCurrentlyRenderingBoundaryResourcesTarget(renderState, boundaryResources) {\n            renderState.boundaryResources = boundaryResources;\n        }\n        function getResourceKey(href) {\n            return href;\n        }\n        function getImageResourceKey(href, imageSrcSet, imageSizes) {\n            if (imageSrcSet) {\n                return imageSrcSet + \"\\n\" + (imageSizes || \"\");\n            }\n            return href;\n        }\n        function prefetchDNS(href) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (typeof href === \"string\" && href) {\n                var key = getResourceKey(href);\n                if (!resumableState.dnsResources.hasOwnProperty(key)) {\n                    resumableState.dnsResources[key] = EXISTS;\n                    var headers = renderState.headers;\n                    var header;\n                    if (headers && headers.remainingCapacity > 0 && (header = getPrefetchDNSAsHeader(href), // we assume all the rest won't as well. This is to avoid getting into a situation\n                    // where we have a very small remaining capacity but no headers will ever fit and we end\n                    // up constantly trying to see if the next resource might make it. In the future we can\n                    // make this behavior different between render and prerender since in the latter case\n                    // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                    // headers.\n                    (headers.remainingCapacity -= header.length) >= 2)) {\n                        // Store this as resettable in case we are prerendering and postpone in the Shell\n                        renderState.resets.dns[key] = EXISTS;\n                        if (headers.preconnects) {\n                            headers.preconnects += \", \";\n                        } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                        headers.preconnects += header;\n                    } else {\n                        // Encode as element\n                        var resource = [];\n                        pushLinkImpl(resource, {\n                            href: href,\n                            rel: \"dns-prefetch\"\n                        });\n                        renderState.preconnects.add(resource);\n                    }\n                }\n                flushResources(request);\n            }\n        }\n        function preconnect(href, crossOrigin) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (typeof href === \"string\" && href) {\n                var bucket = crossOrigin === \"use-credentials\" ? \"credentials\" : typeof crossOrigin === \"string\" ? \"anonymous\" : \"default\";\n                var key = getResourceKey(href);\n                if (!resumableState.connectResources[bucket].hasOwnProperty(key)) {\n                    resumableState.connectResources[bucket][key] = EXISTS;\n                    var headers = renderState.headers;\n                    var header;\n                    if (headers && headers.remainingCapacity > 0 && (header = getPreconnectAsHeader(href, crossOrigin), // we assume all the rest won't as well. This is to avoid getting into a situation\n                    // where we have a very small remaining capacity but no headers will ever fit and we end\n                    // up constantly trying to see if the next resource might make it. In the future we can\n                    // make this behavior different between render and prerender since in the latter case\n                    // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                    // headers.\n                    (headers.remainingCapacity -= header.length) >= 2)) {\n                        // Store this in resettableState in case we are prerending and postpone in the Shell\n                        renderState.resets.connect[bucket][key] = EXISTS;\n                        if (headers.preconnects) {\n                            headers.preconnects += \", \";\n                        } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                        headers.preconnects += header;\n                    } else {\n                        var resource = [];\n                        pushLinkImpl(resource, {\n                            rel: \"preconnect\",\n                            href: href,\n                            crossOrigin: crossOrigin\n                        });\n                        renderState.preconnects.add(resource);\n                    }\n                }\n                flushResources(request);\n            }\n        }\n        function preload(href, as, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (as && href) {\n                switch(as){\n                    case \"image\":\n                        {\n                            var imageSrcSet, imageSizes, fetchPriority;\n                            if (options) {\n                                imageSrcSet = options.imageSrcSet;\n                                imageSizes = options.imageSizes;\n                                fetchPriority = options.fetchPriority;\n                            }\n                            var key = getImageResourceKey(href, imageSrcSet, imageSizes);\n                            if (resumableState.imageResources.hasOwnProperty(key)) {\n                                // we can return if we already have this resource\n                                return;\n                            }\n                            resumableState.imageResources[key] = PRELOAD_NO_CREDS;\n                            var headers = renderState.headers;\n                            var header;\n                            if (headers && headers.remainingCapacity > 0 && fetchPriority === \"high\" && (header = getPreloadAsHeader(href, as, options), // we assume all the rest won't as well. This is to avoid getting into a situation\n                            // where we have a very small remaining capacity but no headers will ever fit and we end\n                            // up constantly trying to see if the next resource might make it. In the future we can\n                            // make this behavior different between render and prerender since in the latter case\n                            // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                            // headers.\n                            (headers.remainingCapacity -= header.length) >= 2)) {\n                                // If we postpone in the shell we will still emit a preload as a header so we\n                                // track this to make sure we don't reset it.\n                                renderState.resets.image[key] = PRELOAD_NO_CREDS;\n                                if (headers.highImagePreloads) {\n                                    headers.highImagePreloads += \", \";\n                                } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                                headers.highImagePreloads += header;\n                            } else {\n                                // If we don't have headers to write to we have to encode as elements to flush in the head\n                                // When we have imageSrcSet the browser probably cannot load the right version from headers\n                                // (this should be verified by testing). For now we assume these need to go in the head\n                                // as elements even if headers are available.\n                                var resource = [];\n                                pushLinkImpl(resource, assign({\n                                    rel: \"preload\",\n                                    // There is a bug in Safari where imageSrcSet is not respected on preload links\n                                    // so we omit the href here if we have imageSrcSet b/c safari will load the wrong image.\n                                    // This harms older browers that do not support imageSrcSet by making their preloads not work\n                                    // but this population is shrinking fast and is already small so we accept this tradeoff.\n                                    href: imageSrcSet ? undefined : href,\n                                    as: as\n                                }, options));\n                                if (fetchPriority === \"high\") {\n                                    renderState.highImagePreloads.add(resource);\n                                } else {\n                                    renderState.bulkPreloads.add(resource); // Stash the resource in case we need to promote it to higher priority\n                                    // when an img tag is rendered\n                                    renderState.preloads.images.set(key, resource);\n                                }\n                            }\n                            break;\n                        }\n                    case \"style\":\n                        {\n                            var _key = getResourceKey(href);\n                            if (resumableState.styleResources.hasOwnProperty(_key)) {\n                                // we can return if we already have this resource\n                                return;\n                            }\n                            var _resource2 = [];\n                            pushLinkImpl(_resource2, assign({\n                                rel: \"preload\",\n                                href: href,\n                                as: as\n                            }, options));\n                            resumableState.styleResources[_key] = options && (typeof options.crossOrigin === \"string\" || typeof options.integrity === \"string\") ? [\n                                options.crossOrigin,\n                                options.integrity\n                            ] : PRELOAD_NO_CREDS;\n                            renderState.preloads.stylesheets.set(_key, _resource2);\n                            renderState.bulkPreloads.add(_resource2);\n                            break;\n                        }\n                    case \"script\":\n                        {\n                            var _key2 = getResourceKey(href);\n                            if (resumableState.scriptResources.hasOwnProperty(_key2)) {\n                                // we can return if we already have this resource\n                                return;\n                            }\n                            var _resource3 = [];\n                            renderState.preloads.scripts.set(_key2, _resource3);\n                            renderState.bulkPreloads.add(_resource3);\n                            pushLinkImpl(_resource3, assign({\n                                rel: \"preload\",\n                                href: href,\n                                as: as\n                            }, options));\n                            resumableState.scriptResources[_key2] = options && (typeof options.crossOrigin === \"string\" || typeof options.integrity === \"string\") ? [\n                                options.crossOrigin,\n                                options.integrity\n                            ] : PRELOAD_NO_CREDS;\n                            break;\n                        }\n                    default:\n                        {\n                            var _key3 = getResourceKey(href);\n                            var hasAsType = resumableState.unknownResources.hasOwnProperty(as);\n                            var resources;\n                            if (hasAsType) {\n                                resources = resumableState.unknownResources[as];\n                                if (resources.hasOwnProperty(_key3)) {\n                                    // we can return if we already have this resource\n                                    return;\n                                }\n                            } else {\n                                resources = {};\n                                resumableState.unknownResources[as] = resources;\n                            }\n                            resources[_key3] = PRELOAD_NO_CREDS;\n                            var _headers = renderState.headers;\n                            var _header;\n                            if (_headers && _headers.remainingCapacity > 0 && as === \"font\" && (_header = getPreloadAsHeader(href, as, options), // we assume all the rest won't as well. This is to avoid getting into a situation\n                            // where we have a very small remaining capacity but no headers will ever fit and we end\n                            // up constantly trying to see if the next resource might make it. In the future we can\n                            // make this behavior different between render and prerender since in the latter case\n                            // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                            // headers.\n                            (_headers.remainingCapacity -= _header.length) >= 2)) {\n                                // If we postpone in the shell we will still emit this preload so we\n                                // track it here to prevent it from being reset.\n                                renderState.resets.font[_key3] = PRELOAD_NO_CREDS;\n                                if (_headers.fontPreloads) {\n                                    _headers.fontPreloads += \", \";\n                                } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                                _headers.fontPreloads += _header;\n                            } else {\n                                // We either don't have headers or we are preloading something that does\n                                // not warrant elevated priority so we encode as an element.\n                                var _resource4 = [];\n                                var props = assign({\n                                    rel: \"preload\",\n                                    href: href,\n                                    as: as\n                                }, options);\n                                pushLinkImpl(_resource4, props);\n                                switch(as){\n                                    case \"font\":\n                                        renderState.fontPreloads.add(_resource4);\n                                        break;\n                                    // intentional fall through\n                                    default:\n                                        renderState.bulkPreloads.add(_resource4);\n                                }\n                            }\n                        }\n                } // If we got this far we created a new resource\n                flushResources(request);\n            }\n        }\n        function preloadModule(href, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (href) {\n                var key = getResourceKey(href);\n                var as = options && typeof options.as === \"string\" ? options.as : \"script\";\n                var resource;\n                switch(as){\n                    case \"script\":\n                        {\n                            if (resumableState.moduleScriptResources.hasOwnProperty(key)) {\n                                // we can return if we already have this resource\n                                return;\n                            }\n                            resource = [];\n                            resumableState.moduleScriptResources[key] = options && (typeof options.crossOrigin === \"string\" || typeof options.integrity === \"string\") ? [\n                                options.crossOrigin,\n                                options.integrity\n                            ] : PRELOAD_NO_CREDS;\n                            renderState.preloads.moduleScripts.set(key, resource);\n                            break;\n                        }\n                    default:\n                        {\n                            var hasAsType = resumableState.moduleUnknownResources.hasOwnProperty(as);\n                            var resources;\n                            if (hasAsType) {\n                                resources = resumableState.unknownResources[as];\n                                if (resources.hasOwnProperty(key)) {\n                                    // we can return if we already have this resource\n                                    return;\n                                }\n                            } else {\n                                resources = {};\n                                resumableState.moduleUnknownResources[as] = resources;\n                            }\n                            resource = [];\n                            resources[key] = PRELOAD_NO_CREDS;\n                        }\n                }\n                pushLinkImpl(resource, assign({\n                    rel: \"modulepreload\",\n                    href: href\n                }, options));\n                renderState.bulkPreloads.add(resource); // If we got this far we created a new resource\n                flushResources(request);\n            }\n        }\n        function preinitStyle(href, precedence, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (href) {\n                precedence = precedence || \"default\";\n                var key = getResourceKey(href);\n                var styleQueue = renderState.styles.get(precedence);\n                var hasKey = resumableState.styleResources.hasOwnProperty(key);\n                var resourceState = hasKey ? resumableState.styleResources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resumableState.styleResources[key] = EXISTS; // If this is the first time we've encountered this precedence we need\n                    // to create a StyleQueue\n                    if (!styleQueue) {\n                        styleQueue = {\n                            precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                            rules: [],\n                            hrefs: [],\n                            sheets: new Map()\n                        };\n                        renderState.styles.set(precedence, styleQueue);\n                    }\n                    var resource = {\n                        state: PENDING$1,\n                        props: assign({\n                            rel: \"stylesheet\",\n                            href: href,\n                            \"data-precedence\": precedence\n                        }, options)\n                    };\n                    if (resourceState) {\n                        // When resourceState is truty it is a Preload state. We cast it for clarity\n                        var preloadState = resourceState;\n                        if (preloadState.length === 2) {\n                            adoptPreloadCredentials(resource.props, preloadState);\n                        }\n                        var preloadResource = renderState.preloads.stylesheets.get(key);\n                        if (preloadResource && preloadResource.length > 0) {\n                            // The Preload for this resource was created in this render pass and has not flushed yet so\n                            // we need to clear it to avoid it flushing.\n                            preloadResource.length = 0;\n                        } else {\n                            // Either the preload resource from this render already flushed in this render pass\n                            // or the preload flushed in a prior pass (prerender). In either case we need to mark\n                            // this resource as already having been preloaded.\n                            resource.state = PRELOADED;\n                        }\n                    } // We add the newly created resource to our StyleQueue and if necessary\n                    // track the resource with the currently rendering boundary\n                    styleQueue.sheets.set(key, resource); // Notify the request that there are resources to flush even if no work is currently happening\n                    flushResources(request);\n                }\n            }\n        }\n        function preinitScript(src, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (src) {\n                var key = getResourceKey(src);\n                var hasKey = resumableState.scriptResources.hasOwnProperty(key);\n                var resourceState = hasKey ? resumableState.scriptResources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resumableState.scriptResources[key] = EXISTS;\n                    var props = assign({\n                        src: src,\n                        async: true\n                    }, options);\n                    if (resourceState) {\n                        // When resourceState is truty it is a Preload state. We cast it for clarity\n                        var preloadState = resourceState;\n                        if (preloadState.length === 2) {\n                            adoptPreloadCredentials(props, preloadState);\n                        }\n                        var preloadResource = renderState.preloads.scripts.get(key);\n                        if (preloadResource) {\n                            // the preload resource exists was created in this render. Now that we have\n                            // a script resource which will emit earlier than a preload would if it\n                            // hasn't already flushed we prevent it from flushing by zeroing the length\n                            preloadResource.length = 0;\n                        }\n                    }\n                    var resource = []; // Add to the script flushing queue\n                    renderState.scripts.add(resource); // encode the tag as Chunks\n                    pushScriptImpl(resource, props); // Notify the request that there are resources to flush even if no work is currently happening\n                    flushResources(request);\n                }\n                return;\n            }\n        }\n        function preinitModuleScript(src, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (src) {\n                var key = getResourceKey(src);\n                var hasKey = resumableState.moduleScriptResources.hasOwnProperty(key);\n                var resourceState = hasKey ? resumableState.moduleScriptResources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resumableState.moduleScriptResources[key] = EXISTS;\n                    var props = assign({\n                        src: src,\n                        type: \"module\",\n                        async: true\n                    }, options);\n                    if (resourceState) {\n                        // When resourceState is truty it is a Preload state. We cast it for clarity\n                        var preloadState = resourceState;\n                        if (preloadState.length === 2) {\n                            adoptPreloadCredentials(props, preloadState);\n                        }\n                        var preloadResource = renderState.preloads.moduleScripts.get(key);\n                        if (preloadResource) {\n                            // the preload resource exists was created in this render. Now that we have\n                            // a script resource which will emit earlier than a preload would if it\n                            // hasn't already flushed we prevent it from flushing by zeroing the length\n                            preloadResource.length = 0;\n                        }\n                    }\n                    var resource = []; // Add to the script flushing queue\n                    renderState.scripts.add(resource); // encode the tag as Chunks\n                    pushScriptImpl(resource, props); // Notify the request that there are resources to flush even if no work is currently happening\n                    flushResources(request);\n                }\n                return;\n            }\n        } // This function is only safe to call at Request start time since it assumes\n        // that each module has not already been preloaded. If we find a need to preload\n        // scripts at any other point in time we will need to check whether the preload\n        // already exists and not assume it\n        function preloadBootstrapScriptOrModule(resumableState, renderState, href, props) {\n            var key = getResourceKey(href);\n            {\n                if (resumableState.scriptResources.hasOwnProperty(key) || resumableState.moduleScriptResources.hasOwnProperty(key)) {\n                    // This is coded as a React error because it should be impossible for a userspace preload to preempt this call\n                    // If a userspace preload can preempt it then this assumption is broken and we need to reconsider this strategy\n                    // rather than instruct the user to not preload their bootstrap scripts themselves\n                    error('Internal React Error: React expected bootstrap script or module with src \"%s\" to not have been preloaded already. please file an issue', href);\n                }\n            }\n            // used to preinit the resource. If a script can be preinited then it shouldn't\n            // be a bootstrap script/module and if it is a bootstrap script/module then it\n            // must not be safe to emit early. To avoid possibly allowing for preinits of\n            // bootstrap scripts/modules we occlude these keys.\n            resumableState.scriptResources[key] = EXISTS;\n            resumableState.moduleScriptResources[key] = EXISTS;\n            var resource = [];\n            pushLinkImpl(resource, props);\n            renderState.bootstrapScripts.add(resource);\n        }\n        function internalPreinitScript(resumableState, renderState, src, chunks) {\n            var key = getResourceKey(src);\n            if (!resumableState.scriptResources.hasOwnProperty(key)) {\n                var resource = chunks;\n                resumableState.scriptResources[key] = EXISTS;\n                renderState.scripts.add(resource);\n            }\n            return;\n        }\n        function preloadAsStylePropsFromProps(href, props) {\n            return {\n                rel: \"preload\",\n                as: \"style\",\n                href: href,\n                crossOrigin: props.crossOrigin,\n                fetchPriority: props.fetchPriority,\n                integrity: props.integrity,\n                media: props.media,\n                hrefLang: props.hrefLang,\n                referrerPolicy: props.referrerPolicy\n            };\n        }\n        function stylesheetPropsFromRawProps(rawProps) {\n            return assign({}, rawProps, {\n                \"data-precedence\": rawProps.precedence,\n                precedence: null\n            });\n        }\n        function adoptPreloadCredentials(target, preloadState) {\n            if (target.crossOrigin == null) target.crossOrigin = preloadState[0];\n            if (target.integrity == null) target.integrity = preloadState[1];\n        }\n        function getPrefetchDNSAsHeader(href) {\n            var escapedHref = escapeHrefForLinkHeaderURLContext(href);\n            return \"<\" + escapedHref + \">; rel=dns-prefetch\";\n        }\n        function getPreconnectAsHeader(href, crossOrigin) {\n            var escapedHref = escapeHrefForLinkHeaderURLContext(href);\n            var value = \"<\" + escapedHref + \">; rel=preconnect\";\n            if (typeof crossOrigin === \"string\") {\n                var escapedCrossOrigin = escapeStringForLinkHeaderQuotedParamValueContext(crossOrigin, \"crossOrigin\");\n                value += '; crossorigin=\"' + escapedCrossOrigin + '\"';\n            }\n            return value;\n        }\n        function getPreloadAsHeader(href, as, params) {\n            var escapedHref = escapeHrefForLinkHeaderURLContext(href);\n            var escapedAs = escapeStringForLinkHeaderQuotedParamValueContext(as, \"as\");\n            var value = \"<\" + escapedHref + '>; rel=preload; as=\"' + escapedAs + '\"';\n            for(var paramName in params){\n                if (hasOwnProperty.call(params, paramName)) {\n                    var paramValue = params[paramName];\n                    if (typeof paramValue === \"string\") {\n                        value += \"; \" + paramName.toLowerCase() + '=\"' + escapeStringForLinkHeaderQuotedParamValueContext(paramValue, paramName) + '\"';\n                    }\n                }\n            }\n            return value;\n        }\n        function getStylesheetPreloadAsHeader(stylesheet) {\n            var props = stylesheet.props;\n            var preloadOptions = {\n                crossOrigin: props.crossOrigin,\n                integrity: props.integrity,\n                nonce: props.nonce,\n                type: props.type,\n                fetchPriority: props.fetchPriority,\n                referrerPolicy: props.referrerPolicy,\n                media: props.media\n            };\n            return getPreloadAsHeader(props.href, \"style\", preloadOptions);\n        } // This escaping function is only safe to use for href values being written into\n        // a \"Link\" header in between `<` and `>` characters. The primary concern with the href is\n        // to escape the bounding characters as well as new lines. This is unsafe to use in any other\n        // context\n        var regexForHrefInLinkHeaderURLContext = /[<>\\r\\n]/g;\n        function escapeHrefForLinkHeaderURLContext(hrefInput) {\n            {\n                checkAttributeStringCoercion(hrefInput, \"href\");\n            }\n            var coercedHref = \"\" + hrefInput;\n            return coercedHref.replace(regexForHrefInLinkHeaderURLContext, escapeHrefForLinkHeaderURLContextReplacer);\n        }\n        function escapeHrefForLinkHeaderURLContextReplacer(match) {\n            switch(match){\n                case \"<\":\n                    return \"%3C\";\n                case \">\":\n                    return \"%3E\";\n                case \"\\n\":\n                    return \"%0A\";\n                case \"\\r\":\n                    return \"%0D\";\n                default:\n                    {\n                        // eslint-disable-next-line react-internal/prod-error-codes\n                        throw new Error(\"escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                    }\n            }\n        } // This escaping function is only safe to use for quoted param values in an HTTP header.\n        // It is unsafe to use for any value not inside quote marks in parater value position.\n        var regexForLinkHeaderQuotedParamValueContext = /[\"';,\\r\\n]/g;\n        function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {\n            {\n                checkOptionStringCoercion(value, name);\n            }\n            var coerced = \"\" + value;\n            return coerced.replace(regexForLinkHeaderQuotedParamValueContext, escapeStringForLinkHeaderQuotedParamValueContextReplacer);\n        }\n        function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {\n            switch(match){\n                case '\"':\n                    return \"%22\";\n                case \"'\":\n                    return \"%27\";\n                case \";\":\n                    return \"%3B\";\n                case \",\":\n                    return \"%2C\";\n                case \"\\n\":\n                    return \"%0A\";\n                case \"\\r\":\n                    return \"%0D\";\n                default:\n                    {\n                        // eslint-disable-next-line react-internal/prod-error-codes\n                        throw new Error(\"escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                    }\n            }\n        }\n        function hoistStyleQueueDependency(styleQueue) {\n            this.styles.add(styleQueue);\n        }\n        function hoistStylesheetDependency(stylesheet) {\n            this.stylesheets.add(stylesheet);\n        }\n        function hoistResources(renderState, source) {\n            var currentBoundaryResources = renderState.boundaryResources;\n            if (currentBoundaryResources) {\n                source.styles.forEach(hoistStyleQueueDependency, currentBoundaryResources);\n                source.stylesheets.forEach(hoistStylesheetDependency, currentBoundaryResources);\n            }\n        } // This function is called at various times depending on whether we are rendering\n        // or prerendering. In this implementation we only actually emit headers once and\n        // subsequent calls are ignored. We track whether the request has a completed shell\n        // to determine whether we will follow headers with a flush including stylesheets.\n        // In the context of prerrender we don't have a completed shell when the request finishes\n        // with a postpone in the shell. In the context of a render we don't have a completed shell\n        // if this is called before the shell finishes rendering which usually will happen anytime\n        // anything suspends in the shell.\n        function emitEarlyPreloads(renderState, resumableState, shellComplete) {\n            var onHeaders = renderState.onHeaders;\n            if (onHeaders) {\n                var headers = renderState.headers;\n                if (headers) {\n                    // Even if onHeaders throws we don't want to call this again so\n                    // we drop the headers state from this point onwards.\n                    renderState.headers = null;\n                    var linkHeader = headers.preconnects;\n                    if (headers.fontPreloads) {\n                        if (linkHeader) {\n                            linkHeader += \", \";\n                        }\n                        linkHeader += headers.fontPreloads;\n                    }\n                    if (headers.highImagePreloads) {\n                        if (linkHeader) {\n                            linkHeader += \", \";\n                        }\n                        linkHeader += headers.highImagePreloads;\n                    }\n                    if (!shellComplete) {\n                        // We use raw iterators because we want to be able to halt iteration\n                        // We could refactor renderState to store these dually in arrays to\n                        // make this more efficient at the cost of additional memory and\n                        // write overhead. However this code only runs once per request so\n                        // for now I consider this sufficient.\n                        var queueIter = renderState.styles.values();\n                        outer: for(var queueStep = queueIter.next(); headers.remainingCapacity > 0 && !queueStep.done; queueStep = queueIter.next()){\n                            var sheets = queueStep.value.sheets;\n                            var sheetIter = sheets.values();\n                            for(var sheetStep = sheetIter.next(); headers.remainingCapacity > 0 && !sheetStep.done; sheetStep = sheetIter.next()){\n                                var sheet = sheetStep.value;\n                                var props = sheet.props;\n                                var key = getResourceKey(props.href);\n                                var header = getStylesheetPreloadAsHeader(sheet); // We mutate the capacity b/c we don't want to keep checking if later headers will fit.\n                                // This means that a particularly long header might close out the header queue where later\n                                // headers could still fit. We could in the future alter the behavior here based on prerender vs render\n                                // since during prerender we aren't as concerned with pure runtime performance.\n                                if ((headers.remainingCapacity -= header.length) >= 2) {\n                                    renderState.resets.style[key] = PRELOAD_NO_CREDS;\n                                    if (linkHeader) {\n                                        linkHeader += \", \";\n                                    }\n                                    linkHeader += header; // We already track that the resource exists in resumableState however\n                                    // if the resumableState resets because we postponed in the shell\n                                    // which is what is happening in this branch if we are prerendering\n                                    // then we will end up resetting the resumableState. When it resets we\n                                    // want to record the fact that this stylesheet was already preloaded\n                                    renderState.resets.style[key] = typeof props.crossOrigin === \"string\" || typeof props.integrity === \"string\" ? [\n                                        props.crossOrigin,\n                                        props.integrity\n                                    ] : PRELOAD_NO_CREDS;\n                                } else {\n                                    break outer;\n                                }\n                            }\n                        }\n                    }\n                    if (linkHeader) {\n                        onHeaders({\n                            Link: linkHeader\n                        });\n                    } else {\n                        // We still call this with no headers because a user may be using it as a signal that\n                        // it React will not provide any headers\n                        onHeaders({});\n                    }\n                    return;\n                }\n            }\n        }\n        function createRenderState(resumableState, generateStaticMarkup) {\n            var renderState = createRenderState$1(resumableState, undefined, undefined, undefined, undefined, undefined);\n            return {\n                // Keep this in sync with ReactFizzConfigDOM\n                placeholderPrefix: renderState.placeholderPrefix,\n                segmentPrefix: renderState.segmentPrefix,\n                boundaryPrefix: renderState.boundaryPrefix,\n                startInlineScript: renderState.startInlineScript,\n                htmlChunks: renderState.htmlChunks,\n                headChunks: renderState.headChunks,\n                externalRuntimeScript: renderState.externalRuntimeScript,\n                bootstrapChunks: renderState.bootstrapChunks,\n                onHeaders: renderState.onHeaders,\n                headers: renderState.headers,\n                resets: renderState.resets,\n                charsetChunks: renderState.charsetChunks,\n                preconnectChunks: renderState.preconnectChunks,\n                importMapChunks: renderState.importMapChunks,\n                preloadChunks: renderState.preloadChunks,\n                hoistableChunks: renderState.hoistableChunks,\n                preconnects: renderState.preconnects,\n                fontPreloads: renderState.fontPreloads,\n                highImagePreloads: renderState.highImagePreloads,\n                // usedImagePreloads: renderState.usedImagePreloads,\n                styles: renderState.styles,\n                bootstrapScripts: renderState.bootstrapScripts,\n                scripts: renderState.scripts,\n                bulkPreloads: renderState.bulkPreloads,\n                preloads: renderState.preloads,\n                boundaryResources: renderState.boundaryResources,\n                stylesToHoist: renderState.stylesToHoist,\n                // This is an extra field for the legacy renderer\n                generateStaticMarkup: generateStaticMarkup\n            };\n        }\n        var doctypeChunk = stringToPrecomputedChunk(\"\");\n        function pushTextInstance(target, text, renderState, textEmbedded) {\n            if (renderState.generateStaticMarkup) {\n                target.push(stringToChunk(escapeTextForBrowser(text)));\n                return false;\n            } else {\n                return pushTextInstance$1(target, text, renderState, textEmbedded);\n            }\n        }\n        function pushSegmentFinale(target, renderState, lastPushedText, textEmbedded) {\n            if (renderState.generateStaticMarkup) {\n                return;\n            } else {\n                return pushSegmentFinale$1(target, renderState, lastPushedText, textEmbedded);\n            }\n        }\n        function writeStartCompletedSuspenseBoundary(destination, renderState) {\n            if (renderState.generateStaticMarkup) {\n                // A completed boundary is done and doesn't need a representation in the HTML\n                // if we're not going to be hydrating it.\n                return true;\n            }\n            return writeStartCompletedSuspenseBoundary$1(destination);\n        }\n        function writeStartClientRenderedSuspenseBoundary(destination, renderState, errorDigest, errorMessage, errorComponentStack) {\n            if (renderState.generateStaticMarkup) {\n                // A client rendered boundary is done and doesn't need a representation in the HTML\n                // since we'll never hydrate it. This is arguably an error in static generation.\n                return true;\n            }\n            return writeStartClientRenderedSuspenseBoundary$1(destination, renderState, errorDigest, errorMessage, errorComponentStack);\n        }\n        function writeEndCompletedSuspenseBoundary(destination, renderState) {\n            if (renderState.generateStaticMarkup) {\n                return true;\n            }\n            return writeEndCompletedSuspenseBoundary$1(destination);\n        }\n        function writeEndClientRenderedSuspenseBoundary(destination, renderState) {\n            if (renderState.generateStaticMarkup) {\n                return true;\n            }\n            return writeEndClientRenderedSuspenseBoundary$1(destination);\n        }\n        var NotPendingTransition = NotPending;\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_SCOPE_TYPE = Symbol.for(\"react.scope\");\n        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for(\"react.debug_trace_mode\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for(\"react.default_value\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher$1.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher$1.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeClassComponentFrame(ctor, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(ctor, true);\n            }\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct$1(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct$1(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement(null);\n                        }\n                    }\n                }\n            }\n        }\n        var warnedAboutMissingGetChildContext;\n        {\n            warnedAboutMissingGetChildContext = {};\n        }\n        var emptyContextObject = {};\n        {\n            Object.freeze(emptyContextObject);\n        }\n        function getMaskedContext(type, unmaskedContext) {\n            {\n                var contextTypes = type.contextTypes;\n                if (!contextTypes) {\n                    return emptyContextObject;\n                }\n                var context = {};\n                for(var key in contextTypes){\n                    context[key] = unmaskedContext[key];\n                }\n                {\n                    var name = getComponentNameFromType(type) || \"Unknown\";\n                    checkPropTypes(contextTypes, context, \"context\", name);\n                }\n                return context;\n            }\n        }\n        function processChildContext(instance, type, parentContext, childContextTypes) {\n            {\n                // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n                // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n                if (typeof instance.getChildContext !== \"function\") {\n                    {\n                        var componentName = getComponentNameFromType(type) || \"Unknown\";\n                        if (!warnedAboutMissingGetChildContext[componentName]) {\n                            warnedAboutMissingGetChildContext[componentName] = true;\n                            error(\"%s.childContextTypes is specified but there is no getChildContext() method \" + \"on the instance. You can either define getChildContext() on %s or remove \" + \"childContextTypes from it.\", componentName, componentName);\n                        }\n                    }\n                    return parentContext;\n                }\n                var childContext = instance.getChildContext();\n                for(var contextKey in childContext){\n                    if (!(contextKey in childContextTypes)) {\n                        throw new Error((getComponentNameFromType(type) || \"Unknown\") + '.getChildContext(): key \"' + contextKey + '\" is not defined in childContextTypes.');\n                    }\n                }\n                {\n                    var name = getComponentNameFromType(type) || \"Unknown\";\n                    checkPropTypes(childContextTypes, childContext, \"child context\", name);\n                }\n                return assign({}, parentContext, childContext);\n            }\n        }\n        var rendererSigil;\n        {\n            // Use this to detect multiple renderers using the same context\n            rendererSigil = {};\n        }\n        // Forming a reverse tree.\n        // The structure of a context snapshot is an implementation of this file.\n        // Currently, it's implemented as tracking the current active node.\n        var rootContextSnapshot = null; // We assume that this runtime owns the \"current\" field on all ReactContext instances.\n        // This global (actually thread local) state represents what state all those \"current\",\n        // fields are currently in.\n        var currentActiveSnapshot = null;\n        function popNode(prev) {\n            {\n                prev.context._currentValue2 = prev.parentValue;\n            }\n        }\n        function pushNode(next) {\n            {\n                next.context._currentValue2 = next.value;\n            }\n        }\n        function popToNearestCommonAncestor(prev, next) {\n            if (prev === next) ;\n            else {\n                popNode(prev);\n                var parentPrev = prev.parent;\n                var parentNext = next.parent;\n                if (parentPrev === null) {\n                    if (parentNext !== null) {\n                        throw new Error(\"The stacks must reach the root at the same time. This is a bug in React.\");\n                    }\n                } else {\n                    if (parentNext === null) {\n                        throw new Error(\"The stacks must reach the root at the same time. This is a bug in React.\");\n                    }\n                    popToNearestCommonAncestor(parentPrev, parentNext);\n                } // On the way back, we push the new ones that weren't common.\n                pushNode(next);\n            }\n        }\n        function popAllPrevious(prev) {\n            popNode(prev);\n            var parentPrev = prev.parent;\n            if (parentPrev !== null) {\n                popAllPrevious(parentPrev);\n            }\n        }\n        function pushAllNext(next) {\n            var parentNext = next.parent;\n            if (parentNext !== null) {\n                pushAllNext(parentNext);\n            }\n            pushNode(next);\n        }\n        function popPreviousToCommonLevel(prev, next) {\n            popNode(prev);\n            var parentPrev = prev.parent;\n            if (parentPrev === null) {\n                throw new Error(\"The depth must equal at least at zero before reaching the root. This is a bug in React.\");\n            }\n            if (parentPrev.depth === next.depth) {\n                // We found the same level. Now we just need to find a shared ancestor.\n                popToNearestCommonAncestor(parentPrev, next);\n            } else {\n                // We must still be deeper.\n                popPreviousToCommonLevel(parentPrev, next);\n            }\n        }\n        function popNextToCommonLevel(prev, next) {\n            var parentNext = next.parent;\n            if (parentNext === null) {\n                throw new Error(\"The depth must equal at least at zero before reaching the root. This is a bug in React.\");\n            }\n            if (prev.depth === parentNext.depth) {\n                // We found the same level. Now we just need to find a shared ancestor.\n                popToNearestCommonAncestor(prev, parentNext);\n            } else {\n                // We must still be deeper.\n                popNextToCommonLevel(prev, parentNext);\n            }\n            pushNode(next);\n        } // Perform context switching to the new snapshot.\n        // To make it cheap to read many contexts, while not suspending, we make the switch eagerly by\n        // updating all the context's current values. That way reads, always just read the current value.\n        // At the cost of updating contexts even if they're never read by this subtree.\n        function switchContext(newSnapshot) {\n            // The basic algorithm we need to do is to pop back any contexts that are no longer on the stack.\n            // We also need to update any new contexts that are now on the stack with the deepest value.\n            // The easiest way to update new contexts is to just reapply them in reverse order from the\n            // perspective of the backpointers. To avoid allocating a lot when switching, we use the stack\n            // for that. Therefore this algorithm is recursive.\n            // 1) First we pop which ever snapshot tree was deepest. Popping old contexts as we go.\n            // 2) Then we find the nearest common ancestor from there. Popping old contexts as we go.\n            // 3) Then we reapply new contexts on the way back up the stack.\n            var prev = currentActiveSnapshot;\n            var next = newSnapshot;\n            if (prev !== next) {\n                if (prev === null) {\n                    // $FlowFixMe[incompatible-call]: This has to be non-null since it's not equal to prev.\n                    pushAllNext(next);\n                } else if (next === null) {\n                    popAllPrevious(prev);\n                } else if (prev.depth === next.depth) {\n                    popToNearestCommonAncestor(prev, next);\n                } else if (prev.depth > next.depth) {\n                    popPreviousToCommonLevel(prev, next);\n                } else {\n                    popNextToCommonLevel(prev, next);\n                }\n                currentActiveSnapshot = next;\n            }\n        }\n        function pushProvider(context, nextValue) {\n            var prevValue;\n            {\n                prevValue = context._currentValue2;\n                context._currentValue2 = nextValue;\n                {\n                    if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer2 = rendererSigil;\n                }\n            }\n            var prevNode = currentActiveSnapshot;\n            var newNode = {\n                parent: prevNode,\n                depth: prevNode === null ? 0 : prevNode.depth + 1,\n                context: context,\n                parentValue: prevValue,\n                value: nextValue\n            };\n            currentActiveSnapshot = newNode;\n            return newNode;\n        }\n        function popProvider(context) {\n            var prevSnapshot = currentActiveSnapshot;\n            if (prevSnapshot === null) {\n                throw new Error(\"Tried to pop a Context at the root of the app. This is a bug in React.\");\n            }\n            {\n                if (prevSnapshot.context !== context) {\n                    error(\"The parent context is not the expected context. This is probably a bug in React.\");\n                }\n            }\n            {\n                var _value = prevSnapshot.parentValue;\n                if (_value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {\n                    prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue;\n                } else {\n                    prevSnapshot.context._currentValue2 = _value;\n                }\n                {\n                    if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer2 = rendererSigil;\n                }\n            }\n            return currentActiveSnapshot = prevSnapshot.parent;\n        }\n        function getActiveContext() {\n            return currentActiveSnapshot;\n        }\n        function readContext$1(context) {\n            var value = context._currentValue2;\n            return value;\n        }\n        /**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */ function get(key) {\n            return key._reactInternals;\n        }\n        function set(key, value) {\n            key._reactInternals = value;\n        }\n        var didWarnAboutNoopUpdateForComponent = {};\n        var didWarnAboutDeprecatedWillMount = {};\n        var didWarnAboutUninitializedState;\n        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n        var didWarnAboutLegacyLifecyclesAndDerivedState;\n        var didWarnAboutUndefinedDerivedState;\n        var didWarnAboutDirectlyAssigningPropsToState;\n        var didWarnAboutContextTypeAndContextTypes;\n        var didWarnAboutInvalidateContextType;\n        var didWarnOnInvalidCallback;\n        {\n            didWarnAboutUninitializedState = new Set();\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n            didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n            didWarnAboutDirectlyAssigningPropsToState = new Set();\n            didWarnAboutUndefinedDerivedState = new Set();\n            didWarnAboutContextTypeAndContextTypes = new Set();\n            didWarnAboutInvalidateContextType = new Set();\n            didWarnOnInvalidCallback = new Set();\n        }\n        function warnOnInvalidCallback(callback, callerName) {\n            {\n                if (callback === null || typeof callback === \"function\") {\n                    return;\n                }\n                var key = callerName + \"_\" + callback;\n                if (!didWarnOnInvalidCallback.has(key)) {\n                    didWarnOnInvalidCallback.add(key);\n                    error(\"%s(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callerName, callback);\n                }\n            }\n        }\n        function warnOnUndefinedDerivedState(type, partialState) {\n            {\n                if (partialState === undefined) {\n                    var componentName = getComponentNameFromType(type) || \"Component\";\n                    if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n                        didWarnAboutUndefinedDerivedState.add(componentName);\n                        error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \" + \"You have returned undefined.\", componentName);\n                    }\n                }\n            }\n        }\n        function warnNoop(publicInstance, callerName) {\n            {\n                var _constructor = publicInstance.constructor;\n                var componentName = _constructor && getComponentNameFromType(_constructor) || \"ReactClass\";\n                var warningKey = componentName + \".\" + callerName;\n                if (didWarnAboutNoopUpdateForComponent[warningKey]) {\n                    return;\n                }\n                error(\"%s(...): Can only update a mounting component. \" + \"This usually means you called %s() outside componentWillMount() on the server. \" + \"This is a no-op.\\n\\nPlease check the code for the %s component.\", callerName, callerName, componentName);\n                didWarnAboutNoopUpdateForComponent[warningKey] = true;\n            }\n        }\n        var classComponentUpdater = {\n            isMounted: function(inst) {\n                return false;\n            },\n            // $FlowFixMe[missing-local-annot]\n            enqueueSetState: function(inst, payload, callback) {\n                var internals = get(inst);\n                if (internals.queue === null) {\n                    warnNoop(inst, \"setState\");\n                } else {\n                    internals.queue.push(payload);\n                    {\n                        if (callback !== undefined && callback !== null) {\n                            warnOnInvalidCallback(callback, \"setState\");\n                        }\n                    }\n                }\n            },\n            enqueueReplaceState: function(inst, payload, callback) {\n                var internals = get(inst);\n                internals.replace = true;\n                internals.queue = [\n                    payload\n                ];\n                {\n                    if (callback !== undefined && callback !== null) {\n                        warnOnInvalidCallback(callback, \"setState\");\n                    }\n                }\n            },\n            // $FlowFixMe[missing-local-annot]\n            enqueueForceUpdate: function(inst, callback) {\n                var internals = get(inst);\n                if (internals.queue === null) {\n                    warnNoop(inst, \"forceUpdate\");\n                } else {\n                    {\n                        if (callback !== undefined && callback !== null) {\n                            warnOnInvalidCallback(callback, \"setState\");\n                        }\n                    }\n                }\n            }\n        };\n        function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {\n            var partialState = getDerivedStateFromProps(nextProps, prevState);\n            {\n                warnOnUndefinedDerivedState(ctor, partialState);\n            }\n            var newState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n            return newState;\n        }\n        function constructClassInstance(ctor, props, maskedLegacyContext) {\n            var context = emptyContextObject;\n            var contextType = ctor.contextType;\n            {\n                if (\"contextType\" in ctor) {\n                    var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n                    if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n                        didWarnAboutInvalidateContextType.add(ctor);\n                        var addendum = \"\";\n                        if (contextType === undefined) {\n                            addendum = \" However, it is set to undefined. \" + \"This can be caused by a typo or by mixing up named and default imports. \" + \"This can also happen due to a circular dependency, so \" + \"try moving the createContext() call to a separate file.\";\n                        } else if (typeof contextType !== \"object\") {\n                            addendum = \" However, it is set to a \" + typeof contextType + \".\";\n                        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n                            addendum = \" Did you accidentally pass the Context.Provider instead?\";\n                        } else if (contextType._context !== undefined) {\n                            // <Context.Consumer>\n                            addendum = \" Did you accidentally pass the Context.Consumer instead?\";\n                        } else {\n                            addendum = \" However, it is set to an object with keys {\" + Object.keys(contextType).join(\", \") + \"}.\";\n                        }\n                        error(\"%s defines an invalid contextType. \" + \"contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(ctor) || \"Component\", addendum);\n                    }\n                }\n            }\n            if (typeof contextType === \"object\" && contextType !== null) {\n                context = readContext$1(contextType);\n            } else {\n                context = maskedLegacyContext;\n            }\n            var instance = new ctor(props, context);\n            {\n                if (typeof ctor.getDerivedStateFromProps === \"function\" && (instance.state === null || instance.state === undefined)) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutUninitializedState.has(componentName)) {\n                        didWarnAboutUninitializedState.add(componentName);\n                        error(\"`%s` uses `getDerivedStateFromProps` but its initial state is \" + \"%s. This is not recommended. Instead, define the initial state by \" + \"assigning an object to `this.state` in the constructor of `%s`. \" + \"This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", componentName, instance.state === null ? \"null\" : \"undefined\", componentName);\n                    }\n                } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n                // Warn about these lifecycles if they are present.\n                // Don't warn about react-lifecycles-compat polyfilled methods though.\n                if (typeof ctor.getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    var foundWillMountName = null;\n                    var foundWillReceivePropsName = null;\n                    var foundWillUpdateName = null;\n                    if (typeof instance.componentWillMount === \"function\" && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        foundWillMountName = \"componentWillMount\";\n                    } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                        foundWillMountName = \"UNSAFE_componentWillMount\";\n                    }\n                    if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                        foundWillReceivePropsName = \"componentWillReceiveProps\";\n                    } else if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                        foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n                    }\n                    if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                        foundWillUpdateName = \"componentWillUpdate\";\n                    } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                        foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n                    }\n                    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n                        var _componentName = getComponentNameFromType(ctor) || \"Component\";\n                        var newApiName = typeof ctor.getDerivedStateFromProps === \"function\" ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n                            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n                            error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n\" + \"%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n\" + \"The above lifecycles should be removed. Learn more about this warning here:\\n\" + \"https://reactjs.org/link/unsafe-component-lifecycles\", _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : \"\", foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : \"\", foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : \"\");\n                        }\n                    }\n                }\n            }\n            return instance;\n        }\n        function checkClassInstance(instance, ctor, newProps) {\n            {\n                var name = getComponentNameFromType(ctor) || \"Component\";\n                var renderPresent = instance.render;\n                if (!renderPresent) {\n                    if (ctor.prototype && typeof ctor.prototype.render === \"function\") {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: did you accidentally return an object from the constructor?\", name);\n                    } else {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: you may have forgotten to define `render`.\", name);\n                    }\n                }\n                if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n                    error(\"getInitialState was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Did you mean to define a state property instead?\", name);\n                }\n                if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Use a static property to define defaultProps instead.\", name);\n                }\n                if (instance.propTypes) {\n                    error(\"propTypes was defined as an instance property on %s. Use a static \" + \"property to define propTypes instead.\", name);\n                }\n                if (instance.contextType) {\n                    error(\"contextType was defined as an instance property on %s. Use a static \" + \"property to define contextType instead.\", name);\n                }\n                {\n                    if (instance.contextTypes) {\n                        error(\"contextTypes was defined as an instance property on %s. Use a static \" + \"property to define contextTypes instead.\", name);\n                    }\n                    if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n                        didWarnAboutContextTypeAndContextTypes.add(ctor);\n                        error(\"%s declares both contextTypes and contextType static properties. \" + \"The legacy contextTypes property will be ignored.\", name);\n                    }\n                }\n                if (typeof instance.componentShouldUpdate === \"function\") {\n                    error(\"%s has a method called \" + \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" + \"The name is phrased as a question because the function is \" + \"expected to return a value.\", name);\n                }\n                if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== \"undefined\") {\n                    error(\"%s has a method called shouldComponentUpdate(). \" + \"shouldComponentUpdate should not be used when extending React.PureComponent. \" + \"Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(ctor) || \"A pure component\");\n                }\n                if (typeof instance.componentDidUnmount === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidUnmount(). But there is no such lifecycle method. \" + \"Did you mean componentWillUnmount()?\", name);\n                }\n                if (typeof instance.componentDidReceiveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidReceiveProps(). But there is no such lifecycle method. \" + \"If you meant to update the state in response to changing props, \" + \"use componentWillReceiveProps(). If you meant to fetch data or \" + \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", name);\n                }\n                if (typeof instance.componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", name);\n                }\n                if (typeof instance.UNSAFE_componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", name);\n                }\n                var hasMutatedProps = instance.props !== newProps;\n                if (instance.props !== undefined && hasMutatedProps) {\n                    error(\"%s(...): When calling super() in `%s`, make sure to pass \" + \"up the same props that your component's constructor was passed.\", name, name);\n                }\n                if (instance.defaultProps) {\n                    error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" + \" Instead, define defaultProps as a static property on %s.\", name, name);\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\" && typeof instance.componentDidUpdate !== \"function\" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n                    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n                    error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). \" + \"This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(ctor));\n                }\n                if (typeof instance.getDerivedStateFromProps === \"function\") {\n                    error(\"%s: getDerivedStateFromProps() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof instance.getDerivedStateFromError === \"function\") {\n                    error(\"%s: getDerivedStateFromError() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof ctor.getSnapshotBeforeUpdate === \"function\") {\n                    error(\"%s: getSnapshotBeforeUpdate() is defined as a static method \" + \"and will be ignored. Instead, declare it as an instance method.\", name);\n                }\n                var state = instance.state;\n                if (state && (typeof state !== \"object\" || isArray(state))) {\n                    error(\"%s.state: must be set to an object or null\", name);\n                }\n                if (typeof instance.getChildContext === \"function\" && typeof ctor.childContextTypes !== \"object\") {\n                    error(\"%s.getChildContext(): childContextTypes must be defined in order to \" + \"use getChildContext().\", name);\n                }\n            }\n        }\n        function callComponentWillMount(type, instance) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillMount === \"function\") {\n                {\n                    if (instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        var componentName = getComponentNameFromType(type) || \"Unknown\";\n                        if (!didWarnAboutDeprecatedWillMount[componentName]) {\n                            warn(\"componentWillMount has been renamed, and is not recommended for use. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move code from componentWillMount to componentDidMount (preferred in most cases) \" + \"or the constructor.\\n\" + \"\\nPlease update the following components: %s\", componentName);\n                            didWarnAboutDeprecatedWillMount[componentName] = true;\n                        }\n                    }\n                }\n                instance.componentWillMount();\n            }\n            if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                instance.UNSAFE_componentWillMount();\n            }\n            if (oldState !== instance.state) {\n                {\n                    error(\"%s.componentWillMount(): Assigning directly to this.state is \" + \"deprecated (except inside a component's \" + \"constructor). Use setState instead.\", getComponentNameFromType(type) || \"Component\");\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        }\n        function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {\n            if (internalInstance.queue !== null && internalInstance.queue.length > 0) {\n                var oldQueue = internalInstance.queue;\n                var oldReplace = internalInstance.replace;\n                internalInstance.queue = null;\n                internalInstance.replace = false;\n                if (oldReplace && oldQueue.length === 1) {\n                    inst.state = oldQueue[0];\n                } else {\n                    var nextState = oldReplace ? oldQueue[0] : inst.state;\n                    var dontMutate = true;\n                    for(var i = oldReplace ? 1 : 0; i < oldQueue.length; i++){\n                        var partial = oldQueue[i];\n                        var partialState = typeof partial === \"function\" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;\n                        if (partialState != null) {\n                            if (dontMutate) {\n                                dontMutate = false;\n                                nextState = assign({}, nextState, partialState);\n                            } else {\n                                assign(nextState, partialState);\n                            }\n                        }\n                    }\n                    inst.state = nextState;\n                }\n            } else {\n                internalInstance.queue = null;\n            }\n        } // Invokes the mount life-cycles on a previously never rendered instance.\n        function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {\n            {\n                checkClassInstance(instance, ctor, newProps);\n            }\n            var initialState = instance.state !== undefined ? instance.state : null;\n            instance.updater = classComponentUpdater;\n            instance.props = newProps;\n            instance.state = initialState; // We don't bother initializing the refs object on the server, since we're not going to resolve them anyway.\n            // The internal instance will be used to manage updates that happen during this mount.\n            var internalInstance = {\n                queue: [],\n                replace: false\n            };\n            set(instance, internalInstance);\n            var contextType = ctor.contextType;\n            if (typeof contextType === \"object\" && contextType !== null) {\n                instance.context = readContext$1(contextType);\n            } else {\n                instance.context = maskedLegacyContext;\n            }\n            {\n                if (instance.state === newProps) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n                        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n                        error(\"%s: It is not recommended to assign props directly to state \" + \"because updates to props won't be reflected in state. \" + \"In most cases, it is better to use props directly.\", componentName);\n                    }\n                }\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            if (typeof getDerivedStateFromProps === \"function\") {\n                instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);\n            } // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (typeof ctor.getDerivedStateFromProps !== \"function\" && typeof instance.getSnapshotBeforeUpdate !== \"function\" && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n                callComponentWillMount(ctor, instance); // If we had additional state updates during this life-cycle, let's\n                // process them now.\n                processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);\n            }\n        }\n        // Ids are base 32 strings whose binary representation corresponds to the\n        // position of a node in a tree.\n        // Every time the tree forks into multiple children, we add additional bits to\n        // the left of the sequence that represent the position of the child within the\n        // current level of children.\n        //\n        //      00101       00010001011010101\n        //             \n        //   Fork 5 of 20       Parent id\n        //\n        // The leading 0s are important. In the above example, you only need 3 bits to\n        // represent slot 5. However, you need 5 bits to represent all the forks at\n        // the current level, so we must account for the empty bits at the end.\n        //\n        // For this same reason, slots are 1-indexed instead of 0-indexed. Otherwise,\n        // the zeroth id at a level would be indistinguishable from its parent.\n        //\n        // If a node has only one child, and does not materialize an id (i.e. does not\n        // contain a useId hook), then we don't need to allocate any space in the\n        // sequence. It's treated as a transparent indirection. For example, these two\n        // trees produce the same ids:\n        //\n        // <>                          <>\n        //   <Indirection>               <A />\n        //     <A />                     <B />\n        //   </Indirection>            </>\n        //   <B />\n        // </>\n        //\n        // However, we cannot skip any node that materializes an id. Otherwise, a parent\n        // id that does not fork would be indistinguishable from its child id. For\n        // example, this tree does not fork, but the parent and child must have\n        // different ids.\n        //\n        // <Parent>\n        //   <Child />\n        // </Parent>\n        //\n        // To handle this scenario, every time we materialize an id, we allocate a\n        // new level with a single slot. You can think of this as a fork with only one\n        // prong, or an array of children with length 1.\n        //\n        // It's possible for the size of the sequence to exceed 32 bits, the max\n        // size for bitwise operations. When this happens, we make more room by\n        // converting the right part of the id to a string and storing it in an overflow\n        // variable. We use a base 32 string representation, because 32 is the largest\n        // power of 2 that is supported by toString(). We want the base to be large so\n        // that the resulting ids are compact, and we want the base to be a power of 2\n        // because every log2(base) bits corresponds to a single character, i.e. every\n        // log2(32) = 5 bits. That means we can lop bits off the end 5 at a time without\n        // affecting the final result.\n        var emptyTreeContext = {\n            id: 1,\n            overflow: \"\"\n        };\n        function getTreeId(context) {\n            var overflow = context.overflow;\n            var idWithLeadingBit = context.id;\n            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n            return id.toString(32) + overflow;\n        }\n        function pushTreeContext(baseContext, totalChildren, index) {\n            var baseIdWithLeadingBit = baseContext.id;\n            var baseOverflow = baseContext.overflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n            // of the id; we use it to account for leading 0s.\n            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n            var slot = index + 1;\n            var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n            // consideration the leading 1 we use to mark the end of the sequence.\n            if (length > 30) {\n                // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n                // This branch assumes the length of the base id is greater than 5; it won't\n                // work for smaller ids, because you need 5 bits per character.\n                //\n                // We encode the id in multiple steps: first the base id, then the\n                // remaining digits.\n                //\n                // Each 5 bit sequence corresponds to a single base 32 character. So for\n                // example, if the current id is 23 bits long, we can convert 20 of those\n                // bits into a string of 4 characters, with 3 bits left over.\n                //\n                // First calculate how many bits in the base id represent a complete\n                // sequence of characters.\n                var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n                var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n                var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n                var restOfBaseId = baseId >> numberOfOverflowBits;\n                var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n                // we made more room, this time it won't overflow.\n                var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n                var restOfNewBits = slot << restOfBaseLength;\n                var id = restOfNewBits | restOfBaseId;\n                var overflow = newOverflow + baseOverflow;\n                return {\n                    id: 1 << restOfLength | id,\n                    overflow: overflow\n                };\n            } else {\n                // Normal path\n                var newBits = slot << baseLength;\n                var _id = newBits | baseId;\n                var _overflow = baseOverflow;\n                return {\n                    id: 1 << length | _id,\n                    overflow: _overflow\n                };\n            }\n        }\n        function getBitLength(number) {\n            return 32 - clz32(number);\n        }\n        function getLeadingBit(id) {\n            return 1 << getBitLength(id) - 1;\n        } // TODO: Math.clz32 is supported in Node 12+. Maybe we can drop the fallback.\n        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n        // Based on:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n        var log = Math.log;\n        var LN2 = Math.LN2;\n        function clz32Fallback(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0;\n        }\n        // Corresponds to ReactFiberWakeable and ReactFlightWakeable modules. Generally,\n        // changes to one module should be reflected in the others.\n        // TODO: Rename this module and the corresponding Fiber one to \"Thenable\"\n        // instead of \"Wakeable\". Or some other more appropriate name.\n        // An error that is thrown (e.g. by `use`) to trigger Suspense. If we\n        // detect this is caught by userspace, we'll log a warning in development.\n        var SuspenseException = new Error(\"Suspense Exception: This is not a real error! It's an implementation \" + \"detail of `use` to interrupt the current render. You must either \" + \"rethrow it immediately, or move the `use` call outside of the \" + \"`try/catch` block. Capturing without rethrowing will lead to \" + \"unexpected behavior.\\n\\n\" + \"To handle async errors, wrap your component in an error boundary, or \" + \"call the promise's `.catch` method and pass the result to `use`\");\n        function createThenableState() {\n            // The ThenableState is created the first time a component suspends. If it\n            // suspends again, we'll reuse the same state.\n            return [];\n        }\n        function noop$2() {}\n        function trackUsedThenable(thenableState, thenable, index) {\n            var previous = thenableState[index];\n            if (previous === undefined) {\n                thenableState.push(thenable);\n            } else {\n                if (previous !== thenable) {\n                    // Reuse the previous thenable, and drop the new one. We can assume\n                    // they represent the same value, because components are idempotent.\n                    // Avoid an unhandled rejection errors for the Promises that we'll\n                    // intentionally ignore.\n                    thenable.then(noop$2, noop$2);\n                    thenable = previous;\n                }\n            } // We use an expando to track the status and result of a thenable so that we\n            // can synchronously unwrap the value. Think of this as an extension of the\n            // Promise API, or a custom interface that is a superset of Thenable.\n            //\n            // If the thenable doesn't have a status, set it to \"pending\" and attach\n            // a listener that will update its status and result when it resolves.\n            switch(thenable.status){\n                case \"fulfilled\":\n                    {\n                        var fulfilledValue = thenable.value;\n                        return fulfilledValue;\n                    }\n                case \"rejected\":\n                    {\n                        var rejectedError = thenable.reason;\n                        throw rejectedError;\n                    }\n                default:\n                    {\n                        if (typeof thenable.status === \"string\") ;\n                        else {\n                            var pendingThenable = thenable;\n                            pendingThenable.status = \"pending\";\n                            pendingThenable.then(function(fulfilledValue) {\n                                if (thenable.status === \"pending\") {\n                                    var fulfilledThenable = thenable;\n                                    fulfilledThenable.status = \"fulfilled\";\n                                    fulfilledThenable.value = fulfilledValue;\n                                }\n                            }, function(error) {\n                                if (thenable.status === \"pending\") {\n                                    var rejectedThenable = thenable;\n                                    rejectedThenable.status = \"rejected\";\n                                    rejectedThenable.reason = error;\n                                }\n                            }); // Check one more time in case the thenable resolved synchronously\n                            switch(thenable.status){\n                                case \"fulfilled\":\n                                    {\n                                        var fulfilledThenable = thenable;\n                                        return fulfilledThenable.value;\n                                    }\n                                case \"rejected\":\n                                    {\n                                        var rejectedThenable = thenable;\n                                        throw rejectedThenable.reason;\n                                    }\n                            }\n                        } // Suspend.\n                        //\n                        // Throwing here is an implementation detail that allows us to unwind the\n                        // call stack. But we shouldn't allow it to leak into userspace. Throw an\n                        // opaque placeholder value instead of the actual thenable. If it doesn't\n                        // get captured by the work loop, log a warning, because that means\n                        // something in userspace must have caught it.\n                        suspendedThenable = thenable;\n                        throw SuspenseException;\n                    }\n            }\n        } // This is used to track the actual thenable that suspended so it can be\n        // passed to the rest of the Suspense implementation  which, for historical\n        // reasons, expects to receive a thenable.\n        var suspendedThenable = null;\n        function getSuspendedThenable() {\n            // This is called right after `use` suspends by throwing an exception. `use`\n            // throws an opaque value instead of the thenable itself so that it can't be\n            // caught in userspace. Then the work loop accesses the actual thenable using\n            // this function.\n            if (suspendedThenable === null) {\n                throw new Error(\"Expected a suspended thenable. This is a bug in React. Please file \" + \"an issue.\");\n            }\n            var thenable = suspendedThenable;\n            suspendedThenable = null;\n            return thenable;\n        }\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        var currentlyRenderingComponent = null;\n        var currentlyRenderingTask = null;\n        var currentlyRenderingRequest = null;\n        var currentlyRenderingKeyPath = null;\n        var firstWorkInProgressHook = null;\n        var workInProgressHook = null; // Whether the work-in-progress hook is a re-rendered hook\n        var isReRender = false; // Whether an update was scheduled during the currently executing render pass.\n        var didScheduleRenderPhaseUpdate = false; // Counts the number of useId hooks in this component\n        var localIdCounter = 0; // Chunks that should be pushed to the stream once the component\n        // finishes rendering.\n        // Counts the number of useFormState calls in this component\n        var formStateCounter = 0; // The index of the useFormState hook that matches the one passed in at the\n        // root during an MPA navigation, if any.\n        var formStateMatchingIndex = -1; // Counts the number of use(thenable) calls in this component\n        var thenableIndexCounter = 0;\n        var thenableState = null; // Lazily created map of render-phase updates\n        var renderPhaseUpdates = null; // Counter to prevent infinite loops.\n        var numberOfReRenders = 0;\n        var RE_RENDER_LIMIT = 25;\n        var isInHookUserCodeInDev = false; // In DEV, this is the name of the currently executing primitive hook\n        var currentHookNameInDev;\n        function resolveCurrentlyRenderingComponent() {\n            if (currentlyRenderingComponent === null) {\n                throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for\" + \" one of the following reasons:\\n\" + \"1. You might have mismatching versions of React and the renderer (such as React DOM)\\n\" + \"2. You might be breaking the Rules of Hooks\\n\" + \"3. You might have more than one copy of React in the same app\\n\" + \"See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n            }\n            {\n                if (isInHookUserCodeInDev) {\n                    error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. \" + \"You can only call Hooks at the top level of your React function. \" + \"For more information, see \" + \"https://reactjs.org/link/rules-of-hooks\");\n                }\n            }\n            return currentlyRenderingComponent;\n        }\n        function areHookInputsEqual(nextDeps, prevDeps) {\n            if (prevDeps === null) {\n                {\n                    error(\"%s received a final argument during this render, but not during \" + \"the previous render. Even though the final argument is optional, \" + \"its type cannot change between renders.\", currentHookNameInDev);\n                }\n                return false;\n            }\n            {\n                // Don't bother comparing lengths in prod because these arrays should be\n                // passed inline.\n                if (nextDeps.length !== prevDeps.length) {\n                    error(\"The final argument passed to %s changed size between renders. The \" + \"order and size of this array must remain constant.\\n\\n\" + \"Previous: %s\\n\" + \"Incoming: %s\", currentHookNameInDev, \"[\" + nextDeps.join(\", \") + \"]\", \"[\" + prevDeps.join(\", \") + \"]\");\n                }\n            }\n            for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){\n                // $FlowFixMe[incompatible-use] found when upgrading Flow\n                if (objectIs(nextDeps[i], prevDeps[i])) {\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        function createHook() {\n            if (numberOfReRenders > 0) {\n                throw new Error(\"Rendered more hooks than during the previous render\");\n            }\n            return {\n                memoizedState: null,\n                queue: null,\n                next: null\n            };\n        }\n        function createWorkInProgressHook() {\n            if (workInProgressHook === null) {\n                // This is the first hook in the list\n                if (firstWorkInProgressHook === null) {\n                    isReRender = false;\n                    firstWorkInProgressHook = workInProgressHook = createHook();\n                } else {\n                    // There's already a work-in-progress. Reuse it.\n                    isReRender = true;\n                    workInProgressHook = firstWorkInProgressHook;\n                }\n            } else {\n                if (workInProgressHook.next === null) {\n                    isReRender = false; // Append to the end of the list\n                    workInProgressHook = workInProgressHook.next = createHook();\n                } else {\n                    // There's already a work-in-progress. Reuse it.\n                    isReRender = true;\n                    workInProgressHook = workInProgressHook.next;\n                }\n            }\n            return workInProgressHook;\n        }\n        function prepareToUseHooks(request, task, keyPath, componentIdentity, prevThenableState) {\n            currentlyRenderingComponent = componentIdentity;\n            currentlyRenderingTask = task;\n            currentlyRenderingRequest = request;\n            currentlyRenderingKeyPath = keyPath;\n            {\n                isInHookUserCodeInDev = false;\n            }\n            // didScheduleRenderPhaseUpdate = false;\n            // firstWorkInProgressHook = null;\n            // numberOfReRenders = 0;\n            // renderPhaseUpdates = null;\n            // workInProgressHook = null;\n            localIdCounter = 0;\n            formStateCounter = 0;\n            formStateMatchingIndex = -1;\n            thenableIndexCounter = 0;\n            thenableState = prevThenableState;\n        }\n        function finishHooks(Component, props, children, refOrContext) {\n            // This must be called after every function component to prevent hooks from\n            // being used in classes.\n            while(didScheduleRenderPhaseUpdate){\n                // Updates were scheduled during the render phase. They are stored in\n                // the `renderPhaseUpdates` map. Call the component again, reusing the\n                // work-in-progress hooks and applying the additional updates on top. Keep\n                // restarting until no more updates are scheduled.\n                didScheduleRenderPhaseUpdate = false;\n                localIdCounter = 0;\n                formStateCounter = 0;\n                formStateMatchingIndex = -1;\n                thenableIndexCounter = 0;\n                numberOfReRenders += 1; // Start over from the beginning of the list\n                workInProgressHook = null;\n                children = Component(props, refOrContext);\n            }\n            resetHooksState();\n            return children;\n        }\n        function getThenableStateAfterSuspending() {\n            var state = thenableState;\n            thenableState = null;\n            return state;\n        }\n        function checkDidRenderIdHook() {\n            // This should be called immediately after every finishHooks call.\n            // Conceptually, it's part of the return value of finishHooks; it's only a\n            // separate function to avoid using an array tuple.\n            var didRenderIdHook = localIdCounter !== 0;\n            return didRenderIdHook;\n        }\n        function getFormStateCount() {\n            // This should be called immediately after every finishHooks call.\n            // Conceptually, it's part of the return value of finishHooks; it's only a\n            // separate function to avoid using an array tuple.\n            return formStateCounter;\n        }\n        function getFormStateMatchingIndex() {\n            // This should be called immediately after every finishHooks call.\n            // Conceptually, it's part of the return value of finishHooks; it's only a\n            // separate function to avoid using an array tuple.\n            return formStateMatchingIndex;\n        } // Reset the internal hooks state if an error occurs while rendering a component\n        function resetHooksState() {\n            {\n                isInHookUserCodeInDev = false;\n            }\n            currentlyRenderingComponent = null;\n            currentlyRenderingTask = null;\n            currentlyRenderingRequest = null;\n            currentlyRenderingKeyPath = null;\n            didScheduleRenderPhaseUpdate = false;\n            firstWorkInProgressHook = null;\n            numberOfReRenders = 0;\n            renderPhaseUpdates = null;\n            workInProgressHook = null;\n        }\n        function readContext(context) {\n            {\n                if (isInHookUserCodeInDev) {\n                    error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n                }\n            }\n            return readContext$1(context);\n        }\n        function useContext(context) {\n            {\n                currentHookNameInDev = \"useContext\";\n            }\n            resolveCurrentlyRenderingComponent();\n            return readContext$1(context);\n        }\n        function basicStateReducer(state, action) {\n            // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n            return typeof action === \"function\" ? action(state) : action;\n        }\n        function useState(initialState) {\n            _s();\n            {\n                currentHookNameInDev = \"useState\";\n            }\n            return useReducer(basicStateReducer, initialState);\n        }\n        _s(useState, \"skVOqNGrFQuDFh+lpttAJ2AZFeA=\");\n        function useReducer(reducer, initialArg, init) {\n            {\n                if (reducer !== basicStateReducer) {\n                    currentHookNameInDev = \"useReducer\";\n                }\n            }\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            if (isReRender) {\n                // This is a re-render. Apply the new render phase updates to the previous\n                // current hook.\n                var queue = workInProgressHook.queue;\n                var dispatch = queue.dispatch;\n                if (renderPhaseUpdates !== null) {\n                    // Render phase updates are stored in a map of queue -> linked list\n                    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                    if (firstRenderPhaseUpdate !== undefined) {\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        renderPhaseUpdates.delete(queue); // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        var newState = workInProgressHook.memoizedState;\n                        var update = firstRenderPhaseUpdate;\n                        do {\n                            // Process this render phase update. We don't have to check the\n                            // priority because it will always be the same as the current\n                            // render's.\n                            var action = update.action;\n                            {\n                                isInHookUserCodeInDev = true;\n                            }\n                            newState = reducer(newState, action);\n                            {\n                                isInHookUserCodeInDev = false;\n                            }\n                            update = update.next;\n                        }while (update !== null); // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        workInProgressHook.memoizedState = newState;\n                        return [\n                            newState,\n                            dispatch\n                        ];\n                    }\n                } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                return [\n                    workInProgressHook.memoizedState,\n                    dispatch\n                ];\n            } else {\n                {\n                    isInHookUserCodeInDev = true;\n                }\n                var initialState;\n                if (reducer === basicStateReducer) {\n                    // Special case for `useState`.\n                    initialState = typeof initialArg === \"function\" ? initialArg() : initialArg;\n                } else {\n                    initialState = init !== undefined ? init(initialArg) : initialArg;\n                }\n                {\n                    isInHookUserCodeInDev = false;\n                }\n                workInProgressHook.memoizedState = initialState; // $FlowFixMe[incompatible-use] found when upgrading Flow\n                var _queue = workInProgressHook.queue = {\n                    last: null,\n                    dispatch: null\n                };\n                var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue); // $FlowFixMe[incompatible-use] found when upgrading Flow\n                return [\n                    workInProgressHook.memoizedState,\n                    _dispatch\n                ];\n            }\n        }\n        function useMemo(nextCreate, deps) {\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            if (workInProgressHook !== null) {\n                var prevState = workInProgressHook.memoizedState;\n                if (prevState !== null) {\n                    if (nextDeps !== null) {\n                        var prevDeps = prevState[1];\n                        if (areHookInputsEqual(nextDeps, prevDeps)) {\n                            return prevState[0];\n                        }\n                    }\n                }\n            }\n            {\n                isInHookUserCodeInDev = true;\n            }\n            var nextValue = nextCreate();\n            {\n                isInHookUserCodeInDev = false;\n            }\n            workInProgressHook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function useRef(initialValue) {\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            var previousRef = workInProgressHook.memoizedState;\n            if (previousRef === null) {\n                var ref = {\n                    current: initialValue\n                };\n                {\n                    Object.seal(ref);\n                }\n                workInProgressHook.memoizedState = ref;\n                return ref;\n            } else {\n                return previousRef;\n            }\n        }\n        function dispatchAction(componentIdentity, queue, action) {\n            if (numberOfReRenders >= RE_RENDER_LIMIT) {\n                throw new Error(\"Too many re-renders. React limits the number of renders to prevent \" + \"an infinite loop.\");\n            }\n            if (componentIdentity === currentlyRenderingComponent) {\n                // This is a render phase update. Stash it in a lazily-created map of\n                // queue -> linked list of updates. After this render pass, we'll restart\n                // and apply the stashed updates on top of the work-in-progress hook.\n                didScheduleRenderPhaseUpdate = true;\n                var update = {\n                    action: action,\n                    next: null\n                };\n                if (renderPhaseUpdates === null) {\n                    renderPhaseUpdates = new Map();\n                }\n                var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                if (firstRenderPhaseUpdate === undefined) {\n                    // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    renderPhaseUpdates.set(queue, update);\n                } else {\n                    // Append the update to the end of the list.\n                    var lastRenderPhaseUpdate = firstRenderPhaseUpdate;\n                    while(lastRenderPhaseUpdate.next !== null){\n                        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n                    }\n                    lastRenderPhaseUpdate.next = update;\n                }\n            }\n        }\n        function useCallback(callback, deps) {\n            _s1();\n            return useMemo(function() {\n                return callback;\n            }, deps);\n        }\n        _s1(useCallback, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\n        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            if (getServerSnapshot === undefined) {\n                throw new Error(\"Missing getServerSnapshot, which is required for \" + \"server-rendered content. Will revert to client rendering.\");\n            }\n            return getServerSnapshot();\n        }\n        function useDeferredValue(value, initialValue) {\n            resolveCurrentlyRenderingComponent();\n            {\n                return value;\n            }\n        }\n        function unsupportedStartTransition() {\n            throw new Error(\"startTransition cannot be called during server rendering.\");\n        }\n        function useTransition() {\n            resolveCurrentlyRenderingComponent();\n            return [\n                false,\n                unsupportedStartTransition\n            ];\n        }\n        function useHostTransitionStatus() {\n            resolveCurrentlyRenderingComponent();\n            return NotPendingTransition;\n        }\n        function unsupportedSetOptimisticState() {\n            throw new Error(\"Cannot update optimistic state while rendering.\");\n        }\n        function useOptimistic(passthrough, reducer) {\n            resolveCurrentlyRenderingComponent();\n            return [\n                passthrough,\n                unsupportedSetOptimisticState\n            ];\n        }\n        function createPostbackFormStateKey(permalink, componentKeyPath, hookIndex) {\n            if (permalink !== undefined) {\n                // Don't bother to hash a permalink-based key since it's already short.\n                return \"p\" + permalink;\n            } else {\n                // Append a node to the key path that represents the form state hook.\n                var keyPath = [\n                    componentKeyPath,\n                    null,\n                    hookIndex\n                ]; // Key paths are hashed to reduce the size. It does not need to be secure,\n                // and it's more important that it's fast than that it's completely\n                // collision-free.\n                var keyPathHash = createFastHashJS(JSON.stringify(keyPath));\n                return \"k\" + keyPathHash;\n            }\n        }\n        function useFormState(action, initialState, permalink) {\n            resolveCurrentlyRenderingComponent(); // Count the number of useFormState hooks per component. We also use this to\n            // track the position of this useFormState hook relative to the other ones in\n            // this component, so we can generate a unique key for each one.\n            var formStateHookIndex = formStateCounter++;\n            var request = currentlyRenderingRequest; // $FlowIgnore[prop-missing]\n            var formAction = action.$$FORM_ACTION;\n            if (typeof formAction === \"function\") {\n                // This is a server action. These have additional features to enable\n                // MPA-style form submissions with progressive enhancement.\n                // TODO: If the same permalink is passed to multiple useFormStates, and\n                // they all have the same action signature, Fizz will pass the postback\n                // state to all of them. We should probably only pass it to the first one,\n                // and/or warn.\n                // The key is lazily generated and deduped so the that the keypath doesn't\n                // get JSON.stringify-ed unnecessarily, and at most once.\n                var nextPostbackStateKey = null; // Determine the current form state. If we received state during an MPA form\n                // submission, then we will reuse that, if the action identity matches.\n                // Otherwise we'll use the initial state argument. We will emit a comment\n                // marker into the stream that indicates whether the state was reused.\n                var state = initialState;\n                var componentKeyPath = currentlyRenderingKeyPath;\n                var postbackFormState = getFormState(request); // $FlowIgnore[prop-missing]\n                var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;\n                if (postbackFormState !== null && typeof isSignatureEqual === \"function\") {\n                    var postbackKey = postbackFormState[1];\n                    var postbackReferenceId = postbackFormState[2];\n                    var postbackBoundArity = postbackFormState[3];\n                    if (isSignatureEqual.call(action, postbackReferenceId, postbackBoundArity)) {\n                        nextPostbackStateKey = createPostbackFormStateKey(permalink, componentKeyPath, formStateHookIndex);\n                        if (postbackKey === nextPostbackStateKey) {\n                            // This was a match\n                            formStateMatchingIndex = formStateHookIndex; // Reuse the state that was submitted by the form.\n                            state = postbackFormState[0];\n                        }\n                    }\n                } // Bind the state to the first argument of the action.\n                var boundAction = action.bind(null, state); // Wrap the action so the return value is void.\n                var dispatch = function(payload) {\n                    boundAction(payload);\n                }; // $FlowIgnore[prop-missing]\n                if (typeof boundAction.$$FORM_ACTION === \"function\") {\n                    // $FlowIgnore[prop-missing]\n                    dispatch.$$FORM_ACTION = function(prefix) {\n                        var metadata = boundAction.$$FORM_ACTION(prefix); // Override the action URL\n                        if (permalink !== undefined) {\n                            {\n                                checkAttributeStringCoercion(permalink, \"target\");\n                            }\n                            permalink += \"\";\n                            metadata.action = permalink;\n                        }\n                        var formData = metadata.data;\n                        if (formData) {\n                            if (nextPostbackStateKey === null) {\n                                nextPostbackStateKey = createPostbackFormStateKey(permalink, componentKeyPath, formStateHookIndex);\n                            }\n                            formData.append(\"$ACTION_KEY\", nextPostbackStateKey);\n                        }\n                        return metadata;\n                    };\n                }\n                return [\n                    state,\n                    dispatch\n                ];\n            } else {\n                // This is not a server action, so the implementation is much simpler.\n                // Bind the state to the first argument of the action.\n                var _boundAction = action.bind(null, initialState); // Wrap the action so the return value is void.\n                var _dispatch2 = function(payload) {\n                    _boundAction(payload);\n                };\n                return [\n                    initialState,\n                    _dispatch2\n                ];\n            }\n        }\n        function useId() {\n            var task = currentlyRenderingTask;\n            var treeId = getTreeId(task.treeContext);\n            var resumableState = currentResumableState;\n            if (resumableState === null) {\n                throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component.\");\n            }\n            var localId = localIdCounter++;\n            return makeId(resumableState, treeId, localId);\n        }\n        function use(usable) {\n            if (usable !== null && typeof usable === \"object\") {\n                // $FlowFixMe[method-unbinding]\n                if (typeof usable.then === \"function\") {\n                    // This is a thenable.\n                    var thenable = usable;\n                    return unwrapThenable(thenable);\n                } else if (usable.$$typeof === REACT_CONTEXT_TYPE || usable.$$typeof === REACT_SERVER_CONTEXT_TYPE) {\n                    var context = usable;\n                    return readContext(context);\n                }\n            } // eslint-disable-next-line react-internal/safe-string-coercion\n            throw new Error(\"An unsupported type was passed to use(): \" + String(usable));\n        }\n        function unwrapThenable(thenable) {\n            var index = thenableIndexCounter;\n            thenableIndexCounter += 1;\n            if (thenableState === null) {\n                thenableState = createThenableState();\n            }\n            return trackUsedThenable(thenableState, thenable, index);\n        }\n        function unsupportedRefresh() {\n            throw new Error(\"Cache cannot be refreshed during server rendering.\");\n        }\n        function useCacheRefresh() {\n            return unsupportedRefresh;\n        }\n        function noop$1() {}\n        var HooksDispatcher = {\n            readContext: readContext,\n            use: use,\n            useContext: useContext,\n            useMemo: useMemo,\n            useReducer: useReducer,\n            useRef: useRef,\n            useState: useState,\n            useInsertionEffect: noop$1,\n            useLayoutEffect: noop$1,\n            useCallback: useCallback,\n            // useImperativeHandle is not run in the server environment\n            useImperativeHandle: noop$1,\n            // Effects are not run in the server environment.\n            useEffect: noop$1,\n            // Debugging effect\n            useDebugValue: noop$1,\n            useDeferredValue: useDeferredValue,\n            useTransition: useTransition,\n            useId: useId,\n            // Subscriptions are not setup in a server environment.\n            useSyncExternalStore: useSyncExternalStore\n        };\n        {\n            HooksDispatcher.useCacheRefresh = useCacheRefresh;\n        }\n        {\n            HooksDispatcher.useHostTransitionStatus = useHostTransitionStatus;\n        }\n        {\n            HooksDispatcher.useOptimistic = useOptimistic;\n            HooksDispatcher.useFormState = useFormState;\n        }\n        var currentResumableState = null;\n        function setCurrentResumableState(resumableState) {\n            currentResumableState = resumableState;\n        }\n        function getCacheSignal() {\n            throw new Error(\"Not implemented.\");\n        }\n        function getCacheForType(resourceType) {\n            throw new Error(\"Not implemented.\");\n        }\n        var DefaultCacheDispatcher = {\n            getCacheSignal: getCacheSignal,\n            getCacheForType: getCacheForType\n        };\n        function getStackByComponentStackNode(componentStack) {\n            try {\n                var info = \"\";\n                var node = componentStack;\n                do {\n                    switch(node.tag){\n                        case 0:\n                            info += describeBuiltInComponentFrame(node.type, null, null);\n                            break;\n                        case 1:\n                            info += describeFunctionComponentFrame(node.type, null, null);\n                            break;\n                        case 2:\n                            info += describeClassComponentFrame(node.type, null, null);\n                            break;\n                    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                    node = node.parent;\n                }while (node);\n                return info;\n            } catch (x) {\n                return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var ReactCurrentCache = ReactSharedInternals.ReactCurrentCache;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame; // Linked list representing the identity of a component given the component/tag name and key.\n        // The name might be minified but we assume that it's going to be the same generated name. Typically\n        // because it's just the same compiled output in practice.\n        // resume with segmentID at the index\n        var CLIENT_RENDERED = 4; // if it errors or infinitely suspends\n        var PENDING = 0;\n        var COMPLETED = 1;\n        var FLUSHED = 2;\n        var ABORTED = 3;\n        var ERRORED = 4;\n        var POSTPONED = 5;\n        var OPEN = 0;\n        var CLOSING = 1;\n        var CLOSED = 2; // This is a default heuristic for how to split up the HTML content into progressive\n        // loading. Our goal is to be able to display additional new content about every 500ms.\n        // Faster than that is unnecessary and should be throttled on the client. It also\n        // adds unnecessary overhead to do more splits. We don't know if it's a higher or lower\n        // end device but higher end suffer less from the overhead than lower end does from\n        // not getting small enough pieces. We error on the side of low end.\n        // We base this on low end 3G speeds which is about 500kbits per second. We assume\n        // that there can be a reasonable drop off from max bandwidth which leaves you with\n        // as little as 80%. We can receive half of that each 500ms - at best. In practice,\n        // a little bandwidth is lost to processing and contention - e.g. CSS and images that\n        // are downloaded along with the main content. So we estimate about half of that to be\n        // the lower end throughput. In other words, we expect that you can at least show\n        // about 12.5kb of content per 500ms. Not counting starting latency for the first\n        // paint.\n        // 500 * 1024 / 8 * .8 * 0.5 / 2\n        var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;\n        function defaultErrorHandler(error) {\n            console[\"error\"](error); // Don't transform to our wrapper\n            return null;\n        }\n        function noop() {}\n        function createRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {\n            prepareHostDispatcher();\n            var pingedTasks = [];\n            var abortSet = new Set();\n            var request = {\n                destination: null,\n                flushScheduled: false,\n                resumableState: resumableState,\n                renderState: renderState,\n                rootFormatContext: rootFormatContext,\n                progressiveChunkSize: progressiveChunkSize === undefined ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,\n                status: OPEN,\n                fatalError: null,\n                nextSegmentId: 0,\n                allPendingTasks: 0,\n                pendingRootTasks: 0,\n                completedRootSegment: null,\n                abortableTasks: abortSet,\n                pingedTasks: pingedTasks,\n                clientRenderedBoundaries: [],\n                completedBoundaries: [],\n                partialBoundaries: [],\n                trackedPostpones: null,\n                onError: onError === undefined ? defaultErrorHandler : onError,\n                onPostpone: onPostpone === undefined ? noop : onPostpone,\n                onAllReady: onAllReady === undefined ? noop : onAllReady,\n                onShellReady: onShellReady === undefined ? noop : onShellReady,\n                onShellError: onShellError === undefined ? noop : onShellError,\n                onFatalError: onFatalError === undefined ? noop : onFatalError,\n                formState: formState === undefined ? null : formState\n            }; // This segment represents the root fallback.\n            var rootSegment = createPendingSegment(request, 0, null, rootFormatContext, false, false); // There is no parent so conceptually, we're unblocked to flush this segment.\n            rootSegment.parentFlushed = true;\n            var rootTask = createRenderTask(request, null, children, -1, null, rootSegment, abortSet, null, rootFormatContext, emptyContextObject, rootContextSnapshot, emptyTreeContext, null);\n            pingedTasks.push(rootTask);\n            return request;\n        }\n        var currentRequest = null;\n        function resolveRequest() {\n            if (currentRequest) return currentRequest;\n            return null;\n        }\n        function pingTask(request, task) {\n            var pingedTasks = request.pingedTasks;\n            pingedTasks.push(task);\n            if (request.pingedTasks.length === 1) {\n                request.flushScheduled = request.destination !== null;\n                scheduleWork(function() {\n                    return performWork(request);\n                });\n            }\n        }\n        function createSuspenseBoundary(request, fallbackAbortableTasks) {\n            return {\n                status: PENDING,\n                rootSegmentID: -1,\n                parentFlushed: false,\n                pendingTasks: 0,\n                completedSegments: [],\n                byteSize: 0,\n                fallbackAbortableTasks: fallbackAbortableTasks,\n                errorDigest: null,\n                resources: createBoundaryResources(),\n                trackedContentKeyPath: null,\n                trackedFallbackNode: null\n            };\n        }\n        function createRenderTask(request, thenableState, node, childIndex, blockedBoundary, blockedSegment, abortSet, keyPath, formatContext, legacyContext, context, treeContext, componentStack) {\n            request.allPendingTasks++;\n            if (blockedBoundary === null) {\n                request.pendingRootTasks++;\n            } else {\n                blockedBoundary.pendingTasks++;\n            }\n            var task = {\n                replay: null,\n                node: node,\n                childIndex: childIndex,\n                ping: function() {\n                    return pingTask(request, task);\n                },\n                blockedBoundary: blockedBoundary,\n                blockedSegment: blockedSegment,\n                abortSet: abortSet,\n                keyPath: keyPath,\n                formatContext: formatContext,\n                legacyContext: legacyContext,\n                context: context,\n                treeContext: treeContext,\n                componentStack: componentStack,\n                thenableState: thenableState\n            };\n            abortSet.add(task);\n            return task;\n        }\n        function createReplayTask(request, thenableState, replay, node, childIndex, blockedBoundary, abortSet, keyPath, formatContext, legacyContext, context, treeContext, componentStack) {\n            request.allPendingTasks++;\n            if (blockedBoundary === null) {\n                request.pendingRootTasks++;\n            } else {\n                blockedBoundary.pendingTasks++;\n            }\n            replay.pendingTasks++;\n            var task = {\n                replay: replay,\n                node: node,\n                childIndex: childIndex,\n                ping: function() {\n                    return pingTask(request, task);\n                },\n                blockedBoundary: blockedBoundary,\n                blockedSegment: null,\n                abortSet: abortSet,\n                keyPath: keyPath,\n                formatContext: formatContext,\n                legacyContext: legacyContext,\n                context: context,\n                treeContext: treeContext,\n                componentStack: componentStack,\n                thenableState: thenableState\n            };\n            abortSet.add(task);\n            return task;\n        }\n        function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {\n            return {\n                status: PENDING,\n                id: -1,\n                // lazily assigned later\n                index: index,\n                parentFlushed: false,\n                chunks: [],\n                children: [],\n                parentFormatContext: parentFormatContext,\n                boundary: boundary,\n                lastPushedText: lastPushedText,\n                textEmbedded: textEmbedded\n            };\n        } // DEV-only global reference to the currently executing task\n        var currentTaskInDEV = null;\n        function getCurrentStackInDEV() {\n            {\n                if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {\n                    return \"\";\n                }\n                return getStackByComponentStackNode(currentTaskInDEV.componentStack);\n            }\n        }\n        function getStackFromNode(stackNode) {\n            return getStackByComponentStackNode(stackNode);\n        }\n        function createBuiltInComponentStack(task, type) {\n            return {\n                tag: 0,\n                parent: task.componentStack,\n                type: type\n            };\n        }\n        function createFunctionComponentStack(task, type) {\n            return {\n                tag: 1,\n                parent: task.componentStack,\n                type: type\n            };\n        }\n        function createClassComponentStack(task, type) {\n            return {\n                tag: 2,\n                parent: task.componentStack,\n                type: type\n            };\n        } // While we track component stacks in prod all the time we only produce a reified stack in dev and\n        // during prerender in Prod. The reason for this is that the stack is useful for prerender where the timeliness\n        // of the request is less critical than the observability of the execution. For renders and resumes however we\n        // prioritize speed of the request.\n        function getThrownInfo(request, node) {\n            if (node && true) {\n                return {\n                    componentStack: getStackFromNode(node)\n                };\n            } else {\n                return {};\n            }\n        }\n        function encodeErrorForBoundary(boundary, digest, error, thrownInfo) {\n            boundary.errorDigest = digest;\n            {\n                // In dev we additionally encode the error message and component stack on the boundary\n                var errorMessage;\n                if (typeof error === \"string\") {\n                    errorMessage = error;\n                } else if (error && typeof error.message === \"string\") {\n                    errorMessage = error.message;\n                } else {\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    errorMessage = String(error);\n                }\n                boundary.errorMessage = errorMessage;\n                boundary.errorComponentStack = thrownInfo.componentStack;\n            }\n        }\n        function logRecoverableError(request, error$1, errorInfo) {\n            // If this callback errors, we intentionally let that error bubble up to become a fatal error\n            // so that someone fixes the error reporting instead of hiding it.\n            var errorDigest = request.onError(error$1, errorInfo);\n            if (errorDigest != null && typeof errorDigest !== \"string\") {\n                // We used to throw here but since this gets called from a variety of unprotected places it\n                // seems better to just warn and discard the returned value.\n                {\n                    error('onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"%s\" instead', typeof errorDigest);\n                }\n                return;\n            }\n            return errorDigest;\n        }\n        function fatalError(request, error) {\n            // This is called outside error handling code such as if the root errors outside\n            // a suspense boundary or if the root suspense boundary's fallback errors.\n            // It's also called if React itself or its host configs errors.\n            var onShellError = request.onShellError;\n            onShellError(error);\n            var onFatalError = request.onFatalError;\n            onFatalError(error);\n            if (request.destination !== null) {\n                request.status = CLOSED;\n                closeWithError(request.destination, error);\n            } else {\n                request.status = CLOSING;\n                request.fatalError = error;\n            }\n        }\n        function renderSuspenseBoundary(request, someTask, keyPath, props) {\n            if (someTask.replay !== null) {\n                // If we're replaying through this pass, it means we're replaying through\n                // an already completed Suspense boundary. It's too late to do anything about it\n                // so we can just render through it.\n                var _prevKeyPath = someTask.keyPath;\n                someTask.keyPath = keyPath;\n                var _content = props.children;\n                try {\n                    renderNode(request, someTask, _content, -1);\n                } finally{\n                    someTask.keyPath = _prevKeyPath;\n                }\n                return;\n            } // $FlowFixMe: Refined.\n            var task = someTask;\n            var previousComponentStack = task.componentStack; // If we end up creating the fallback task we need it to have the correct stack which is\n            // the stack for the boundary itself. We stash it here so we can use it if needed later\n            var suspenseComponentStack = task.componentStack = createBuiltInComponentStack(task, \"Suspense\");\n            var prevKeyPath = task.keyPath;\n            var parentBoundary = task.blockedBoundary;\n            var parentSegment = task.blockedSegment; // Each time we enter a suspense boundary, we split out into a new segment for\n            // the fallback so that we can later replace that segment with the content.\n            // This also lets us split out the main content even if it doesn't suspend,\n            // in case it ends up generating a large subtree of content.\n            var fallback = props.fallback;\n            var content = props.children;\n            var fallbackAbortSet = new Set();\n            var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);\n            if (request.trackedPostpones !== null) {\n                newBoundary.trackedContentKeyPath = keyPath;\n            }\n            var insertionIndex = parentSegment.chunks.length; // The children of the boundary segment is actually the fallback.\n            var boundarySegment = createPendingSegment(request, insertionIndex, newBoundary, task.formatContext, false, false);\n            parentSegment.children.push(boundarySegment); // The parentSegment has a child Segment at this index so we reset the lastPushedText marker on the parent\n            parentSegment.lastPushedText = false; // This segment is the actual child content. We can start rendering that immediately.\n            var contentRootSegment = createPendingSegment(request, 0, null, task.formatContext, false, false); // We mark the root segment as having its parent flushed. It's not really flushed but there is\n            // no parent segment so there's nothing to wait on.\n            contentRootSegment.parentFlushed = true; // Currently this is running synchronously. We could instead schedule this to pingedTasks.\n            // I suspect that there might be some efficiency benefits from not creating the suspended task\n            // and instead just using the stack if possible.\n            // TODO: Call this directly instead of messing with saving and restoring contexts.\n            // We can reuse the current context and task to render the content immediately without\n            // context switching. We just need to temporarily switch which boundary and which segment\n            // we're writing to. If something suspends, it'll spawn new suspended task with that context.\n            task.blockedBoundary = newBoundary;\n            task.blockedSegment = contentRootSegment;\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, newBoundary.resources);\n            }\n            task.keyPath = keyPath;\n            try {\n                // We use the safe form because we don't handle suspending here. Only error handling.\n                renderNode(request, task, content, -1);\n                pushSegmentFinale(contentRootSegment.chunks, request.renderState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);\n                contentRootSegment.status = COMPLETED;\n                queueCompletedSegment(newBoundary, contentRootSegment);\n                if (newBoundary.pendingTasks === 0 && newBoundary.status === PENDING) {\n                    // This must have been the last segment we were waiting on. This boundary is now complete.\n                    // Therefore we won't need the fallback. We early return so that we don't have to create\n                    // the fallback.\n                    newBoundary.status = COMPLETED; // We are returning early so we need to restore the\n                    task.componentStack = previousComponentStack;\n                    return;\n                }\n            } catch (error) {\n                contentRootSegment.status = ERRORED;\n                newBoundary.status = CLIENT_RENDERED;\n                var thrownInfo = getThrownInfo(request, task.componentStack);\n                var errorDigest;\n                {\n                    errorDigest = logRecoverableError(request, error, thrownInfo);\n                }\n                encodeErrorForBoundary(newBoundary, errorDigest, error, thrownInfo);\n                untrackBoundary(request, newBoundary); // We don't need to decrement any task numbers because we didn't spawn any new task.\n            // We don't need to schedule any task because we know the parent has written yet.\n            // We do need to fallthrough to create the fallback though.\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, parentBoundary ? parentBoundary.resources : null);\n                }\n                task.blockedBoundary = parentBoundary;\n                task.blockedSegment = parentSegment;\n                task.keyPath = prevKeyPath;\n                task.componentStack = previousComponentStack;\n            }\n            var fallbackKeyPath = [\n                keyPath[0],\n                \"Suspense Fallback\",\n                keyPath[2]\n            ];\n            var trackedPostpones = request.trackedPostpones;\n            if (trackedPostpones !== null) {\n                // We create a detached replay node to track any postpones inside the fallback.\n                var fallbackReplayNode = [\n                    fallbackKeyPath[1],\n                    fallbackKeyPath[2],\n                    [],\n                    null\n                ];\n                trackedPostpones.workingMap.set(fallbackKeyPath, fallbackReplayNode);\n                if (newBoundary.status === POSTPONED) {\n                    // This must exist now.\n                    var boundaryReplayNode = trackedPostpones.workingMap.get(keyPath);\n                    boundaryReplayNode[4] = fallbackReplayNode;\n                } else {\n                    // We might not inject it into the postponed tree, unless the content actually\n                    // postpones too. We need to keep track of it until that happpens.\n                    newBoundary.trackedFallbackNode = fallbackReplayNode;\n                }\n            } // We create suspended task for the fallback because we don't want to actually work\n            // on it yet in case we finish the main content, so we queue for later.\n            var suspendedFallbackTask = createRenderTask(request, null, fallback, -1, parentBoundary, boundarySegment, fallbackAbortSet, fallbackKeyPath, task.formatContext, task.legacyContext, task.context, task.treeContext, // of the parent boundary from a component standpoint the fallback is a child of the Suspense boundary itself\n            suspenseComponentStack); // TODO: This should be queued at a separate lower priority queue so that we only work\n            // on preparing fallbacks if we don't have any more main content to task on.\n            request.pingedTasks.push(suspendedFallbackTask);\n        }\n        function replaySuspenseBoundary(request, task, keyPath, props, id, childNodes, childSlots, fallbackNodes, fallbackSlots) {\n            var previousComponentStack = task.componentStack; // If we end up creating the fallback task we need it to have the correct stack which is\n            // the stack for the boundary itself. We stash it here so we can use it if needed later\n            var suspenseComponentStack = task.componentStack = createBuiltInComponentStack(task, \"Suspense\");\n            var prevKeyPath = task.keyPath;\n            var previousReplaySet = task.replay;\n            var parentBoundary = task.blockedBoundary;\n            var content = props.children;\n            var fallback = props.fallback;\n            var fallbackAbortSet = new Set();\n            var resumedBoundary = createSuspenseBoundary(request, fallbackAbortSet);\n            resumedBoundary.parentFlushed = true; // We restore the same id of this boundary as was used during prerender.\n            resumedBoundary.rootSegmentID = id; // We can reuse the current context and task to render the content immediately without\n            // context switching. We just need to temporarily switch which boundary and replay node\n            // we're writing to. If something suspends, it'll spawn new suspended task with that context.\n            task.blockedBoundary = resumedBoundary;\n            task.replay = {\n                nodes: childNodes,\n                slots: childSlots,\n                pendingTasks: 1\n            };\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, resumedBoundary.resources);\n            }\n            try {\n                // We use the safe form because we don't handle suspending here. Only error handling.\n                renderNode(request, task, content, -1);\n                if (task.replay.pendingTasks === 1 && task.replay.nodes.length > 0) {\n                    throw new Error(\"Couldn't find all resumable slots by key/index during replaying. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                }\n                task.replay.pendingTasks--;\n                if (resumedBoundary.pendingTasks === 0 && resumedBoundary.status === PENDING) {\n                    // This must have been the last segment we were waiting on. This boundary is now complete.\n                    // Therefore we won't need the fallback. We early return so that we don't have to create\n                    // the fallback.\n                    resumedBoundary.status = COMPLETED;\n                    request.completedBoundaries.push(resumedBoundary); // We restore the parent componentStack. Semantically this is the same as\n                    // popComponentStack(task) but we do this instead because it should be slightly\n                    // faster\n                    return;\n                }\n            } catch (error) {\n                resumedBoundary.status = CLIENT_RENDERED;\n                var thrownInfo = getThrownInfo(request, task.componentStack);\n                var errorDigest;\n                {\n                    errorDigest = logRecoverableError(request, error, thrownInfo);\n                }\n                encodeErrorForBoundary(resumedBoundary, errorDigest, error, thrownInfo);\n                task.replay.pendingTasks--; // The parent already flushed in the prerender so we need to schedule this to be emitted.\n                request.clientRenderedBoundaries.push(resumedBoundary); // We don't need to decrement any task numbers because we didn't spawn any new task.\n            // We don't need to schedule any task because we know the parent has written yet.\n            // We do need to fallthrough to create the fallback though.\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, parentBoundary ? parentBoundary.resources : null);\n                }\n                task.blockedBoundary = parentBoundary;\n                task.replay = previousReplaySet;\n                task.keyPath = prevKeyPath;\n                task.componentStack = previousComponentStack;\n            }\n            var fallbackKeyPath = [\n                keyPath[0],\n                \"Suspense Fallback\",\n                keyPath[2]\n            ]; // We create suspended task for the fallback because we don't want to actually work\n            // on it yet in case we finish the main content, so we queue for later.\n            var fallbackReplay = {\n                nodes: fallbackNodes,\n                slots: fallbackSlots,\n                pendingTasks: 0\n            };\n            var suspendedFallbackTask = createReplayTask(request, null, fallbackReplay, fallback, -1, parentBoundary, fallbackAbortSet, fallbackKeyPath, task.formatContext, task.legacyContext, task.context, task.treeContext, // of the parent boundary from a component standpoint the fallback is a child of the Suspense boundary itself\n            suspenseComponentStack); // TODO: This should be queued at a separate lower priority queue so that we only work\n            // on preparing fallbacks if we don't have any more main content to task on.\n            request.pingedTasks.push(suspendedFallbackTask);\n        }\n        function renderHostElement(request, task, keyPath, type, props) {\n            var previousComponentStack = task.componentStack;\n            task.componentStack = createBuiltInComponentStack(task, type);\n            var segment = task.blockedSegment;\n            if (segment === null) {\n                // Replay\n                var children = props.children; // TODO: Make this a Config for replaying.\n                var prevContext = task.formatContext;\n                var prevKeyPath = task.keyPath;\n                task.formatContext = getChildFormatContext(prevContext, type, props);\n                task.keyPath = keyPath; // We use the non-destructive form because if something suspends, we still\n                // need to pop back up and finish this subtree of HTML.\n                renderNode(request, task, children, -1); // We expect that errors will fatal the whole task and that we don't need\n                // the correct context. Therefore this is not in a finally.\n                task.formatContext = prevContext;\n                task.keyPath = prevKeyPath;\n            } else {\n                // Render\n                var _children = pushStartInstance(segment.chunks, type, props, request.resumableState, request.renderState, task.formatContext, segment.lastPushedText);\n                segment.lastPushedText = false;\n                var _prevContext = task.formatContext;\n                var _prevKeyPath2 = task.keyPath;\n                task.formatContext = getChildFormatContext(_prevContext, type, props);\n                task.keyPath = keyPath; // We use the non-destructive form because if something suspends, we still\n                // need to pop back up and finish this subtree of HTML.\n                renderNode(request, task, _children, -1); // We expect that errors will fatal the whole task and that we don't need\n                // the correct context. Therefore this is not in a finally.\n                task.formatContext = _prevContext;\n                task.keyPath = _prevKeyPath2;\n                pushEndInstance(segment.chunks, type, props, request.resumableState, _prevContext);\n                segment.lastPushedText = false;\n            }\n            task.componentStack = previousComponentStack;\n        }\n        function shouldConstruct(Component) {\n            return Component.prototype && Component.prototype.isReactComponent;\n        }\n        function renderWithHooks(request, task, keyPath, prevThenableState, Component, props, secondArg) {\n            var componentIdentity = {};\n            prepareToUseHooks(request, task, keyPath, componentIdentity, prevThenableState);\n            var result = Component(props, secondArg);\n            return finishHooks(Component, props, result, secondArg);\n        }\n        function finishClassComponent(request, task, keyPath, instance, Component, props) {\n            var nextChildren = instance.render();\n            {\n                if (instance.props !== props) {\n                    if (!didWarnAboutReassigningProps) {\n                        error(\"It looks like %s is reassigning its own `this.props` while rendering. \" + \"This is not supported and can lead to confusing bugs.\", getComponentNameFromType(Component) || \"a component\");\n                    }\n                    didWarnAboutReassigningProps = true;\n                }\n            }\n            {\n                var childContextTypes = Component.childContextTypes;\n                if (childContextTypes !== null && childContextTypes !== undefined) {\n                    var previousContext = task.legacyContext;\n                    var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);\n                    task.legacyContext = mergedContext;\n                    renderNodeDestructive(request, task, null, nextChildren, -1);\n                    task.legacyContext = previousContext;\n                    return;\n                }\n            }\n            var prevKeyPath = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, null, nextChildren, -1);\n            task.keyPath = prevKeyPath;\n        }\n        function renderClassComponent(request, task, keyPath, Component, props) {\n            var previousComponentStack = task.componentStack;\n            task.componentStack = createClassComponentStack(task, Component);\n            var maskedContext = getMaskedContext(Component, task.legacyContext);\n            var instance = constructClassInstance(Component, props, maskedContext);\n            mountClassInstance(instance, Component, props, maskedContext);\n            finishClassComponent(request, task, keyPath, instance, Component, props);\n            task.componentStack = previousComponentStack;\n        }\n        var didWarnAboutBadClass = {};\n        var didWarnAboutModulePatternComponent = {};\n        var didWarnAboutContextTypeOnFunctionComponent = {};\n        var didWarnAboutGetDerivedStateOnFunctionComponent = {};\n        var didWarnAboutReassigningProps = false;\n        var didWarnAboutDefaultPropsOnFunctionComponent = {};\n        var didWarnAboutGenerators = false;\n        var didWarnAboutMaps = false;\n        var hasWarnedAboutUsingContextAsConsumer = false; // This would typically be a function component but we still support module pattern\n        // components for some reason.\n        function renderIndeterminateComponent(request, task, keyPath, prevThenableState, Component, props) {\n            var legacyContext;\n            {\n                legacyContext = getMaskedContext(Component, task.legacyContext);\n            }\n            var previousComponentStack = task.componentStack;\n            task.componentStack = createFunctionComponentStack(task, Component);\n            {\n                if (Component.prototype && typeof Component.prototype.render === \"function\") {\n                    var componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutBadClass[componentName]) {\n                        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + \"This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName);\n                        didWarnAboutBadClass[componentName] = true;\n                    }\n                }\n            }\n            var value = renderWithHooks(request, task, keyPath, prevThenableState, Component, props, legacyContext);\n            var hasId = checkDidRenderIdHook();\n            var formStateCount = getFormStateCount();\n            var formStateMatchingIndex = getFormStateMatchingIndex();\n            {\n                // Support for module components is deprecated and is removed behind a flag.\n                // Whether or not it would crash later, we want to show a good message in DEV first.\n                if (typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                    var _componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName, _componentName, _componentName);\n                        didWarnAboutModulePatternComponent[_componentName] = true;\n                    }\n                }\n            }\n            if (// Eventually we'll delete this branch altogether.\n            typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                {\n                    var _componentName2 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName2]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName2, _componentName2, _componentName2);\n                        didWarnAboutModulePatternComponent[_componentName2] = true;\n                    }\n                }\n                mountClassInstance(value, Component, props, legacyContext);\n                finishClassComponent(request, task, keyPath, value, Component, props);\n            } else {\n                {\n                    validateFunctionComponentInDev(Component);\n                }\n                finishFunctionComponent(request, task, keyPath, value, hasId, formStateCount, formStateMatchingIndex);\n            }\n            task.componentStack = previousComponentStack;\n        }\n        function finishFunctionComponent(request, task, keyPath, children, hasId, formStateCount, formStateMatchingIndex) {\n            var didEmitFormStateMarkers = false;\n            if (formStateCount !== 0 && request.formState !== null) {\n                // For each useFormState hook, emit a marker that indicates whether we\n                // rendered using the form state passed at the root. We only emit these\n                // markers if form state is passed at the root.\n                var segment = task.blockedSegment;\n                if (segment === null) ;\n                else {\n                    didEmitFormStateMarkers = true;\n                    var target = segment.chunks;\n                    for(var i = 0; i < formStateCount; i++){\n                        if (i === formStateMatchingIndex) {\n                            pushFormStateMarkerIsMatching(target);\n                        } else {\n                            pushFormStateMarkerIsNotMatching(target);\n                        }\n                    }\n                }\n            }\n            var prevKeyPath = task.keyPath;\n            task.keyPath = keyPath;\n            if (hasId) {\n                // This component materialized an id. We treat this as its own level, with\n                // a single \"child\" slot.\n                var prevTreeContext = task.treeContext;\n                var totalChildren = 1;\n                var index = 0; // Modify the id context. Because we'll need to reset this if something\n                // suspends or errors, we'll use the non-destructive render path.\n                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);\n                renderNode(request, task, children, -1); // Like the other contexts, this does not need to be in a finally block\n                // because renderNode takes care of unwinding the stack.\n                task.treeContext = prevTreeContext;\n            } else if (didEmitFormStateMarkers) {\n                // If there were formState hooks, we must use the non-destructive path\n                // because this component is not a pure indirection; we emitted markers\n                // to the stream.\n                renderNode(request, task, children, -1);\n            } else {\n                // We're now successfully past this task, and we haven't modified the\n                // context stack. We don't have to pop back to the previous task every\n                // again, so we can use the destructive recursive form.\n                renderNodeDestructive(request, task, null, children, -1);\n            }\n            task.keyPath = prevKeyPath;\n        }\n        function validateFunctionComponentInDev(Component) {\n            {\n                if (Component) {\n                    if (Component.childContextTypes) {\n                        error(\"%s(...): childContextTypes cannot be defined on a function component.\", Component.displayName || Component.name || \"Component\");\n                    }\n                }\n                if (Component.defaultProps !== undefined) {\n                    var componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n                        error(\"%s: Support for defaultProps will be removed from function components \" + \"in a future major release. Use JavaScript default parameters instead.\", componentName);\n                        didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n                    }\n                }\n                if (typeof Component.getDerivedStateFromProps === \"function\") {\n                    var _componentName3 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\n                        error(\"%s: Function components do not support getDerivedStateFromProps.\", _componentName3);\n                        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\n                    }\n                }\n                if (typeof Component.contextType === \"object\" && Component.contextType !== null) {\n                    var _componentName4 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\n                        error(\"%s: Function components do not support contextType.\", _componentName4);\n                        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\n                    }\n                }\n            }\n        }\n        function resolveDefaultProps(Component, baseProps) {\n            if (Component && Component.defaultProps) {\n                // Resolve default props. Taken from ReactElement\n                var props = assign({}, baseProps);\n                var defaultProps = Component.defaultProps;\n                for(var propName in defaultProps){\n                    if (props[propName] === undefined) {\n                        props[propName] = defaultProps[propName];\n                    }\n                }\n                return props;\n            }\n            return baseProps;\n        }\n        function renderForwardRef(request, task, keyPath, prevThenableState, type, props, ref) {\n            var previousComponentStack = task.componentStack;\n            task.componentStack = createFunctionComponentStack(task, type.render);\n            var children = renderWithHooks(request, task, keyPath, prevThenableState, type.render, props, ref);\n            var hasId = checkDidRenderIdHook();\n            var formStateCount = getFormStateCount();\n            var formStateMatchingIndex = getFormStateMatchingIndex();\n            finishFunctionComponent(request, task, keyPath, children, hasId, formStateCount, formStateMatchingIndex);\n            task.componentStack = previousComponentStack;\n        }\n        function renderMemo(request, task, keyPath, prevThenableState, type, props, ref) {\n            var innerType = type.type;\n            var resolvedProps = resolveDefaultProps(innerType, props);\n            renderElement(request, task, keyPath, prevThenableState, innerType, resolvedProps, ref);\n        }\n        function renderContextConsumer(request, task, keyPath, context, props) {\n            // The logic below for Context differs depending on PROD or DEV mode. In\n            // DEV mode, we create a separate object for Context.Consumer that acts\n            // like a proxy to Context. This proxy object adds unnecessary code in PROD\n            // so we use the old behaviour (Context.Consumer references Context) to\n            // reduce size and overhead. The separate object references context via\n            // a property called \"_context\", which also gives us the ability to check\n            // in DEV mode if this property exists or not and warn if it does not.\n            {\n                if (context._context === undefined) {\n                    // This may be because it's a Context (rather than a Consumer).\n                    // Or it may be because it's older React where they're the same thing.\n                    // We only want to warn if we're sure it's a new React.\n                    if (context !== context.Consumer) {\n                        if (!hasWarnedAboutUsingContextAsConsumer) {\n                            hasWarnedAboutUsingContextAsConsumer = true;\n                            error(\"Rendering <Context> directly is not supported and will be removed in \" + \"a future major release. Did you mean to render <Context.Consumer> instead?\");\n                        }\n                    }\n                } else {\n                    context = context._context;\n                }\n            }\n            var render = props.children;\n            {\n                if (typeof render !== \"function\") {\n                    error(\"A context consumer was rendered with multiple children, or a child \" + \"that isn't a function. A context consumer expects a single child \" + \"that is a function. If you did pass a function, make sure there \" + \"is no trailing or leading whitespace around it.\");\n                }\n            }\n            var newValue = readContext$1(context);\n            var newChildren = render(newValue);\n            var prevKeyPath = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, null, newChildren, -1);\n            task.keyPath = prevKeyPath;\n        }\n        function renderContextProvider(request, task, keyPath, type, props) {\n            var context = type._context;\n            var value = props.value;\n            var children = props.children;\n            var prevSnapshot;\n            {\n                prevSnapshot = task.context;\n            }\n            var prevKeyPath = task.keyPath;\n            task.context = pushProvider(context, value);\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, null, children, -1);\n            task.context = popProvider(context);\n            task.keyPath = prevKeyPath;\n            {\n                if (prevSnapshot !== task.context) {\n                    error(\"Popping the context provider did not return back to the original snapshot. This is a bug in React.\");\n                }\n            }\n        }\n        function renderLazyComponent(request, task, keyPath, prevThenableState, lazyComponent, props, ref) {\n            var previousComponentStack = task.componentStack;\n            task.componentStack = createBuiltInComponentStack(task, \"Lazy\");\n            var payload = lazyComponent._payload;\n            var init = lazyComponent._init;\n            var Component = init(payload);\n            var resolvedProps = resolveDefaultProps(Component, props);\n            renderElement(request, task, keyPath, prevThenableState, Component, resolvedProps, ref);\n            task.componentStack = previousComponentStack;\n        }\n        function renderOffscreen(request, task, keyPath, props) {\n            var mode = props.mode;\n            if (mode === \"hidden\") ;\n            else {\n                // A visible Offscreen boundary is treated exactly like a fragment: a\n                // pure indirection.\n                var prevKeyPath = task.keyPath;\n                task.keyPath = keyPath;\n                renderNodeDestructive(request, task, null, props.children, -1);\n                task.keyPath = prevKeyPath;\n            }\n        }\n        function renderElement(request, task, keyPath, prevThenableState, type, props, ref) {\n            if (typeof type === \"function\") {\n                if (shouldConstruct(type)) {\n                    renderClassComponent(request, task, keyPath, type, props);\n                    return;\n                } else {\n                    renderIndeterminateComponent(request, task, keyPath, prevThenableState, type, props);\n                    return;\n                }\n            }\n            if (typeof type === \"string\") {\n                renderHostElement(request, task, keyPath, type, props);\n                return;\n            }\n            switch(type){\n                // LegacyHidden acts the same as a fragment. This only works because we\n                // currently assume that every instance of LegacyHidden is accompanied by a\n                // host component wrapper. In the hidden mode, the host component is given a\n                // `hidden` attribute, which ensures that the initial HTML is not visible.\n                // To support the use of LegacyHidden as a true fragment, without an extra\n                // DOM node, we would have to hide the initial HTML in some other way.\n                // TODO: Delete in LegacyHidden. It's an unstable API only used in the\n                // www build. As a migration step, we could add a special prop to Offscreen\n                // that simulates the old behavior (no hiding, no change to effects).\n                case REACT_LEGACY_HIDDEN_TYPE:\n                case REACT_DEBUG_TRACING_MODE_TYPE:\n                case REACT_STRICT_MODE_TYPE:\n                case REACT_PROFILER_TYPE:\n                case REACT_FRAGMENT_TYPE:\n                    {\n                        var prevKeyPath = task.keyPath;\n                        task.keyPath = keyPath;\n                        renderNodeDestructive(request, task, null, props.children, -1);\n                        task.keyPath = prevKeyPath;\n                        return;\n                    }\n                case REACT_OFFSCREEN_TYPE:\n                    {\n                        renderOffscreen(request, task, keyPath, props);\n                        return;\n                    }\n                case REACT_SUSPENSE_LIST_TYPE:\n                    {\n                        var preiousComponentStack = task.componentStack;\n                        task.componentStack = createBuiltInComponentStack(task, \"SuspenseList\"); // TODO: SuspenseList should control the boundaries.\n                        var _prevKeyPath3 = task.keyPath;\n                        task.keyPath = keyPath;\n                        renderNodeDestructive(request, task, null, props.children, -1);\n                        task.keyPath = _prevKeyPath3;\n                        task.componentStack = preiousComponentStack;\n                        return;\n                    }\n                case REACT_SCOPE_TYPE:\n                    {\n                        throw new Error(\"ReactDOMServer does not yet support scope components.\");\n                    }\n                case REACT_SUSPENSE_TYPE:\n                    {\n                        {\n                            renderSuspenseBoundary(request, task, keyPath, props);\n                        }\n                        return;\n                    }\n            }\n            if (typeof type === \"object\" && type !== null) {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        {\n                            renderForwardRef(request, task, keyPath, prevThenableState, type, props, ref);\n                            return;\n                        }\n                    case REACT_MEMO_TYPE:\n                        {\n                            renderMemo(request, task, keyPath, prevThenableState, type, props, ref);\n                            return;\n                        }\n                    case REACT_PROVIDER_TYPE:\n                        {\n                            renderContextProvider(request, task, keyPath, type, props);\n                            return;\n                        }\n                    case REACT_CONTEXT_TYPE:\n                        {\n                            renderContextConsumer(request, task, keyPath, type, props);\n                            return;\n                        }\n                    case REACT_LAZY_TYPE:\n                        {\n                            renderLazyComponent(request, task, keyPath, prevThenableState, type, props);\n                            return;\n                        }\n                }\n            }\n            var info = \"\";\n            {\n                if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                    info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and \" + \"named imports.\";\n                }\n            }\n            throw new Error(\"Element type is invalid: expected a string (for built-in \" + \"components) or a class/function (for composite components) \" + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n        }\n        function resumeNode(request, task, segmentId, node, childIndex) {\n            var prevReplay = task.replay;\n            var blockedBoundary = task.blockedBoundary;\n            var resumedSegment = createPendingSegment(request, 0, null, task.formatContext, false, false);\n            resumedSegment.id = segmentId;\n            resumedSegment.parentFlushed = true;\n            try {\n                // Convert the current ReplayTask to a RenderTask.\n                var renderTask = task;\n                renderTask.replay = null;\n                renderTask.blockedSegment = resumedSegment;\n                renderNode(request, task, node, childIndex);\n                resumedSegment.status = COMPLETED;\n                if (blockedBoundary === null) {\n                    request.completedRootSegment = resumedSegment;\n                } else {\n                    queueCompletedSegment(blockedBoundary, resumedSegment);\n                    if (blockedBoundary.parentFlushed) {\n                        request.partialBoundaries.push(blockedBoundary);\n                    }\n                }\n            } finally{\n                // Restore to a ReplayTask.\n                task.replay = prevReplay;\n                task.blockedSegment = null;\n            }\n        }\n        function replayElement(request, task, keyPath, prevThenableState, name, keyOrIndex, childIndex, type, props, ref, replay) {\n            // We're replaying. Find the path to follow.\n            var replayNodes = replay.nodes;\n            for(var i = 0; i < replayNodes.length; i++){\n                // Flow doesn't support refinement on tuples so we do it manually here.\n                var node = replayNodes[i];\n                if (keyOrIndex !== node[1]) {\n                    continue;\n                }\n                if (node.length === 4) {\n                    // Matched a replayable path.\n                    // Let's double check that the component name matches as a precaution.\n                    if (name !== null && name !== node[0]) {\n                        throw new Error(\"Expected the resume to render <\" + node[0] + \"> in this slot but instead it rendered <\" + name + \">. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                    }\n                    var childNodes = node[2];\n                    var childSlots = node[3];\n                    var currentNode = task.node;\n                    task.replay = {\n                        nodes: childNodes,\n                        slots: childSlots,\n                        pendingTasks: 1\n                    };\n                    try {\n                        renderElement(request, task, keyPath, prevThenableState, type, props, ref);\n                        if (task.replay.pendingTasks === 1 && task.replay.nodes.length > 0 // TODO check remaining slots\n                        ) {\n                            throw new Error(\"Couldn't find all resumable slots by key/index during replaying. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                        }\n                        task.replay.pendingTasks--;\n                    } catch (x) {\n                        if (typeof x === \"object\" && x !== null && (x === SuspenseException || typeof x.then === \"function\")) {\n                            // Suspend\n                            if (task.node === currentNode) {\n                                // This same element suspended so we need to pop the replay we just added.\n                                task.replay = replay;\n                            }\n                            throw x;\n                        }\n                        task.replay.pendingTasks--; // Unlike regular render, we don't terminate the siblings if we error\n                        // during a replay. That's because this component didn't actually error\n                        // in the original prerender. What's unable to complete is the child\n                        // replay nodes which might be Suspense boundaries which are able to\n                        // absorb the error and we can still continue with siblings.\n                        var thrownInfo = getThrownInfo(request, task.componentStack);\n                        erroredReplay(request, task.blockedBoundary, x, thrownInfo, childNodes, childSlots);\n                    }\n                    task.replay = replay;\n                } else {\n                    // Let's double check that the component type matches.\n                    if (type !== REACT_SUSPENSE_TYPE) {\n                        var expectedType = \"Suspense\";\n                        throw new Error(\"Expected the resume to render <\" + expectedType + \"> in this slot but instead it rendered <\" + (getComponentNameFromType(type) || \"Unknown\") + \">. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                    } // Matched a replayable path.\n                    replaySuspenseBoundary(request, task, keyPath, props, node[5], node[2], node[3], node[4] === null ? [] : node[4][2], node[4] === null ? null : node[4][3]);\n                } // We finished rendering this node, so now we can consume this\n                // slot. This must happen after in case we rerender this task.\n                replayNodes.splice(i, 1);\n                return;\n            } // We didn't find any matching nodes. We assume that this element was already\n        // rendered in the prelude and skip it.\n        } // $FlowFixMe[missing-local-annot]\n        function validateIterable(iterable, iteratorFn) {\n            {\n                // We don't support rendering Generators because it's a mutation.\n                // See https://github.com/facebook/react/issues/12995\n                if (typeof Symbol === \"function\" && iterable[Symbol.toStringTag] === \"Generator\") {\n                    if (!didWarnAboutGenerators) {\n                        error(\"Using Generators as children is unsupported and will likely yield \" + \"unexpected results because enumerating a generator mutates it. \" + \"You may convert it to an array with `Array.from()` or the \" + \"`[...spread]` operator before rendering. Keep in mind \" + \"you might need to polyfill these features for older browsers.\");\n                    }\n                    didWarnAboutGenerators = true;\n                } // Warn about using Maps as children\n                if (iterable.entries === iteratorFn) {\n                    if (!didWarnAboutMaps) {\n                        error(\"Using Maps as children is not supported. \" + \"Use an array of keyed ReactElements instead.\");\n                    }\n                    didWarnAboutMaps = true;\n                }\n            }\n        } // This function by it self renders a node and consumes the task by mutating it\n        // to update the current execution state.\n        function renderNodeDestructive(request, task, // always null, except when called by retryTask.\n        prevThenableState, node, childIndex) {\n            if (task.replay !== null && typeof task.replay.slots === \"number\") {\n                // TODO: Figure out a cheaper place than this hot path to do this check.\n                var resumeSegmentID = task.replay.slots;\n                resumeNode(request, task, resumeSegmentID, node, childIndex);\n                return;\n            } // Stash the node we're working on. We'll pick up from this task in case\n            // something suspends.\n            task.node = node;\n            task.childIndex = childIndex; // Handle object types\n            if (typeof node === \"object\" && node !== null) {\n                switch(node.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        {\n                            var element = node;\n                            var type = element.type;\n                            var key = element.key;\n                            var props = element.props;\n                            var ref = element.ref;\n                            var name = getComponentNameFromType(type);\n                            var keyOrIndex = key == null ? childIndex === -1 ? 0 : childIndex : key;\n                            var keyPath = [\n                                task.keyPath,\n                                name,\n                                keyOrIndex\n                            ];\n                            if (task.replay !== null) {\n                                replayElement(request, task, keyPath, prevThenableState, name, keyOrIndex, childIndex, type, props, ref, task.replay); // No matches found for this node. We assume it's already emitted in the\n                            // prelude and skip it during the replay.\n                            } else {\n                                // We're doing a plain render.\n                                renderElement(request, task, keyPath, prevThenableState, type, props, ref);\n                            }\n                            return;\n                        }\n                    case REACT_PORTAL_TYPE:\n                        throw new Error(\"Portals are not currently supported by the server renderer. \" + \"Render them conditionally so that they only appear on the client render.\");\n                    case REACT_LAZY_TYPE:\n                        {\n                            var previousComponentStack = task.componentStack;\n                            task.componentStack = createBuiltInComponentStack(task, \"Lazy\");\n                            var lazyNode = node;\n                            var payload = lazyNode._payload;\n                            var init = lazyNode._init;\n                            var resolvedNode = init(payload); // We restore the stack before rendering the resolved node because once the Lazy\n                            // has resolved any future errors\n                            task.componentStack = previousComponentStack; // Now we render the resolved node\n                            renderNodeDestructive(request, task, null, resolvedNode, childIndex);\n                            return;\n                        }\n                }\n                if (isArray(node)) {\n                    renderChildrenArray(request, task, node, childIndex);\n                    return;\n                }\n                var iteratorFn = getIteratorFn(node);\n                if (iteratorFn) {\n                    {\n                        validateIterable(node, iteratorFn);\n                    }\n                    var iterator = iteratorFn.call(node);\n                    if (iterator) {\n                        // We need to know how many total children are in this set, so that we\n                        // can allocate enough id slots to acommodate them. So we must exhaust\n                        // the iterator before we start recursively rendering the children.\n                        // TODO: This is not great but I think it's inherent to the id\n                        // generation algorithm.\n                        var step = iterator.next(); // If there are not entries, we need to push an empty so we start by checking that.\n                        if (!step.done) {\n                            var children = [];\n                            do {\n                                children.push(step.value);\n                                step = iterator.next();\n                            }while (!step.done);\n                            renderChildrenArray(request, task, children, childIndex);\n                            return;\n                        }\n                        return;\n                    }\n                } // Usables are a valid React node type. When React encounters a Usable in\n                // a child position, it unwraps it using the same algorithm as `use`. For\n                // example, for promises, React will throw an exception to unwind the\n                // stack, then replay the component once the promise resolves.\n                //\n                // A difference from `use` is that React will keep unwrapping the value\n                // until it reaches a non-Usable type.\n                //\n                // e.g. Usable<Usable<Usable<T>>> should resolve to T\n                var maybeUsable = node;\n                if (typeof maybeUsable.then === \"function\") {\n                    var thenable = maybeUsable;\n                    return renderNodeDestructive(request, task, null, unwrapThenable(thenable), childIndex);\n                }\n                if (maybeUsable.$$typeof === REACT_CONTEXT_TYPE || maybeUsable.$$typeof === REACT_SERVER_CONTEXT_TYPE) {\n                    var context = maybeUsable;\n                    return renderNodeDestructive(request, task, null, readContext$1(context), childIndex);\n                } // $FlowFixMe[method-unbinding]\n                var childString = Object.prototype.toString.call(node);\n                throw new Error(\"Objects are not valid as a React child (found: \" + (childString === \"[object Object]\" ? \"object with keys {\" + Object.keys(node).join(\", \") + \"}\" : childString) + \"). \" + \"If you meant to render a collection of children, use an array \" + \"instead.\");\n            }\n            if (typeof node === \"string\") {\n                var segment = task.blockedSegment;\n                if (segment === null) ;\n                else {\n                    segment.lastPushedText = pushTextInstance(segment.chunks, node, request.renderState, segment.lastPushedText);\n                }\n                return;\n            }\n            if (typeof node === \"number\") {\n                var _segment = task.blockedSegment;\n                if (_segment === null) ;\n                else {\n                    _segment.lastPushedText = pushTextInstance(_segment.chunks, \"\" + node, request.renderState, _segment.lastPushedText);\n                }\n                return;\n            }\n            {\n                if (typeof node === \"function\") {\n                    error(\"Functions are not valid as a React child. This may happen if \" + \"you return a Component instead of <Component /> from render. \" + \"Or maybe you meant to call this function rather than return it.\");\n                }\n            }\n        }\n        function replayFragment(request, task, children, childIndex) {\n            // If we're supposed follow this array, we'd expect to see a ReplayNode matching\n            // this fragment.\n            var replay = task.replay;\n            var replayNodes = replay.nodes;\n            for(var j = 0; j < replayNodes.length; j++){\n                var node = replayNodes[j];\n                if (node[1] !== childIndex) {\n                    continue;\n                } // Matched a replayable path.\n                var childNodes = node[2];\n                var childSlots = node[3];\n                task.replay = {\n                    nodes: childNodes,\n                    slots: childSlots,\n                    pendingTasks: 1\n                };\n                try {\n                    renderChildrenArray(request, task, children, -1);\n                    if (task.replay.pendingTasks === 1 && task.replay.nodes.length > 0) {\n                        throw new Error(\"Couldn't find all resumable slots by key/index during replaying. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                    }\n                    task.replay.pendingTasks--;\n                } catch (x) {\n                    if (typeof x === \"object\" && x !== null && (x === SuspenseException || typeof x.then === \"function\")) {\n                        // Suspend\n                        throw x;\n                    }\n                    task.replay.pendingTasks--; // Unlike regular render, we don't terminate the siblings if we error\n                    // during a replay. That's because this component didn't actually error\n                    // in the original prerender. What's unable to complete is the child\n                    // replay nodes which might be Suspense boundaries which are able to\n                    // absorb the error and we can still continue with siblings.\n                    // This is an error, stash the component stack if it is null.\n                    var thrownInfo = getThrownInfo(request, task.componentStack);\n                    erroredReplay(request, task.blockedBoundary, x, thrownInfo, childNodes, childSlots);\n                }\n                task.replay = replay; // We finished rendering this node, so now we can consume this\n                // slot. This must happen after in case we rerender this task.\n                replayNodes.splice(j, 1);\n                break;\n            }\n        }\n        function renderChildrenArray(request, task, children, childIndex) {\n            var prevKeyPath = task.keyPath;\n            if (childIndex !== -1) {\n                task.keyPath = [\n                    task.keyPath,\n                    \"Fragment\",\n                    childIndex\n                ];\n                if (task.replay !== null) {\n                    replayFragment(request, task, children, childIndex);\n                    task.keyPath = prevKeyPath;\n                    return;\n                }\n            }\n            var prevTreeContext = task.treeContext;\n            var totalChildren = children.length;\n            if (task.replay !== null) {\n                // Replay\n                // First we need to check if we have any resume slots at this level.\n                var resumeSlots = task.replay.slots;\n                if (resumeSlots !== null && typeof resumeSlots === \"object\") {\n                    for(var i = 0; i < totalChildren; i++){\n                        var node = children[i];\n                        task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i); // We need to use the non-destructive form so that we can safely pop back\n                        // up and render the sibling if something suspends.\n                        var resumeSegmentID = resumeSlots[i]; // TODO: If this errors we should still continue with the next sibling.\n                        if (typeof resumeSegmentID === \"number\") {\n                            resumeNode(request, task, resumeSegmentID, node, i); // We finished rendering this node, so now we can consume this\n                            // slot. This must happen after in case we rerender this task.\n                            delete resumeSlots[i];\n                        } else {\n                            renderNode(request, task, node, i);\n                        }\n                    }\n                    task.treeContext = prevTreeContext;\n                    task.keyPath = prevKeyPath;\n                    return;\n                }\n            }\n            for(var _i = 0; _i < totalChildren; _i++){\n                var _node = children[_i];\n                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, _i); // We need to use the non-destructive form so that we can safely pop back\n                // up and render the sibling if something suspends.\n                renderNode(request, task, _node, _i);\n            } // Because this context is always set right before rendering every child, we\n            // only need to reset it to the previous value at the very end.\n            task.treeContext = prevTreeContext;\n            task.keyPath = prevKeyPath;\n        }\n        // resume it.\n        function untrackBoundary(request, boundary) {\n            var trackedPostpones = request.trackedPostpones;\n            if (trackedPostpones === null) {\n                return;\n            }\n            var boundaryKeyPath = boundary.trackedContentKeyPath;\n            if (boundaryKeyPath === null) {\n                return;\n            }\n            var boundaryNode = trackedPostpones.workingMap.get(boundaryKeyPath);\n            if (boundaryNode === undefined) {\n                return;\n            } // Downgrade to plain ReplayNode since we won't replay through it.\n            // $FlowFixMe[cannot-write]: We intentionally downgrade this to the other tuple.\n            boundaryNode.length = 4; // Remove any resumable slots.\n            boundaryNode[2] = [];\n            boundaryNode[3] = null; // TODO: We should really just remove the boundary from all parent paths too so\n        // we don't replay the path to it.\n        }\n        function spawnNewSuspendedReplayTask(request, task, thenableState, x) {\n            var newTask = createReplayTask(request, thenableState, task.replay, task.node, task.childIndex, task.blockedBoundary, task.abortSet, task.keyPath, task.formatContext, task.legacyContext, task.context, task.treeContext, // which will add it back onto the stack.\n            task.componentStack !== null ? task.componentStack.parent : null);\n            var ping = newTask.ping;\n            x.then(ping, ping);\n        }\n        function spawnNewSuspendedRenderTask(request, task, thenableState, x) {\n            // Something suspended, we'll need to create a new segment and resolve it later.\n            var segment = task.blockedSegment;\n            var insertionIndex = segment.chunks.length;\n            var newSegment = createPendingSegment(request, insertionIndex, null, task.formatContext, segment.lastPushedText, true);\n            segment.children.push(newSegment); // Reset lastPushedText for current Segment since the new Segment \"consumed\" it\n            segment.lastPushedText = false;\n            var newTask = createRenderTask(request, thenableState, task.node, task.childIndex, task.blockedBoundary, newSegment, task.abortSet, task.keyPath, task.formatContext, task.legacyContext, task.context, task.treeContext, // which will add it back onto the stack.\n            task.componentStack !== null ? task.componentStack.parent : null);\n            var ping = newTask.ping;\n            x.then(ping, ping);\n        } // This is a non-destructive form of rendering a node. If it suspends it spawns\n        // a new task and restores the context of this task to what it was before.\n        function renderNode(request, task, node, childIndex) {\n            // Snapshot the current context in case something throws to interrupt the\n            // process.\n            var previousFormatContext = task.formatContext;\n            var previousLegacyContext = task.legacyContext;\n            var previousContext = task.context;\n            var previousKeyPath = task.keyPath;\n            var previousTreeContext = task.treeContext;\n            var previousComponentStack = task.componentStack;\n            var x; // Store how much we've pushed at this point so we can reset it in case something\n            // suspended partially through writing something.\n            var segment = task.blockedSegment;\n            if (segment === null) {\n                // Replay\n                try {\n                    return renderNodeDestructive(request, task, null, node, childIndex);\n                } catch (thrownValue) {\n                    resetHooksState();\n                    x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                    // value to be a thenable, because before `use` existed that was the\n                    // (unstable) API for suspending. This implementation detail can change\n                    // later, once we deprecate the old API in favor of `use`.\n                    getSuspendedThenable() : thrownValue;\n                    if (typeof x === \"object\" && x !== null) {\n                        // $FlowFixMe[method-unbinding]\n                        if (typeof x.then === \"function\") {\n                            var wakeable = x;\n                            var thenableState = getThenableStateAfterSuspending();\n                            spawnNewSuspendedReplayTask(request, task, thenableState, wakeable); // Restore the context. We assume that this will be restored by the inner\n                            // functions in case nothing throws so we don't use \"finally\" here.\n                            task.formatContext = previousFormatContext;\n                            task.legacyContext = previousLegacyContext;\n                            task.context = previousContext;\n                            task.keyPath = previousKeyPath;\n                            task.treeContext = previousTreeContext;\n                            task.componentStack = previousComponentStack; // Restore all active ReactContexts to what they were before.\n                            switchContext(previousContext);\n                            return;\n                        }\n                    } // TODO: Abort any undiscovered Suspense boundaries in the ReplayNode.\n                }\n            } else {\n                // Render\n                var childrenLength = segment.children.length;\n                var chunkLength = segment.chunks.length;\n                try {\n                    return renderNodeDestructive(request, task, null, node, childIndex);\n                } catch (thrownValue) {\n                    resetHooksState(); // Reset the write pointers to where we started.\n                    segment.children.length = childrenLength;\n                    segment.chunks.length = chunkLength;\n                    x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                    // value to be a thenable, because before `use` existed that was the\n                    // (unstable) API for suspending. This implementation detail can change\n                    // later, once we deprecate the old API in favor of `use`.\n                    getSuspendedThenable() : thrownValue;\n                    if (typeof x === \"object\" && x !== null) {\n                        // $FlowFixMe[method-unbinding]\n                        if (typeof x.then === \"function\") {\n                            var _wakeable = x;\n                            var _thenableState = getThenableStateAfterSuspending();\n                            spawnNewSuspendedRenderTask(request, task, _thenableState, _wakeable); // Restore the context. We assume that this will be restored by the inner\n                            // functions in case nothing throws so we don't use \"finally\" here.\n                            task.formatContext = previousFormatContext;\n                            task.legacyContext = previousLegacyContext;\n                            task.context = previousContext;\n                            task.keyPath = previousKeyPath;\n                            task.treeContext = previousTreeContext;\n                            task.componentStack = previousComponentStack; // Restore all active ReactContexts to what they were before.\n                            switchContext(previousContext);\n                            return;\n                        }\n                    }\n                }\n            } // Restore the context. We assume that this will be restored by the inner\n            // functions in case nothing throws so we don't use \"finally\" here.\n            task.formatContext = previousFormatContext;\n            task.legacyContext = previousLegacyContext;\n            task.context = previousContext;\n            task.keyPath = previousKeyPath;\n            task.treeContext = previousTreeContext; // We intentionally do not restore the component stack on the error pathway\n            // Whatever handles the error needs to use this stack which is the location of the\n            // error. We must restore the stack wherever we handle this\n            // Restore all active ReactContexts to what they were before.\n            switchContext(previousContext);\n            throw x;\n        }\n        function erroredReplay(request, boundary, error, errorInfo, replayNodes, resumeSlots) {\n            // Erroring during a replay doesn't actually cause an error by itself because\n            // that component has already rendered. What causes the error is the resumable\n            // points that we did not yet finish which will be below the point of the reset.\n            // For example, if we're replaying a path to a Suspense boundary that is not done\n            // that doesn't error the parent Suspense boundary.\n            // This might be a bit strange that the error in a parent gets thrown at a child.\n            // We log it only once and reuse the digest.\n            var errorDigest;\n            {\n                errorDigest = logRecoverableError(request, error, errorInfo);\n            }\n            abortRemainingReplayNodes(request, boundary, replayNodes, resumeSlots, error, errorDigest, errorInfo);\n        }\n        function erroredTask(request, boundary, error, errorInfo) {\n            // Report the error to a global handler.\n            var errorDigest;\n            {\n                errorDigest = logRecoverableError(request, error, errorInfo);\n            }\n            if (boundary === null) {\n                fatalError(request, error);\n            } else {\n                boundary.pendingTasks--;\n                if (boundary.status !== CLIENT_RENDERED) {\n                    boundary.status = CLIENT_RENDERED;\n                    encodeErrorForBoundary(boundary, errorDigest, error, errorInfo);\n                    untrackBoundary(request, boundary); // Regardless of what happens next, this boundary won't be displayed,\n                    // so we can flush it, if the parent already flushed.\n                    if (boundary.parentFlushed) {\n                        // We don't have a preference where in the queue this goes since it's likely\n                        // to error on the client anyway. However, intentionally client-rendered\n                        // boundaries should be flushed earlier so that they can start on the client.\n                        // We reuse the same queue for errors.\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                }\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                completeAll(request);\n            }\n        }\n        function abortTaskSoft(task) {\n            // This aborts task without aborting the parent boundary that it blocks.\n            // It's used for when we didn't need this task to complete the tree.\n            // If task was needed, then it should use abortTask instead.\n            var request = this;\n            var boundary = task.blockedBoundary;\n            var segment = task.blockedSegment;\n            if (segment !== null) {\n                segment.status = ABORTED;\n                finishedTask(request, boundary, segment);\n            }\n        }\n        function abortRemainingSuspenseBoundary(request, rootSegmentID, error, errorDigest, errorInfo) {\n            var resumedBoundary = createSuspenseBoundary(request, new Set());\n            resumedBoundary.parentFlushed = true; // We restore the same id of this boundary as was used during prerender.\n            resumedBoundary.rootSegmentID = rootSegmentID;\n            resumedBoundary.status = CLIENT_RENDERED;\n            var errorMessage = error;\n            {\n                var errorPrefix = \"The server did not finish this Suspense boundary: \";\n                if (error && typeof error.message === \"string\") {\n                    errorMessage = errorPrefix + error.message;\n                } else {\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    errorMessage = errorPrefix + String(error);\n                }\n            }\n            encodeErrorForBoundary(resumedBoundary, errorDigest, errorMessage, errorInfo);\n            if (resumedBoundary.parentFlushed) {\n                request.clientRenderedBoundaries.push(resumedBoundary);\n            }\n        }\n        function abortRemainingReplayNodes(request, boundary, nodes, slots, error, errorDigest, errorInfo) {\n            for(var i = 0; i < nodes.length; i++){\n                var node = nodes[i];\n                if (node.length === 4) {\n                    abortRemainingReplayNodes(request, boundary, node[2], node[3], error, errorDigest, errorInfo);\n                } else {\n                    var boundaryNode = node;\n                    var rootSegmentID = boundaryNode[5];\n                    abortRemainingSuspenseBoundary(request, rootSegmentID, error, errorDigest, errorInfo);\n                }\n            } // Empty the set, since we've cleared it now.\n            nodes.length = 0;\n            if (slots !== null) {\n                // We had something still to resume in the parent boundary. We must trigger\n                // the error on the parent boundary since it's not able to complete.\n                if (boundary === null) {\n                    throw new Error(\"We should not have any resumable nodes in the shell. \" + \"This is a bug in React.\");\n                } else if (boundary.status !== CLIENT_RENDERED) {\n                    boundary.status = CLIENT_RENDERED;\n                    encodeErrorForBoundary(boundary, errorDigest, error, errorInfo);\n                    if (boundary.parentFlushed) {\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                } // Empty the set\n                if (typeof slots === \"object\") {\n                    for(var index in slots){\n                        delete slots[index];\n                    }\n                }\n            }\n        }\n        function abortTask(task, request, error) {\n            // This aborts the task and aborts the parent that it blocks, putting it into\n            // client rendered mode.\n            var boundary = task.blockedBoundary;\n            var segment = task.blockedSegment;\n            if (segment !== null) {\n                segment.status = ABORTED;\n            }\n            if (boundary === null) {\n                var errorInfo = {};\n                if (request.status !== CLOSING && request.status !== CLOSED) {\n                    var replay = task.replay;\n                    if (replay === null) {\n                        // We didn't complete the root so we have nothing to show. We can close\n                        // the request;\n                        logRecoverableError(request, error, errorInfo);\n                        fatalError(request, error);\n                        return;\n                    } else {\n                        // If the shell aborts during a replay, that's not a fatal error. Instead\n                        // we should be able to recover by client rendering all the root boundaries in\n                        // the ReplaySet.\n                        replay.pendingTasks--;\n                        if (replay.pendingTasks === 0 && replay.nodes.length > 0) {\n                            var errorDigest = logRecoverableError(request, error, errorInfo);\n                            abortRemainingReplayNodes(request, null, replay.nodes, replay.slots, error, errorDigest, errorInfo);\n                        }\n                        request.pendingRootTasks--;\n                        if (request.pendingRootTasks === 0) {\n                            completeShell(request);\n                        }\n                    }\n                }\n            } else {\n                boundary.pendingTasks--;\n                if (boundary.status !== CLIENT_RENDERED) {\n                    boundary.status = CLIENT_RENDERED; // We construct an errorInfo from the boundary's componentStack so the error in dev will indicate which\n                    // boundary the message is referring to\n                    var _errorInfo = getThrownInfo(request, task.componentStack);\n                    var _errorDigest = logRecoverableError(request, error, _errorInfo);\n                    var errorMessage = error;\n                    {\n                        var errorPrefix = \"The server did not finish this Suspense boundary: \";\n                        if (error && typeof error.message === \"string\") {\n                            errorMessage = errorPrefix + error.message;\n                        } else {\n                            // eslint-disable-next-line react-internal/safe-string-coercion\n                            errorMessage = errorPrefix + String(error);\n                        }\n                    }\n                    encodeErrorForBoundary(boundary, _errorDigest, errorMessage, _errorInfo);\n                    untrackBoundary(request, boundary);\n                    if (boundary.parentFlushed) {\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                } // If this boundary was still pending then we haven't already cancelled its fallbacks.\n                // We'll need to abort the fallbacks, which will also error that parent boundary.\n                boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {\n                    return abortTask(fallbackTask, request, error);\n                });\n                boundary.fallbackAbortableTasks.clear();\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                completeAll(request);\n            }\n        }\n        function safelyEmitEarlyPreloads(request, shellComplete) {\n            try {\n                emitEarlyPreloads(request.renderState, request.resumableState, shellComplete);\n            } catch (error) {\n                // We assume preloads are optimistic and thus non-fatal if errored.\n                var errorInfo = {};\n                logRecoverableError(request, error, errorInfo);\n            }\n        } // I extracted this function out because we want to ensure we consistently emit preloads before\n        // transitioning to the next request stage and this transition can happen in multiple places in this\n        // implementation.\n        function completeShell(request) {\n            if (request.trackedPostpones === null) {\n                // We only emit early preloads on shell completion for renders. For prerenders\n                // we wait for the entire Request to finish because we are not responding to a\n                // live request and can wait for as much data as possible.\n                // we should only be calling completeShell when the shell is complete so we\n                // just use a literal here\n                var shellComplete = true;\n                safelyEmitEarlyPreloads(request, shellComplete);\n            } // We have completed the shell so the shell can't error anymore.\n            request.onShellError = noop;\n            var onShellReady = request.onShellReady;\n            onShellReady();\n        } // I extracted this function out because we want to ensure we consistently emit preloads before\n        // transitioning to the next request stage and this transition can happen in multiple places in this\n        // implementation.\n        function completeAll(request) {\n            // During a render the shell must be complete if the entire request is finished\n            // however during a Prerender it is possible that the shell is incomplete because\n            // it postponed. We cannot use rootPendingTasks in the prerender case because\n            // those hit zero even when the shell postpones. Instead we look at the completedRootSegment\n            var shellComplete = request.trackedPostpones === null ? true : request.completedRootSegment === null || request.completedRootSegment.status !== POSTPONED;\n            safelyEmitEarlyPreloads(request, shellComplete);\n            var onAllReady = request.onAllReady;\n            onAllReady();\n        }\n        function queueCompletedSegment(boundary, segment) {\n            if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null && segment.children[0].id === -1) {\n                // This is an empty segment. There's nothing to write, so we can instead transfer the ID\n                // to the child. That way any existing references point to the child.\n                var childSegment = segment.children[0];\n                childSegment.id = segment.id;\n                childSegment.parentFlushed = true;\n                if (childSegment.status === COMPLETED) {\n                    queueCompletedSegment(boundary, childSegment);\n                }\n            } else {\n                var completedSegments = boundary.completedSegments;\n                completedSegments.push(segment);\n            }\n        }\n        function finishedTask(request, boundary, segment) {\n            if (boundary === null) {\n                if (segment !== null && segment.parentFlushed) {\n                    if (request.completedRootSegment !== null) {\n                        throw new Error(\"There can only be one root segment. This is a bug in React.\");\n                    }\n                    request.completedRootSegment = segment;\n                }\n                request.pendingRootTasks--;\n                if (request.pendingRootTasks === 0) {\n                    completeShell(request);\n                }\n            } else {\n                boundary.pendingTasks--;\n                if (boundary.status === CLIENT_RENDERED) ;\n                else if (boundary.pendingTasks === 0) {\n                    if (boundary.status === PENDING) {\n                        boundary.status = COMPLETED;\n                    } // This must have been the last segment we were waiting on. This boundary is now complete.\n                    if (segment !== null && segment.parentFlushed) {\n                        // Our parent segment already flushed, so we need to schedule this segment to be emitted.\n                        // If it is a segment that was aborted, we'll write other content instead so we don't need\n                        // to emit it.\n                        if (segment.status === COMPLETED) {\n                            queueCompletedSegment(boundary, segment);\n                        }\n                    }\n                    if (boundary.parentFlushed) {\n                        // The segment might be part of a segment that didn't flush yet, but if the boundary's\n                        // parent flushed, we need to schedule the boundary to be emitted.\n                        request.completedBoundaries.push(boundary);\n                    } // We can now cancel any pending task on the fallback since we won't need to show it anymore.\n                    // This needs to happen after we read the parentFlushed flags because aborting can finish\n                    // work which can trigger user code, which can start flushing, which can change those flags.\n                    // If the boundary was POSTPONED, we still need to finish the fallback first.\n                    if (boundary.status === COMPLETED) {\n                        boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);\n                        boundary.fallbackAbortableTasks.clear();\n                    }\n                } else {\n                    if (segment !== null && segment.parentFlushed) {\n                        // Our parent already flushed, so we need to schedule this segment to be emitted.\n                        // If it is a segment that was aborted, we'll write other content instead so we don't need\n                        // to emit it.\n                        if (segment.status === COMPLETED) {\n                            queueCompletedSegment(boundary, segment);\n                            var completedSegments = boundary.completedSegments;\n                            if (completedSegments.length === 1) {\n                                // This is the first time since we last flushed that we completed anything.\n                                // We can schedule this boundary to emit its partially completed segments early\n                                // in case the parent has already been flushed.\n                                if (boundary.parentFlushed) {\n                                    request.partialBoundaries.push(boundary);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                completeAll(request);\n            }\n        }\n        function retryTask(request, task) {\n            {\n                var blockedBoundary = task.blockedBoundary;\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, blockedBoundary ? blockedBoundary.resources : null);\n            }\n            var segment = task.blockedSegment;\n            if (segment === null) {\n                retryReplayTask(request, task);\n            } else {\n                retryRenderTask(request, task, segment);\n            }\n        }\n        function retryRenderTask(request, task, segment) {\n            if (segment.status !== PENDING) {\n                // We completed this by other means before we had a chance to retry it.\n                return;\n            } // We restore the context to what it was when we suspended.\n            // We don't restore it after we leave because it's likely that we'll end up\n            // needing a very similar context soon again.\n            switchContext(task.context);\n            var prevTaskInDEV = null;\n            {\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = task;\n            }\n            var childrenLength = segment.children.length;\n            var chunkLength = segment.chunks.length;\n            try {\n                // We call the destructive form that mutates this task. That way if something\n                // suspends again, we can reuse the same task instead of spawning a new one.\n                // Reset the task's thenable state before continuing, so that if a later\n                // component suspends we can reuse the same task object. If the same\n                // component suspends again, the thenable state will be restored.\n                var prevThenableState = task.thenableState;\n                task.thenableState = null;\n                renderNodeDestructive(request, task, prevThenableState, task.node, task.childIndex);\n                pushSegmentFinale(segment.chunks, request.renderState, segment.lastPushedText, segment.textEmbedded);\n                task.abortSet.delete(task);\n                segment.status = COMPLETED;\n                finishedTask(request, task.blockedBoundary, segment);\n            } catch (thrownValue) {\n                resetHooksState(); // Reset the write pointers to where we started.\n                segment.children.length = childrenLength;\n                segment.chunks.length = chunkLength;\n                var x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                // value to be a thenable, because before `use` existed that was the\n                // (unstable) API for suspending. This implementation detail can change\n                // later, once we deprecate the old API in favor of `use`.\n                getSuspendedThenable() : thrownValue;\n                if (typeof x === \"object\" && x !== null) {\n                    // $FlowFixMe[method-unbinding]\n                    if (typeof x.then === \"function\") {\n                        // Something suspended again, let's pick it back up later.\n                        var ping = task.ping;\n                        x.then(ping, ping);\n                        task.thenableState = getThenableStateAfterSuspending();\n                        return;\n                    }\n                }\n                var errorInfo = getThrownInfo(request, task.componentStack);\n                task.abortSet.delete(task);\n                segment.status = ERRORED;\n                erroredTask(request, task.blockedBoundary, x, errorInfo);\n                return;\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, null);\n                }\n                {\n                    currentTaskInDEV = prevTaskInDEV;\n                }\n            }\n        }\n        function retryReplayTask(request, task) {\n            if (task.replay.pendingTasks === 0) {\n                // There are no pending tasks working on this set, so we must have aborted.\n                return;\n            } // We restore the context to what it was when we suspended.\n            // We don't restore it after we leave because it's likely that we'll end up\n            // needing a very similar context soon again.\n            switchContext(task.context);\n            var prevTaskInDEV = null;\n            {\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = task;\n            }\n            try {\n                // We call the destructive form that mutates this task. That way if something\n                // suspends again, we can reuse the same task instead of spawning a new one.\n                // Reset the task's thenable state before continuing, so that if a later\n                // component suspends we can reuse the same task object. If the same\n                // component suspends again, the thenable state will be restored.\n                var prevThenableState = task.thenableState;\n                task.thenableState = null;\n                renderNodeDestructive(request, task, prevThenableState, task.node, task.childIndex);\n                if (task.replay.pendingTasks === 1 && task.replay.nodes.length > 0) {\n                    throw new Error(\"Couldn't find all resumable slots by key/index during replaying. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                }\n                task.replay.pendingTasks--;\n                task.abortSet.delete(task);\n                finishedTask(request, task.blockedBoundary, null);\n            } catch (thrownValue) {\n                resetHooksState();\n                var x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                // value to be a thenable, because before `use` existed that was the\n                // (unstable) API for suspending. This implementation detail can change\n                // later, once we deprecate the old API in favor of `use`.\n                getSuspendedThenable() : thrownValue;\n                if (typeof x === \"object\" && x !== null) {\n                    // $FlowFixMe[method-unbinding]\n                    if (typeof x.then === \"function\") {\n                        // Something suspended again, let's pick it back up later.\n                        var ping = task.ping;\n                        x.then(ping, ping);\n                        task.thenableState = getThenableStateAfterSuspending();\n                        return;\n                    }\n                }\n                task.replay.pendingTasks--;\n                task.abortSet.delete(task);\n                var errorInfo = getThrownInfo(request, task.componentStack);\n                erroredReplay(request, task.blockedBoundary, x, errorInfo, task.replay.nodes, task.replay.slots);\n                request.pendingRootTasks--;\n                if (request.pendingRootTasks === 0) {\n                    completeShell(request);\n                }\n                request.allPendingTasks--;\n                if (request.allPendingTasks === 0) {\n                    completeAll(request);\n                }\n                return;\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, null);\n                }\n                {\n                    currentTaskInDEV = prevTaskInDEV;\n                }\n            }\n        }\n        function performWork(request) {\n            if (request.status === CLOSED) {\n                return;\n            }\n            var prevContext = getActiveContext();\n            var prevDispatcher = ReactCurrentDispatcher.current;\n            ReactCurrentDispatcher.current = HooksDispatcher;\n            var prevCacheDispatcher;\n            {\n                prevCacheDispatcher = ReactCurrentCache.current;\n                ReactCurrentCache.current = DefaultCacheDispatcher;\n            }\n            var prevRequest = currentRequest;\n            currentRequest = request;\n            var prevGetCurrentStackImpl;\n            {\n                prevGetCurrentStackImpl = ReactDebugCurrentFrame.getCurrentStack;\n                ReactDebugCurrentFrame.getCurrentStack = getCurrentStackInDEV;\n            }\n            var prevResumableState = currentResumableState;\n            setCurrentResumableState(request.resumableState);\n            try {\n                var pingedTasks = request.pingedTasks;\n                var i;\n                for(i = 0; i < pingedTasks.length; i++){\n                    var task = pingedTasks[i];\n                    retryTask(request, task);\n                }\n                pingedTasks.splice(0, i);\n                if (request.destination !== null) {\n                    flushCompletedQueues(request, request.destination);\n                }\n            } catch (error) {\n                var errorInfo = {};\n                logRecoverableError(request, error, errorInfo);\n                fatalError(request, error);\n            } finally{\n                setCurrentResumableState(prevResumableState);\n                ReactCurrentDispatcher.current = prevDispatcher;\n                {\n                    ReactCurrentCache.current = prevCacheDispatcher;\n                }\n                {\n                    ReactDebugCurrentFrame.getCurrentStack = prevGetCurrentStackImpl;\n                }\n                if (prevDispatcher === HooksDispatcher) {\n                    // This means that we were in a reentrant work loop. This could happen\n                    // in a renderer that supports synchronous work like renderToString,\n                    // when it's called from within another renderer.\n                    // Normally we don't bother switching the contexts to their root/default\n                    // values when leaving because we'll likely need the same or similar\n                    // context again. However, when we're inside a synchronous loop like this\n                    // we'll to restore the context to what it was before returning.\n                    switchContext(prevContext);\n                }\n                currentRequest = prevRequest;\n            }\n        }\n        function flushSubtree(request, destination, segment) {\n            segment.parentFlushed = true;\n            switch(segment.status){\n                case PENDING:\n                    {\n                        // We're emitting a placeholder for this segment to be filled in later.\n                        // Therefore we'll need to assign it an ID - to refer to it by.\n                        segment.id = request.nextSegmentId++; // Fallthrough\n                    }\n                case POSTPONED:\n                    {\n                        var segmentID = segment.id; // When this segment finally completes it won't be embedded in text since it will flush separately\n                        segment.lastPushedText = false;\n                        segment.textEmbedded = false;\n                        return writePlaceholder(destination, request.renderState, segmentID);\n                    }\n                case COMPLETED:\n                    {\n                        segment.status = FLUSHED;\n                        var r = true;\n                        var chunks = segment.chunks;\n                        var chunkIdx = 0;\n                        var children = segment.children;\n                        for(var childIdx = 0; childIdx < children.length; childIdx++){\n                            var nextChild = children[childIdx]; // Write all the chunks up until the next child.\n                            for(; chunkIdx < nextChild.index; chunkIdx++){\n                                writeChunk(destination, chunks[chunkIdx]);\n                            }\n                            r = flushSegment(request, destination, nextChild);\n                        } // Finally just write all the remaining chunks\n                        for(; chunkIdx < chunks.length - 1; chunkIdx++){\n                            writeChunk(destination, chunks[chunkIdx]);\n                        }\n                        if (chunkIdx < chunks.length) {\n                            r = writeChunkAndReturn(destination, chunks[chunkIdx]);\n                        }\n                        return r;\n                    }\n                default:\n                    {\n                        throw new Error(\"Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.\");\n                    }\n            }\n        }\n        function flushSegment(request, destination, segment) {\n            var boundary = segment.boundary;\n            if (boundary === null) {\n                // Not a suspense boundary.\n                return flushSubtree(request, destination, segment);\n            }\n            boundary.parentFlushed = true; // This segment is a Suspense boundary. We need to decide whether to\n            // emit the content or the fallback now.\n            if (boundary.status === CLIENT_RENDERED) {\n                // Emit a client rendered suspense boundary wrapper.\n                // We never queue the inner boundary so we'll never emit its content or partial segments.\n                writeStartClientRenderedSuspenseBoundary(destination, request.renderState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndClientRenderedSuspenseBoundary(destination, request.renderState);\n            } else if (boundary.status !== COMPLETED) {\n                if (boundary.status === PENDING) {\n                    // For pending boundaries we lazily assign an ID to the boundary\n                    // and root segment.\n                    boundary.rootSegmentID = request.nextSegmentId++;\n                }\n                if (boundary.completedSegments.length > 0) {\n                    // If this is at least partially complete, we can queue it to be partially emitted early.\n                    request.partialBoundaries.push(boundary);\n                } // This boundary is still loading. Emit a pending suspense boundary wrapper.\n                var id = boundary.rootSegmentID;\n                writeStartPendingSuspenseBoundary(destination, request.renderState, id); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndPendingSuspenseBoundary(destination);\n            } else if (boundary.byteSize > request.progressiveChunkSize) {\n                // This boundary is large and will be emitted separately so that we can progressively show\n                // other content. We add it to the queue during the flush because we have to ensure that\n                // the parent flushes first so that there's something to inject it into.\n                // We also have to make sure that it's emitted into the queue in a deterministic slot.\n                // I.e. we can't insert it here when it completes.\n                // Assign an ID to refer to the future content by.\n                boundary.rootSegmentID = request.nextSegmentId++;\n                request.completedBoundaries.push(boundary); // Emit a pending rendered suspense boundary wrapper.\n                writeStartPendingSuspenseBoundary(destination, request.renderState, boundary.rootSegmentID); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndPendingSuspenseBoundary(destination);\n            } else {\n                {\n                    hoistResources(request.renderState, boundary.resources);\n                }\n                writeStartCompletedSuspenseBoundary(destination, request.renderState);\n                var completedSegments = boundary.completedSegments;\n                if (completedSegments.length !== 1) {\n                    throw new Error(\"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\");\n                }\n                var contentSegment = completedSegments[0];\n                flushSegment(request, destination, contentSegment);\n                return writeEndCompletedSuspenseBoundary(destination, request.renderState);\n            }\n        }\n        function flushClientRenderedBoundary(request, destination, boundary) {\n            return writeClientRenderBoundaryInstruction(destination, request.resumableState, request.renderState, boundary.rootSegmentID, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);\n        }\n        function flushSegmentContainer(request, destination, segment) {\n            writeStartSegment(destination, request.renderState, segment.parentFormatContext, segment.id);\n            flushSegment(request, destination, segment);\n            return writeEndSegment(destination, segment.parentFormatContext);\n        }\n        function flushCompletedBoundary(request, destination, boundary) {\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, boundary.resources);\n            }\n            var completedSegments = boundary.completedSegments;\n            var i = 0;\n            for(; i < completedSegments.length; i++){\n                var segment = completedSegments[i];\n                flushPartiallyCompletedSegment(request, destination, boundary, segment);\n            }\n            completedSegments.length = 0;\n            {\n                writeResourcesForBoundary(destination, boundary.resources, request.renderState);\n            }\n            return writeCompletedBoundaryInstruction(destination, request.resumableState, request.renderState, boundary.rootSegmentID, boundary.resources);\n        }\n        function flushPartialBoundary(request, destination, boundary) {\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, boundary.resources);\n            }\n            var completedSegments = boundary.completedSegments;\n            var i = 0;\n            for(; i < completedSegments.length; i++){\n                var segment = completedSegments[i];\n                if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {\n                    i++;\n                    completedSegments.splice(0, i); // Only write as much as the buffer wants. Something higher priority\n                    // might want to write later.\n                    return false;\n                }\n            }\n            completedSegments.splice(0, i);\n            {\n                // The way this is structured we only write resources for partial boundaries\n                // if there is no backpressure. Later before we complete the boundary we\n                // will write resources regardless of backpressure before we emit the\n                // completion instruction\n                return writeResourcesForBoundary(destination, boundary.resources, request.renderState);\n            }\n        }\n        function flushPartiallyCompletedSegment(request, destination, boundary, segment) {\n            if (segment.status === FLUSHED) {\n                // We've already flushed this inline.\n                return true;\n            }\n            var segmentID = segment.id;\n            if (segmentID === -1) {\n                // This segment wasn't previously referred to. This happens at the root of\n                // a boundary. We make kind of a leap here and assume this is the root.\n                var rootSegmentID = segment.id = boundary.rootSegmentID;\n                if (rootSegmentID === -1) {\n                    throw new Error(\"A root segment ID must have been assigned by now. This is a bug in React.\");\n                }\n                return flushSegmentContainer(request, destination, segment);\n            } else if (segmentID === boundary.rootSegmentID) {\n                // When we emit postponed boundaries, we might have assigned the ID already\n                // but it's still the root segment so we can't inject it into the parent yet.\n                return flushSegmentContainer(request, destination, segment);\n            } else {\n                flushSegmentContainer(request, destination, segment);\n                return writeCompletedSegmentInstruction(destination, request.resumableState, request.renderState, segmentID);\n            }\n        }\n        function flushCompletedQueues(request, destination) {\n            try {\n                // The structure of this is to go through each queue one by one and write\n                // until the sink tells us to stop. When we should stop, we still finish writing\n                // that item fully and then yield. At that point we remove the already completed\n                // items up until the point we completed them.\n                var i;\n                var completedRootSegment = request.completedRootSegment;\n                if (completedRootSegment !== null) {\n                    if (completedRootSegment.status === POSTPONED) {\n                        // We postponed the root, so we write nothing.\n                        return;\n                    } else if (request.pendingRootTasks === 0) {\n                        if (enableFloat) {\n                            writePreamble(destination, request.resumableState, request.renderState, request.allPendingTasks === 0 && request.trackedPostpones === null);\n                        }\n                        flushSegment(request, destination, completedRootSegment);\n                        request.completedRootSegment = null;\n                        writeCompletedRoot(destination, request.renderState);\n                    } else {\n                        // We haven't flushed the root yet so we don't need to check any other branches further down\n                        return;\n                    }\n                }\n                if (enableFloat) {\n                    writeHoistables(destination, request.resumableState, request.renderState);\n                } // We emit client rendering instructions for already emitted boundaries first.\n                // This is so that we can signal to the client to start client rendering them as\n                // soon as possible.\n                var clientRenderedBoundaries = request.clientRenderedBoundaries;\n                for(i = 0; i < clientRenderedBoundaries.length; i++){\n                    var boundary = clientRenderedBoundaries[i];\n                    if (!flushClientRenderedBoundary(request, destination, boundary)) {\n                        request.destination = null;\n                        i++;\n                        clientRenderedBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                clientRenderedBoundaries.splice(0, i); // Next we emit any complete boundaries. It's better to favor boundaries\n                // that are completely done since we can actually show them, than it is to emit\n                // any individual segments from a partially complete boundary.\n                var completedBoundaries = request.completedBoundaries;\n                for(i = 0; i < completedBoundaries.length; i++){\n                    var _boundary = completedBoundaries[i];\n                    if (!flushCompletedBoundary(request, destination, _boundary)) {\n                        request.destination = null;\n                        i++;\n                        completedBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                completedBoundaries.splice(0, i); // Allow anything written so far to flush to the underlying sink before\n                // we continue with lower priorities.\n                completeWriting(destination);\n                beginWriting(destination); // TODO: Here we'll emit data used by hydration.\n                // Next we emit any segments of any boundaries that are partially complete\n                // but not deeply complete.\n                var partialBoundaries = request.partialBoundaries;\n                for(i = 0; i < partialBoundaries.length; i++){\n                    var _boundary2 = partialBoundaries[i];\n                    if (!flushPartialBoundary(request, destination, _boundary2)) {\n                        request.destination = null;\n                        i++;\n                        partialBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                partialBoundaries.splice(0, i); // Next we check the completed boundaries again. This may have had\n                // boundaries added to it in case they were too larged to be inlined.\n                // New ones might be added in this loop.\n                var largeBoundaries = request.completedBoundaries;\n                for(i = 0; i < largeBoundaries.length; i++){\n                    var _boundary3 = largeBoundaries[i];\n                    if (!flushCompletedBoundary(request, destination, _boundary3)) {\n                        request.destination = null;\n                        i++;\n                        largeBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                largeBoundaries.splice(0, i);\n            } finally{\n                if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 // We don't need to check any partially completed segments because\n                ) {\n                    request.flushScheduled = false;\n                    {\n                        // We write the trailing tags but only if don't have any data to resume.\n                        // If we need to resume we'll write the postamble in the resume instead.\n                        {\n                            writePostamble(destination, request.resumableState);\n                        }\n                    }\n                    {\n                        if (request.abortableTasks.size !== 0) {\n                            error(\"There was still abortable task at the root when we closed. This is a bug in React.\");\n                        }\n                    }\n                    close(destination); // We need to stop flowing now because we do not want any async contexts which might call\n                    // float methods to initiate any flushes after this point\n                    stopFlowing(request);\n                }\n            }\n        }\n        function startWork(request) {\n            request.flushScheduled = request.destination !== null;\n            {\n                scheduleWork(function() {\n                    return performWork(request);\n                });\n            }\n            if (request.trackedPostpones === null) {\n                // this is either a regular render or a resume. For regular render we want\n                // to call emitEarlyPreloads after the first performWork because we want\n                // are responding to a live request and need to balance sending something early\n                // (i.e. don't want for the shell to finish) but we need something to send.\n                // The only implementation of this is for DOM at the moment and during resumes nothing\n                // actually emits but the code paths here are the same.\n                // During a prerender we don't want to be too aggressive in emitting early preloads\n                // because we aren't responding to a live request and we can wait for the prerender to\n                // postpone before we emit anything.\n                {\n                    scheduleWork(function() {\n                        return enqueueEarlyPreloadsAfterInitialWork(request);\n                    });\n                }\n            }\n        }\n        function enqueueEarlyPreloadsAfterInitialWork(request) {\n            var shellComplete = request.pendingRootTasks === 0;\n            safelyEmitEarlyPreloads(request, shellComplete);\n        }\n        function enqueueFlush(request) {\n            if (request.flushScheduled === false && // If there are pinged tasks we are going to flush anyway after work completes\n            request.pingedTasks.length === 0 && // If there is no destination there is nothing we can flush to. A flush will\n            // happen when we start flowing again\n            request.destination !== null) {\n                request.flushScheduled = true;\n                scheduleWork(function() {\n                    // We need to existence check destination again here because it might go away\n                    // in between the enqueueFlush call and the work execution\n                    var destination = request.destination;\n                    if (destination) {\n                        flushCompletedQueues(request, destination);\n                    } else {\n                        request.flushScheduled = false;\n                    }\n                });\n            }\n        } // This function is intented to only be called during the pipe function for the Node builds.\n        function startFlowing(request, destination) {\n            if (request.status === CLOSING) {\n                request.status = CLOSED;\n                closeWithError(destination, request.fatalError);\n                return;\n            }\n            if (request.status === CLOSED) {\n                return;\n            }\n            if (request.destination !== null) {\n                // We're already flowing.\n                return;\n            }\n            request.destination = destination;\n            try {\n                flushCompletedQueues(request, destination);\n            } catch (error) {\n                var errorInfo = {};\n                logRecoverableError(request, error, errorInfo);\n                fatalError(request, error);\n            }\n        }\n        function stopFlowing(request) {\n            request.destination = null;\n        } // This is called to early terminate a request. It puts all pending boundaries in client rendered state.\n        function abort(request, reason) {\n            try {\n                var abortableTasks = request.abortableTasks;\n                if (abortableTasks.size > 0) {\n                    var error = reason === undefined ? new Error(\"The render was aborted by the server without a reason.\") : reason;\n                    abortableTasks.forEach(function(task) {\n                        return abortTask(task, request, error);\n                    });\n                    abortableTasks.clear();\n                }\n                if (request.destination !== null) {\n                    flushCompletedQueues(request, request.destination);\n                }\n            } catch (error) {\n                var errorInfo = {};\n                logRecoverableError(request, error, errorInfo);\n                fatalError(request, error);\n            }\n        }\n        function flushResources(request) {\n            enqueueFlush(request);\n        }\n        function getFormState(request) {\n            return request.formState;\n        }\n        function getResumableState(request) {\n            return request.resumableState;\n        }\n        function getRenderState(request) {\n            return request.renderState;\n        }\n        function onError() {}\n        function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {\n            var didFatal = false;\n            var fatalError = null;\n            var result = \"\";\n            var destination = {\n                // $FlowFixMe[missing-local-annot]\n                push: function(chunk) {\n                    if (chunk !== null) {\n                        result += chunk;\n                    }\n                    return true;\n                },\n                // $FlowFixMe[missing-local-annot]\n                destroy: function(error) {\n                    didFatal = true;\n                    fatalError = error;\n                }\n            };\n            var readyToStream = false;\n            function onShellReady() {\n                readyToStream = true;\n            }\n            var resumableState = createResumableState(options ? options.identifierPrefix : undefined, undefined);\n            var request = createRequest(children, resumableState, createRenderState(resumableState, generateStaticMarkup), createRootFormatContext(), Infinity, onError, undefined, onShellReady, undefined, undefined, undefined);\n            startWork(request); // If anything suspended and is still pending, we'll abort it before writing.\n            // That way we write only client-rendered boundaries from the start.\n            abort(request, abortReason);\n            startFlowing(request, destination);\n            if (didFatal && fatalError !== abortReason) {\n                throw fatalError;\n            }\n            if (!readyToStream) {\n                // Note: This error message is the one we use on the client. It doesn't\n                // really make sense here. But this is the legacy server renderer, anyway.\n                // We're going to delete it soon.\n                throw new Error(\"A component suspended while responding to synchronous input. This \" + \"will cause the UI to be replaced with a loading indicator. To fix, \" + \"updates that suspend should be wrapped with startTransition.\");\n            }\n            return result;\n        }\n        function renderToString(children, options) {\n            return renderToStringImpl(children, options, false, 'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToReadableStream\" which supports Suspense on the server');\n        }\n        function renderToStaticMarkup(children, options) {\n            return renderToStringImpl(children, options, true, 'The server used \"renderToStaticMarkup\" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to \"renderToReadableStream\" which supports Suspense on the server');\n        }\n        function renderToNodeStream() {\n            throw new Error(\"ReactDOMServer.renderToNodeStream(): The streaming API is not available \" + \"in the browser. Use ReactDOMServer.renderToString() instead.\");\n        }\n        function renderToStaticNodeStream() {\n            throw new Error(\"ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available \" + \"in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.\");\n        }\n        exports.renderToNodeStream = renderToNodeStream;\n        exports.renderToStaticMarkup = renderToStaticMarkup;\n        exports.renderToStaticNodeStream = renderToStaticNodeStream;\n        exports.renderToString = renderToString;\n        exports.version = ReactVersion;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20tc2VydmVyLWxlZ2FjeS5icm93c2VyLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDLEdBRUQ7QUFFQSxJQUFJQSxJQUFxQyxFQUFFO0lBQ3hDOztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBQzlDLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO1FBRXZCLElBQUlFLGVBQWU7UUFFbkIsSUFBSUMsdUJBQXVCSixNQUFNSyxrREFBa0Q7UUFFbkYsK0NBQStDO1FBQy9DLEVBQUU7UUFDRiw4REFBOEQ7UUFDOUQscUNBQXFDO1FBRXJDLFNBQVNDLEtBQUtDLE1BQU07WUFDbEI7Z0JBQ0U7b0JBQ0UsSUFBSyxJQUFJQyxPQUFPQyxVQUFVQyxNQUFNLEVBQUVDLE9BQU8sSUFBSUMsTUFBTUosT0FBTyxJQUFJQSxPQUFPLElBQUksSUFBSUssT0FBTyxHQUFHQSxPQUFPTCxNQUFNSyxPQUFRO3dCQUMxR0YsSUFBSSxDQUFDRSxPQUFPLEVBQUUsR0FBR0osU0FBUyxDQUFDSSxLQUFLO29CQUNsQztvQkFFQUMsYUFBYSxRQUFRUCxRQUFRSTtnQkFDL0I7WUFDRjtRQUNGO1FBQ0EsU0FBU0ksTUFBTVIsTUFBTTtZQUNuQjtnQkFDRTtvQkFDRSxJQUFLLElBQUlTLFFBQVFQLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSSxRQUFRLElBQUlBLFFBQVEsSUFBSSxJQUFJQyxRQUFRLEdBQUdBLFFBQVFELE9BQU9DLFFBQVM7d0JBQ2pITixJQUFJLENBQUNNLFFBQVEsRUFBRSxHQUFHUixTQUFTLENBQUNRLE1BQU07b0JBQ3BDO29CQUVBSCxhQUFhLFNBQVNQLFFBQVFJO2dCQUNoQztZQUNGO1FBQ0Y7UUFFQSxTQUFTRyxhQUFhSSxLQUFLLEVBQUVYLE1BQU0sRUFBRUks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QkFBQztnQkFBYzthQUFjO1lBQUU7Z0JBQUM7Z0JBQWlCO2FBQWlCO1lBQUU7Z0JBQUM7Z0JBQWE7YUFBYTtZQUFFO2dCQUFDO2dCQUFZO2FBQVk7WUFBRTtnQkFBQztnQkFBWTthQUFZO1lBQUU7Z0JBQUM7Z0JBQXNCO2FBQXNCO1lBQUU7Z0JBQUM7Z0JBQTZCO2FBQThCO1lBQUU7Z0JBQUM7Z0JBQWdCO2FBQWdCO1lBQUU7Z0JBQUM7Z0JBQWtCO2FBQWtCO1lBQUU7Z0JBQUM7Z0JBQW9CO2FBQW9CO1lBQUU7Z0JBQUM7Z0JBQW9CO2FBQW9CO1lBQUU7Z0JBQUM7Z0JBQWU7YUFBZTtZQUFFO2dCQUFDO2dCQUFZO2FBQVk7WUFBRTtnQkFBQztnQkFBYzthQUFjO1lBQUU7Z0JBQUM7Z0JBQWdCO2FBQWdCO1lBQUU7Z0JBQUM7Z0JBQWM7YUFBYztZQUFFO2dCQUFDO2dCQUFZO2FBQVk7WUFBRTtnQkFBQztnQkFBa0I7YUFBbUI7WUFBRTtnQkFBQztnQkFBZTthQUFlO1lBQUU7Z0JBQUM7Z0JBQWE7YUFBYTtZQUFFO2dCQUFDO2dCQUFlO2FBQWU7WUFBRTtnQkFBQztnQkFBYzthQUFjO1lBQUU7Z0JBQUM7Z0JBQWE7YUFBYTtZQUFFO2dCQUFDO2dCQUE4QjthQUErQjtZQUFFO2dCQUFDO2dCQUE0QjthQUE2QjtZQUFFO2dCQUFDO2dCQUFhO2FBQWM7WUFBRTtnQkFBQztnQkFBZ0I7YUFBaUI7WUFBRTtnQkFBQztnQkFBa0I7YUFBa0I7WUFBRTtnQkFBQztnQkFBaUI7YUFBaUI7WUFBRTtnQkFBQztnQkFBaUI7YUFBaUI7WUFBRTtnQkFBQztnQkFBYTthQUFhO1lBQUU7Z0JBQUM7Z0JBQWE7YUFBYTtZQUFFO2dCQUFDO2dCQUFlO2FBQWU7WUFBRTtnQkFBQztnQkFBb0I7YUFBb0I7WUFBRTtnQkFBQztnQkFBcUI7YUFBcUI7WUFBRTtnQkFBQztnQkFBYzthQUFjO1lBQUU7Z0JBQUM7Z0JBQVk7YUFBVztZQUFFO2dCQUFDO2dCQUFpQjthQUFpQjtZQUFFO2dCQUFDO2dCQUFtQjthQUFtQjtZQUFFO2dCQUFD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dWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20tc2VydmVyLWxlZ2FjeS5icm93c2VyLmRldmVsb3BtZW50LmpzP2E4YzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtZG9tLXNlcnZlci1sZWdhY3kuYnJvd3Nlci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE4LjMuMC1jYW5hcnktNjBhOTI3ZDA0LTIwMjQwMTEzJztcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnd2FybicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIEEgcHVyZSBKUyBpbXBsZW1lbnRhdGlvbiBvZiBhIHN0cmluZyBoYXNoaW5nIGZ1bmN0aW9uLiBXZSBkbyBub3QgdXNlIGl0IGZvclxuLy8gc2VjdXJpdHkgb3Igb2JmdXNjYXRpb24gcHVycG9zZXMsIG9ubHkgdG8gY3JlYXRlIGNvbXBhY3QgaGFzaGVzLiBTbyB3ZVxuLy8gcHJpb3JpdGl6ZSBzcGVlZCBvdmVyIGNvbGxpc2lvbiBhdm9pZGFuY2UuIEZvciBleGFtcGxlLCB3ZSB1c2UgdGhpcyB0byBoYXNoXG4vLyB0aGUgY29tcG9uZW50IGtleSBwYXRoIHVzZWQgYnkgdXNlRm9ybVN0YXRlIGZvciBNUEEtc3R5bGUgc3VibWlzc2lvbnMuXG4vL1xuLy8gSW4gZW52aXJvbm1lbnRzIHdoZXJlIGJ1aWx0LWluIGhhc2hpbmcgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUsIHdlIHByZWZlclxuLy8gdGhvc2UgaW5zdGVhZC4gTGlrZSBOb2RlJ3MgY3J5cHRvIG1vZHVsZSwgb3IgQnVuLmhhc2guIFVuZm9ydHVuYXRlbHkgdGhpc1xuLy8gZG9lcyBub3QgaW5jbHVkZSB0aGUgd2ViIHN0YW5kYXJkIGNyeXB0byBBUEkgYmVjYXVzZSB0aG9zZSBtZXRob2RzIGFyZSBhbGxcbi8vIGFzeW5jLiBGb3Igb3VyIHB1cnBvc2VzLCB3ZSBuZWVkIGl0IHRvIGJlIHN5bmMgYmVjYXVzZSB0aGUgY29zdCBvZiBjb250ZXh0XG4vLyBzd2l0Y2hpbmcgaXMgdG9vIGhpZ2ggdG8gYmUgd29ydGggaXQuXG4vL1xuLy8gVGhlIG1vc3QgcG9wdWxhciBoYXNoaW5nIGFsZ29yaXRobSB0aGF0IG1lZXRzIHRoZXNlIHJlcXVpcmVtZW50cyBpbiB0aGUgSlNcbi8vIGVjb3N5c3RlbSBpcyBNdXJtdXJIYXNoMywgYW5kIGFsbW9zdCBhbGwgaW1wbGVtZW50YXRpb25zIEkgY291bGQgZmluZCB1c2VkXG4vLyBzb21lIHZlcnNpb24gb2YgdGhlIGltcGxlbWVudGF0aW9uIGJ5IEdhcnkgQ291cnQgaW5saW5lZCBiZWxvdy5cbmZ1bmN0aW9uIGNyZWF0ZUZhc3RIYXNoSlMoa2V5KSB7XG4gIHJldHVybiBtdXJtdXJoYXNoM18zMl9nYyhrZXksIDApO1xufVxuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWNvbnN0LCBuby1mYWxsdGhyb3VnaCAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKlxuICogSlMgSW1wbGVtZW50YXRpb24gb2YgTXVybXVySGFzaDMgKHIxMzYpIChhcyBvZiBNYXkgMjAsIDIwMTEpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDExIEdhcnkgQ291cnRcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuZnVuY3Rpb24gbXVybXVyaGFzaDNfMzJfZ2Moa2V5LCBzZWVkKSB7XG4gIHZhciByZW1haW5kZXIsIGJ5dGVzLCBoMSwgaDFiLCBjMSwgYzIsIGsxLCBpO1xuICByZW1haW5kZXIgPSBrZXkubGVuZ3RoICYgMzsgLy8ga2V5Lmxlbmd0aCAlIDRcblxuICBieXRlcyA9IGtleS5sZW5ndGggLSByZW1haW5kZXI7XG4gIGgxID0gc2VlZDtcbiAgYzEgPSAweGNjOWUyZDUxO1xuICBjMiA9IDB4MWI4NzM1OTM7XG4gIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgYnl0ZXMpIHtcbiAgICBrMSA9IGtleS5jaGFyQ29kZUF0KGkpICYgMHhmZiB8IChrZXkuY2hhckNvZGVBdCgrK2kpICYgMHhmZikgPDwgOCB8IChrZXkuY2hhckNvZGVBdCgrK2kpICYgMHhmZikgPDwgMTYgfCAoa2V5LmNoYXJDb2RlQXQoKytpKSAmIDB4ZmYpIDw8IDI0O1xuICAgICsraTtcbiAgICBrMSA9IChrMSAmIDB4ZmZmZikgKiBjMSArICgoKGsxID4+PiAxNikgKiBjMSAmIDB4ZmZmZikgPDwgMTYpICYgMHhmZmZmZmZmZjtcbiAgICBrMSA9IGsxIDw8IDE1IHwgazEgPj4+IDE3O1xuICAgIGsxID0gKGsxICYgMHhmZmZmKSAqIGMyICsgKCgoazEgPj4+IDE2KSAqIGMyICYgMHhmZmZmKSA8PCAxNikgJiAweGZmZmZmZmZmO1xuICAgIGgxIF49IGsxO1xuICAgIGgxID0gaDEgPDwgMTMgfCBoMSA+Pj4gMTk7XG4gICAgaDFiID0gKGgxICYgMHhmZmZmKSAqIDUgKyAoKChoMSA+Pj4gMTYpICogNSAmIDB4ZmZmZikgPDwgMTYpICYgMHhmZmZmZmZmZjtcbiAgICBoMSA9IChoMWIgJiAweGZmZmYpICsgMHg2YjY0ICsgKCgoaDFiID4+PiAxNikgKyAweGU2NTQgJiAweGZmZmYpIDw8IDE2KTtcbiAgfVxuXG4gIGsxID0gMDtcblxuICBzd2l0Y2ggKHJlbWFpbmRlcikge1xuICAgIGNhc2UgMzpcbiAgICAgIGsxIF49IChrZXkuY2hhckNvZGVBdChpICsgMikgJiAweGZmKSA8PCAxNjtcblxuICAgIGNhc2UgMjpcbiAgICAgIGsxIF49IChrZXkuY2hhckNvZGVBdChpICsgMSkgJiAweGZmKSA8PCA4O1xuXG4gICAgY2FzZSAxOlxuICAgICAgazEgXj0ga2V5LmNoYXJDb2RlQXQoaSkgJiAweGZmO1xuICAgICAgazEgPSAoazEgJiAweGZmZmYpICogYzEgKyAoKChrMSA+Pj4gMTYpICogYzEgJiAweGZmZmYpIDw8IDE2KSAmIDB4ZmZmZmZmZmY7XG4gICAgICBrMSA9IGsxIDw8IDE1IHwgazEgPj4+IDE3O1xuICAgICAgazEgPSAoazEgJiAweGZmZmYpICogYzIgKyAoKChrMSA+Pj4gMTYpICogYzIgJiAweGZmZmYpIDw8IDE2KSAmIDB4ZmZmZmZmZmY7XG4gICAgICBoMSBePSBrMTtcbiAgfVxuXG4gIGgxIF49IGtleS5sZW5ndGg7XG4gIGgxIF49IGgxID4+PiAxNjtcbiAgaDEgPSAoaDEgJiAweGZmZmYpICogMHg4NWViY2E2YiArICgoKGgxID4+PiAxNikgKiAweDg1ZWJjYTZiICYgMHhmZmZmKSA8PCAxNikgJiAweGZmZmZmZmZmO1xuICBoMSBePSBoMSA+Pj4gMTM7XG4gIGgxID0gKGgxICYgMHhmZmZmKSAqIDB4YzJiMmFlMzUgKyAoKChoMSA+Pj4gMTYpICogMHhjMmIyYWUzNSAmIDB4ZmZmZikgPDwgMTYpICYgMHhmZmZmZmZmZjtcbiAgaDEgXj0gaDEgPj4+IDE2O1xuICByZXR1cm4gaDEgPj4+IDA7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlV29yayhjYWxsYmFjaykge1xuICBjYWxsYmFjaygpO1xufVxuZnVuY3Rpb24gYmVnaW5Xcml0aW5nKGRlc3RpbmF0aW9uKSB7fVxuZnVuY3Rpb24gd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmspIHtcbiAgd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2h1bmspO1xufVxuZnVuY3Rpb24gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2h1bmspIHtcbiAgcmV0dXJuIGRlc3RpbmF0aW9uLnB1c2goY2h1bmspO1xufVxuZnVuY3Rpb24gY29tcGxldGVXcml0aW5nKGRlc3RpbmF0aW9uKSB7fVxuZnVuY3Rpb24gY2xvc2UoZGVzdGluYXRpb24pIHtcbiAgZGVzdGluYXRpb24ucHVzaChudWxsKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvQ2h1bmsoY29udGVudCkge1xuICByZXR1cm4gY29udGVudDtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjb250ZW50KSB7XG4gIHJldHVybiBjb250ZW50O1xufVxuZnVuY3Rpb24gY2xvbmVQcmVjb21wdXRlZENodW5rKGNodW5rKSB7XG4gIHJldHVybiBjaHVuaztcbn1cbmZ1bmN0aW9uIGNsb3NlV2l0aEVycm9yKGRlc3RpbmF0aW9uLCBlcnJvcikge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogVGhpcyBpcyBhbiBFcnJvciBvYmplY3Qgb3IgdGhlIGRlc3RpbmF0aW9uIGFjY2VwdHMgb3RoZXIgdHlwZXMuXG4gIGRlc3RpbmF0aW9uLmRlc3Ryb3koZXJyb3IpO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQgYCVzYCBhdHRyaWJ1dGUgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCBhdHRyaWJ1dGVOYW1lLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrT3B0aW9uU3RyaW5nQ29lcmNpb24odmFsdWUsIHByb3BOYW1lKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGAlc2Agb3B0aW9uIGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgcHJvcE5hbWUsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBwcm9wTmFtZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBgJXNgIENTUyBwcm9wZXJ0eSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHByb3BOYW1lLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIEhUTUwgbWFya3VwIHVzZXMgYSB2YWx1ZSBvZiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIGVuYWJsZUZsb2F0ID0gdHJ1ZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV91c2VNZW1vQ2FjaGUgaG9vaywgaW50ZW5kZWQgYXMgYSBjb21waWxhdGlvbiB0YXJnZXQgZm9yXG5cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSBcIjpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcIjtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG52YXIgQVRUUklCVVRFX05BTUVfQ0hBUiA9IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyBcIlxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXCI7XG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKCdeWycgKyBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG5cbiAge1xuICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgd2hpY2ggYWNjZXB0IG51bWJlcnMgYnV0IGFyZSBub3QgaW4gdW5pdHMgb2YgXCJweFwiLlxuICovXG52YXIgdW5pdGxlc3NOdW1iZXJzID0gbmV3IFNldChbJ2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50JywgJ2FzcGVjdFJhdGlvJywgJ2JvcmRlckltYWdlT3V0c2V0JywgJ2JvcmRlckltYWdlU2xpY2UnLCAnYm9yZGVySW1hZ2VXaWR0aCcsICdib3hGbGV4JywgJ2JveEZsZXhHcm91cCcsICdib3hPcmRpbmFsR3JvdXAnLCAnY29sdW1uQ291bnQnLCAnY29sdW1ucycsICdmbGV4JywgJ2ZsZXhHcm93JywgJ2ZsZXhQb3NpdGl2ZScsICdmbGV4U2hyaW5rJywgJ2ZsZXhOZWdhdGl2ZScsICdmbGV4T3JkZXInLCAnZ3JpZEFyZWEnLCAnZ3JpZFJvdycsICdncmlkUm93RW5kJywgJ2dyaWRSb3dTcGFuJywgJ2dyaWRSb3dTdGFydCcsICdncmlkQ29sdW1uJywgJ2dyaWRDb2x1bW5FbmQnLCAnZ3JpZENvbHVtblNwYW4nLCAnZ3JpZENvbHVtblN0YXJ0JywgJ2ZvbnRXZWlnaHQnLCAnbGluZUNsYW1wJywgJ2xpbmVIZWlnaHQnLCAnb3BhY2l0eScsICdvcmRlcicsICdvcnBoYW5zJywgJ3NjYWxlJywgJ3RhYlNpemUnLCAnd2lkb3dzJywgJ3pJbmRleCcsICd6b29tJywgJ2ZpbGxPcGFjaXR5JywgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuJ2Zsb29kT3BhY2l0eScsICdzdG9wT3BhY2l0eScsICdzdHJva2VEYXNoYXJyYXknLCAnc3Ryb2tlRGFzaG9mZnNldCcsICdzdHJva2VNaXRlcmxpbWl0JywgJ3N0cm9rZU9wYWNpdHknLCAnc3Ryb2tlV2lkdGgnLCAnTW96QW5pbWF0aW9uSXRlcmF0aW9uQ291bnQnLCAvLyBLbm93biBQcmVmaXhlZCBQcm9wZXJ0aWVzXG4nTW96Qm94RmxleCcsIC8vIFRPRE86IFJlbW92ZSB0aGVzZSBzaW5jZSB0aGV5IHNob3VsZG4ndCBiZSB1c2VkIGluIG1vZGVybiBjb2RlXG4nTW96Qm94RmxleEdyb3VwJywgJ01vekxpbmVDbGFtcCcsICdtc0FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50JywgJ21zRmxleCcsICdtc1pvb20nLCAnbXNGbGV4R3JvdycsICdtc0ZsZXhOZWdhdGl2ZScsICdtc0ZsZXhPcmRlcicsICdtc0ZsZXhQb3NpdGl2ZScsICdtc0ZsZXhTaHJpbmsnLCAnbXNHcmlkQ29sdW1uJywgJ21zR3JpZENvbHVtblNwYW4nLCAnbXNHcmlkUm93JywgJ21zR3JpZFJvd1NwYW4nLCAnV2Via2l0QW5pbWF0aW9uSXRlcmF0aW9uQ291bnQnLCAnV2Via2l0Qm94RmxleCcsICdXZWJLaXRCb3hGbGV4R3JvdXAnLCAnV2Via2l0Qm94T3JkaW5hbEdyb3VwJywgJ1dlYmtpdENvbHVtbkNvdW50JywgJ1dlYmtpdENvbHVtbnMnLCAnV2Via2l0RmxleCcsICdXZWJraXRGbGV4R3JvdycsICdXZWJraXRGbGV4UG9zaXRpdmUnLCAnV2Via2l0RmxleFNocmluaycsICdXZWJraXRMaW5lQ2xhbXAnXSk7XG5mdW5jdGlvbiBpc1VuaXRsZXNzTnVtYmVyIChuYW1lKSB7XG4gIHJldHVybiB1bml0bGVzc051bWJlcnMuaGFzKG5hbWUpO1xufVxuXG52YXIgYWxpYXNlcyA9IG5ldyBNYXAoW1snYWNjZXB0Q2hhcnNldCcsICdhY2NlcHQtY2hhcnNldCddLCBbJ2h0bWxGb3InLCAnZm9yJ10sIFsnaHR0cEVxdWl2JywgJ2h0dHAtZXF1aXYnXSwgLy8gSFRNTCBhbmQgU1ZHIGF0dHJpYnV0ZXMsIGJ1dCB0aGUgU1ZHIGF0dHJpYnV0ZSBpcyBjYXNlIHNlbnNpdGl2ZS5dLFxuWydjcm9zc09yaWdpbicsICdjcm9zc29yaWdpbiddLCAvLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLlxuLy8gUmVndWxhciBhdHRyaWJ1dGVzIHRoYXQganVzdCBhY2NlcHQgc3RyaW5ncy5dLFxuWydhY2NlbnRIZWlnaHQnLCAnYWNjZW50LWhlaWdodCddLCBbJ2FsaWdubWVudEJhc2VsaW5lJywgJ2FsaWdubWVudC1iYXNlbGluZSddLCBbJ2FyYWJpY0Zvcm0nLCAnYXJhYmljLWZvcm0nXSwgWydiYXNlbGluZVNoaWZ0JywgJ2Jhc2VsaW5lLXNoaWZ0J10sIFsnY2FwSGVpZ2h0JywgJ2NhcC1oZWlnaHQnXSwgWydjbGlwUGF0aCcsICdjbGlwLXBhdGgnXSwgWydjbGlwUnVsZScsICdjbGlwLXJ1bGUnXSwgWydjb2xvckludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbiddLCBbJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJ10sIFsnY29sb3JQcm9maWxlJywgJ2NvbG9yLXByb2ZpbGUnXSwgWydjb2xvclJlbmRlcmluZycsICdjb2xvci1yZW5kZXJpbmcnXSwgWydkb21pbmFudEJhc2VsaW5lJywgJ2RvbWluYW50LWJhc2VsaW5lJ10sIFsnZW5hYmxlQmFja2dyb3VuZCcsICdlbmFibGUtYmFja2dyb3VuZCddLCBbJ2ZpbGxPcGFjaXR5JywgJ2ZpbGwtb3BhY2l0eSddLCBbJ2ZpbGxSdWxlJywgJ2ZpbGwtcnVsZSddLCBbJ2Zsb29kQ29sb3InLCAnZmxvb2QtY29sb3InXSwgWydmbG9vZE9wYWNpdHknLCAnZmxvb2Qtb3BhY2l0eSddLCBbJ2ZvbnRGYW1pbHknLCAnZm9udC1mYW1pbHknXSwgWydmb250U2l6ZScsICdmb250LXNpemUnXSwgWydmb250U2l6ZUFkanVzdCcsICdmb250LXNpemUtYWRqdXN0J10sIFsnZm9udFN0cmV0Y2gnLCAnZm9udC1zdHJldGNoJ10sIFsnZm9udFN0eWxlJywgJ2ZvbnQtc3R5bGUnXSwgWydmb250VmFyaWFudCcsICdmb250LXZhcmlhbnQnXSwgWydmb250V2VpZ2h0JywgJ2ZvbnQtd2VpZ2h0J10sIFsnZ2x5cGhOYW1lJywgJ2dseXBoLW5hbWUnXSwgWydnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJ10sIFsnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJywgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJ10sIFsnaG9yaXpBZHZYJywgJ2hvcml6LWFkdi14J10sIFsnaG9yaXpPcmlnaW5YJywgJ2hvcml6LW9yaWdpbi14J10sIFsnaW1hZ2VSZW5kZXJpbmcnLCAnaW1hZ2UtcmVuZGVyaW5nJ10sIFsnbGV0dGVyU3BhY2luZycsICdsZXR0ZXItc3BhY2luZyddLCBbJ2xpZ2h0aW5nQ29sb3InLCAnbGlnaHRpbmctY29sb3InXSwgWydtYXJrZXJFbmQnLCAnbWFya2VyLWVuZCddLCBbJ21hcmtlck1pZCcsICdtYXJrZXItbWlkJ10sIFsnbWFya2VyU3RhcnQnLCAnbWFya2VyLXN0YXJ0J10sIFsnb3ZlcmxpbmVQb3NpdGlvbicsICdvdmVybGluZS1wb3NpdGlvbiddLCBbJ292ZXJsaW5lVGhpY2tuZXNzJywgJ292ZXJsaW5lLXRoaWNrbmVzcyddLCBbJ3BhaW50T3JkZXInLCAncGFpbnQtb3JkZXInXSwgWydwYW5vc2UtMScsICdwYW5vc2UtMSddLCBbJ3BvaW50ZXJFdmVudHMnLCAncG9pbnRlci1ldmVudHMnXSwgWydyZW5kZXJpbmdJbnRlbnQnLCAncmVuZGVyaW5nLWludGVudCddLCBbJ3NoYXBlUmVuZGVyaW5nJywgJ3NoYXBlLXJlbmRlcmluZyddLCBbJ3N0b3BDb2xvcicsICdzdG9wLWNvbG9yJ10sIFsnc3RvcE9wYWNpdHknLCAnc3RvcC1vcGFjaXR5J10sIFsnc3RyaWtldGhyb3VnaFBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nXSwgWydzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJywgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJ10sIFsnc3Ryb2tlRGFzaGFycmF5JywgJ3N0cm9rZS1kYXNoYXJyYXknXSwgWydzdHJva2VEYXNob2Zmc2V0JywgJ3N0cm9rZS1kYXNob2Zmc2V0J10sIFsnc3Ryb2tlTGluZWNhcCcsICdzdHJva2UtbGluZWNhcCddLCBbJ3N0cm9rZUxpbmVqb2luJywgJ3N0cm9rZS1saW5lam9pbiddLCBbJ3N0cm9rZU1pdGVybGltaXQnLCAnc3Ryb2tlLW1pdGVybGltaXQnXSwgWydzdHJva2VPcGFjaXR5JywgJ3N0cm9rZS1vcGFjaXR5J10sIFsnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlLXdpZHRoJ10sIFsndGV4dEFuY2hvcicsICd0ZXh0LWFuY2hvciddLCBbJ3RleHREZWNvcmF0aW9uJywgJ3RleHQtZGVjb3JhdGlvbiddLCBbJ3RleHRSZW5kZXJpbmcnLCAndGV4dC1yZW5kZXJpbmcnXSwgWyd0cmFuc2Zvcm1PcmlnaW4nLCAndHJhbnNmb3JtLW9yaWdpbiddLCBbJ3VuZGVybGluZVBvc2l0aW9uJywgJ3VuZGVybGluZS1wb3NpdGlvbiddLCBbJ3VuZGVybGluZVRoaWNrbmVzcycsICd1bmRlcmxpbmUtdGhpY2tuZXNzJ10sIFsndW5pY29kZUJpZGknLCAndW5pY29kZS1iaWRpJ10sIFsndW5pY29kZVJhbmdlJywgJ3VuaWNvZGUtcmFuZ2UnXSwgWyd1bml0c1BlckVtJywgJ3VuaXRzLXBlci1lbSddLCBbJ3ZBbHBoYWJldGljJywgJ3YtYWxwaGFiZXRpYyddLCBbJ3ZIYW5naW5nJywgJ3YtaGFuZ2luZyddLCBbJ3ZJZGVvZ3JhcGhpYycsICd2LWlkZW9ncmFwaGljJ10sIFsndk1hdGhlbWF0aWNhbCcsICd2LW1hdGhlbWF0aWNhbCddLCBbJ3ZlY3RvckVmZmVjdCcsICd2ZWN0b3ItZWZmZWN0J10sIFsndmVydEFkdlknLCAndmVydC1hZHYteSddLCBbJ3ZlcnRPcmlnaW5YJywgJ3ZlcnQtb3JpZ2luLXgnXSwgWyd2ZXJ0T3JpZ2luWScsICd2ZXJ0LW9yaWdpbi15J10sIFsnd29yZFNwYWNpbmcnLCAnd29yZC1zcGFjaW5nJ10sIFsnd3JpdGluZ01vZGUnLCAnd3JpdGluZy1tb2RlJ10sIFsneG1sbnNYbGluaycsICd4bWxuczp4bGluayddLCBbJ3hIZWlnaHQnLCAneC1oZWlnaHQnXV0pO1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlQWxpYXMgKG5hbWUpIHtcbiAgcmV0dXJuIGFsaWFzZXMuZ2V0KG5hbWUpIHx8IG5hbWU7XG59XG5cbnZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICBidXR0b246IHRydWUsXG4gIGNoZWNrYm94OiB0cnVlLFxuICBpbWFnZTogdHJ1ZSxcbiAgaGlkZGVuOiB0cnVlLFxuICByYWRpbzogdHJ1ZSxcbiAgcmVzZXQ6IHRydWUsXG4gIHN1Ym1pdDogdHJ1ZVxufTtcbmZ1bmN0aW9uIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHModGFnTmFtZSwgcHJvcHMpIHtcbiAge1xuICAgIGlmICghKGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMub25JbnB1dCB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy52YWx1ZSA9PSBudWxsKSkge1xuICAgICAgaWYgKHRhZ05hbWUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIGVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCBzZXQgYG9uQ2hhbmdlYC4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCBzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIShwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5jaGVja2VkID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWRlc2NyaXB0aW9uJzogMCxcbiAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICdhcmlhLWRpc2FibGVkJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtaGlkZGVuJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtaW52YWxpZCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICdhcmlhLWxhYmVsJzogMCxcbiAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogMCxcbiAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgJ2FyaWEtaGFzcG9wdXAnOiAwLFxuICAnYXJpYS1sZXZlbCc6IDAsXG4gICdhcmlhLW1vZGFsJzogMCxcbiAgJ2FyaWEtbXVsdGlsaW5lJzogMCxcbiAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAnYXJpYS1wbGFjZWhvbGRlcic6IDAsXG4gICdhcmlhLXByZXNzZWQnOiAwLFxuICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICdhcmlhLXJlcXVpcmVkJzogMCxcbiAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAnYXJpYS1zb3J0JzogMCxcbiAgJ2FyaWEtdmFsdWVtYXgnOiAwLFxuICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICdhcmlhLXZhbHVlbm93JzogMCxcbiAgJ2FyaWEtdmFsdWV0ZXh0JzogMCxcbiAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAnYXJpYS1hdG9taWMnOiAwLFxuICAnYXJpYS1idXN5JzogMCxcbiAgJ2FyaWEtbGl2ZSc6IDAsXG4gICdhcmlhLXJlbGV2YW50JzogMCxcbiAgLy8gRHJhZy1hbmQtRHJvcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgLy8gUmVsYXRpb25zaGlwIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICdhcmlhLWNvbGNvdW50JzogMCxcbiAgJ2FyaWEtY29saW5kZXgnOiAwLFxuICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAnYXJpYS1kZXNjcmliZWRieSc6IDAsXG4gICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICdhcmlhLWZsb3d0byc6IDAsXG4gICdhcmlhLWxhYmVsbGVkYnknOiAwLFxuICAnYXJpYS1vd25zJzogMCxcbiAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAnYXJpYS1yb3djb3VudCc6IDAsXG4gICdhcmlhLXJvd2luZGV4JzogMCxcbiAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICdhcmlhLXNldHNpemUnOiAwXG59O1xuXG52YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG52YXIgckFSSUEkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSQxKHRhZ05hbWUsIG5hbWUpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMkMSwgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllcyQxW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAockFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHZhciBhcmlhTmFtZSA9ICdhcmlhLScgKyBuYW1lLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgY29ycmVjdE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShhcmlhTmFtZSkgPyBhcmlhTmFtZSA6IG51bGw7IC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuXG4gICAgICBpZiAoY29ycmVjdE5hbWUgPT0gbnVsbCkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBBUklBIGF0dHJpYnV0ZXMgZm9sbG93IHRoZSBwYXR0ZXJuIGFyaWEtKiBhbmQgbXVzdCBiZSBsb3dlcmNhc2UuJywgbmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBjb3JyZWN0TmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJBUklBJDEudGVzdChuYW1lKSkge1xuICAgICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogbnVsbDsgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5cbiAgICAgIGlmIChzdGFuZGFyZE5hbWUgPT0gbnVsbCkge1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5JDEodHlwZSwga2V5KTtcblxuICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gaW52YWxpZFByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gICAgfSkuam9pbignLCAnKTtcblxuICAgIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCBhcmlhIHByb3AgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1hcmlhLXByb3BzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH0gZWxzZSBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1hcmlhLXByb3BzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUVsZW1lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIC8vIFRoZXNlIGFyZSByZXNlcnZlZCBTVkcgYW5kIE1hdGhNTCBlbGVtZW50cy5cbiAgICAvLyBXZSBkb24ndCBtaW5kIHRoaXMgbGlzdCB0b28gbXVjaCBiZWNhdXNlIHdlIGV4cGVjdCBpdCB0byBuZXZlciBncm93LlxuICAgIC8vIFRoZSBhbHRlcm5hdGl2ZSBpcyB0byB0cmFjayB0aGUgbmFtZXNwYWNlIGluIGEgZmV3IHBsYWNlcyB3aGljaCBpcyBjb252b2x1dGVkLlxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuICAgIGNhc2UgJ2Fubm90YXRpb24teG1sJzpcbiAgICBjYXNlICdjb2xvci1wcm9maWxlJzpcbiAgICBjYXNlICdmb250LWZhY2UnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1zcmMnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS11cmknOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1mb3JtYXQnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1uYW1lJzpcbiAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoZSBIVE1MIG9yIFNWRyBhbGxvd2VkIGF0dHJpYnV0ZSBsaXN0LCBiZSBzdXJlIHRvXG4vLyBhbHNvIGFkZCB0aGVtIHRvIHRoaXMgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdCBuYW1lXG4vLyB3YXJuaW5ncy5cbnZhciBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgY2xhc3M6ICdjbGFzc05hbWUnLFxuICBjbGFzc2lkOiAnY2xhc3NJRCcsXG4gIGNsYXNzbmFtZTogJ2NsYXNzTmFtZScsXG4gIGNvbHM6ICdjb2xzJyxcbiAgY29sc3BhbjogJ2NvbFNwYW4nLFxuICBjb250ZW50OiAnY29udGVudCcsXG4gIGNvbnRlbnRlZGl0YWJsZTogJ2NvbnRlbnRFZGl0YWJsZScsXG4gIGNvbnRleHRtZW51OiAnY29udGV4dE1lbnUnLFxuICBjb250cm9sczogJ2NvbnRyb2xzJyxcbiAgY29udHJvbHNsaXN0OiAnY29udHJvbHNMaXN0JyxcbiAgY29vcmRzOiAnY29vcmRzJyxcbiAgY3Jvc3NvcmlnaW46ICdjcm9zc09yaWdpbicsXG4gIGRhbmdlcm91c2x5c2V0aW5uZXJodG1sOiAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxuICBkYXRhOiAnZGF0YScsXG4gIGRhdGV0aW1lOiAnZGF0ZVRpbWUnLFxuICBkZWZhdWx0OiAnZGVmYXVsdCcsXG4gIGRlZmF1bHRjaGVja2VkOiAnZGVmYXVsdENoZWNrZWQnLFxuICBkZWZhdWx0dmFsdWU6ICdkZWZhdWx0VmFsdWUnLFxuICBkZWZlcjogJ2RlZmVyJyxcbiAgZGlyOiAnZGlyJyxcbiAgZGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG4gIGRpc2FibGVwaWN0dXJlaW5waWN0dXJlOiAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnLFxuICBkaXNhYmxlcmVtb3RlcGxheWJhY2s6ICdkaXNhYmxlUmVtb3RlUGxheWJhY2snLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICBlbnRlcmtleWhpbnQ6ICdlbnRlcktleUhpbnQnLFxuICBmZXRjaHByaW9yaXR5OiAnZmV0Y2hQcmlvcml0eScsXG4gIGZvcjogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGltYWdlc2l6ZXM6ICdpbWFnZVNpemVzJyxcbiAgaW1hZ2VzcmNzZXQ6ICdpbWFnZVNyY1NldCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub21vZHVsZTogJ25vTW9kdWxlJyxcbiAgbm9uY2U6ICdub25jZScsXG4gIG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcbiAgb3BlbjogJ29wZW4nLFxuICBvcHRpbXVtOiAnb3B0aW11bScsXG4gIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgcGxhY2Vob2xkZXI6ICdwbGFjZWhvbGRlcicsXG4gIHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuICBwb3N0ZXI6ICdwb3N0ZXInLFxuICBwcmVsb2FkOiAncHJlbG9hZCcsXG4gIHByb2ZpbGU6ICdwcm9maWxlJyxcbiAgcmFkaW9ncm91cDogJ3JhZGlvR3JvdXAnLFxuICByZWFkb25seTogJ3JlYWRPbmx5JyxcbiAgcmVmZXJyZXJwb2xpY3k6ICdyZWZlcnJlclBvbGljeScsXG4gIHJlbDogJ3JlbCcsXG4gIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICByZXZlcnNlZDogJ3JldmVyc2VkJyxcbiAgcm9sZTogJ3JvbGUnLFxuICByb3dzOiAncm93cycsXG4gIHJvd3NwYW46ICdyb3dTcGFuJyxcbiAgc2FuZGJveDogJ3NhbmRib3gnLFxuICBzY29wZTogJ3Njb3BlJyxcbiAgc2NvcGVkOiAnc2NvcGVkJyxcbiAgc2Nyb2xsaW5nOiAnc2Nyb2xsaW5nJyxcbiAgc2VhbWxlc3M6ICdzZWFtbGVzcycsXG4gIHNlbGVjdGVkOiAnc2VsZWN0ZWQnLFxuICBzaGFwZTogJ3NoYXBlJyxcbiAgc2l6ZTogJ3NpemUnLFxuICBzaXplczogJ3NpemVzJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzcGVsbGNoZWNrOiAnc3BlbGxDaGVjaycsXG4gIHNyYzogJ3NyYycsXG4gIHNyY2RvYzogJ3NyY0RvYycsXG4gIHNyY2xhbmc6ICdzcmNMYW5nJyxcbiAgc3Jjc2V0OiAnc3JjU2V0JyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIHN0ZXA6ICdzdGVwJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgdGFiaW5kZXg6ICd0YWJJbmRleCcsXG4gIHRhcmdldDogJ3RhcmdldCcsXG4gIHRpdGxlOiAndGl0bGUnLFxuICB0eXBlOiAndHlwZScsXG4gIHVzZW1hcDogJ3VzZU1hcCcsXG4gIHZhbHVlOiAndmFsdWUnLFxuICB3aWR0aDogJ3dpZHRoJyxcbiAgd21vZGU6ICd3bW9kZScsXG4gIHdyYXA6ICd3cmFwJyxcbiAgLy8gU1ZHXG4gIGFib3V0OiAnYWJvdXQnLFxuICBhY2NlbnRoZWlnaHQ6ICdhY2NlbnRIZWlnaHQnLFxuICAnYWNjZW50LWhlaWdodCc6ICdhY2NlbnRIZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAnYWNjdW11bGF0ZScsXG4gIGFkZGl0aXZlOiAnYWRkaXRpdmUnLFxuICBhbGlnbm1lbnRiYXNlbGluZTogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gIGFsbG93cmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6ICdhbHBoYWJldGljJyxcbiAgYW1wbGl0dWRlOiAnYW1wbGl0dWRlJyxcbiAgYXJhYmljZm9ybTogJ2FyYWJpY0Zvcm0nLFxuICAnYXJhYmljLWZvcm0nOiAnYXJhYmljRm9ybScsXG4gIGFzY2VudDogJ2FzY2VudCcsXG4gIGF0dHJpYnV0ZW5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRldHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvcmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogJ2F6aW11dGgnLFxuICBiYXNlZnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VsaW5lc2hpZnQ6ICdiYXNlbGluZVNoaWZ0JyxcbiAgJ2Jhc2VsaW5lLXNoaWZ0JzogJ2Jhc2VsaW5lU2hpZnQnLFxuICBiYXNlcHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmJveDogJ2Jib3gnLFxuICBiZWdpbjogJ2JlZ2luJyxcbiAgYmlhczogJ2JpYXMnLFxuICBieTogJ2J5JyxcbiAgY2FsY21vZGU6ICdjYWxjTW9kZScsXG4gIGNhcGhlaWdodDogJ2NhcEhlaWdodCcsXG4gICdjYXAtaGVpZ2h0JzogJ2NhcEhlaWdodCcsXG4gIGNsaXA6ICdjbGlwJyxcbiAgY2xpcHBhdGg6ICdjbGlwUGF0aCcsXG4gICdjbGlwLXBhdGgnOiAnY2xpcFBhdGgnLFxuICBjbGlwcGF0aHVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNsaXBydWxlOiAnY2xpcFJ1bGUnLFxuICAnY2xpcC1ydWxlJzogJ2NsaXBSdWxlJyxcbiAgY29sb3I6ICdjb2xvcicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbjogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uJzogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnM6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyc6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgY29sb3Jwcm9maWxlOiAnY29sb3JQcm9maWxlJyxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAnY29sb3JQcm9maWxlJyxcbiAgY29sb3JyZW5kZXJpbmc6ICdjb2xvclJlbmRlcmluZycsXG4gICdjb2xvci1yZW5kZXJpbmcnOiAnY29sb3JSZW5kZXJpbmcnLFxuICBjb250ZW50c2NyaXB0dHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudHN0eWxldHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6ICdjdXJzb3InLFxuICBjeDogJ2N4JyxcbiAgY3k6ICdjeScsXG4gIGQ6ICdkJyxcbiAgZGF0YXR5cGU6ICdkYXRhdHlwZScsXG4gIGRlY2VsZXJhdGU6ICdkZWNlbGVyYXRlJyxcbiAgZGVzY2VudDogJ2Rlc2NlbnQnLFxuICBkaWZmdXNlY29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246ICdkaXJlY3Rpb24nLFxuICBkaXNwbGF5OiAnZGlzcGxheScsXG4gIGRpdmlzb3I6ICdkaXZpc29yJyxcbiAgZG9taW5hbnRiYXNlbGluZTogJ2RvbWluYW50QmFzZWxpbmUnLFxuICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnZG9taW5hbnRCYXNlbGluZScsXG4gIGR1cjogJ2R1cicsXG4gIGR4OiAnZHgnLFxuICBkeTogJ2R5JyxcbiAgZWRnZW1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogJ2VsZXZhdGlvbicsXG4gIGVuYWJsZWJhY2tncm91bmQ6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogJ2VuYWJsZUJhY2tncm91bmQnLFxuICBlbmQ6ICdlbmQnLFxuICBleHBvbmVudDogJ2V4cG9uZW50JyxcbiAgZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAnZmlsbCcsXG4gIGZpbGxvcGFjaXR5OiAnZmlsbE9wYWNpdHknLFxuICAnZmlsbC1vcGFjaXR5JzogJ2ZpbGxPcGFjaXR5JyxcbiAgZmlsbHJ1bGU6ICdmaWxsUnVsZScsXG4gICdmaWxsLXJ1bGUnOiAnZmlsbFJ1bGUnLFxuICBmaWx0ZXI6ICdmaWx0ZXInLFxuICBmaWx0ZXJyZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJ1bml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RvcGFjaXR5OiAnZmxvb2RPcGFjaXR5JyxcbiAgJ2Zsb29kLW9wYWNpdHknOiAnZmxvb2RPcGFjaXR5JyxcbiAgZmxvb2Rjb2xvcjogJ2Zsb29kQ29sb3InLFxuICAnZmxvb2QtY29sb3InOiAnZmxvb2RDb2xvcicsXG4gIGZvY3VzYWJsZTogJ2ZvY3VzYWJsZScsXG4gIGZvbnRmYW1pbHk6ICdmb250RmFtaWx5JyxcbiAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICBmb250c2l6ZTogJ2ZvbnRTaXplJyxcbiAgJ2ZvbnQtc2l6ZSc6ICdmb250U2l6ZScsXG4gIGZvbnRzaXplYWRqdXN0OiAnZm9udFNpemVBZGp1c3QnLFxuICAnZm9udC1zaXplLWFkanVzdCc6ICdmb250U2l6ZUFkanVzdCcsXG4gIGZvbnRzdHJldGNoOiAnZm9udFN0cmV0Y2gnLFxuICAnZm9udC1zdHJldGNoJzogJ2ZvbnRTdHJldGNoJyxcbiAgZm9udHN0eWxlOiAnZm9udFN0eWxlJyxcbiAgJ2ZvbnQtc3R5bGUnOiAnZm9udFN0eWxlJyxcbiAgZm9udHZhcmlhbnQ6ICdmb250VmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQnOiAnZm9udFZhcmlhbnQnLFxuICBmb250d2VpZ2h0OiAnZm9udFdlaWdodCcsXG4gICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgZm9ybWF0OiAnZm9ybWF0JyxcbiAgZnJvbTogJ2Zyb20nLFxuICBmeDogJ2Z4JyxcbiAgZnk6ICdmeScsXG4gIGcxOiAnZzEnLFxuICBnMjogJ2cyJyxcbiAgZ2x5cGhuYW1lOiAnZ2x5cGhOYW1lJyxcbiAgJ2dseXBoLW5hbWUnOiAnZ2x5cGhOYW1lJyxcbiAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJzogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gIGdseXBocmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudHRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnR1bml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAnaGFuZ2luZycsXG4gIGhvcml6YWR2eDogJ2hvcml6QWR2WCcsXG4gICdob3Jpei1hZHYteCc6ICdob3JpekFkdlgnLFxuICBob3Jpem9yaWdpbng6ICdob3Jpek9yaWdpblgnLFxuICAnaG9yaXotb3JpZ2luLXgnOiAnaG9yaXpPcmlnaW5YJyxcbiAgaWRlb2dyYXBoaWM6ICdpZGVvZ3JhcGhpYycsXG4gIGltYWdlcmVuZGVyaW5nOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgaW4yOiAnaW4yJyxcbiAgaW46ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gIHRyYW5zZm9ybW9yaWdpbjogJ3RyYW5zZm9ybU9yaWdpbicsXG4gICd0cmFuc2Zvcm0tb3JpZ2luJzogJ3RyYW5zZm9ybU9yaWdpbicsXG4gIHR5cGVvZjogJ3R5cGVvZicsXG4gIHUxOiAndTEnLFxuICB1MjogJ3UyJyxcbiAgdW5kZXJsaW5lcG9zaXRpb246ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gICd1bmRlcmxpbmUtcG9zaXRpb24nOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICB1bmRlcmxpbmV0aGlja25lc3M6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICAndW5kZXJsaW5lLXRoaWNrbmVzcyc6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICB1bmljb2RlOiAndW5pY29kZScsXG4gIHVuaWNvZGViaWRpOiAndW5pY29kZUJpZGknLFxuICAndW5pY29kZS1iaWRpJzogJ3VuaWNvZGVCaWRpJyxcbiAgdW5pY29kZXJhbmdlOiAndW5pY29kZVJhbmdlJyxcbiAgJ3VuaWNvZGUtcmFuZ2UnOiAndW5pY29kZVJhbmdlJyxcbiAgdW5pdHNwZXJlbTogJ3VuaXRzUGVyRW0nLFxuICAndW5pdHMtcGVyLWVtJzogJ3VuaXRzUGVyRW0nLFxuICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnLFxuICB2YWxwaGFiZXRpYzogJ3ZBbHBoYWJldGljJyxcbiAgJ3YtYWxwaGFiZXRpYyc6ICd2QWxwaGFiZXRpYycsXG4gIHZhbHVlczogJ3ZhbHVlcycsXG4gIHZlY3RvcmVmZmVjdDogJ3ZlY3RvckVmZmVjdCcsXG4gICd2ZWN0b3ItZWZmZWN0JzogJ3ZlY3RvckVmZmVjdCcsXG4gIHZlcnNpb246ICd2ZXJzaW9uJyxcbiAgdmVydGFkdnk6ICd2ZXJ0QWR2WScsXG4gICd2ZXJ0LWFkdi15JzogJ3ZlcnRBZHZZJyxcbiAgdmVydG9yaWdpbng6ICd2ZXJ0T3JpZ2luWCcsXG4gICd2ZXJ0LW9yaWdpbi14JzogJ3ZlcnRPcmlnaW5YJyxcbiAgdmVydG9yaWdpbnk6ICd2ZXJ0T3JpZ2luWScsXG4gICd2ZXJ0LW9yaWdpbi15JzogJ3ZlcnRPcmlnaW5ZJyxcbiAgdmhhbmdpbmc6ICd2SGFuZ2luZycsXG4gICd2LWhhbmdpbmcnOiAndkhhbmdpbmcnLFxuICB2aWRlb2dyYXBoaWM6ICd2SWRlb2dyYXBoaWMnLFxuICAndi1pZGVvZ3JhcGhpYyc6ICd2SWRlb2dyYXBoaWMnLFxuICB2aWV3Ym94OiAndmlld0JveCcsXG4gIHZpZXd0YXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogJ3Zpc2liaWxpdHknLFxuICB2bWF0aGVtYXRpY2FsOiAndk1hdGhlbWF0aWNhbCcsXG4gICd2LW1hdGhlbWF0aWNhbCc6ICd2TWF0aGVtYXRpY2FsJyxcbiAgdm9jYWI6ICd2b2NhYicsXG4gIHdpZHRoczogJ3dpZHRocycsXG4gIHdvcmRzcGFjaW5nOiAnd29yZFNwYWNpbmcnLFxuICAnd29yZC1zcGFjaW5nJzogJ3dvcmRTcGFjaW5nJyxcbiAgd3JpdGluZ21vZGU6ICd3cml0aW5nTW9kZScsXG4gICd3cml0aW5nLW1vZGUnOiAnd3JpdGluZ01vZGUnLFxuICB4MTogJ3gxJyxcbiAgeDI6ICd4MicsXG4gIHg6ICd4JyxcbiAgeGNoYW5uZWxzZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4aGVpZ2h0OiAneEhlaWdodCcsXG4gICd4LWhlaWdodCc6ICd4SGVpZ2h0JyxcbiAgeGxpbmthY3R1YXRlOiAneGxpbmtBY3R1YXRlJyxcbiAgJ3hsaW5rOmFjdHVhdGUnOiAneGxpbmtBY3R1YXRlJyxcbiAgeGxpbmthcmNyb2xlOiAneGxpbmtBcmNyb2xlJyxcbiAgJ3hsaW5rOmFyY3JvbGUnOiAneGxpbmtBcmNyb2xlJyxcbiAgeGxpbmtocmVmOiAneGxpbmtIcmVmJyxcbiAgJ3hsaW5rOmhyZWYnOiAneGxpbmtIcmVmJyxcbiAgeGxpbmtyb2xlOiAneGxpbmtSb2xlJyxcbiAgJ3hsaW5rOnJvbGUnOiAneGxpbmtSb2xlJyxcbiAgeGxpbmtzaG93OiAneGxpbmtTaG93JyxcbiAgJ3hsaW5rOnNob3cnOiAneGxpbmtTaG93JyxcbiAgeGxpbmt0aXRsZTogJ3hsaW5rVGl0bGUnLFxuICAneGxpbms6dGl0bGUnOiAneGxpbmtUaXRsZScsXG4gIHhsaW5rdHlwZTogJ3hsaW5rVHlwZScsXG4gICd4bGluazp0eXBlJzogJ3hsaW5rVHlwZScsXG4gIHhtbGJhc2U6ICd4bWxCYXNlJyxcbiAgJ3htbDpiYXNlJzogJ3htbEJhc2UnLFxuICB4bWxsYW5nOiAneG1sTGFuZycsXG4gICd4bWw6bGFuZyc6ICd4bWxMYW5nJyxcbiAgeG1sbnM6ICd4bWxucycsXG4gICd4bWw6c3BhY2UnOiAneG1sU3BhY2UnLFxuICB4bWxuc3hsaW5rOiAneG1sbnNYbGluaycsXG4gICd4bWxuczp4bGluayc6ICd4bWxuc1hsaW5rJyxcbiAgeG1sc3BhY2U6ICd4bWxTcGFjZScsXG4gIHkxOiAneTEnLFxuICB5MjogJ3kyJyxcbiAgeTogJ3knLFxuICB5Y2hhbm5lbHNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6ICd6JyxcbiAgem9vbWFuZHBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xudmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG52YXIgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYID0gL15vblteQS1aXS87XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKSA7XG52YXIgckFSSUFDYW1lbCA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKSA7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGV2ZW50UmVnaXN0cnkpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgZXJyb3IoJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gQWN0aW9ucyBhcmUgc3BlY2lhbCBiZWNhdXNlIHVubGlrZSBldmVudHMgdGhleSBjYW4gaGF2ZSBvdGhlciB2YWx1ZSB0eXBlcy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdmb3JtJyAmJiBuYW1lID09PSAnYWN0aW9uJykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdpbnB1dCcgJiYgbmFtZSA9PT0gJ2Zvcm1BY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ2J1dHRvbicgJiYgbmFtZSA9PT0gJ2Zvcm1BY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuXG5cbiAgICBpZiAoZXZlbnRSZWdpc3RyeSAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IGV2ZW50UmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcbiAgICAgICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gZXZlbnRSZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICBlcnJvcignVW5rbm93biBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIEl0IHdpbGwgYmUgaWdub3JlZC4nLCBuYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIElmIG5vIGV2ZW50IHBsdWdpbnMgaGF2ZSBiZWVuIGluamVjdGVkLCB3ZSBhcmUgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gICAgICAvLyBTbyB3ZSBjYW4ndCB0ZWxsIGlmIHRoZSBldmVudCBuYW1lIGlzIGNvcnJlY3QgZm9yIHN1cmUsIGJ1dCB3ZSBjYW4gZmlsdGVyXG4gICAgICAvLyBvdXQga25vd24gYmFkIG9uZXMgbGlrZSBgb25jbGlja2AuIFdlIGNhbid0IHN1Z2dlc3QgYSBzcGVjaWZpYyByZXBsYWNlbWVudCB0aG91Z2guXG4gICAgICBpZiAoSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiAnICsgJ1JlYWN0IGV2ZW50cyB1c2UgdGhlIGNhbWVsQ2FzZSBuYW1pbmcgY29udmVudGlvbiwgZm9yIGV4YW1wbGUgYG9uQ2xpY2tgLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuXG5cbiAgICBpZiAockFSSUEudGVzdChuYW1lKSB8fCByQVJJQUNhbWVsLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIGVycm9yKCdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIGVycm9yKCdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJywgdHlwZW9mIHZhbHVlKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCBuYW1lKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIEtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIG1hdGNoIHRoZSBjYXNpbmcgc3BlY2lmaWVkIGluIHRoZSBwcm9wZXJ0eSBjb25maWcuXG5cblxuICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lICE9PSBsb3dlckNhc2VkTmFtZSkge1xuICAgICAgLy8gVW5rbm93biBhdHRyaWJ1dGVzIHNob3VsZCBoYXZlIGxvd2VyY2FzZSBjYXNpbmcgc2luY2UgdGhhdCdzIGhvdyB0aGV5XG4gICAgICAvLyB3aWxsIGJlIGNhc2VkIGFueXdheSB3aXRoIHNlcnZlciByZW5kZXJpbmcuXG4gICAgICBlcnJvcignUmVhY3QgZG9lcyBub3QgcmVjb2duaXplIHRoZSBgJXNgIHByb3Agb24gYSBET00gZWxlbWVudC4gSWYgeW91ICcgKyAnaW50ZW50aW9uYWxseSB3YW50IGl0IHRvIGFwcGVhciBpbiB0aGUgRE9NIGFzIGEgY3VzdG9tICcgKyAnYXR0cmlidXRlLCBzcGVsbCBpdCBhcyBsb3dlcmNhc2UgYCVzYCBpbnN0ZWFkLiAnICsgJ0lmIHlvdSBhY2NpZGVudGFsbHkgcGFzc2VkIGl0IGZyb20gYSBwYXJlbnQgY29tcG9uZW50LCByZW1vdmUgJyArICdpdCBmcm9tIHRoZSBET00gZWxlbWVudC4nLCBuYW1lLCBsb3dlckNhc2VkTmFtZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBOb3cgdGhhdCB3ZSd2ZSB2YWxpZGF0ZWQgY2FzaW5nLCBkbyBub3QgdmFsaWRhdGVcbiAgICAvLyBkYXRhIHR5cGVzIGZvciByZXNlcnZlZCBwcm9wc1xuXG5cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgIGNhc2UgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc6XG4gICAgICBjYXNlICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnOlxuICAgICAgY2FzZSAnZGVmYXVsdFZhbHVlJzogLy8gUmVzZXJ2ZWRcblxuICAgICAgY2FzZSAnZGVmYXVsdENoZWNrZWQnOlxuICAgICAgY2FzZSAnaW5uZXJIVE1MJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHtcbiAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2F1dG9Gb2N1cyc6XG4gICAgICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICAgIGNhc2UgJ211bHRpcGxlJzpcbiAgICAgICAgICAgIGNhc2UgJ211dGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ3NlbGVjdGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRlbnRFZGl0YWJsZSc6XG4gICAgICAgICAgICBjYXNlICdzcGVsbENoZWNrJzpcbiAgICAgICAgICAgIGNhc2UgJ2RyYWdnYWJsZSc6XG4gICAgICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgICBjYXNlICdhdXRvUmV2ZXJzZSc6XG4gICAgICAgICAgICBjYXNlICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJzpcbiAgICAgICAgICAgIGNhc2UgJ2ZvY3VzYWJsZSc6XG4gICAgICAgICAgICBjYXNlICdwcmVzZXJ2ZUFscGhhJzpcbiAgICAgICAgICAgIGNhc2UgJ2FsbG93RnVsbFNjcmVlbic6XG4gICAgICAgICAgICBjYXNlICdhc3luYyc6XG4gICAgICAgICAgICBjYXNlICdhdXRvUGxheSc6XG4gICAgICAgICAgICBjYXNlICdjb250cm9scyc6XG4gICAgICAgICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgICAgIGNhc2UgJ2RlZmVyJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVSZW1vdGVQbGF5YmFjayc6XG4gICAgICAgICAgICBjYXNlICdmb3JtTm9WYWxpZGF0ZSc6XG4gICAgICAgICAgICBjYXNlICdoaWRkZW4nOlxuICAgICAgICAgICAgY2FzZSAnbG9vcCc6XG4gICAgICAgICAgICBjYXNlICdub01vZHVsZSc6XG4gICAgICAgICAgICBjYXNlICdub1ZhbGlkYXRlJzpcbiAgICAgICAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICAgICAgY2FzZSAncGxheXNJbmxpbmUnOlxuICAgICAgICAgICAgY2FzZSAncmVhZE9ubHknOlxuICAgICAgICAgICAgY2FzZSAncmVxdWlyZWQnOlxuICAgICAgICAgICAgY2FzZSAncmV2ZXJzZWQnOlxuICAgICAgICAgICAgY2FzZSAnc2NvcGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ3NlYW1sZXNzJzpcbiAgICAgICAgICAgIGNhc2UgJ2l0ZW1TY29wZSc6XG4gICAgICAgICAgICBjYXNlICdjYXB0dXJlJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rvd25sb2FkJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIEJvb2xlYW4gcHJvcGVydGllcyBjYW4gYWNjZXB0IGJvb2xlYW4gdmFsdWVzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJlZml4ID09PSAnZGF0YS0nIHx8IHByZWZpeCA9PT0gJ2FyaWEtJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIG5hbWUsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdhcm4gd2hlbiBwYXNzaW5nIHRoZSBzdHJpbmdzICdmYWxzZScgb3IgJ3RydWUnIGludG8gYSBib29sZWFuIHByb3BcbiAgICAgICAgICBpZiAodmFsdWUgPT09ICdmYWxzZScgfHwgdmFsdWUgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgICAgICBjYXNlICdzZWxlY3RlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ211bHRpcGxlJzpcbiAgICAgICAgICAgICAgY2FzZSAnbXV0ZWQnOlxuICAgICAgICAgICAgICBjYXNlICdhbGxvd0Z1bGxTY3JlZW4nOlxuICAgICAgICAgICAgICBjYXNlICdhc3luYyc6XG4gICAgICAgICAgICAgIGNhc2UgJ2F1dG9QbGF5JzpcbiAgICAgICAgICAgICAgY2FzZSAnY29udHJvbHMnOlxuICAgICAgICAgICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgICAgICAgY2FzZSAnZGVmZXInOlxuICAgICAgICAgICAgICBjYXNlICdkaXNhYmxlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJzpcbiAgICAgICAgICAgICAgY2FzZSAnZGlzYWJsZVJlbW90ZVBsYXliYWNrJzpcbiAgICAgICAgICAgICAgY2FzZSAnZm9ybU5vVmFsaWRhdGUnOlxuICAgICAgICAgICAgICBjYXNlICdoaWRkZW4nOlxuICAgICAgICAgICAgICBjYXNlICdsb29wJzpcbiAgICAgICAgICAgICAgY2FzZSAnbm9Nb2R1bGUnOlxuICAgICAgICAgICAgICBjYXNlICdub1ZhbGlkYXRlJzpcbiAgICAgICAgICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgICAgICAgIGNhc2UgJ3BsYXlzSW5saW5lJzpcbiAgICAgICAgICAgICAgY2FzZSAncmVhZE9ubHknOlxuICAgICAgICAgICAgICBjYXNlICdyZXF1aXJlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3JldmVyc2VkJzpcbiAgICAgICAgICAgICAgY2FzZSAnc2NvcGVkJzpcbiAgICAgICAgICAgICAgY2FzZSAnc2VhbWxlc3MnOlxuICAgICAgICAgICAgICBjYXNlICdpdGVtU2NvcGUnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3IoJ1JlY2VpdmVkIHRoZSBzdHJpbmcgYCVzYCBmb3IgdGhlIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuICcgKyAnJXMgJyArICdEaWQgeW91IG1lYW4gJXM9eyVzfT8nLCB2YWx1ZSwgbmFtZSwgdmFsdWUgPT09ICdmYWxzZScgPyAnVGhlIGJyb3dzZXIgd2lsbCBpbnRlcnByZXQgaXQgYXMgYSB0cnV0aHkgdmFsdWUuJyA6ICdBbHRob3VnaCB0aGlzIHdvcmtzLCBpdCB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIGlmIHlvdSBwYXNzIHRoZSBzdHJpbmcgXCJmYWxzZVwiLicsIG5hbWUsIHZhbHVlKTtcblxuICAgICAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAge1xuICAgIHZhciB1bmtub3duUHJvcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSwgcHJvcHNba2V5XSwgZXZlbnRSZWdpc3RyeSk7XG5cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmtub3duUHJvcFN0cmluZyA9IHVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIHRoZW0gaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAgaWYgKGlzQ3VzdG9tRWxlbWVudCh0eXBlKSB8fCB0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2FyblVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KTtcbn1cblxuLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxudmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcbnZhciBtc1BhdHRlcm4kMSA9IC9eLW1zLS87XG52YXIgaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7IC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuXG52YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XG52YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xudmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG52YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcbnZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUpIHtcbiAge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIC8vIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbiAgICAvLyAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gICAgLy8gaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICAgIGNhbWVsaXplKG5hbWUucmVwbGFjZShtc1BhdHRlcm4kMSwgJ21zLScpKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUpIHtcbiAge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG5cbiAgICBlcnJvcihcIlN0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gXCIgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2FybmVkRm9yTmFOVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XG5cbiAgICBlcnJvcignYE5hTmAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LicsIG5hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eShuYW1lLCB2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgSW5maW5pdHlgIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuVmFsaWRTdHlsZShuYW1lLCB2YWx1ZSkge1xuICB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUpO1xuICAgICAgfSBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eShuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q3Jvc3NPcmlnaW5TdHJpbmcoaW5wdXQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gaW5wdXQgPT09ICd1c2UtY3JlZGVudGlhbHMnID8gaW5wdXQgOiAnJztcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG52YXIgbWF0Y2hIdG1sUmVnRXhwID0gL1tcIicmPD5dLztcbi8qKlxuICogRXNjYXBlcyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIEhUTUwgZW50aXRpZXMgaW4gYSBnaXZlbiBodG1sIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0cmluZyBIVE1MIHN0cmluZyB0byBlc2NhcGUgZm9yIGxhdGVyIGluc2VydGlvblxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gIHtcbiAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihzdHJpbmcpO1xuICB9XG5cbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4O1xuICB2YXIgbGFzdEluZGV4ID0gMDtcblxuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICAvLyBcIlxuICAgICAgICBlc2NhcGUgPSAnJnF1b3Q7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIC8vICZcbiAgICAgICAgZXNjYXBlID0gJyZhbXA7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIC8vIDxcbiAgICAgICAgZXNjYXBlID0gJyZsdDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgaHRtbCArPSBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCk7XG4gICAgfVxuXG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgIGh0bWwgKz0gZXNjYXBlO1xuICB9XG5cbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn0gLy8gZW5kIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuXG4gIHJldHVybiBlc2NhcGVIdG1sKHRleHQpO1xufVxuXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKi9cblxuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxuLy8gYW5kIGFueSBuZXdsaW5lIG9yIHRhYiBhcmUgZmlsdGVyZWQgb3V0IGFzIGlmIHRoZXkncmUgbm90IHBhcnQgb2YgdGhlIFVSTC5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsLXBhcnNpbmdcbi8vIFRhYiBvciBuZXdsaW5lIGFyZSBkZWZpbmVkIGFzIFxcclxcblxcdDpcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS10YWItb3ItbmV3bGluZVxuLy8gQSBDMCBjb250cm9sIGlzIGEgY29kZSBwb2ludCBpbiB0aGUgcmFuZ2UgXFx1MDAwMCBOVUxMIHRvIFxcdTAwMUZcbi8vIElORk9STUFUSU9OIFNFUEFSQVRPUiBPTkUsIGluY2x1c2l2ZTpcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNjMC1jb250cm9sLW9yLXNwYWNlXG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxudmFyIGlzSmF2YVNjcmlwdFByb3RvY29sID0gL15bXFx1MDAwMC1cXHUwMDFGIF0qaltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSp2W1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnNbXFxyXFxuXFx0XSpjW1xcclxcblxcdF0qcltcXHJcXG5cXHRdKmlbXFxyXFxuXFx0XSpwW1xcclxcblxcdF0qdFtcXHJcXG5cXHRdKlxcOi9pO1xudmFyIGRpZFdhcm4gPSBmYWxzZTtcblxuZnVuY3Rpb24gc2FuaXRpemVVUkwodXJsKSB7XG4gIC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIHN5bWJvbHMgaGVyZSBiZWNhdXNlIHRoZXkgZ2V0IGZpbHRlcmVkIG91dCBlbHNld2hlcmUuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICB2YXIgc3RyaW5naWZpZWRVUkwgPSAnJyArIHVybDtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuICYmIGlzSmF2YVNjcmlwdFByb3RvY29sLnRlc3Qoc3RyaW5naWZpZWRVUkwpKSB7XG4gICAgICBkaWRXYXJuID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ0EgZnV0dXJlIHZlcnNpb24gb2YgUmVhY3Qgd2lsbCBibG9jayBqYXZhc2NyaXB0OiBVUkxzIGFzIGEgc2VjdXJpdHkgcHJlY2F1dGlvbi4gJyArICdVc2UgZXZlbnQgaGFuZGxlcnMgaW5zdGVhZCBpZiB5b3UgY2FuLiBJZiB5b3UgbmVlZCB0byBnZW5lcmF0ZSB1bnNhZmUgSFRNTCB0cnkgJyArICd1c2luZyBkYW5nZXJvdXNseVNldElubmVySFRNTCBpbnN0ZWFkLiBSZWFjdCB3YXMgcGFzc2VkICVzLicsIEpTT04uc3RyaW5naWZ5KHN0cmluZ2lmaWVkVVJMKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBUaGUgYnVpbGQgc2NyaXB0IGlzIGF0IHNjcmlwdHMvcm9sbHVwL2dlbmVyYXRlLWlubGluZS1maXp6LXJ1bnRpbWUuanMuXG4vLyBSdW4gYHlhcm4gZ2VuZXJhdGUtaW5saW5lLWZpenotcnVudGltZWAgdG8gZ2VuZXJhdGUuXG52YXIgY2xpZW50UmVuZGVyQm91bmRhcnkgPSAnJFJYPWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2EmJihiPWEucHJldmlvdXNTaWJsaW5nLGIuZGF0YT1cIiQhXCIsYT1hLmRhdGFzZXQsYyYmKGEuZGdzdD1jKSxkJiYoYS5tc2c9ZCksZSYmKGEuc3Rjaz1lKSxiLl9yZWFjdFJldHJ5JiZiLl9yZWFjdFJldHJ5KCkpfTsnO1xudmFyIGNvbXBsZXRlQm91bmRhcnkgPSAnJFJDPWZ1bmN0aW9uKGIsYyxlKXtjPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGMpO2MucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKTt2YXIgYT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKTtpZihhKXtiPWEucHJldmlvdXNTaWJsaW5nO2lmKGUpYi5kYXRhPVwiJCFcIixhLnNldEF0dHJpYnV0ZShcImRhdGEtZGdzdFwiLGUpO2Vsc2V7ZT1iLnBhcmVudE5vZGU7YT1iLm5leHRTaWJsaW5nO3ZhciBmPTA7ZG97aWYoYSYmOD09PWEubm9kZVR5cGUpe3ZhciBkPWEuZGF0YTtpZihcIi8kXCI9PT1kKWlmKDA9PT1mKWJyZWFrO2Vsc2UgZi0tO2Vsc2VcIiRcIiE9PWQmJlwiJD9cIiE9PWQmJlwiJCFcIiE9PWR8fGYrK31kPWEubmV4dFNpYmxpbmc7ZS5yZW1vdmVDaGlsZChhKTthPWR9d2hpbGUoYSk7Zm9yKDtjLmZpcnN0Q2hpbGQ7KWUuaW5zZXJ0QmVmb3JlKGMuZmlyc3RDaGlsZCxhKTtiLmRhdGE9XCIkXCJ9Yi5fcmVhY3RSZXRyeSYmYi5fcmVhY3RSZXRyeSgpfX07JztcbnZhciBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlcyA9ICckUk09bmV3IE1hcDtcXG4kUlI9ZnVuY3Rpb24ocix0LHcpe2Zvcih2YXIgdT0kUkMsbj0kUk0scD1uZXcgTWFwLHE9ZG9jdW1lbnQsZyxiLGg9cS5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1tkYXRhLXByZWNlZGVuY2VdLHN0eWxlW2RhdGEtcHJlY2VkZW5jZV1cIiksdj1bXSxrPTA7Yj1oW2srK107KVwibm90IGFsbFwiPT09Yi5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKT92LnB1c2goYik6KFwiTElOS1wiPT09Yi50YWdOYW1lJiZuLnNldChiLmdldEF0dHJpYnV0ZShcImhyZWZcIiksYikscC5zZXQoYi5kYXRhc2V0LnByZWNlZGVuY2UsZz1iKSk7Yj0wO2g9W107dmFyIGwsYTtmb3Ioaz0hMDs7KXtpZihrKXt2YXIgZj13W2IrK107aWYoIWYpe2s9ITE7Yj0wO2NvbnRpbnVlfXZhciBjPSExLG09MDt2YXIgZD1mW20rK107aWYoYT1uLmdldChkKSl7dmFyIGU9YS5fcDtjPSEwfWVsc2V7YT1xLmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO2EuaHJlZj1kO2EucmVsPVwic3R5bGVzaGVldFwiO2ZvcihhLmRhdGFzZXQucHJlY2VkZW5jZT1cXG5sPWZbbSsrXTtlPWZbbSsrXTspYS5zZXRBdHRyaWJ1dGUoZSxmW20rK10pO2U9YS5fcD1uZXcgUHJvbWlzZShmdW5jdGlvbih4LHkpe2Eub25sb2FkPXg7YS5vbmVycm9yPXl9KTtuLnNldChkLGEpfWQ9YS5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKTshZXx8XCJsXCI9PT1lLnN8fGQmJiFtYXRjaE1lZGlhKGQpLm1hdGNoZXN8fGgucHVzaChlKTtpZihjKWNvbnRpbnVlfWVsc2V7YT12W2IrK107aWYoIWEpYnJlYWs7bD1hLmdldEF0dHJpYnV0ZShcImRhdGEtcHJlY2VkZW5jZVwiKTthLnJlbW92ZUF0dHJpYnV0ZShcIm1lZGlhXCIpfWM9cC5nZXQobCl8fGc7Yz09PWcmJihnPWEpO3Auc2V0KGwsYSk7Yz9jLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsYy5uZXh0U2libGluZyk6KGM9cS5oZWFkLGMuaW5zZXJ0QmVmb3JlKGEsYy5maXJzdENoaWxkKSl9UHJvbWlzZS5hbGwoaCkudGhlbih1LmJpbmQobnVsbCxyLHQsXCJcIiksdS5iaW5kKG51bGwscix0LFwiUmVzb3VyY2UgZmFpbGVkIHRvIGxvYWRcIikpfTsnO1xudmFyIGNvbXBsZXRlU2VnbWVudCA9ICckUlM9ZnVuY3Rpb24oYSxiKXthPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpO2I9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7Zm9yKGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKTthLmZpcnN0Q2hpbGQ7KWIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYS5maXJzdENoaWxkLGIpO2IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKX07JztcbnZhciBmb3JtUmVwbGF5aW5nID0gJ2FkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIixmdW5jdGlvbihhKXtpZighYS5kZWZhdWx0UHJldmVudGVkKXt2YXIgYz1hLnRhcmdldCxkPWEuc3VibWl0dGVyLGU9Yy5hY3Rpb24sYj1kO2lmKGQpe3ZhciBmPWQuZ2V0QXR0cmlidXRlKFwiZm9ybUFjdGlvblwiKTtudWxsIT1mJiYoZT1mLGI9bnVsbCl9XCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcihcXCdBIFJlYWN0IGZvcm0gd2FzIHVuZXhwZWN0ZWRseSBzdWJtaXR0ZWQuXFwnKVwiPT09ZSYmKGEucHJldmVudERlZmF1bHQoKSxiPyhhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxhLm5hbWU9Yi5uYW1lLGEudmFsdWU9Yi52YWx1ZSxiLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsYiksYj1uZXcgRm9ybURhdGEoYyksYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpKTpiPW5ldyBGb3JtRGF0YShjKSxhPWMuZ2V0Um9vdE5vZGUoKSwoYS4kJHJlYWN0Rm9ybVJlcGxheT1hLiQkcmVhY3RGb3JtUmVwbGF5fHxbXSkucHVzaChjLFxcbmQsYikpfX0pOyc7XG5cbmZ1bmN0aW9uIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcodGhpbmcpIHtcbiAgcmV0dXJuIHRoaW5nID09PSBudWxsID8gJ2BudWxsYCcgOiB0aGluZyA9PT0gdW5kZWZpbmVkID8gJ2B1bmRlZmluZWRgJyA6IHRoaW5nID09PSAnJyA/ICdhbiBlbXB0eSBzdHJpbmcnIDogXCJzb21ldGhpbmcgd2l0aCB0eXBlIFxcXCJcIiArIHR5cGVvZiB0aGluZyArIFwiXFxcIlwiO1xufVxuXG4vLyBzYW1lIG9iamVjdCBhY3Jvc3MgYWxsIHRyYW5zaXRpb25zLlxuXG52YXIgc2hhcmVkTm90UGVuZGluZ09iamVjdCA9IHtcbiAgcGVuZGluZzogZmFsc2UsXG4gIGRhdGE6IG51bGwsXG4gIG1ldGhvZDogbnVsbCxcbiAgYWN0aW9uOiBudWxsXG59O1xudmFyIE5vdFBlbmRpbmcgPSBPYmplY3QuZnJlZXplKHNoYXJlZE5vdFBlbmRpbmdPYmplY3QpIDtcblxudmFyIFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzID0gUmVhY3RET00uX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbnZhciBSZWFjdERPTUN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMuRGlzcGF0Y2hlcjtcbnZhciBSZWFjdERPTVNlcnZlckRpc3BhdGNoZXIgPSB7XG4gIHByZWZldGNoRE5TOiBwcmVmZXRjaEROUyxcbiAgcHJlY29ubmVjdDogcHJlY29ubmVjdCxcbiAgcHJlbG9hZDogcHJlbG9hZCxcbiAgcHJlbG9hZE1vZHVsZTogcHJlbG9hZE1vZHVsZSxcbiAgcHJlaW5pdFN0eWxlOiBwcmVpbml0U3R5bGUsXG4gIHByZWluaXRTY3JpcHQ6IHByZWluaXRTY3JpcHQsXG4gIHByZWluaXRNb2R1bGVTY3JpcHQ6IHByZWluaXRNb2R1bGVTY3JpcHRcbn07XG5mdW5jdGlvbiBwcmVwYXJlSG9zdERpc3BhdGNoZXIoKSB7XG4gIFJlYWN0RE9NQ3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IFJlYWN0RE9NU2VydmVyRGlzcGF0Y2hlcjtcbn0gLy8gV2UgbWFrZSBldmVyeSBwcm9wZXJ0eSBvZiB0aGUgZGVzY3JpcHRvciBvcHRpb25hbCBiZWNhdXNlIGl0IGlzIG5vdCBhIGNvbnRyYWN0IHRoYXRcbnZhciBTY3JpcHRTdHJlYW1pbmdGb3JtYXQgPSAwO1xudmFyIERhdGFTdHJlYW1pbmdGb3JtYXQgPSAxO1xudmFyIE5vdGhpbmdTZW50XG4vKiAgICAgICAgICAgICAgICAgICAgICAqL1xuPSAwO1xudmFyIFNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvblxuLyogICAgICAqL1xuPSAxO1xudmFyIFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb25cbi8qICAgICAqL1xuPSAyO1xudmFyIFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvblxuLyogICAgICAgICAqL1xuPSA0O1xudmFyIFNlbnRTdHlsZUluc2VydGlvbkZ1bmN0aW9uXG4vKiAgICAgICAqL1xuPSA4O1xudmFyIFNlbnRGb3JtUmVwbGF5aW5nUnVudGltZVxuLyogICAgICAgICAqL1xuPSAxNjsgLy8gUGVyIHJlcXVlc3QsIGdsb2JhbCBzdGF0ZSB0aGF0IGlzIG5vdCBjb250ZXh0dWFsIHRvIHRoZSByZW5kZXJpbmcgc3VidHJlZS5cbi8vIFRoaXMgY2Fubm90IGJlIHJlc3VtZWQgYW5kIHRoZXJlZm9yZSBzaG91bGQgb25seSBjb250YWluIHRoaW5ncyB0aGF0IGFyZVxuLy8gdGVtcG9yYXJ5IHdvcmtpbmcgc3RhdGUgb3IgYXJlIG5ldmVyIHVzZWQgaW4gdGhlIHByZXJlbmRlciBwYXNzLlxuLy8gQ3JlZGVudGlhbHMgaGVyZSBhcmUgdGhpbmdzIHRoYXQgYWZmZWN0IHdoZXRoZXIgYSBicm93c2VyIHdpbGwgbWFrZSBhIHJlcXVlc3Rcbi8vIGFzIHdlbGwgYXMgdGhpbmdzIHRoYXQgYWZmZWN0IHdoaWNoIGNvbm5lY3Rpb24gdGhlIGJyb3dzZXIgd2lsbCB1c2UgZm9yIHRoYXQgcmVxdWVzdC5cbi8vIFdlIHdhbnQgdGhlc2UgdG8gYmUgYWxpZ25lZCBhY3Jvc3MgcHJlbG9hZHMgYW5kIHJlc291cmNlcyBiZWNhdXNlIG90aGVyd2lzZSB0aGUgcHJlbG9hZFxuLy8gd2lsbCBiZSB3YXN0ZWQuXG4vLyBXZSBpbnZlc3RpZ2F0ZWQgd2hldGhlciByZWZlcnJlclBvbGljeSBzaG91bGQgYmUgaW5jbHVkZWQgaGVyZSBidXQgZnJvbSBleHBlcmltZW50YXRpb25cbi8vIGl0IHNlZW1zIHRoYXQgYnJvd3NlcnMgZG8gbm90IHRyZWF0IHRoaXMgYXMgcGFydCBvZiB0aGUgaHR0cCBjYWNoZSBrZXkgYW5kIGRvZXMgbm90IGFmZmVjdFxuLy8gd2hpY2ggY29ubmVjdGlvbiBpcyB1c2VkLlxuXG52YXIgRVhJU1RTID0gbnVsbDsgLy8gVGhpcyBjb25zdGFudCBpcyB0byBtYXJrIHByZWxvYWRzIHRoYXQgaGF2ZSBubyB1bmlxdWUgY3JlZGVudGlhbHNcbi8vIHRvIGNvbnZleS4gSXQgc2hvdWxkIG5ldmVyIGJlIGNoZWNrZWQgYnkgaWRlbnRpdHkgYW5kIHdlIHNob3VsZCBub3Rcbi8vIGFzc3VtZSBQcmVsb2FkIHZhbHVlcyBpbiBSZXN1bWFibGVTdGF0ZSBlcXVhbCB0aGlzIHZhbHVlIGJlY2F1c2UgdGhleVxuLy8gd2lsbCBoYXZlIGNvbWUgZnJvbSBzb21lIHBhcnNlZCBpbnB1dC5cblxudmFyIFBSRUxPQURfTk9fQ1JFRFMgPSBbXTtcblxue1xuICBPYmplY3QuZnJlZXplKFBSRUxPQURfTk9fQ1JFRFMpO1xufSAvLyBQZXIgcmVzcG9uc2UsIGdsb2JhbCBzdGF0ZSB0aGF0IGlzIG5vdCBjb250ZXh0dWFsIHRvIHRoZSByZW5kZXJpbmcgc3VidHJlZS5cbi8vIFRoaXMgaXMgcmVzdW1hYmxlIGFuZCB0aGVyZWZvcmUgc2hvdWxkIGJlIHNlcmlhbGl6YWJsZS5cblxuXG52YXIgZGF0YUVsZW1lbnRRdW90ZWRFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPjwvdGVtcGxhdGU+Jyk7XG52YXIgc3RhcnRJbmxpbmVTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzY3JpcHQ+Jyk7XG52YXIgZW5kSW5saW5lU2NyaXB0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3NjcmlwdD4nKTtcbnZhciBzdGFydFNjcmlwdFNyYyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCBzcmM9XCInKTtcbnZhciBzdGFydE1vZHVsZVNyYyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCB0eXBlPVwibW9kdWxlXCIgc3JjPVwiJyk7XG52YXIgc2NyaXB0Tm9uY2UgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIG5vbmNlPVwiJyk7XG52YXIgc2NyaXB0SW50ZWdpcnR5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBpbnRlZ3JpdHk9XCInKTtcbnZhciBzY3JpcHRDcm9zc09yaWdpbiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgY3Jvc3NvcmlnaW49XCInKTtcbnZhciBlbmRBc3luY1NjcmlwdCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgYXN5bmM9XCJcIj48L3NjcmlwdD4nKTtcbi8qKlxuICogVGhpcyBlc2NhcGluZyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byB3b3JrIHdpdGggYm9vdHN0cmFwU2NyaXB0Q29udGVudCBhbmQgaW1wb3J0TWFwIG9ubHkuXG4gKiBiZWNhdXNlIHdlIGtub3cgd2UgYXJlIGVzY2FwaW5nIHRoZSBlbnRpcmUgc2NyaXB0LiBXZSBjYW4gYXZvaWQgZm9yIGluc3RhbmNlXG4gKiBlc2NhcGluZyBodG1sIGNvbW1lbnQgc3RyaW5nIHNlcXVlbmNlcyB0aGF0IGFyZSB2YWxpZCBqYXZhc2NyaXB0IGFzIHdlbGwgYmVjYXVzZVxuICogaWYgdGhlcmUgYXJlIG5vIHNlYnNlcXVlbnQgPHNjcmlwdCBzZXF1ZW5jZXMgdGhlIGh0bWwgcGFyc2VyIHdpbGwgbmV2ZXIgZW50ZXJcbiAqIHNjcmlwdCBkYXRhIGRvdWJsZSBlc2NhcGVkIHN0YXRlIChzZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTMvc3ludGF4Lmh0bWwjc2NyaXB0LWRhdGEtZG91YmxlLWVzY2FwZWQtc3RhdGUpXG4gKlxuICogV2hpbGUgdW50cnVzdGVkIHNjcmlwdCBjb250ZW50IHNob3VsZCBiZSBtYWRlIHNhZmUgYmVmb3JlIHVzaW5nIHRoaXMgYXBpIGl0IHdpbGxcbiAqIGVuc3VyZSB0aGF0IHRoZSBzY3JpcHQgY2Fubm90IGJlIGVhcmx5IHRlcm1pbmF0ZWQgb3IgbmV2ZXIgdGVybWluYXRlZCBzdGF0ZVxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZUJvb3RzdHJhcEFuZEltcG9ydE1hcFNjcmlwdENvbnRlbnQoc2NyaXB0VGV4dCkge1xuICB7XG4gICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oc2NyaXB0VGV4dCk7XG4gIH1cblxuICByZXR1cm4gKCcnICsgc2NyaXB0VGV4dCkucmVwbGFjZShzY3JpcHRSZWdleCwgc2NyaXB0UmVwbGFjZXIpO1xufVxuXG52YXIgc2NyaXB0UmVnZXggPSAvKDxcXC98PCkocykoY3JpcHQpL2dpO1xuXG52YXIgc2NyaXB0UmVwbGFjZXIgPSBmdW5jdGlvbiAobWF0Y2gsIHByZWZpeCwgcywgc3VmZml4KSB7XG4gIHJldHVybiBcIlwiICsgcHJlZml4ICsgKHMgPT09ICdzJyA/IFwiXFxcXHUwMDczXCIgOiBcIlxcXFx1MDA1M1wiKSArIHN1ZmZpeDtcbn07XG5cbnZhciBpbXBvcnRNYXBTY3JpcHRTdGFydCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCB0eXBlPVwiaW1wb3J0bWFwXCI+Jyk7XG52YXIgaW1wb3J0TWFwU2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3NjcmlwdD4nKTsgLy8gU2luY2Ugd2Ugc3RvcmUgaGVhZGVycyBhcyBzdHJpbmdzIHdlIGRlYWwgd2l0aCB0aGVpciBsZW5ndGggaW4gdXRmMTYgY29kZSB1bml0c1xuLy8gcmF0aGVyIHRoYW4gdmlzdWFsIGNoYXJhY3RlcnMgb3IgdGhlIHV0ZjggZW5jb2RpbmcgdGhhdCBpcyB1c2VkIGZvciBtb3N0IGJpbmFyeVxuLy8gc2VyaWFsaXphdGlvbi4gU29tZSBjb21tb24gSFRUUCBzZXJ2ZXJzIG9ubHkgYWxsb3cgZm9yIGhlYWRlcnMgdG8gYmUgNGtCIGluIGxlbmd0aC5cbi8vIFdlIGNob29zZSBhIGRlZmF1bHQgbGVuZ3RoIHRoYXQgaXMgbGlrZWx5IHRvIGJlIHdlbGwgdW5kZXIgdGhpcyBhbHJlYWR5IGxpbWl0ZWQgbGVuZ3RoIGhvd2V2ZXJcbi8vIHBhdGhvbG9naWNhbCBjYXNlcyBtYXkgc3RpbGwgY2F1c2UgdGhlIHV0Zi04IGVuY29kaW5nIG9mIHRoZSBoZWFkZXJzIHRvIGFwcHJvYWNoIHRoaXMgbGltaXQuXG4vLyBJdCBzaG91bGQgYWxzbyBiZSBub3RlZCB0aGF0IHRoaXMgbWF4aW11bSBpcyBhIHNvZnQgbWF4aW11bS4gd2UgaGF2ZSBub3QgcmVhY2hlZCB0aGUgbGltaXQgd2Ugd2lsbFxuLy8gYWxsb3cgb25lIG1vcmUgaGVhZGVyIHRvIGJlIGNhcHR1cmVkIHdoaWNoIG1lYW5zIGluIHByYWN0aWNlIGlmIHRoZSBsaW1pdCBpcyBhcHByb2FjaGVkIGl0IHdpbGwgYmUgZXhjZWVkZWRcblxudmFyIERFRkFVTFRfSEVBREVSU19DQVBBQ0lUWV9JTl9VVEYxNl9DT0RFX1VOSVRTID0gMjAwMDsgLy8gQWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2Ygd2hhdCB3ZSd2ZSBhbHJlYWR5IHdyaXR0ZW4gc28gd2UgY2FuIHJlZmVyIGJhY2sgdG8gaXQuXG4vLyBpZiBwYXNzZWQgZXh0ZXJuYWxSdW50aW1lQ29uZmlnIGFuZCB0aGUgZW5hYmxlRml6ekV4dGVybmFsUnVudGltZSBmZWF0dXJlIGZsYWdcbi8vIGlzIHNldCwgdGhlIHNlcnZlciB3aWxsIHNlbmQgaW5zdHJ1Y3Rpb25zIHZpYSBkYXRhIGF0dHJpYnV0ZXMgKGluc3RlYWQgb2YgaW5saW5lIHNjcmlwdHMpXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlclN0YXRlJDEocmVzdW1hYmxlU3RhdGUsIG5vbmNlLCBleHRlcm5hbFJ1bnRpbWVDb25maWcsIGltcG9ydE1hcCwgb25IZWFkZXJzLCBtYXhIZWFkZXJzTGVuZ3RoKSB7XG4gIHZhciBpbmxpbmVTY3JpcHRXaXRoTm9uY2UgPSBub25jZSA9PT0gdW5kZWZpbmVkID8gc3RhcnRJbmxpbmVTY3JpcHQgOiBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzY3JpcHQgbm9uY2U9XCInICsgZXNjYXBlVGV4dEZvckJyb3dzZXIobm9uY2UpICsgJ1wiPicpO1xuICB2YXIgaWRQcmVmaXggPSByZXN1bWFibGVTdGF0ZS5pZFByZWZpeDtcbiAgdmFyIGJvb3RzdHJhcENodW5rcyA9IFtdO1xuICB2YXIgZXh0ZXJuYWxSdW50aW1lU2NyaXB0ID0gbnVsbDtcbiAgdmFyIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgPSByZXN1bWFibGVTdGF0ZS5ib290c3RyYXBTY3JpcHRDb250ZW50LFxuICAgICAgYm9vdHN0cmFwU2NyaXB0cyA9IHJlc3VtYWJsZVN0YXRlLmJvb3RzdHJhcFNjcmlwdHMsXG4gICAgICBib290c3RyYXBNb2R1bGVzID0gcmVzdW1hYmxlU3RhdGUuYm9vdHN0cmFwTW9kdWxlcztcblxuICBpZiAoYm9vdHN0cmFwU2NyaXB0Q29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goaW5saW5lU2NyaXB0V2l0aE5vbmNlLCBzdHJpbmdUb0NodW5rKGVzY2FwZUJvb3RzdHJhcEFuZEltcG9ydE1hcFNjcmlwdENvbnRlbnQoYm9vdHN0cmFwU2NyaXB0Q29udGVudCkpLCBlbmRJbmxpbmVTY3JpcHQpO1xuICB9XG5cbiAge1xuXG4gICAgaWYgKGV4dGVybmFsUnVudGltZUNvbmZpZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGV4dGVybmFsUnVudGltZUNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXh0ZXJuYWxSdW50aW1lU2NyaXB0ID0ge1xuICAgICAgICAgIHNyYzogZXh0ZXJuYWxSdW50aW1lQ29uZmlnLFxuICAgICAgICAgIGNodW5rczogW11cbiAgICAgICAgfTtcbiAgICAgICAgcHVzaFNjcmlwdEltcGwoZXh0ZXJuYWxSdW50aW1lU2NyaXB0LmNodW5rcywge1xuICAgICAgICAgIHNyYzogZXh0ZXJuYWxSdW50aW1lQ29uZmlnLFxuICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgIGludGVncml0eTogdW5kZWZpbmVkLFxuICAgICAgICAgIG5vbmNlOiBub25jZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4dGVybmFsUnVudGltZVNjcmlwdCA9IHtcbiAgICAgICAgICBzcmM6IGV4dGVybmFsUnVudGltZUNvbmZpZy5zcmMsXG4gICAgICAgICAgY2h1bmtzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBwdXNoU2NyaXB0SW1wbChleHRlcm5hbFJ1bnRpbWVTY3JpcHQuY2h1bmtzLCB7XG4gICAgICAgICAgc3JjOiBleHRlcm5hbFJ1bnRpbWVDb25maWcuc3JjLFxuICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgIGludGVncml0eTogZXh0ZXJuYWxSdW50aW1lQ29uZmlnLmludGVncml0eSxcbiAgICAgICAgICBub25jZTogbm9uY2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGltcG9ydE1hcENodW5rcyA9IFtdO1xuXG4gIGlmIChpbXBvcnRNYXAgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBtYXAgPSBpbXBvcnRNYXA7XG4gICAgaW1wb3J0TWFwQ2h1bmtzLnB1c2goaW1wb3J0TWFwU2NyaXB0U3RhcnQpO1xuICAgIGltcG9ydE1hcENodW5rcy5wdXNoKHN0cmluZ1RvQ2h1bmsoZXNjYXBlQm9vdHN0cmFwQW5kSW1wb3J0TWFwU2NyaXB0Q29udGVudChKU09OLnN0cmluZ2lmeShtYXApKSkpO1xuICAgIGltcG9ydE1hcENodW5rcy5wdXNoKGltcG9ydE1hcFNjcmlwdEVuZCk7XG4gIH1cblxuICB7XG4gICAgaWYgKG9uSGVhZGVycyAmJiB0eXBlb2YgbWF4SGVhZGVyc0xlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChtYXhIZWFkZXJzTGVuZ3RoIDw9IDApIHtcbiAgICAgICAgZXJyb3IoJ1JlYWN0IGV4cGVjdGVkIGEgcG9zaXRpdmUgbm9uLXplcm8gYG1heEhlYWRlcnNMZW5ndGhgIG9wdGlvbiBidXQgZm91bmQgJXMgaW5zdGVhZC4gV2hlbiB1c2luZyB0aGUgYG9uSGVhZGVyc2Agb3B0aW9uIHlvdSBtYXkgc3VwcGx5IGFuIG9wdGlvbmFsIGBtYXhIZWFkZXJzTGVuZ3RoYCBvcHRpb24gYXMgd2VsbCBob3dldmVyLCB3aGVuIHNldHRpbmcgdGhpcyB2YWx1ZSB0byB6ZXJvIG9yIGxlc3Mgbm8gaGVhZGVycyB3aWxsIGJlIGNhcHR1cmVkLicsIG1heEhlYWRlcnNMZW5ndGggPT09IDAgPyAnemVybycgOiBtYXhIZWFkZXJzTGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaGVhZGVycyA9IG9uSGVhZGVycyA/IHtcbiAgICBwcmVjb25uZWN0czogJycsXG4gICAgZm9udFByZWxvYWRzOiAnJyxcbiAgICBoaWdoSW1hZ2VQcmVsb2FkczogJycsXG4gICAgcmVtYWluaW5nQ2FwYWNpdHk6IHR5cGVvZiBtYXhIZWFkZXJzTGVuZ3RoID09PSAnbnVtYmVyJyA/IG1heEhlYWRlcnNMZW5ndGggOiBERUZBVUxUX0hFQURFUlNfQ0FQQUNJVFlfSU5fVVRGMTZfQ09ERV9VTklUU1xuICB9IDogbnVsbDtcbiAgdmFyIHJlbmRlclN0YXRlID0ge1xuICAgIHBsYWNlaG9sZGVyUHJlZml4OiBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoaWRQcmVmaXggKyAnUDonKSxcbiAgICBzZWdtZW50UHJlZml4OiBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoaWRQcmVmaXggKyAnUzonKSxcbiAgICBib3VuZGFyeVByZWZpeDogc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGlkUHJlZml4ICsgJ0I6JyksXG4gICAgc3RhcnRJbmxpbmVTY3JpcHQ6IGlubGluZVNjcmlwdFdpdGhOb25jZSxcbiAgICBodG1sQ2h1bmtzOiBudWxsLFxuICAgIGhlYWRDaHVua3M6IG51bGwsXG4gICAgZXh0ZXJuYWxSdW50aW1lU2NyaXB0OiBleHRlcm5hbFJ1bnRpbWVTY3JpcHQsXG4gICAgYm9vdHN0cmFwQ2h1bmtzOiBib290c3RyYXBDaHVua3MsXG4gICAgb25IZWFkZXJzOiBvbkhlYWRlcnMsXG4gICAgaGVhZGVyczogaGVhZGVycyxcbiAgICByZXNldHM6IHtcbiAgICAgIGZvbnQ6IHt9LFxuICAgICAgZG5zOiB7fSxcbiAgICAgIGNvbm5lY3Q6IHtcbiAgICAgICAgZGVmYXVsdDoge30sXG4gICAgICAgIGFub255bW91czoge30sXG4gICAgICAgIGNyZWRlbnRpYWxzOiB7fVxuICAgICAgfSxcbiAgICAgIGltYWdlOiB7fSxcbiAgICAgIHN0eWxlOiB7fVxuICAgIH0sXG4gICAgY2hhcnNldENodW5rczogW10sXG4gICAgcHJlY29ubmVjdENodW5rczogW10sXG4gICAgaW1wb3J0TWFwQ2h1bmtzOiBpbXBvcnRNYXBDaHVua3MsXG4gICAgcHJlbG9hZENodW5rczogW10sXG4gICAgaG9pc3RhYmxlQ2h1bmtzOiBbXSxcbiAgICAvLyBjbGVhcmVkIG9uIGZsdXNoXG4gICAgcHJlY29ubmVjdHM6IG5ldyBTZXQoKSxcbiAgICBmb250UHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICBoaWdoSW1hZ2VQcmVsb2FkczogbmV3IFNldCgpLFxuICAgIC8vIHVzZWRJbWFnZVByZWxvYWRzOiBuZXcgU2V0KCksXG4gICAgc3R5bGVzOiBuZXcgTWFwKCksXG4gICAgYm9vdHN0cmFwU2NyaXB0czogbmV3IFNldCgpLFxuICAgIHNjcmlwdHM6IG5ldyBTZXQoKSxcbiAgICBidWxrUHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICBwcmVsb2Fkczoge1xuICAgICAgaW1hZ2VzOiBuZXcgTWFwKCksXG4gICAgICBzdHlsZXNoZWV0czogbmV3IE1hcCgpLFxuICAgICAgc2NyaXB0czogbmV3IE1hcCgpLFxuICAgICAgbW9kdWxlU2NyaXB0czogbmV3IE1hcCgpXG4gICAgfSxcbiAgICBub25jZTogbm9uY2UsXG4gICAgLy8gbGlrZSBhIG1vZHVsZSBnbG9iYWwgZm9yIGN1cnJlbnRseSByZW5kZXJpbmcgYm91bmRhcnlcbiAgICBib3VuZGFyeVJlc291cmNlczogbnVsbCxcbiAgICBzdHlsZXNUb0hvaXN0OiBmYWxzZVxuICB9O1xuXG4gIGlmIChib290c3RyYXBTY3JpcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb3RzdHJhcFNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzY3JpcHRDb25maWcgPSBib290c3RyYXBTY3JpcHRzW2ldO1xuICAgICAgdmFyIHNyYyA9IHZvaWQgMCxcbiAgICAgICAgICBjcm9zc09yaWdpbiA9IHZvaWQgMCxcbiAgICAgICAgICBpbnRlZ3JpdHkgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICBhczogJ3NjcmlwdCcsXG4gICAgICAgIGZldGNoUHJpb3JpdHk6ICdsb3cnLFxuICAgICAgICBub25jZTogbm9uY2VcbiAgICAgIH07XG5cbiAgICAgIGlmICh0eXBlb2Ygc2NyaXB0Q29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBwcm9wcy5ocmVmID0gc3JjID0gc2NyaXB0Q29uZmlnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcHMuaHJlZiA9IHNyYyA9IHNjcmlwdENvbmZpZy5zcmM7XG4gICAgICAgIHByb3BzLmludGVncml0eSA9IGludGVncml0eSA9IHR5cGVvZiBzY3JpcHRDb25maWcuaW50ZWdyaXR5ID09PSAnc3RyaW5nJyA/IHNjcmlwdENvbmZpZy5pbnRlZ3JpdHkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHByb3BzLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW4gPSB0eXBlb2Ygc2NyaXB0Q29uZmlnID09PSAnc3RyaW5nJyB8fCBzY3JpcHRDb25maWcuY3Jvc3NPcmlnaW4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHNjcmlwdENvbmZpZy5jcm9zc09yaWdpbiA9PT0gJ3VzZS1jcmVkZW50aWFscycgPyAndXNlLWNyZWRlbnRpYWxzJyA6ICcnO1xuICAgICAgfVxuXG4gICAgICBwcmVsb2FkQm9vdHN0cmFwU2NyaXB0T3JNb2R1bGUocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBzcmMsIHByb3BzKTtcbiAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHN0YXJ0U2NyaXB0U3JjLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHNyYykpKTtcblxuICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHNjcmlwdE5vbmNlLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKG5vbmNlKSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGludGVncml0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goc2NyaXB0SW50ZWdpcnR5LCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGludGVncml0eSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjcm9zc09yaWdpbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goc2NyaXB0Q3Jvc3NPcmlnaW4sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoY3Jvc3NPcmlnaW4pKSk7XG4gICAgICB9XG5cbiAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKGVuZEFzeW5jU2NyaXB0KTtcbiAgICB9XG4gIH1cblxuICBpZiAoYm9vdHN0cmFwTW9kdWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJvb3RzdHJhcE1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX3NjcmlwdENvbmZpZyA9IGJvb3RzdHJhcE1vZHVsZXNbX2ldO1xuXG4gICAgICB2YXIgX3NyYyA9IHZvaWQgMCxcbiAgICAgICAgICBfY3Jvc3NPcmlnaW4gPSB2b2lkIDAsXG4gICAgICAgICAgX2ludGVncml0eSA9IHZvaWQgMDtcblxuICAgICAgdmFyIF9wcm9wcyA9IHtcbiAgICAgICAgcmVsOiAnbW9kdWxlcHJlbG9hZCcsXG4gICAgICAgIGZldGNoUHJpb3JpdHk6ICdsb3cnLFxuICAgICAgICBub25jZTogbm9uY2VcbiAgICAgIH07XG5cbiAgICAgIGlmICh0eXBlb2YgX3NjcmlwdENvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgX3Byb3BzLmhyZWYgPSBfc3JjID0gX3NjcmlwdENvbmZpZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9wcm9wcy5ocmVmID0gX3NyYyA9IF9zY3JpcHRDb25maWcuc3JjO1xuICAgICAgICBfcHJvcHMuaW50ZWdyaXR5ID0gX2ludGVncml0eSA9IHR5cGVvZiBfc2NyaXB0Q29uZmlnLmludGVncml0eSA9PT0gJ3N0cmluZycgPyBfc2NyaXB0Q29uZmlnLmludGVncml0eSA6IHVuZGVmaW5lZDtcbiAgICAgICAgX3Byb3BzLmNyb3NzT3JpZ2luID0gX2Nyb3NzT3JpZ2luID0gdHlwZW9mIF9zY3JpcHRDb25maWcgPT09ICdzdHJpbmcnIHx8IF9zY3JpcHRDb25maWcuY3Jvc3NPcmlnaW4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IF9zY3JpcHRDb25maWcuY3Jvc3NPcmlnaW4gPT09ICd1c2UtY3JlZGVudGlhbHMnID8gJ3VzZS1jcmVkZW50aWFscycgOiAnJztcbiAgICAgIH1cblxuICAgICAgcHJlbG9hZEJvb3RzdHJhcFNjcmlwdE9yTW9kdWxlKHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgX3NyYywgX3Byb3BzKTtcbiAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHN0YXJ0TW9kdWxlU3JjLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKF9zcmMpKSk7XG5cbiAgICAgIGlmIChub25jZSkge1xuICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChzY3JpcHROb25jZSwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcihub25jZSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBfaW50ZWdyaXR5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChzY3JpcHRJbnRlZ2lydHksIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoX2ludGVncml0eSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBfY3Jvc3NPcmlnaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHNjcmlwdENyb3NzT3JpZ2luLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKF9jcm9zc09yaWdpbikpKTtcbiAgICAgIH1cblxuICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goZW5kQXN5bmNTY3JpcHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZW5kZXJTdGF0ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc3VtYWJsZVN0YXRlKGlkZW50aWZpZXJQcmVmaXgsIGV4dGVybmFsUnVudGltZUNvbmZpZywgYm9vdHN0cmFwU2NyaXB0Q29udGVudCwgYm9vdHN0cmFwU2NyaXB0cywgYm9vdHN0cmFwTW9kdWxlcykge1xuICB2YXIgaWRQcmVmaXggPSBpZGVudGlmaWVyUHJlZml4ID09PSB1bmRlZmluZWQgPyAnJyA6IGlkZW50aWZpZXJQcmVmaXg7XG4gIHZhciBzdHJlYW1pbmdGb3JtYXQgPSBTY3JpcHRTdHJlYW1pbmdGb3JtYXQ7XG5cbiAge1xuICAgIGlmIChleHRlcm5hbFJ1bnRpbWVDb25maWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RyZWFtaW5nRm9ybWF0ID0gRGF0YVN0cmVhbWluZ0Zvcm1hdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlkUHJlZml4OiBpZFByZWZpeCxcbiAgICBuZXh0Rm9ybUlEOiAwLFxuICAgIHN0cmVhbWluZ0Zvcm1hdDogc3RyZWFtaW5nRm9ybWF0LFxuICAgIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQ6IGJvb3RzdHJhcFNjcmlwdENvbnRlbnQsXG4gICAgYm9vdHN0cmFwU2NyaXB0czogYm9vdHN0cmFwU2NyaXB0cyxcbiAgICBib290c3RyYXBNb2R1bGVzOiBib290c3RyYXBNb2R1bGVzLFxuICAgIGluc3RydWN0aW9uczogTm90aGluZ1NlbnQsXG4gICAgaGFzQm9keTogZmFsc2UsXG4gICAgaGFzSHRtbDogZmFsc2UsXG4gICAgLy8gQFRPRE8gYWRkIGJvb3RzdHJhcCBzY3JpcHQgdG8gaW1wbGljaXQgcHJlbG9hZHNcbiAgICAvLyBwZXJzaXN0ZW50XG4gICAgdW5rbm93blJlc291cmNlczoge30sXG4gICAgZG5zUmVzb3VyY2VzOiB7fSxcbiAgICBjb25uZWN0UmVzb3VyY2VzOiB7XG4gICAgICBkZWZhdWx0OiB7fSxcbiAgICAgIGFub255bW91czoge30sXG4gICAgICBjcmVkZW50aWFsczoge31cbiAgICB9LFxuICAgIGltYWdlUmVzb3VyY2VzOiB7fSxcbiAgICBzdHlsZVJlc291cmNlczoge30sXG4gICAgc2NyaXB0UmVzb3VyY2VzOiB7fSxcbiAgICBtb2R1bGVVbmtub3duUmVzb3VyY2VzOiB7fSxcbiAgICBtb2R1bGVTY3JpcHRSZXNvdXJjZXM6IHt9XG4gIH07XG59XG4vLyBtb2Rlcy4gV2Ugb25seSBpbmNsdWRlIHRoZSB2YXJpYW50cyBhcyB0aGV5IG1hdHRlciBmb3IgdGhlIHNha2Ugb2Ygb3VyIHB1cnBvc2VzLlxuLy8gV2UgZG9uJ3QgYWN0dWFsbHkgcHJvdmlkZSB0aGUgbmFtZXNwYWNlIHRoZXJlZm9yZSB3ZSB1c2UgY29uc3RhbnRzIGluc3RlYWQgb2YgdGhlIHN0cmluZy5cblxudmFyIFJPT1RfSFRNTF9NT0RFID0gMDsgLy8gVXNlZCBmb3IgdGhlIHJvb3QgbW9zdCBlbGVtZW50IHRhZy5cbi8vIFdlIGhhdmUgYSBsZXNzIHRoYW4gSFRNTF9IVE1MX01PREUgY2hlY2sgZWxzZXdoZXJlLiBJZiB5b3UgYWRkIG1vcmUgY2FzZXMgaGVyZSwgbWFrZSBzdXJlIGl0XG4vLyBzdGlsbCBtYWtlcyBzZW5zZVxuXG52YXIgSFRNTF9IVE1MX01PREUgPSAxOyAvLyBVc2VkIGZvciB0aGUgPGh0bWw+IGlmIGl0IGlzIGF0IHRoZSB0b3AgbGV2ZWwuXG5cbnZhciBIVE1MX01PREUgPSAyO1xudmFyIFNWR19NT0RFID0gMztcbnZhciBNQVRITUxfTU9ERSA9IDQ7XG52YXIgSFRNTF9UQUJMRV9NT0RFID0gNTtcbnZhciBIVE1MX1RBQkxFX0JPRFlfTU9ERSA9IDY7XG52YXIgSFRNTF9UQUJMRV9ST1dfTU9ERSA9IDc7XG52YXIgSFRNTF9DT0xHUk9VUF9NT0RFID0gODsgLy8gV2UgaGF2ZSBhIGdyZWF0ZXIgdGhhbiBIVE1MX1RBQkxFX01PREUgY2hlY2sgZWxzZXdoZXJlLiBJZiB5b3UgYWRkIG1vcmUgY2FzZXMgaGVyZSwgbWFrZSBzdXJlIGl0XG4vLyBzdGlsbCBtYWtlcyBzZW5zZVxuXG52YXIgTk9fU0NPUEUgPVxuLyogICAgICAgICAqL1xuMDtcbnZhciBOT1NDUklQVF9TQ09QRSA9XG4vKiAgICovXG4xO1xudmFyIFBJQ1RVUkVfU0NPUEUgPVxuLyogICAgKi9cbjI7IC8vIExldHMgdXMga2VlcCB0cmFjayBvZiBjb250ZXh0dWFsIHN0YXRlIGFuZCBwaWNrIGl0IGJhY2sgdXAgYWZ0ZXIgc3VzcGVuZGluZy5cblxuZnVuY3Rpb24gY3JlYXRlRm9ybWF0Q29udGV4dChpbnNlcnRpb25Nb2RlLCBzZWxlY3RlZFZhbHVlLCB0YWdTY29wZSkge1xuICByZXR1cm4ge1xuICAgIGluc2VydGlvbk1vZGU6IGluc2VydGlvbk1vZGUsXG4gICAgc2VsZWN0ZWRWYWx1ZTogc2VsZWN0ZWRWYWx1ZSxcbiAgICB0YWdTY29wZTogdGFnU2NvcGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUm9vdEZvcm1hdENvbnRleHQobmFtZXNwYWNlVVJJKSB7XG4gIHZhciBpbnNlcnRpb25Nb2RlID0gbmFtZXNwYWNlVVJJID09PSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnID8gU1ZHX01PREUgOiBuYW1lc3BhY2VVUkkgPT09ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJyA/IE1BVEhNTF9NT0RFIDogUk9PVF9IVE1MX01PREU7XG4gIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KGluc2VydGlvbk1vZGUsIG51bGwsIE5PX1NDT1BFKTtcbn1cbmZ1bmN0aW9uIGdldENoaWxkRm9ybWF0Q29udGV4dChwYXJlbnRDb250ZXh0LCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdub3NjcmlwdCc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUgfCBOT1NDUklQVF9TQ09QRSk7XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuXG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFNWR19NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcblxuICAgIGNhc2UgJ3BpY3R1cmUnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlIHwgUElDVFVSRV9TQ09QRSk7XG5cbiAgICBjYXNlICdtYXRoJzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KE1BVEhNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcblxuICAgIGNhc2UgJ2ZvcmVpZ25PYmplY3QnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcbiAgICAvLyBUYWJsZSBwYXJlbnRzIGFyZSBzcGVjaWFsIGluIHRoYXQgdGhlaXIgY2hpbGRyZW4gY2FuIG9ubHkgYmUgY3JlYXRlZCBhdCBhbGwgaWYgdGhleSdyZVxuICAgIC8vIHdyYXBwZWQgaW4gYSB0YWJsZSBwYXJlbnQuIFNvIHdlIG5lZWQgdG8gZW5jb2RlIHRoYXQgd2UncmUgZW50ZXJpbmcgdGhpcyBtb2RlLlxuXG4gICAgY2FzZSAndGFibGUnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9UQUJMRV9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcblxuICAgIGNhc2UgJ3RoZWFkJzpcbiAgICBjYXNlICd0Ym9keSc6XG4gICAgY2FzZSAndGZvb3QnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9UQUJMRV9CT0RZX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuXG4gICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9DT0xHUk9VUF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcblxuICAgIGNhc2UgJ3RyJzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfVEFCTEVfUk9XX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuICB9XG5cbiAgaWYgKHBhcmVudENvbnRleHQuaW5zZXJ0aW9uTW9kZSA+PSBIVE1MX1RBQkxFX01PREUpIHtcbiAgICAvLyBXaGF0ZXZlciB0YWcgdGhpcyB3YXMsIGl0IHdhc24ndCBhIHRhYmxlIHBhcmVudCBvciBvdGhlciBzcGVjaWFsIHBhcmVudCwgc28gd2UgbXVzdCBoYXZlXG4gICAgLy8gZW50ZXJlZCBwbGFpbiBIVE1MIGFnYWluLlxuICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG4gIH1cblxuICBpZiAocGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBST09UX0hUTUxfTU9ERSkge1xuICAgIGlmICh0eXBlID09PSAnaHRtbCcpIHtcbiAgICAgIC8vIFdlJ3ZlIGVtaXR0ZWQgdGhlIHJvb3QgYW5kIGlzIG5vdyBpbiA8aHRtbD4gbW9kZS5cbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UndmUgZW1pdHRlZCB0aGUgcm9vdCBhbmQgaXMgbm93IGluIHBsYWluIEhUTUwgbW9kZS5cbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBhcmVudENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gSFRNTF9IVE1MX01PREUpIHtcbiAgICAvLyBXZSd2ZSBlbWl0dGVkIHRoZSBkb2N1bWVudCBlbGVtZW50IGFuZCBpcyBub3cgaW4gcGxhaW4gSFRNTCBtb2RlLlxuICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG4gIH1cblxuICByZXR1cm4gcGFyZW50Q29udGV4dDtcbn1cbmZ1bmN0aW9uIG1ha2VJZChyZXN1bWFibGVTdGF0ZSwgdHJlZUlkLCBsb2NhbElkKSB7XG4gIHZhciBpZFByZWZpeCA9IHJlc3VtYWJsZVN0YXRlLmlkUHJlZml4O1xuICB2YXIgaWQgPSAnOicgKyBpZFByZWZpeCArICdSJyArIHRyZWVJZDsgLy8gVW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IGlkIGF0IHRoaXMgbGV2ZWwsIGFwcGVuZCBhIG51bWJlciBhdCB0aGUgZW5kXG4gIC8vIHRoYXQgcmVwcmVzZW50cyB0aGUgcG9zaXRpb24gb2YgdGhpcyB1c2VJZCBob29rIGFtb25nIGFsbCB0aGUgdXNlSWRcbiAgLy8gaG9va3MgZm9yIHRoaXMgZmliZXIuXG5cbiAgaWYgKGxvY2FsSWQgPiAwKSB7XG4gICAgaWQgKz0gJ0gnICsgbG9jYWxJZC50b1N0cmluZygzMik7XG4gIH1cblxuICByZXR1cm4gaWQgKyAnOic7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUhUTUxUZXh0Tm9kZSh0ZXh0KSB7XG4gIHJldHVybiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KTtcbn1cblxudmFyIHRleHRTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhLS0gLS0+Jyk7XG5mdW5jdGlvbiBwdXNoVGV4dEluc3RhbmNlJDEodGFyZ2V0LCB0ZXh0LCByZW5kZXJTdGF0ZSwgdGV4dEVtYmVkZGVkKSB7XG4gIGlmICh0ZXh0ID09PSAnJykge1xuICAgIC8vIEVtcHR5IHRleHQgZG9lc24ndCBoYXZlIGEgRE9NIG5vZGUgcmVwcmVzZW50YXRpb24gYW5kIHRoZSBoeWRyYXRpb24gaXMgYXdhcmUgb2YgdGhpcy5cbiAgICByZXR1cm4gdGV4dEVtYmVkZGVkO1xuICB9XG5cbiAgaWYgKHRleHRFbWJlZGRlZCkge1xuICAgIHRhcmdldC5wdXNoKHRleHRTZXBhcmF0b3IpO1xuICB9XG5cbiAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUodGV4dCkpKTtcbiAgcmV0dXJuIHRydWU7XG59IC8vIENhbGxlZCB3aGVuIEZpenogaXMgZG9uZSB3aXRoIGEgU2VnbWVudC4gQ3VycmVudGx5IHRoZSBvbmx5IHB1cnBvc2UgaXMgdG8gY29uZGl0aW9uYWxseVxuLy8gZW1pdCBhIHRleHQgc2VwYXJhdG9yIHdoZW4gd2UgZG9uJ3Qga25vdyBmb3Igc3VyZSBpdCBpcyBzYWZlIHRvIG9taXRcblxuZnVuY3Rpb24gcHVzaFNlZ21lbnRGaW5hbGUkMSh0YXJnZXQsIHJlbmRlclN0YXRlLCBsYXN0UHVzaGVkVGV4dCwgdGV4dEVtYmVkZGVkKSB7XG4gIGlmIChsYXN0UHVzaGVkVGV4dCAmJiB0ZXh0RW1iZWRkZWQpIHtcbiAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgfVxufVxudmFyIHN0eWxlTmFtZUNhY2hlID0gbmV3IE1hcCgpO1xuXG5mdW5jdGlvbiBwcm9jZXNzU3R5bGVOYW1lKHN0eWxlTmFtZSkge1xuICB2YXIgY2h1bmsgPSBzdHlsZU5hbWVDYWNoZS5nZXQoc3R5bGVOYW1lKTtcblxuICBpZiAoY2h1bmsgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjaHVuaztcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSkpKTtcbiAgc3R5bGVOYW1lQ2FjaGUuc2V0KHN0eWxlTmFtZSwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIHN0eWxlQXR0cmlidXRlU3RhcnQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBzdHlsZT1cIicpO1xudmFyIHN0eWxlQXNzaWduID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc6Jyk7XG52YXIgc3R5bGVTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzsnKTtcblxuZnVuY3Rpb24gcHVzaFN0eWxlQXR0cmlidXRlKHRhcmdldCwgc3R5bGUpIHtcbiAgaWYgKHR5cGVvZiBzdHlsZSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgJyArIFwibm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArICdlbSd9fSB3aGVuIFwiICsgJ3VzaW5nIEpTWC4nKTtcbiAgfVxuXG4gIHZhciBpc0ZpcnN0ID0gdHJ1ZTtcblxuICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGUpIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoc3R5bGUsIHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdCBhcmJpdHJhcnkgQ1NTXG4gICAgLy8gd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAgIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gICAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gICAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAgIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAgIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuXG5cbiAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlW3N0eWxlTmFtZV07XG5cbiAgICBpZiAoc3R5bGVWYWx1ZSA9PSBudWxsIHx8IHR5cGVvZiBzdHlsZVZhbHVlID09PSAnYm9vbGVhbicgfHwgc3R5bGVWYWx1ZSA9PT0gJycpIHtcbiAgICAgIC8vIFRPRE86IFdlIHVzZWQgdG8gc2V0IGVtcHR5IHN0cmluZyBhcyBhIHN0eWxlIHdpdGggYW4gZW1wdHkgdmFsdWUuIERvZXMgdGhhdCBldmVyIG1ha2Ugc2Vuc2U/XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZUNodW5rID0gdm9pZCAwO1xuICAgIHZhciB2YWx1ZUNodW5rID0gdm9pZCAwO1xuICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG5cbiAgICBpZiAoaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgbmFtZUNodW5rID0gc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihzdHlsZU5hbWUpKTtcblxuICAgICAge1xuICAgICAgICBjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24oc3R5bGVWYWx1ZSwgc3R5bGVOYW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFsdWVDaHVuayA9IHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoKCcnICsgc3R5bGVWYWx1ZSkudHJpbSgpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgbmFtZUNodW5rID0gcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpO1xuXG4gICAgICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChzdHlsZVZhbHVlICE9PSAwICYmICFpc1VuaXRsZXNzTnVtYmVyKHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICB2YWx1ZUNodW5rID0gc3RyaW5nVG9DaHVuayhzdHlsZVZhbHVlICsgJ3B4Jyk7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVDaHVuayA9IHN0cmluZ1RvQ2h1bmsoJycgKyBzdHlsZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbihzdHlsZVZhbHVlLCBzdHlsZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWVDaHVuayA9IHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoKCcnICsgc3R5bGVWYWx1ZSkudHJpbSgpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgIGlzRmlyc3QgPSBmYWxzZTsgLy8gSWYgaXQncyBmaXJzdCwgd2UgZG9uJ3QgbmVlZCBhbnkgc2VwYXJhdG9ycyBwcmVmaXhlZC5cblxuICAgICAgdGFyZ2V0LnB1c2goc3R5bGVBdHRyaWJ1dGVTdGFydCwgbmFtZUNodW5rLCBzdHlsZUFzc2lnbiwgdmFsdWVDaHVuayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5wdXNoKHN0eWxlU2VwYXJhdG9yLCBuYW1lQ2h1bmssIHN0eWxlQXNzaWduLCB2YWx1ZUNodW5rKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWlzRmlyc3QpIHtcbiAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVFbmQpO1xuICB9XG59XG5cbnZhciBhdHRyaWJ1dGVTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyAnKTtcbnZhciBhdHRyaWJ1dGVBc3NpZ24gPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJz1cIicpO1xudmFyIGF0dHJpYnV0ZUVuZCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCInKTtcbnZhciBhdHRyaWJ1dGVFbXB0eVN0cmluZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPVwiXCInKTtcblxuZnVuY3Rpb24gcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSkgLy8gbm90IG51bGwgb3IgdW5kZWZpbmVkXG57XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJykge1xuICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlRW1wdHlTdHJpbmcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSkgLy8gbm90IG51bGwgb3IgdW5kZWZpbmVkXG57XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUZvcm1GaWVsZFByZWZpeChyZXN1bWFibGVTdGF0ZSkge1xuICB2YXIgaWQgPSByZXN1bWFibGVTdGF0ZS5uZXh0Rm9ybUlEKys7XG4gIHJldHVybiByZXN1bWFibGVTdGF0ZS5pZFByZWZpeCArIGlkO1xufSAvLyBTaW5jZSB0aGlzIHdpbGwgbGlrZWx5IGJlIHJlcGVhdGVkIGEgbG90IGluIHRoZSBIVE1MLCB3ZSB1c2UgYSBtb3JlIGNvbmNpc2UgbWVzc2FnZVxuLy8gdGhhbiBvbiB0aGUgY2xpZW50IGFuZCBob3BlZnVsbHkgaXQncyBnb29nbGVhYmxlLlxuXG5cbnZhciBhY3Rpb25KYXZhU2NyaXB0VVJMID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2NyaXB0LXVybFxuXCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcignQSBSZWFjdCBmb3JtIHdhcyB1bmV4cGVjdGVkbHkgc3VibWl0dGVkLicpXCIpKTtcbnZhciBzdGFydEhpZGRlbklucHV0Q2h1bmsgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCInKTtcblxuZnVuY3Rpb24gcHVzaEFkZGl0aW9uYWxGb3JtRmllbGQodmFsdWUsIGtleSkge1xuICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgdGFyZ2V0LnB1c2goc3RhcnRIaWRkZW5JbnB1dENodW5rKTtcblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRmlsZS9CbG9iIGZpZWxkcyBhcmUgbm90IHlldCBzdXBwb3J0ZWQgaW4gcHJvZ3Jlc3NpdmUgZm9ybXMuICcgKyAnSXQgcHJvYmFibHkgbWVhbnMgeW91IGFyZSBjbG9zaW5nIG92ZXIgYmluYXJ5IGRhdGEgb3IgRm9ybURhdGEgaW4gYSBTZXJ2ZXIgQWN0aW9uLicpO1xuICB9XG5cbiAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICduYW1lJywga2V5KTtcbiAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICd2YWx1ZScsIHZhbHVlKTtcbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKTtcbn1cblxuZnVuY3Rpb24gcHVzaEFkZGl0aW9uYWxGb3JtRmllbGRzKHRhcmdldCwgZm9ybURhdGEpIHtcbiAgaWYgKGZvcm1EYXRhICE9PSBudWxsKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBGb3JtRGF0YSBoYXMgZm9yRWFjaC5cbiAgICBmb3JtRGF0YS5mb3JFYWNoKHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkLCB0YXJnZXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hGb3JtQWN0aW9uQXR0cmlidXRlKHRhcmdldCwgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBmb3JtQWN0aW9uLCBmb3JtRW5jVHlwZSwgZm9ybU1ldGhvZCwgZm9ybVRhcmdldCwgbmFtZSkge1xuICB2YXIgZm9ybURhdGEgPSBudWxsO1xuXG4gIGlmICh0eXBlb2YgZm9ybUFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEZ1bmN0aW9uIGZvcm0gYWN0aW9ucyBjYW5ub3QgY29udHJvbCB0aGUgZm9ybSBwcm9wZXJ0aWVzXG4gICAge1xuICAgICAgaWYgKG5hbWUgIT09IG51bGwgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uTmFtZSkge1xuICAgICAgICBkaWRXYXJuRm9ybUFjdGlvbk5hbWUgPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdDYW5ub3Qgc3BlY2lmeSBhIFwibmFtZVwiIHByb3AgZm9yIGEgYnV0dG9uIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgYSBmb3JtQWN0aW9uLiAnICsgJ1JlYWN0IG5lZWRzIGl0IHRvIGVuY29kZSB3aGljaCBhY3Rpb24gc2hvdWxkIGJlIGludm9rZWQuIEl0IHdpbGwgZ2V0IG92ZXJyaWRkZW4uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoZm9ybUVuY1R5cGUgIT09IG51bGwgfHwgZm9ybU1ldGhvZCAhPT0gbnVsbCkgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kKSB7XG4gICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignQ2Fubm90IHNwZWNpZnkgYSBmb3JtRW5jVHlwZSBvciBmb3JtTWV0aG9kIGZvciBhIGJ1dHRvbiB0aGF0IHNwZWNpZmllcyBhICcgKyAnZnVuY3Rpb24gYXMgYSBmb3JtQWN0aW9uLiBSZWFjdCBwcm92aWRlcyB0aG9zZSBhdXRvbWF0aWNhbGx5LiBUaGV5IHdpbGwgZ2V0IG92ZXJyaWRkZW4uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtVGFyZ2V0ICE9PSBudWxsICYmICFkaWRXYXJuRm9ybUFjdGlvblRhcmdldCkge1xuICAgICAgICBkaWRXYXJuRm9ybUFjdGlvblRhcmdldCA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ0Nhbm5vdCBzcGVjaWZ5IGEgZm9ybVRhcmdldCBmb3IgYSBidXR0b24gdGhhdCBzcGVjaWZpZXMgYSBmdW5jdGlvbiBhcyBhIGZvcm1BY3Rpb24uICcgKyAnVGhlIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIHdpbmRvdy4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY3VzdG9tQWN0aW9uID0gZm9ybUFjdGlvbi4kJEZPUk1fQUNUSU9OO1xuXG4gICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgYWN0aW9uIGhhcyBhIGN1c3RvbSBwcm9ncmVzc2l2ZSBlbmhhbmNlbWVudCBmb3JtIHRoYXQgY2FuIHN1Ym1pdCB0aGUgZm9ybVxuICAgICAgLy8gYmFjayB0byB0aGUgc2VydmVyIGlmIGl0J3MgaW52b2tlZCBiZWZvcmUgaHlkcmF0aW9uLiBTdWNoIGFzIGEgU2VydmVyIEFjdGlvbi5cbiAgICAgIHZhciBwcmVmaXggPSBtYWtlRm9ybUZpZWxkUHJlZml4KHJlc3VtYWJsZVN0YXRlKTtcbiAgICAgIHZhciBjdXN0b21GaWVsZHMgPSBmb3JtQWN0aW9uLiQkRk9STV9BQ1RJT04ocHJlZml4KTtcbiAgICAgIG5hbWUgPSBjdXN0b21GaWVsZHMubmFtZTtcbiAgICAgIGZvcm1BY3Rpb24gPSBjdXN0b21GaWVsZHMuYWN0aW9uIHx8ICcnO1xuICAgICAgZm9ybUVuY1R5cGUgPSBjdXN0b21GaWVsZHMuZW5jVHlwZTtcbiAgICAgIGZvcm1NZXRob2QgPSBjdXN0b21GaWVsZHMubWV0aG9kO1xuICAgICAgZm9ybVRhcmdldCA9IGN1c3RvbUZpZWxkcy50YXJnZXQ7XG4gICAgICBmb3JtRGF0YSA9IGN1c3RvbUZpZWxkcy5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXQgYSBqYXZhc2NyaXB0IFVSTCB0aGF0IGRvZXNuJ3QgZG8gYW55dGhpbmcuIFdlIGRvbid0IGV4cGVjdCB0aGlzIHRvIGJlIGludm9rZWRcbiAgICAgIC8vIGJlY2F1c2Ugd2UnbGwgcHJldmVudERlZmF1bHQgaW4gdGhlIEZpenogcnVudGltZSwgYnV0IGl0IGNhbiBoYXBwZW4gaWYgYSBmb3JtIGlzXG4gICAgICAvLyBtYW51YWxseSBzdWJtaXR0ZWQgb3IgaWYgc29tZW9uZSBjYWxscyBzdG9wUHJvcGFnYXRpb24gYmVmb3JlIFJlYWN0IGdldHMgdGhlIGV2ZW50LlxuICAgICAgLy8gSWYgQ1NQIGlzIHVzZWQgdG8gYmxvY2sgamF2YXNjcmlwdDogVVJMcyB0aGF0J3MgZmluZSB0b28uIEl0IGp1c3Qgd29uJ3Qgc2hvdyB0aGlzXG4gICAgICAvLyBlcnJvciBtZXNzYWdlIGJ1dCB0aGUgVVJMIHdpbGwgYmUgbG9nZ2VkLlxuICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKCdmb3JtQWN0aW9uJyksIGF0dHJpYnV0ZUFzc2lnbiwgYWN0aW9uSmF2YVNjcmlwdFVSTCwgYXR0cmlidXRlRW5kKTtcbiAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgZm9ybUFjdGlvbiA9IG51bGw7XG4gICAgICBmb3JtRW5jVHlwZSA9IG51bGw7XG4gICAgICBmb3JtTWV0aG9kID0gbnVsbDtcbiAgICAgIGZvcm1UYXJnZXQgPSBudWxsO1xuICAgICAgaW5qZWN0Rm9ybVJlcGxheWluZ1J1bnRpbWUocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKTtcbiAgICB9XG4gIH1cblxuICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICduYW1lJywgbmFtZSk7XG4gIH1cblxuICBpZiAoZm9ybUFjdGlvbiAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICdmb3JtQWN0aW9uJywgZm9ybUFjdGlvbik7XG4gIH1cblxuICBpZiAoZm9ybUVuY1R5cGUgIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAnZm9ybUVuY1R5cGUnLCBmb3JtRW5jVHlwZSk7XG4gIH1cblxuICBpZiAoZm9ybU1ldGhvZCAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICdmb3JtTWV0aG9kJywgZm9ybU1ldGhvZCk7XG4gIH1cblxuICBpZiAoZm9ybVRhcmdldCAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICdmb3JtVGFyZ2V0JywgZm9ybVRhcmdldCk7XG4gIH1cblxuICByZXR1cm4gZm9ybURhdGE7XG59XG5cbmZ1bmN0aW9uIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSkgLy8gbm90IG51bGwgb3IgdW5kZWZpbmVkXG57XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIC8vIFRoZXNlIGFyZSB2ZXJ5IGNvbW1vbiBwcm9wcyBhbmQgdGhlcmVmb3JlIGFyZSBpbiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzd2l0Y2guXG4gICAgLy8gVE9ETzogYXJpYS1sYWJlbCBpcyBhIHZlcnkgY29tbW9uIHByb3AgYnV0IGFsbG93cyBib29sZWFucyBzbyBpcyBub3QgbGlrZSB0aGUgb3RoZXJzXG4gICAgLy8gYnV0IHNob3VsZCBpZGVhbGx5IGdvIGluIHRoaXMgbGlzdCB0b28uXG4gICAgY2FzZSAnY2xhc3NOYW1lJzpcbiAgICAgIHtcbiAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICdjbGFzcycsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICd0YWJJbmRleCc6XG4gICAgICB7XG4gICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAndGFiaW5kZXgnLCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZGlyJzpcbiAgICBjYXNlICdyb2xlJzpcbiAgICBjYXNlICd2aWV3Qm94JzpcbiAgICBjYXNlICd3aWR0aCc6XG4gICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgIHtcbiAgICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzdHlsZSc6XG4gICAgICB7XG4gICAgICAgIHB1c2hTdHlsZUF0dHJpYnV0ZSh0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc3JjJzpcbiAgICBjYXNlICdocmVmJzpcbiAgICAvLyBGYWxsIHRocm91Z2ggdG8gdGhlIGxhc3QgY2FzZSB3aGljaCBzaG91bGRuJ3QgcmVtb3ZlIGVtcHR5IHN0cmluZ3MuXG5cbiAgICBjYXNlICdhY3Rpb24nOlxuICAgIGNhc2UgJ2Zvcm1BY3Rpb24nOlxuICAgICAge1xuICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBvbmx5IHNwZWNpYWwgY2FzaW5nIHRoZXNlIGZvciBlYWNoIHRhZy5cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2FuaXRpemVkVmFsdWUgPSBzYW5pdGl6ZVVSTCgnJyArIHZhbHVlKTtcbiAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoc2FuaXRpemVkVmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZGVmYXVsdFZhbHVlJzpcbiAgICBjYXNlICdkZWZhdWx0Q2hlY2tlZCc6IC8vIFRoZXNlIHNob3VsZG4ndCBiZSBzZXQgYXMgYXR0cmlidXRlcyBvbiBnZW5lcmljIEhUTUwgZWxlbWVudHMuXG5cbiAgICBjYXNlICdpbm5lckhUTUwnOiAvLyBNdXN0IHVzZSBkYW5nZXJvdXNseVNldElubmVySFRNTCBpbnN0ZWFkLlxuXG4gICAgY2FzZSAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJzpcbiAgICBjYXNlICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnOlxuICAgICAgLy8gSWdub3JlZC4gVGhlc2UgYXJlIGJ1aWx0LWluIHRvIFJlYWN0IG9uIHRoZSBjbGllbnQuXG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICdhdXRvRm9jdXMnOlxuICAgIGNhc2UgJ211bHRpcGxlJzpcbiAgICBjYXNlICdtdXRlZCc6XG4gICAgICB7XG4gICAgICAgIHB1c2hCb29sZWFuQXR0cmlidXRlKHRhcmdldCwgbmFtZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3hsaW5rSHJlZic6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc2FuaXRpemVkVmFsdWUgPSBzYW5pdGl6ZVVSTCgnJyArIHZhbHVlKTtcblxuICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsoJ3hsaW5rOmhyZWYnKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKF9zYW5pdGl6ZWRWYWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlICdjb250ZW50RWRpdGFibGUnOlxuICAgIGNhc2UgJ3NwZWxsQ2hlY2snOlxuICAgIGNhc2UgJ2RyYWdnYWJsZSc6XG4gICAgY2FzZSAndmFsdWUnOlxuICAgIGNhc2UgJ2F1dG9SZXZlcnNlJzpcbiAgICBjYXNlICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJzpcbiAgICBjYXNlICdmb2N1c2FibGUnOlxuICAgIGNhc2UgJ3ByZXNlcnZlQWxwaGEnOlxuICAgICAge1xuICAgICAgICAvLyBCb29sZWFuaXNoIFN0cmluZ1xuICAgICAgICAvLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuICAgICAgICAvLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4gICAgICAgIC8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlICdhbGxvd0Z1bGxTY3JlZW4nOlxuICAgIGNhc2UgJ2FzeW5jJzpcbiAgICBjYXNlICdhdXRvUGxheSc6XG4gICAgY2FzZSAnY29udHJvbHMnOlxuICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgIGNhc2UgJ2RlZmVyJzpcbiAgICBjYXNlICdkaXNhYmxlZCc6XG4gICAgY2FzZSAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnOlxuICAgIGNhc2UgJ2Rpc2FibGVSZW1vdGVQbGF5YmFjayc6XG4gICAgY2FzZSAnZm9ybU5vVmFsaWRhdGUnOlxuICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgY2FzZSAnbG9vcCc6XG4gICAgY2FzZSAnbm9Nb2R1bGUnOlxuICAgIGNhc2UgJ25vVmFsaWRhdGUnOlxuICAgIGNhc2UgJ29wZW4nOlxuICAgIGNhc2UgJ3BsYXlzSW5saW5lJzpcbiAgICBjYXNlICdyZWFkT25seSc6XG4gICAgY2FzZSAncmVxdWlyZWQnOlxuICAgIGNhc2UgJ3JldmVyc2VkJzpcbiAgICBjYXNlICdzY29wZWQnOlxuICAgIGNhc2UgJ3NlYW1sZXNzJzpcbiAgICBjYXNlICdpdGVtU2NvcGUnOlxuICAgICAge1xuICAgICAgICAvLyBCb29sZWFuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlRW1wdHlTdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAnY2FwdHVyZSc6XG4gICAgY2FzZSAnZG93bmxvYWQnOlxuICAgICAge1xuICAgICAgICAvLyBPdmVybG9hZGVkIEJvb2xlYW5cbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVFbXB0eVN0cmluZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IGZhbHNlKSA7IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2NvbHMnOlxuICAgIGNhc2UgJ3Jvd3MnOlxuICAgIGNhc2UgJ3NpemUnOlxuICAgIGNhc2UgJ3NwYW4nOlxuICAgICAge1xuICAgICAgICAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzLlxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N5bWJvbCcgJiYgIWlzTmFOKHZhbHVlKSAmJiB2YWx1ZSA+PSAxKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3Jvd1NwYW4nOlxuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIHtcbiAgICAgICAgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgbnVtYmVycy5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdzeW1ib2wnICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsobmFtZSksIGF0dHJpYnV0ZUFzc2lnbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAneGxpbmtBY3R1YXRlJzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneGxpbms6YWN0dWF0ZScsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3hsaW5rQXJjcm9sZSc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3hsaW5rOmFyY3JvbGUnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bGlua1JvbGUnOlxuICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICd4bGluazpyb2xlJywgdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuXG4gICAgY2FzZSAneGxpbmtTaG93JzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneGxpbms6c2hvdycsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3hsaW5rVGl0bGUnOlxuICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICd4bGluazp0aXRsZScsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3hsaW5rVHlwZSc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3hsaW5rOnR5cGUnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bWxCYXNlJzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneG1sOmJhc2UnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bWxMYW5nJzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneG1sOmxhbmcnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bWxTcGFjZSc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3htbDpzcGFjZScsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoIC8vIHNob3VsZElnbm9yZUF0dHJpYnV0ZVxuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IGZpbHRlcmVkIG91dCBudWxsL3VuZGVmaW5lZCBhbmQgcmVzZXJ2ZWQgd29yZHMuXG4gICAgICBuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gZ2V0QXR0cmlidXRlQWxpYXMobmFtZSk7XG5cbiAgICAgIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIC8vIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwcmVmaXggPSBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG5cbiAgICAgICAgICAgICAgaWYgKHByZWZpeCAhPT0gJ2RhdGEtJyAmJiBwcmVmaXggIT09ICdhcmlhLScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhhdHRyaWJ1dGVOYW1lKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gICAgICB9XG5cbiAgfVxufVxuXG52YXIgZW5kT2ZTdGFydFRhZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPicpO1xudmFyIGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnLz4nKTtcblxuZnVuY3Rpb24gcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pIHtcbiAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbm5lckhUTUwgIT09ICdvYmplY3QnIHx8ICEoJ19faHRtbCcgaW4gaW5uZXJIVE1MKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiAnICsgJ1BsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgJyArICdmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgaHRtbCA9IGlubmVySFRNTC5fX2h0bWw7XG5cbiAgICBpZiAoaHRtbCAhPT0gbnVsbCAmJiBodG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oaHRtbCk7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoJycgKyBodG1sKSk7XG4gICAgfVxuICB9XG59IC8vIFRPRE86IE1vdmUgdGhlc2UgdG8gUmVuZGVyU3RhdGUgc28gdGhhdCB3ZSB3YXJuIGZvciBldmVyeSByZXF1ZXN0LlxuLy8gSXQgd291bGQgaGVscCBkZWJ1Z2dpbmcgaW4gc3RhdGVmdWwgc2VydmVycyAoZS5nLiBzZXJ2aWNlIHdvcmtlcikuXG5cblxudmFyIGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gZmFsc2U7XG52YXIgZGlkV2FybkludmFsaWRPcHRpb25Jbm5lckhUTUwgPSBmYWxzZTtcbnZhciBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5Gb3JtQWN0aW9uTmFtZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0ID0gZmFsc2U7XG52YXIgZGlkV2FybkZvcm1BY3Rpb25NZXRob2QgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wKHByb3BzLCBwcm9wTmFtZSkge1xuICB7XG4gICAgdmFyIHZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHZhciBhcnJheSA9IGlzQXJyYXkodmFsdWUpO1xuXG4gICAgICBpZiAocHJvcHMubXVsdGlwbGUgJiYgIWFycmF5KSB7XG4gICAgICAgIGVycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJywgcHJvcE5hbWUpO1xuICAgICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgYXJyYXkpIHtcbiAgICAgICAgZXJyb3IoJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJywgcHJvcE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRTZWxlY3QodGFyZ2V0LCBwcm9wcykge1xuICB7XG4gICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnc2VsZWN0JywgcHJvcHMpO1xuICAgIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgJ3ZhbHVlJyk7XG4gICAgY2hlY2tTZWxlY3RQcm9wKHByb3BzLCAnZGVmYXVsdFZhbHVlJyk7XG5cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSkge1xuICAgICAgZXJyb3IoJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygnc2VsZWN0JykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgLy8gVE9ETzogVGhpcyBkb2Vzbid0IHJlYWxseSBtYWtlIHNlbnNlIGZvciBzZWxlY3Qgc2luY2UgaXQgY2FuJ3QgdXNlIHRoZSBjb250cm9sbGVkXG4gICAgICAgICAgLy8gdmFsdWUgaW4gdGhlIGlubmVySFRNTC5cbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGVmYXVsdFZhbHVlJzpcbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIC8vIFRoZXNlIGFyZSBzZXQgb24gdGhlIENvbnRleHQgaW5zdGVhZCBhbmQgYXBwbGllZCB0byB0aGUgbmVzdGVkIG9wdGlvbnMuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5PcHRpb25DaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgY29udGVudCA9ICcnOyAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cblxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG5cbiAgICB7XG4gICAgICBpZiAoIWRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gJiYgdHlwZW9mIGNoaWxkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgY2hpbGQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdDYW5ub3QgaW5mZXIgdGhlIG9wdGlvbiB2YWx1ZSBvZiBjb21wbGV4IGNoaWxkcmVuLiAnICsgJ1Bhc3MgYSBgdmFsdWVgIHByb3Agb3IgdXNlIGEgcGxhaW4gc3RyaW5nIGFzIGNoaWxkcmVuIHRvIDxvcHRpb24+LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjb250ZW50O1xufVxuXG52YXIgc2VsZWN0ZWRNYXJrZXJBdHRyaWJ1dGUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBzZWxlY3RlZD1cIlwiJyk7XG5cbmZ1bmN0aW9uIHB1c2hTdGFydE9wdGlvbih0YXJnZXQsIHByb3BzLCBmb3JtYXRDb250ZXh0KSB7XG4gIHZhciBzZWxlY3RlZFZhbHVlID0gZm9ybWF0Q29udGV4dC5zZWxlY3RlZFZhbHVlO1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdvcHRpb24nKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciB2YWx1ZSA9IG51bGw7XG4gIHZhciBzZWxlY3RlZCA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NlbGVjdGVkJzpcbiAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICBzZWxlY3RlZCA9IHByb3BWYWx1ZTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuICAgICAgICAgICAgaWYgKCFkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbikge1xuICAgICAgICAgICAgICBlcnJvcignVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJyArICdzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJyk7XG5cbiAgICAgICAgICAgICAgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIHZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICAvLyBXZSBpbnRlbnRpb25hbGx5IGZhbGx0aHJvdWdoIHRvIGFsc28gc2V0IHRoZSBhdHRyaWJ1dGUgb24gdGhlIG5vZGUuXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZWN0ZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdmFyIHN0cmluZ1ZhbHVlO1xuXG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsICd2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICBzdHJpbmdWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGlubmVySFRNTCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghZGlkV2FybkludmFsaWRPcHRpb25Jbm5lckhUTUwpIHtcbiAgICAgICAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1Bhc3MgYSBgdmFsdWVgIHByb3AgaWYgeW91IHNldCBkYW5nZXJvdXNseUlubmVySFRNTCBzbyBSZWFjdCBrbm93cyAnICsgJ3doaWNoIHZhbHVlIHNob3VsZCBiZSBzZWxlY3RlZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RyaW5nVmFsdWUgPSBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KHNlbGVjdGVkVmFsdWUpKSB7XG4gICAgICAvLyBtdWx0aXBsZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHNlbGVjdGVkVmFsdWVbaV0sICd2YWx1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHYgPSAnJyArIHNlbGVjdGVkVmFsdWVbaV07XG5cbiAgICAgICAgaWYgKHYgPT09IHN0cmluZ1ZhbHVlKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goc2VsZWN0ZWRNYXJrZXJBdHRyaWJ1dGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihzZWxlY3RlZFZhbHVlLCAnc2VsZWN0LnZhbHVlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICgnJyArIHNlbGVjdGVkVmFsdWUgPT09IHN0cmluZ1ZhbHVlKSB7XG4gICAgICAgIHRhcmdldC5wdXNoKHNlbGVjdGVkTWFya2VyQXR0cmlidXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoc2VsZWN0ZWQpIHtcbiAgICB0YXJnZXQucHVzaChzZWxlY3RlZE1hcmtlckF0dHJpYnV0ZSk7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbnZhciBmb3JtUmVwbGF5aW5nUnVudGltZVNjcmlwdCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhmb3JtUmVwbGF5aW5nKTtcblxuZnVuY3Rpb24gaW5qZWN0Rm9ybVJlcGxheWluZ1J1bnRpbWUocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKSB7XG4gIC8vIElmIHdlIGhhdmVuJ3Qgc2VudCBpdCB5ZXQsIGluamVjdCB0aGUgcnVudGltZSB0aGF0IHRyYWNrcyBzdWJtaXR0ZWQgSlMgYWN0aW9uc1xuICAvLyBmb3IgbGF0ZXIgcmVwbGF5aW5nIGJ5IEZpYmVyLiBJZiB3ZSB1c2UgYW4gZXh0ZXJuYWwgcnVudGltZSwgd2UgZG9uJ3QgbmVlZFxuICAvLyB0byBlbWl0IGFueXRoaW5nLiBJdCdzIGFsd2F5cyB1c2VkLlxuICBpZiAoKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIFNlbnRGb3JtUmVwbGF5aW5nUnVudGltZSkgPT09IE5vdGhpbmdTZW50ICYmICghcmVuZGVyU3RhdGUuZXh0ZXJuYWxSdW50aW1lU2NyaXB0KSkge1xuICAgIHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyB8PSBTZW50Rm9ybVJlcGxheWluZ1J1bnRpbWU7XG4gICAgcmVuZGVyU3RhdGUuYm9vdHN0cmFwQ2h1bmtzLnVuc2hpZnQocmVuZGVyU3RhdGUuc3RhcnRJbmxpbmVTY3JpcHQsIGZvcm1SZXBsYXlpbmdSdW50aW1lU2NyaXB0LCBlbmRJbmxpbmVTY3JpcHQpO1xuICB9XG59XG5cbnZhciBmb3JtU3RhdGVNYXJrZXJJc01hdGNoaW5nID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tRiEtLT4nKTtcbnZhciBmb3JtU3RhdGVNYXJrZXJJc05vdE1hdGNoaW5nID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tRi0tPicpO1xuZnVuY3Rpb24gcHVzaEZvcm1TdGF0ZU1hcmtlcklzTWF0Y2hpbmcodGFyZ2V0KSB7XG4gIHRhcmdldC5wdXNoKGZvcm1TdGF0ZU1hcmtlcklzTWF0Y2hpbmcpO1xufVxuZnVuY3Rpb24gcHVzaEZvcm1TdGF0ZU1hcmtlcklzTm90TWF0Y2hpbmcodGFyZ2V0KSB7XG4gIHRhcmdldC5wdXNoKGZvcm1TdGF0ZU1hcmtlcklzTm90TWF0Y2hpbmcpO1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRGb3JtKHRhcmdldCwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSkge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdmb3JtJykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcbiAgdmFyIGZvcm1BY3Rpb24gPSBudWxsO1xuICB2YXIgZm9ybUVuY1R5cGUgPSBudWxsO1xuICB2YXIgZm9ybU1ldGhvZCA9IG51bGw7XG4gIHZhciBmb3JtVGFyZ2V0ID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2FjdGlvbic6XG4gICAgICAgICAgZm9ybUFjdGlvbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdlbmNUeXBlJzpcbiAgICAgICAgICBmb3JtRW5jVHlwZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtZXRob2QnOlxuICAgICAgICAgIGZvcm1NZXRob2QgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICBmb3JtVGFyZ2V0ID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGZvcm1EYXRhID0gbnVsbDtcbiAgdmFyIGZvcm1BY3Rpb25OYW1lID0gbnVsbDtcblxuICBpZiAodHlwZW9mIGZvcm1BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBGdW5jdGlvbiBmb3JtIGFjdGlvbnMgY2Fubm90IGNvbnRyb2wgdGhlIGZvcm0gcHJvcGVydGllc1xuICAgIHtcbiAgICAgIGlmICgoZm9ybUVuY1R5cGUgIT09IG51bGwgfHwgZm9ybU1ldGhvZCAhPT0gbnVsbCkgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kKSB7XG4gICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignQ2Fubm90IHNwZWNpZnkgYSBlbmNUeXBlIG9yIG1ldGhvZCBmb3IgYSBmb3JtIHRoYXQgc3BlY2lmaWVzIGEgJyArICdmdW5jdGlvbiBhcyB0aGUgYWN0aW9uLiBSZWFjdCBwcm92aWRlcyB0aG9zZSBhdXRvbWF0aWNhbGx5LiAnICsgJ1RoZXkgd2lsbCBnZXQgb3ZlcnJpZGRlbi4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcm1UYXJnZXQgIT09IG51bGwgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0KSB7XG4gICAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVGFyZ2V0ID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignQ2Fubm90IHNwZWNpZnkgYSB0YXJnZXQgZm9yIGEgZm9ybSB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIHRoZSBhY3Rpb24uICcgKyAnVGhlIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIHdpbmRvdy4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY3VzdG9tQWN0aW9uID0gZm9ybUFjdGlvbi4kJEZPUk1fQUNUSU9OO1xuXG4gICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgYWN0aW9uIGhhcyBhIGN1c3RvbSBwcm9ncmVzc2l2ZSBlbmhhbmNlbWVudCBmb3JtIHRoYXQgY2FuIHN1Ym1pdCB0aGUgZm9ybVxuICAgICAgLy8gYmFjayB0byB0aGUgc2VydmVyIGlmIGl0J3MgaW52b2tlZCBiZWZvcmUgaHlkcmF0aW9uLiBTdWNoIGFzIGEgU2VydmVyIEFjdGlvbi5cbiAgICAgIHZhciBwcmVmaXggPSBtYWtlRm9ybUZpZWxkUHJlZml4KHJlc3VtYWJsZVN0YXRlKTtcbiAgICAgIHZhciBjdXN0b21GaWVsZHMgPSBmb3JtQWN0aW9uLiQkRk9STV9BQ1RJT04ocHJlZml4KTtcbiAgICAgIGZvcm1BY3Rpb24gPSBjdXN0b21GaWVsZHMuYWN0aW9uIHx8ICcnO1xuICAgICAgZm9ybUVuY1R5cGUgPSBjdXN0b21GaWVsZHMuZW5jVHlwZTtcbiAgICAgIGZvcm1NZXRob2QgPSBjdXN0b21GaWVsZHMubWV0aG9kO1xuICAgICAgZm9ybVRhcmdldCA9IGN1c3RvbUZpZWxkcy50YXJnZXQ7XG4gICAgICBmb3JtRGF0YSA9IGN1c3RvbUZpZWxkcy5kYXRhO1xuICAgICAgZm9ybUFjdGlvbk5hbWUgPSBjdXN0b21GaWVsZHMubmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0IGEgamF2YXNjcmlwdCBVUkwgdGhhdCBkb2Vzbid0IGRvIGFueXRoaW5nLiBXZSBkb24ndCBleHBlY3QgdGhpcyB0byBiZSBpbnZva2VkXG4gICAgICAvLyBiZWNhdXNlIHdlJ2xsIHByZXZlbnREZWZhdWx0IGluIHRoZSBGaXp6IHJ1bnRpbWUsIGJ1dCBpdCBjYW4gaGFwcGVuIGlmIGEgZm9ybSBpc1xuICAgICAgLy8gbWFudWFsbHkgc3VibWl0dGVkIG9yIGlmIHNvbWVvbmUgY2FsbHMgc3RvcFByb3BhZ2F0aW9uIGJlZm9yZSBSZWFjdCBnZXRzIHRoZSBldmVudC5cbiAgICAgIC8vIElmIENTUCBpcyB1c2VkIHRvIGJsb2NrIGphdmFzY3JpcHQ6IFVSTHMgdGhhdCdzIGZpbmUgdG9vLiBJdCBqdXN0IHdvbid0IHNob3cgdGhpc1xuICAgICAgLy8gZXJyb3IgbWVzc2FnZSBidXQgdGhlIFVSTCB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuaygnYWN0aW9uJyksIGF0dHJpYnV0ZUFzc2lnbiwgYWN0aW9uSmF2YVNjcmlwdFVSTCwgYXR0cmlidXRlRW5kKTtcbiAgICAgIGZvcm1BY3Rpb24gPSBudWxsO1xuICAgICAgZm9ybUVuY1R5cGUgPSBudWxsO1xuICAgICAgZm9ybU1ldGhvZCA9IG51bGw7XG4gICAgICBmb3JtVGFyZ2V0ID0gbnVsbDtcbiAgICAgIGluamVjdEZvcm1SZXBsYXlpbmdSdW50aW1lKHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZvcm1BY3Rpb24gIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAnYWN0aW9uJywgZm9ybUFjdGlvbik7XG4gIH1cblxuICBpZiAoZm9ybUVuY1R5cGUgIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAnZW5jVHlwZScsIGZvcm1FbmNUeXBlKTtcbiAgfVxuXG4gIGlmIChmb3JtTWV0aG9kICE9IG51bGwpIHtcbiAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgJ21ldGhvZCcsIGZvcm1NZXRob2QpO1xuICB9XG5cbiAgaWYgKGZvcm1UYXJnZXQgIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAndGFyZ2V0JywgZm9ybVRhcmdldCk7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcblxuICBpZiAoZm9ybUFjdGlvbk5hbWUgIT09IG51bGwpIHtcbiAgICB0YXJnZXQucHVzaChzdGFydEhpZGRlbklucHV0Q2h1bmspO1xuICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAnbmFtZScsIGZvcm1BY3Rpb25OYW1lKTtcbiAgICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICAgIHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkcyh0YXJnZXQsIGZvcm1EYXRhKTtcbiAgfVxuXG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcblxuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgIC8vIFNwZWNpYWwgY2FzZSBjaGlsZHJlbiBhcyBhIHN0cmluZyB0byBhdm9pZCB0aGUgdW5uZWNlc3NhcnkgY29tbWVudC5cbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBzcGVjaWFsIGNhc2UgYWZ0ZXIgdGhlIGdlbmVyYWwgb3B0aW1pemF0aW9uIGlzIGluIHBsYWNlLlxuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZW5jb2RlSFRNTFRleHROb2RlKGNoaWxkcmVuKSkpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBwdXNoSW5wdXQodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKSB7XG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCdpbnB1dCcsIHByb3BzKTtcbiAgfVxuXG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ2lucHV0JykpO1xuICB2YXIgbmFtZSA9IG51bGw7XG4gIHZhciBmb3JtQWN0aW9uID0gbnVsbDtcbiAgdmFyIGZvcm1FbmNUeXBlID0gbnVsbDtcbiAgdmFyIGZvcm1NZXRob2QgPSBudWxsO1xuICB2YXIgZm9ybVRhcmdldCA9IG51bGw7XG4gIHZhciB2YWx1ZSA9IG51bGw7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBudWxsO1xuICB2YXIgY2hlY2tlZCA9IG51bGw7XG4gIHZhciBkZWZhdWx0Q2hlY2tlZCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0JyArIFwiIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgXCIgKyAndXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgbmFtZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb3JtQWN0aW9uJzpcbiAgICAgICAgICBmb3JtQWN0aW9uID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1FbmNUeXBlJzpcbiAgICAgICAgICBmb3JtRW5jVHlwZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb3JtTWV0aG9kJzpcbiAgICAgICAgICBmb3JtTWV0aG9kID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1UYXJnZXQnOlxuICAgICAgICAgIGZvcm1UYXJnZXQgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGVmYXVsdENoZWNrZWQnOlxuICAgICAgICAgIGRlZmF1bHRDaGVja2VkID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RlZmF1bHRWYWx1ZSc6XG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgIGNoZWNrZWQgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIHZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChmb3JtQWN0aW9uICE9PSBudWxsICYmIHByb3BzLnR5cGUgIT09ICdpbWFnZScgJiYgcHJvcHMudHlwZSAhPT0gJ3N1Ym1pdCcgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uVHlwZSkge1xuICAgICAgZGlkV2FybkZvcm1BY3Rpb25UeXBlID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ0FuIGlucHV0IGNhbiBvbmx5IHNwZWNpZnkgYSBmb3JtQWN0aW9uIGFsb25nIHdpdGggdHlwZT1cInN1Ym1pdFwiIG9yIHR5cGU9XCJpbWFnZVwiLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmb3JtRGF0YSA9IHB1c2hGb3JtQWN0aW9uQXR0cmlidXRlKHRhcmdldCwgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBmb3JtQWN0aW9uLCBmb3JtRW5jVHlwZSwgZm9ybU1ldGhvZCwgZm9ybVRhcmdldCwgbmFtZSk7XG5cbiAge1xuICAgIGlmIChjaGVja2VkICE9PSBudWxsICYmIGRlZmF1bHRDaGVja2VkICE9PSBudWxsICYmICFkaWRXYXJuRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcblxuICAgICAgZGlkV2FybkRlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSBudWxsICYmICFkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUpIHtcbiAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgIGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNoZWNrZWQgIT09IG51bGwpIHtcbiAgICBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQsICdjaGVja2VkJywgY2hlY2tlZCk7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdENoZWNrZWQgIT09IG51bGwpIHtcbiAgICBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQsICdjaGVja2VkJywgZGVmYXVsdENoZWNrZWQpO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICd2YWx1ZScsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0VmFsdWUgIT09IG51bGwpIHtcbiAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgJ3ZhbHVlJywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7IC8vIFdlIHBsYWNlIGFueSBhZGRpdGlvbmFsIGhpZGRlbiBmb3JtIGZpZWxkcyBhZnRlciB0aGUgaW5wdXQuXG5cbiAgcHVzaEFkZGl0aW9uYWxGb3JtRmllbGRzKHRhcmdldCwgZm9ybURhdGEpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0QnV0dG9uKHRhcmdldCwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSkge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdidXR0b24nKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuICB2YXIgbmFtZSA9IG51bGw7XG4gIHZhciBmb3JtQWN0aW9uID0gbnVsbDtcbiAgdmFyIGZvcm1FbmNUeXBlID0gbnVsbDtcbiAgdmFyIGZvcm1NZXRob2QgPSBudWxsO1xuICB2YXIgZm9ybVRhcmdldCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICBuYW1lID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1BY3Rpb24nOlxuICAgICAgICAgIGZvcm1BY3Rpb24gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZm9ybUVuY1R5cGUnOlxuICAgICAgICAgIGZvcm1FbmNUeXBlID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1NZXRob2QnOlxuICAgICAgICAgIGZvcm1NZXRob2QgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZm9ybVRhcmdldCc6XG4gICAgICAgICAgZm9ybVRhcmdldCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoZm9ybUFjdGlvbiAhPT0gbnVsbCAmJiBwcm9wcy50eXBlICE9IG51bGwgJiYgcHJvcHMudHlwZSAhPT0gJ3N1Ym1pdCcgJiYgIWRpZFdhcm5Gb3JtQWN0aW9uVHlwZSkge1xuICAgICAgZGlkV2FybkZvcm1BY3Rpb25UeXBlID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ0EgYnV0dG9uIGNhbiBvbmx5IHNwZWNpZnkgYSBmb3JtQWN0aW9uIGFsb25nIHdpdGggdHlwZT1cInN1Ym1pdFwiIG9yIG5vIHR5cGUuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZvcm1EYXRhID0gcHVzaEZvcm1BY3Rpb25BdHRyaWJ1dGUodGFyZ2V0LCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIGZvcm1BY3Rpb24sIGZvcm1FbmNUeXBlLCBmb3JtTWV0aG9kLCBmb3JtVGFyZ2V0LCBuYW1lKTtcbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7IC8vIFdlIHBsYWNlIGFueSBhZGRpdGlvbmFsIGhpZGRlbiBmb3JtIGZpZWxkcyB3ZSBuZWVkIHRvIGluY2x1ZGUgaW5zaWRlIHRoZSBidXR0b24gaXRzZWxmLlxuXG4gIHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkcyh0YXJnZXQsIGZvcm1EYXRhKTtcbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGNoaWxkcmVuIGFzIGEgc3RyaW5nIHRvIGF2b2lkIHRoZSB1bm5lY2Vzc2FyeSBjb21tZW50LlxuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBhZnRlciB0aGUgZ2VuZXJhbCBvcHRpbWl6YXRpb24gaXMgaW4gcGxhY2UuXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUoY2hpbGRyZW4pKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydFRleHRBcmVhKHRhcmdldCwgcHJvcHMpIHtcbiAge1xuICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ3RleHRhcmVhJywgcHJvcHMpO1xuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSkge1xuICAgICAgZXJyb3IoJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuXG4gICAgICBkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ3RleHRhcmVhJykpO1xuICB2YXIgdmFsdWUgPSBudWxsO1xuICB2YXIgZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgdmFsdWUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGVmYXVsdFZhbHVlJzpcbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJyk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodmFsdWUgPT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSBudWxsKSB7XG4gICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTsgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cblxuICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGVycm9yKCdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKTtcbiAgICAgIH0gLy8gVE9ETzogcmVtb3ZlIHRoZSBjb2VyY2lvbiBhbmQgdGhlIERFViBjaGVjayBiZWxvdyBiZWNhdXNlIGl0IHdpbGxcbiAgICAgIC8vIGFsd2F5cyBiZSBvdmVyd3JpdHRlbiBieSB0aGUgY29lcmNpb24gc2V2ZXJhbCBsaW5lcyBiZWxvdyBpdC4gIzIyMzA5XG5cblxuICAgICAge1xuICAgICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihjaGlsZHJlblswXSk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gJycgKyBjaGlsZHJlblswXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihjaGlsZHJlbik7XG4gICAgfVxuXG4gICAgdmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWVbMF0gPT09ICdcXG4nKSB7XG4gICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gICAgLy8gUHJlZmVyIHRvIGJyZWFrIGFwcGxpY2F0aW9uL3htbCBvdmVyIHRleHQvaHRtbCAoZm9yIG5vdykgYnkgYWRkaW5nXG4gICAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAgIC8vIFxcciBpcyBub3JtYWxpemVkIG91dCBieSBIVE1MVGV4dEFyZWFFbGVtZW50I3ZhbHVlLilcbiAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI25ld2xpbmVzPlxuICAgIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgICB0YXJnZXQucHVzaChsZWFkaW5nTmV3bGluZSk7XG4gIH0gLy8gVG9TdHJpbmcgYW5kIHB1c2ggZGlyZWN0bHkgaW5zdGVhZCBvZiByZWN1cnNlIG92ZXIgY2hpbGRyZW4uXG4gIC8vIFdlIGRvbid0IHJlYWxseSBzdXBwb3J0IGNvbXBsZXggY2hpbGRyZW4gaW4gdGhlIHZhbHVlIGFueXdheS5cbiAgLy8gVGhpcyBhbHNvIGN1cnJlbnRseSBhdm9pZHMgYSB0cmFpbGluZyBjb21tZW50IG5vZGUgd2hpY2ggYnJlYWtzIHRleHRhcmVhLlxuXG5cbiAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUoJycgKyB2YWx1ZSkpKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoTWV0YSh0YXJnZXQsIHByb3BzLCByZW5kZXJTdGF0ZSwgdGV4dEVtYmVkZGVkLCBpbnNlcnRpb25Nb2RlLCBub3NjcmlwdFRhZ0luU2NvcGUpIHtcbiAge1xuICAgIGlmIChpbnNlcnRpb25Nb2RlID09PSBTVkdfTU9ERSB8fCBub3NjcmlwdFRhZ0luU2NvcGUgfHwgcHJvcHMuaXRlbVByb3AgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHB1c2hTZWxmQ2xvc2luZyh0YXJnZXQsIHByb3BzLCAnbWV0YScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGV4dEVtYmVkZGVkKSB7XG4gICAgICAgIC8vIFRoaXMgbGluayBmb2xsb3dzIHRleHQgYnV0IHdlIGFyZW4ndCB3cml0aW5nIGEgdGFnLiB3aGlsZSBub3QgYXMgZWZmaWNpZW50IGFzIHBvc3NpYmxlIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gYmUgc2FmZSBhbmQgYXNzdW1lIHRleHQgd2lsbCBmb2xsb3cgYnkgaW5zZXJ0aW5nIGEgdGV4dFNlcGFyYXRvclxuICAgICAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5jaGFyU2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcHVzaFNlbGZDbG9zaW5nKHJlbmRlclN0YXRlLmNoYXJzZXRDaHVua3MsIHByb3BzLCAnbWV0YScpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wcy5uYW1lID09PSAndmlld3BvcnQnKSB7XG4gICAgICAgIC8vIFwidmlld3BvcnRcIiBpc24ndCByZWxhdGVkIHRvIHByZWNvbm5lY3QgYnV0IGl0IGhhcyB0aGUgcmlnaHQgcHJpb3JpdHlcbiAgICAgICAgcmV0dXJuIHB1c2hTZWxmQ2xvc2luZyhyZW5kZXJTdGF0ZS5wcmVjb25uZWN0Q2h1bmtzLCBwcm9wcywgJ21ldGEnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwdXNoU2VsZkNsb3NpbmcocmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLCBwcm9wcywgJ21ldGEnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaExpbmsodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQsIGluc2VydGlvbk1vZGUsIG5vc2NyaXB0VGFnSW5TY29wZSkge1xuICB7XG4gICAgdmFyIHJlbCA9IHByb3BzLnJlbDtcbiAgICB2YXIgaHJlZiA9IHByb3BzLmhyZWY7XG4gICAgdmFyIHByZWNlZGVuY2UgPSBwcm9wcy5wcmVjZWRlbmNlO1xuXG4gICAgaWYgKGluc2VydGlvbk1vZGUgPT09IFNWR19NT0RFIHx8IG5vc2NyaXB0VGFnSW5TY29wZSB8fCBwcm9wcy5pdGVtUHJvcCAhPSBudWxsIHx8IHR5cGVvZiByZWwgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBocmVmICE9PSAnc3RyaW5nJyB8fCBocmVmID09PSAnJykge1xuICAgICAge1xuICAgICAgICBpZiAocmVsID09PSAnc3R5bGVzaGVldCcgJiYgdHlwZW9mIHByb3BzLnByZWNlZGVuY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBocmVmICE9PSAnc3RyaW5nJyB8fCAhaHJlZikge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0IGVuY291bnRlcmVkIGEgYDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiAuLi4vPmAgd2l0aCBhIGBwcmVjZWRlbmNlYCBwcm9wIGFuZCBleHBlY3RlZCB0aGUgYGhyZWZgIHByb3AgdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nIGJ1dCBlY291bnRlcmVkICVzIGluc3RlYWQuIElmIHlvdXIgaW50ZW50IHdhcyB0byBoYXZlIFJlYWN0IGhvaXN0IGFuZCBkZWR1cGxjaWF0ZSB0aGlzIHN0eWxlc2hlZXQgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIGVuc3VyZSB0aGVyZSBpcyBhIG5vbi1lbXB0eSBzdHJpbmcgYGhyZWZgIHByb3AgYXMgd2VsbCwgb3RoZXJ3aXNlIHJlbW92ZSB0aGUgYHByZWNlZGVuY2VgIHByb3AuJywgZ2V0VmFsdWVEZXNjcmlwdG9yRXhwZWN0aW5nT2JqZWN0Rm9yV2FybmluZyhocmVmKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHB1c2hMaW5rSW1wbCh0YXJnZXQsIHByb3BzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5yZWwgPT09ICdzdHlsZXNoZWV0Jykge1xuICAgICAgLy8gVGhpcyA8bGluaz4gbWF5IGhvaXN0YWJsZSBhcyBhIFN0eWxlc2hlZXQgUmVzb3VyY2UsIG90aGVyd2lzZSBpdCB3aWxsIGVtaXQgaW4gcGxhY2VcbiAgICAgIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleShocmVmKTtcblxuICAgICAgaWYgKHR5cGVvZiBwcmVjZWRlbmNlICE9PSAnc3RyaW5nJyB8fCBwcm9wcy5kaXNhYmxlZCAhPSBudWxsIHx8IHByb3BzLm9uTG9hZCB8fCBwcm9wcy5vbkVycm9yKSB7XG4gICAgICAgIC8vIFRoaXMgc3R5bGVzaGVldCBpcyBlaXRoZXIgbm90IG9wdGVkIGludG8gUmVzb3VyY2Ugc2VtYW50aWNzIG9yIGhhcyBjb25mbGljdGluZyBwcm9wZXJ0aWVzIHdoaWNoXG4gICAgICAgIC8vIGRpc3F1YWxpZnkgaXQgZm9yIHN1Y2guIFdlIGNhbiBzdGlsbCBjcmVhdGUgYSBwcmVsb2FkIHJlc291cmNlIHRvIGhlbHAgaXQgbG9hZCBmYXN0ZXIgb24gdGhlXG4gICAgICAgIC8vIGNsaWVudFxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwcmVjZWRlbmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHByb3BzLmRpc2FibGVkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1JlYWN0IGVuY291bnRlcmVkIGEgYDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiAuLi4vPmAgd2l0aCBhIGBwcmVjZWRlbmNlYCBwcm9wIGFuZCBhIGBkaXNhYmxlZGAgcHJvcC4gVGhlIHByZXNlbmNlIG9mIHRoZSBgZGlzYWJsZWRgIHByb3AgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgYWN0aXZlIHN0YXRlIGZyb20geW91ciBmcm9tIHlvdXIgQ29tcG9uZW50IGNvZGUgYW5kIFJlYWN0IHdpbGwgbm90IGhvaXN0IG9yIGRlZHVwbGljYXRlIHRoaXMgc3R5bGVzaGVldC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgcmVtb3ZlIHRoZSBgZGlzYWJsZWRgIHByb3AsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5vbkxvYWQgfHwgcHJvcHMub25FcnJvcikge1xuICAgICAgICAgICAgICB2YXIgcHJvcERlc2NyaXB0aW9uID0gcHJvcHMub25Mb2FkICYmIHByb3BzLm9uRXJyb3IgPyAnYG9uTG9hZGAgYW5kIGBvbkVycm9yYCBwcm9wcycgOiBwcm9wcy5vbkxvYWQgPyAnYG9uTG9hZGAgcHJvcCcgOiAnYG9uRXJyb3JgIHByb3AnO1xuXG4gICAgICAgICAgICAgIGVycm9yKCdSZWFjdCBlbmNvdW50ZXJlZCBhIGA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgLi4uLz5gIHdpdGggYSBgcHJlY2VkZW5jZWAgcHJvcCBhbmQgJXMuIFRoZSBwcmVzZW5jZSBvZiBsb2FkaW5nIGFuZCBlcnJvciBoYW5kbGVycyBpbmRpY2F0ZXMgYW4gaW50ZW50IHRvIG1hbmFnZSB0aGUgc3R5bGVzaGVldCBsb2FkaW5nIHN0YXRlIGZyb20geW91ciBmcm9tIHlvdXIgQ29tcG9uZW50IGNvZGUgYW5kIFJlYWN0IHdpbGwgbm90IGhvaXN0IG9yIGRlZHVwbGljYXRlIHRoaXMgc3R5bGVzaGVldC4gSWYgeW91ciBpbnRlbnQgd2FzIHRvIGhhdmUgUmVhY3QgaG9pc3QgYW5kIGRlZHVwbGNpYXRlIHRoaXMgc3R5bGVzaGVldCB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgcmVtb3ZlIHRoZSAlcywgb3RoZXJ3aXNlIHJlbW92ZSB0aGUgYHByZWNlZGVuY2VgIHByb3AuJywgcHJvcERlc2NyaXB0aW9uLCBwcm9wRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwdXNoTGlua0ltcGwodGFyZ2V0LCBwcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHN0eWxlc2hlZXQgcmVmZXJzIHRvIGEgUmVzb3VyY2UgYW5kIHdlIGNyZWF0ZSBhIG5ldyBvbmUgaWYgbmVjZXNzYXJ5XG4gICAgICAgIHZhciBzdHlsZVF1ZXVlID0gcmVuZGVyU3RhdGUuc3R5bGVzLmdldChwcmVjZWRlbmNlKTtcbiAgICAgICAgdmFyIGhhc0tleSA9IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICAgIHZhciByZXNvdXJjZVN0YXRlID0gaGFzS2V5ID8gcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNba2V5XSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAocmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTKSB7XG4gICAgICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIGNyZWF0ZSB0aGlzIHJlc291cmNlIG5vdyBzbyBpdCBpcyBtYXJrZWQgYXMgRXhpc3RzXG4gICAgICAgICAgcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXNba2V5XSA9IEVYSVNUUzsgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSd2ZSBlbmNvdW50ZXJlZCB0aGlzIHByZWNlZGVuY2Ugd2UgbmVlZFxuICAgICAgICAgIC8vIHRvIGNyZWF0ZSBhIFN0eWxlUXVldWVcblxuICAgICAgICAgIGlmICghc3R5bGVRdWV1ZSkge1xuICAgICAgICAgICAgc3R5bGVRdWV1ZSA9IHtcbiAgICAgICAgICAgICAgcHJlY2VkZW5jZTogc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihwcmVjZWRlbmNlKSksXG4gICAgICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICAgICAgaHJlZnM6IFtdLFxuICAgICAgICAgICAgICBzaGVldHM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5zZXQocHJlY2VkZW5jZSwgc3R5bGVRdWV1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlc291cmNlID0ge1xuICAgICAgICAgICAgc3RhdGU6IFBFTkRJTkckMSxcbiAgICAgICAgICAgIHByb3BzOiBzdHlsZXNoZWV0UHJvcHNGcm9tUmF3UHJvcHMocHJvcHMpXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyZXNvdXJjZVN0YXRlKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHJlc291cmNlU3RhdGUgaXMgdHJ1dHkgaXQgaXMgYSBQcmVsb2FkIHN0YXRlLiBXZSBjYXN0IGl0IGZvciBjbGFyaXR5XG4gICAgICAgICAgICB2YXIgcHJlbG9hZFN0YXRlID0gcmVzb3VyY2VTdGF0ZTtcblxuICAgICAgICAgICAgaWYgKHByZWxvYWRTdGF0ZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMocmVzb3VyY2UucHJvcHMsIHByZWxvYWRTdGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwcmVsb2FkUmVzb3VyY2UgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zdHlsZXNoZWV0cy5nZXQoa2V5KTtcblxuICAgICAgICAgICAgaWYgKHByZWxvYWRSZXNvdXJjZSAmJiBwcmVsb2FkUmVzb3VyY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyBUaGUgUHJlbG9hZCBmb3IgdGhpcyByZXNvdXJjZSB3YXMgY3JlYXRlZCBpbiB0aGlzIHJlbmRlciBwYXNzIGFuZCBoYXMgbm90IGZsdXNoZWQgeWV0IHNvXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY2xlYXIgaXQgdG8gYXZvaWQgaXQgZmx1c2hpbmcuXG4gICAgICAgICAgICAgIHByZWxvYWRSZXNvdXJjZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gRWl0aGVyIHRoZSBwcmVsb2FkIHJlc291cmNlIGZyb20gdGhpcyByZW5kZXIgYWxyZWFkeSBmbHVzaGVkIGluIHRoaXMgcmVuZGVyIHBhc3NcbiAgICAgICAgICAgICAgLy8gb3IgdGhlIHByZWxvYWQgZmx1c2hlZCBpbiBhIHByaW9yIHBhc3MgKHByZXJlbmRlcikuIEluIGVpdGhlciBjYXNlIHdlIG5lZWQgdG8gbWFya1xuICAgICAgICAgICAgICAvLyB0aGlzIHJlc291cmNlIGFzIGFscmVhZHkgaGF2aW5nIGJlZW4gcHJlbG9hZGVkLlxuICAgICAgICAgICAgICByZXNvdXJjZS5zdGF0ZSA9IFBSRUxPQURFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFdlIGFkZCB0aGUgbmV3bHkgY3JlYXRlZCByZXNvdXJjZSB0byBvdXIgU3R5bGVRdWV1ZSBhbmQgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgLy8gdHJhY2sgdGhlIHJlc291cmNlIHdpdGggdGhlIGN1cnJlbnRseSByZW5kZXJpbmcgYm91bmRhcnlcblxuXG4gICAgICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuc2V0KGtleSwgcmVzb3VyY2UpO1xuXG4gICAgICAgICAgaWYgKHJlbmRlclN0YXRlLmJvdW5kYXJ5UmVzb3VyY2VzKSB7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5ib3VuZGFyeVJlc291cmNlcy5zdHlsZXNoZWV0cy5hZGQocmVzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRyYWNrIHdoZXRoZXIgdGhpcyBib3VuZGFyeSBzaG91bGQgd2FpdCBvbiB0aGlzIHJlc291cmNlIG9yIG5vdC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyByZXNvdXJjZSBzaG91bGQgYWx3YXlzIGV4aXN0IHNpbmNlIHdlIGVpdGhlciBoYWQgaXQgb3IganVzdCBjcmVhdGVkXG4gICAgICAgICAgLy8gaXQuIEhvd2V2ZXIsIGl0J3MgcG9zc2libGUgd2hlbiB5b3UgcmVzdW1lIHRoYXQgdGhlIHN0eWxlIGhhcyBhbHJlYWR5IGJlZW4gZW1pdHRlZFxuICAgICAgICAgIC8vIGFuZCB0aGVuIGl0IHdvdWxkbid0IGJlIHJlY3JlYXRlZCBpbiB0aGUgUmVuZGVyU3RhdGUgYW5kIHRoZXJlJ3Mgbm8gbmVlZCB0byB0cmFja1xuICAgICAgICAgIC8vIGl0IGFnYWluIHNpbmNlIHdlIHNob3VsZCd2ZSBob2lzdGVkIGl0IHRvIHRoZSBzaGVsbCBhbHJlYWR5LlxuICAgICAgICAgIGlmIChzdHlsZVF1ZXVlKSB7XG4gICAgICAgICAgICB2YXIgX3Jlc291cmNlID0gc3R5bGVRdWV1ZS5zaGVldHMuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIGlmIChfcmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlLmJvdW5kYXJ5UmVzb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYm91bmRhcnlSZXNvdXJjZXMuc3R5bGVzaGVldHMuYWRkKF9yZXNvdXJjZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dEVtYmVkZGVkKSB7XG4gICAgICAgICAgLy8gVGhpcyBsaW5rIGZvbGxvd3MgdGV4dCBidXQgd2UgYXJlbid0IHdyaXRpbmcgYSB0YWcuIHdoaWxlIG5vdCBhcyBlZmZpY2llbnQgYXMgcG9zc2libGUgd2UgbmVlZFxuICAgICAgICAgIC8vIHRvIGJlIHNhZmUgYW5kIGFzc3VtZSB0ZXh0IHdpbGwgZm9sbG93IGJ5IGluc2VydGluZyBhIHRleHRTZXBhcmF0b3JcbiAgICAgICAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3IpIHtcbiAgICAgIC8vIFdoZW4gdXNpbmcgbG9hZCBoYW5kbGVycyB3ZSBjYW5ub3QgaG9pc3QgYW5kIG5lZWQgdG8gZW1pdCBsaW5rcyBpbiBwbGFjZVxuICAgICAgcmV0dXJuIHB1c2hMaW5rSW1wbCh0YXJnZXQsIHByb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgY2FuIGhvaXN0IHRoaXMgbGluayBzbyB3ZSBtYXkgbmVlZCB0byBlbWl0IGEgdGV4dCBzZXBhcmF0b3IuXG4gICAgICAvLyBAVE9ETyByZWZhY3RvciB0ZXh0IHNlcGFyYXRvcnMgc28gd2UgZG9uJ3QgaGF2ZSB0byBkZWZlbnNpdmVseSBhZGRcbiAgICAgIC8vIHRoZW0gd2hlbiB3ZSBkb24ndCBlbmQgdXAgZW1pdHRpbmcgYSB0YWcgYXMgYSByZXN1bHQgb2YgcHVzaFN0YXJ0SW5zdGFuY2VcbiAgICAgIGlmICh0ZXh0RW1iZWRkZWQpIHtcbiAgICAgICAgLy8gVGhpcyBsaW5rIGZvbGxvd3MgdGV4dCBidXQgd2UgYXJlbid0IHdyaXRpbmcgYSB0YWcuIHdoaWxlIG5vdCBhcyBlZmZpY2llbnQgYXMgcG9zc2libGUgd2UgbmVlZFxuICAgICAgICAvLyB0byBiZSBzYWZlIGFuZCBhc3N1bWUgdGV4dCB3aWxsIGZvbGxvdyBieSBpbnNlcnRpbmcgYSB0ZXh0U2VwYXJhdG9yXG4gICAgICAgIHRhcmdldC5wdXNoKHRleHRTZXBhcmF0b3IpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BzLnJlbCkge1xuICAgICAgICBjYXNlICdwcmVjb25uZWN0JzpcbiAgICAgICAgY2FzZSAnZG5zLXByZWZldGNoJzpcbiAgICAgICAgICByZXR1cm4gcHVzaExpbmtJbXBsKHJlbmRlclN0YXRlLnByZWNvbm5lY3RDaHVua3MsIHByb3BzKTtcblxuICAgICAgICBjYXNlICdwcmVsb2FkJzpcbiAgICAgICAgICByZXR1cm4gcHVzaExpbmtJbXBsKHJlbmRlclN0YXRlLnByZWxvYWRDaHVua3MsIHByb3BzKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwdXNoTGlua0ltcGwocmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hMaW5rSW1wbCh0YXJnZXQsIHByb3BzKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ2xpbmsnKSk7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpbmsnICsgXCIgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIiArICd1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoU3R5bGUodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQsIGluc2VydGlvbk1vZGUsIG5vc2NyaXB0VGFnSW5TY29wZSkge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICdjaGlsZHJlbicpKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBjaGlsZCA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4ubGVuZ3RoIDwgMiA/IGNoaWxkcmVuWzBdIDogbnVsbCA6IGNoaWxkcmVuO1xuXG4gICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ3N5bWJvbCcgfHwgQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgdmFyIGNoaWxkVHlwZSA9IHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJyA/ICdhIEZ1bmN0aW9uJyA6IHR5cGVvZiBjaGlsZCA9PT0gJ3N5bWJvbCcgPyAnYSBTeWJtb2wnIDogJ2FuIEFycmF5JztcblxuICAgICAgICBlcnJvcignUmVhY3QgZXhwZWN0IGNoaWxkcmVuIG9mIDxzdHlsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBvciBvYmplY3Qgd2l0aCBhIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCAlcyBpbnN0ZWFkLiAnICsgJ0luIGJyb3dzZXJzIHN0eWxlIEVsZW1lbnRzIGNhbiBvbmx5IGhhdmUgYFRleHRgIE5vZGVzIGFzIGNoaWxkcmVuLicsIGNoaWxkVHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciBwcmVjZWRlbmNlID0gcHJvcHMucHJlY2VkZW5jZTtcbiAgICB2YXIgaHJlZiA9IHByb3BzLmhyZWY7XG5cbiAgICBpZiAoaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHwgbm9zY3JpcHRUYWdJblNjb3BlIHx8IHByb3BzLml0ZW1Qcm9wICE9IG51bGwgfHwgdHlwZW9mIHByZWNlZGVuY2UgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBocmVmICE9PSAnc3RyaW5nJyB8fCBocmVmID09PSAnJykge1xuICAgICAgLy8gVGhpcyBzdHlsZSB0YWcgaXMgbm90IGFibGUgdG8gYmUgdHVybmVkIGludG8gYSBTdHlsZSBSZXNvdXJjZVxuICAgICAgcmV0dXJuIHB1c2hTdHlsZUltcGwodGFyZ2V0LCBwcm9wcyk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGhyZWYuaW5jbHVkZXMoJyAnKSkge1xuICAgICAgICBlcnJvcignUmVhY3QgZXhwZWN0ZWQgdGhlIGBocmVmYCBwcm9wIGZvciBhIDxzdHlsZT4gdGFnIG9wdGluZyBpbnRvIGhvaXN0aW5nIHNlbWFudGljcyB1c2luZyB0aGUgYHByZWNlZGVuY2VgIHByb3AgdG8gbm90IGhhdmUgYW55IHNwYWNlcyBidXQgZWNvdW50ZXJlZCBzcGFjZXMgaW5zdGVhZC4gdXNpbmcgc3BhY2VzIGluIHRoaXMgcHJvcCB3aWxsIGNhdXNlIGh5ZHJhdGlvbiBvZiB0aGlzIHN0eWxlIHRvIGZhaWwgb24gdGhlIGNsaWVudC4gVGhlIGhyZWYgZm9yIHRoZSA8c3R5bGU+IHdoZXJlIHRoaXMgb2N1cnJlZCBpcyBcIiVzXCIuJywgaHJlZik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KGhyZWYpO1xuICAgIHZhciBzdHlsZVF1ZXVlID0gcmVuZGVyU3RhdGUuc3R5bGVzLmdldChwcmVjZWRlbmNlKTtcbiAgICB2YXIgaGFzS2V5ID0gcmVzdW1hYmxlU3RhdGUuc3R5bGVSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICB2YXIgcmVzb3VyY2VTdGF0ZSA9IGhhc0tleSA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2tleV0gOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAocmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTKSB7XG4gICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gY3JlYXRlIHRoaXMgcmVzb3VyY2Ugbm93IHNvIGl0IGlzIG1hcmtlZCBhcyBFeGlzdHNcbiAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2tleV0gPSBFWElTVFM7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHJlc291cmNlU3RhdGUpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QgZW5jb3VudGVyZWQgYSBob2lzdGFibGUgc3R5bGUgdGFnIGZvciB0aGUgc2FtZSBocmVmIGFzIGEgcHJlbG9hZDogXCIlc1wiLiBXaGVuIHVzaW5nIGEgc3R5bGUgdGFnIHRvIGlubGluZSBzdHlsZXMgeW91IHNob3VsZCBub3QgYWxzbyBwcmVsb2FkIGl0IGFzIGEgc3R5bHNoZWV0LicsIGhyZWYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghc3R5bGVRdWV1ZSkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB0aW1lIHdlJ3ZlIGVuY291bnRlcmVkIHRoaXMgcHJlY2VkZW5jZSB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIGNyZWF0ZSBhIFN0eWxlUXVldWUuXG4gICAgICAgIHN0eWxlUXVldWUgPSB7XG4gICAgICAgICAgcHJlY2VkZW5jZTogc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihwcmVjZWRlbmNlKSksXG4gICAgICAgICAgcnVsZXM6IFtdLFxuICAgICAgICAgIGhyZWZzOiBbc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihocmVmKSldLFxuICAgICAgICAgIHNoZWV0czogbmV3IE1hcCgpXG4gICAgICAgIH07XG4gICAgICAgIHJlbmRlclN0YXRlLnN0eWxlcy5zZXQocHJlY2VkZW5jZSwgc3R5bGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBoYXZlIHNlZW4gdGhpcyBwcmVjZWRlbmNlIGJlZm9yZSBhbmQgbmVlZCB0byB0cmFjayB0aGlzIGhyZWZcbiAgICAgICAgc3R5bGVRdWV1ZS5ocmVmcy5wdXNoKHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaHJlZikpKTtcbiAgICAgIH1cblxuICAgICAgcHVzaFN0eWxlQ29udGVudHMoc3R5bGVRdWV1ZS5ydWxlcywgcHJvcHMpO1xuICAgIH1cblxuICAgIGlmIChzdHlsZVF1ZXVlKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHRyYWNrIHdoZXRoZXIgdGhpcyBib3VuZGFyeSBzaG91bGQgd2FpdCBvbiB0aGlzIHJlc291cmNlIG9yIG5vdC5cbiAgICAgIC8vIFR5cGljYWxseSB0aGlzIHJlc291cmNlIHNob3VsZCBhbHdheXMgZXhpc3Qgc2luY2Ugd2UgZWl0aGVyIGhhZCBpdCBvciBqdXN0IGNyZWF0ZWRcbiAgICAgIC8vIGl0LiBIb3dldmVyLCBpdCdzIHBvc3NpYmxlIHdoZW4geW91IHJlc3VtZSB0aGF0IHRoZSBzdHlsZSBoYXMgYWxyZWFkeSBiZWVuIGVtaXR0ZWRcbiAgICAgIC8vIGFuZCB0aGVuIGl0IHdvdWxkbid0IGJlIHJlY3JlYXRlZCBpbiB0aGUgUmVuZGVyU3RhdGUgYW5kIHRoZXJlJ3Mgbm8gbmVlZCB0byB0cmFja1xuICAgICAgLy8gaXQgYWdhaW4gc2luY2Ugd2Ugc2hvdWxkJ3ZlIGhvaXN0ZWQgaXQgdG8gdGhlIHNoZWxsIGFscmVhZHkuXG4gICAgICBpZiAocmVuZGVyU3RhdGUuYm91bmRhcnlSZXNvdXJjZXMpIHtcbiAgICAgICAgcmVuZGVyU3RhdGUuYm91bmRhcnlSZXNvdXJjZXMuc3R5bGVzLmFkZChzdHlsZVF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGV4dEVtYmVkZGVkKSB7XG4gICAgICAvLyBUaGlzIGxpbmsgZm9sbG93cyB0ZXh0IGJ1dCB3ZSBhcmVuJ3Qgd3JpdGluZyBhIHRhZy4gd2hpbGUgbm90IGFzIGVmZmljaWVudCBhcyBwb3NzaWJsZSB3ZSBuZWVkXG4gICAgICAvLyB0byBiZSBzYWZlIGFuZCBhc3N1bWUgdGV4dCB3aWxsIGZvbGxvdyBieSBpbnNlcnRpbmcgYSB0ZXh0U2VwYXJhdG9yXG4gICAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFN0eWxlSW1wbCh0YXJnZXQsIHByb3BzKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ3N0eWxlJykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHZhciBjaGlsZCA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4ubGVuZ3RoIDwgMiA/IGNoaWxkcmVuWzBdIDogbnVsbCA6IGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlb2YgY2hpbGQgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNoaWxkICE9PSAnc3ltYm9sJyAmJiBjaGlsZCAhPT0gbnVsbCAmJiBjaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcignJyArIGNoaWxkKSkpO1xuICB9XG5cbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICB0YXJnZXQucHVzaChlbmRDaHVua0ZvclRhZygnc3R5bGUnKSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoU3R5bGVDb250ZW50cyh0YXJnZXQsIHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoaWxkID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5sZW5ndGggPCAyID8gY2hpbGRyZW5bMF0gOiBudWxsIDogY2hpbGRyZW47XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY2hpbGQgIT09ICdzeW1ib2wnICYmIGNoaWxkICE9PSBudWxsICYmIGNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCcnICsgY2hpbGQpKSk7XG4gIH1cblxuICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gcHVzaEltZyh0YXJnZXQsIHByb3BzLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIHBpY3R1cmVUYWdJblNjb3BlKSB7XG4gIHZhciBzcmMgPSBwcm9wcy5zcmMsXG4gICAgICBzcmNTZXQgPSBwcm9wcy5zcmNTZXQ7XG5cbiAgaWYgKHByb3BzLmxvYWRpbmcgIT09ICdsYXp5JyAmJiAoc3JjIHx8IHNyY1NldCkgJiYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnIHx8IHNyYyA9PSBudWxsKSAmJiAodHlwZW9mIHNyY1NldCA9PT0gJ3N0cmluZycgfHwgc3JjU2V0ID09IG51bGwpICYmIHByb3BzLmZldGNoUHJpb3JpdHkgIT09ICdsb3cnICYmIHBpY3R1cmVUYWdJblNjb3BlID09PSBmYWxzZSAmJiAvLyBXZSBleGNsdWRlIGRhdGEgVVJJcyBpbiBzcmMgYW5kIHNyY1NldCBzaW5jZSB0aGVzZSBzaG91bGQgbm90IGJlIHByZWxvYWRlZFxuICAhKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnICYmIHNyY1s0XSA9PT0gJzonICYmIChzcmNbMF0gPT09ICdkJyB8fCBzcmNbMF0gPT09ICdEJykgJiYgKHNyY1sxXSA9PT0gJ2EnIHx8IHNyY1sxXSA9PT0gJ0EnKSAmJiAoc3JjWzJdID09PSAndCcgfHwgc3JjWzJdID09PSAnVCcpICYmIChzcmNbM10gPT09ICdhJyB8fCBzcmNbM10gPT09ICdBJykpICYmICEodHlwZW9mIHNyY1NldCA9PT0gJ3N0cmluZycgJiYgc3JjU2V0WzRdID09PSAnOicgJiYgKHNyY1NldFswXSA9PT0gJ2QnIHx8IHNyY1NldFswXSA9PT0gJ0QnKSAmJiAoc3JjU2V0WzFdID09PSAnYScgfHwgc3JjU2V0WzFdID09PSAnQScpICYmIChzcmNTZXRbMl0gPT09ICd0JyB8fCBzcmNTZXRbMl0gPT09ICdUJykgJiYgKHNyY1NldFszXSA9PT0gJ2EnIHx8IHNyY1NldFszXSA9PT0gJ0EnKSkpIHtcbiAgICAvLyBXZSBoYXZlIGEgc3VzcGVuc2V5IGltYWdlIGFuZCBvdWdodCB0byBwcmVsb2FkIGl0IHRvIG9wdGltaXplIHRoZSBsb2FkaW5nIG9mIGRpc3BsYXkgYmxvY2tpbmdcbiAgICAvLyByZXN1bWFibGVTdGF0ZS5cbiAgICB2YXIgc2l6ZXMgPSB0eXBlb2YgcHJvcHMuc2l6ZXMgPT09ICdzdHJpbmcnID8gcHJvcHMuc2l6ZXMgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGtleSA9IGdldEltYWdlUmVzb3VyY2VLZXkoc3JjLCBzcmNTZXQsIHNpemVzKTtcbiAgICB2YXIgcHJvbW90YWJsZVByZWxvYWRzID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuaW1hZ2VzO1xuICAgIHZhciByZXNvdXJjZSA9IHByb21vdGFibGVQcmVsb2Fkcy5nZXQoa2V5KTtcblxuICAgIGlmIChyZXNvdXJjZSkge1xuICAgICAgLy8gV2UgY29uc2lkZXIgd2hldGhlciB0aGlzIHByZWxvYWQgY2FuIGJlIHByb21vdGVkIHRvIGhpZ2hlciBwcmlvcml0eSBmbHVzaGluZyBxdWV1ZS5cbiAgICAgIC8vIFRoZSBvbmx5IHRpbWUgYSByZXNvdXJjZSB3aWxsIGV4aXN0IGhlcmUgaXMgaWYgaXQgd2FzIGNyZWF0ZWQgZHVyaW5nIHRoaXMgcmVuZGVyXG4gICAgICAvLyBhbmQgd2FzIG5vdCBhbHJlYWR5IGluIHRoZSBoaWdoIHByaW9yaXR5IHF1ZXVlLlxuICAgICAgaWYgKHByb3BzLmZldGNoUHJpb3JpdHkgPT09ICdoaWdoJyB8fCByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5zaXplIDwgMTApIHtcbiAgICAgICAgLy8gRGVsZXRlIHRoZSByZXNvdXJjZSBmcm9tIHRoZSBtYXAgc2luY2Ugd2UgYXJlIHByb21vdGluZyBpdCBhbmQgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyByZWVudGVyIHRoaXMgYnJhbmNoIGluIGEgc2Vjb25kIHBhc3MgZm9yIGR1cGxpY2F0ZSBpbWcgaHJlZnMuXG4gICAgICAgIHByb21vdGFibGVQcmVsb2Fkcy5kZWxldGUoa2V5KTsgLy8gJEZsb3dGaXhNZSAtIEZsb3cgc2hvdWxkIHVuZGVyc3RhbmQgdGhhdCB0aGlzIGlzIGEgUmVzb3VyY2UgaWYgdGhlIGNvbmRpdGlvbiB3YXMgdHJ1ZVxuXG4gICAgICAgIHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmFkZChyZXNvdXJjZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLy8gV2UgbXVzdCBjb25zdHJ1Y3QgYSBuZXcgcHJlbG9hZCByZXNvdXJjZVxuICAgICAgcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXNba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICB2YXIgY3Jvc3NPcmlnaW4gPSBnZXRDcm9zc09yaWdpblN0cmluZyhwcm9wcy5jcm9zc09yaWdpbik7XG4gICAgICB2YXIgaGVhZGVycyA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICB2YXIgaGVhZGVyO1xuXG4gICAgICBpZiAoaGVhZGVycyAmJiBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ID4gMCAmJiAoIC8vIHRoaXMgaXMgYSBodWVyaXN0aWMgc2ltaWxhciB0byBjYXBwaW5nIGVsZW1lbnQgcHJlbG9hZHMgdG8gMTAgdW5sZXNzIGV4cGxpY2l0bHlcbiAgICAgIC8vIGZldGNoUHJpb3JpdHk9XCJoaWdoXCIuIFdlIHVzZSBsZW5ndGggaGVyZSB3aGljaCBtZWFucyBpdCB3aWxsIGZpdCBmZXdlciBpbWFnZXMgd2hlblxuICAgICAgLy8gdGhlIHVybHMgYXJlIGxvbmcgYW5kIG1vcmUgd2hlbiBzaG9ydC4gYXJndWFibHkgYnl0ZSBzaXplIGlzIGEgYmV0dGVyIGh1ZXJpc3RpYyBiZWNhdXNlXG4gICAgICAvLyBpdCBkaXJlY3RseSB0cmFuc2xhdGVzIHRvIGhvdyBtdWNoIHdlIHNlbmQgZG93biBiZWZvcmUgY29udGVudCBpcyBhY3R1YWxseSBzZWVuLlxuICAgICAgLy8gV2UgY291bGQgdW5pZnkgdGhlIGNvdW50cyBhbmQgYWxzbyBtYWtlIGl0IHNvIHRoZSB0b3RhbCBpcyB0cmFja2VkIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgIC8vIGZsdXNoaW5nIG91dHB1dCBidXQgc2luY2UgdGhlIGhlYWRlcnMgYXJlIGxpa2VseSB0byBiZSBnbyBlYXJsaWVyIHRoYW4gY29udGVudFxuICAgICAgLy8gdGhleSBkb24ndCByZWFsbHkgY29uZmxpY3Qgc28gZm9yIG5vdyBJJ3ZlIGtlcHQgdGhlbSBzZXBhcmF0ZVxuICAgICAgcHJvcHMuZmV0Y2hQcmlvcml0eSA9PT0gJ2hpZ2gnIHx8IGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMubGVuZ3RoIDwgNTAwKSAmJiAoIC8vIFdlIG1hbnVhbGx5IGNvbnN0cnVjdCB0aGUgb3B0aW9ucyBmb3IgdGhlIHByZWxvYWQgb25seSBmcm9tIHN0cmluZ3MuIFdlIGRvbid0IHdhbnQgdG8gcG9sbHV0ZVxuICAgICAgLy8gdGhlIHBhcmFtcyBsaXN0IHdpdGggYXJiaXRyYXJ5IHByb3BzIGFuZCBpZiB3ZSBjb3BpZWQgZXZlcnl0aGluZyBvdmVyIGFzIGl0IHdlIG1pZ2h0IGdldFxuICAgICAgLy8gY29lcmNpb24gZXJyb3JzLiBXZSBoYXZlIGNoZWNrcyBmb3IgdGhpcyBpbiBEZXYgYnV0IGl0IHNlZW1zIHNhZmVyIHRvIGp1c3Qgb25seSBhY2NlcHQgdmFsdWVzXG4gICAgICAvLyB0aGF0IGFyZSBzdHJpbmdzXG4gICAgICBoZWFkZXIgPSBnZXRQcmVsb2FkQXNIZWFkZXIoc3JjLCAnaW1hZ2UnLCB7XG4gICAgICAgIGltYWdlU3JjU2V0OiBwcm9wcy5zcmNTZXQsXG4gICAgICAgIGltYWdlU2l6ZXM6IHByb3BzLnNpemVzLFxuICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgIGludGVncml0eTogcHJvcHMuaW50ZWdyaXR5LFxuICAgICAgICBub25jZTogcHJvcHMubm9uY2UsXG4gICAgICAgIHR5cGU6IHByb3BzLnR5cGUsXG4gICAgICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcy5yZWZlcmVyUG9saWN5XG4gICAgICB9KSwgLy8gV2UgYWx3YXlzIGNvbnN1bWUgdGhlIGhlYWRlciBsZW5ndGggc2luY2Ugb25jZSB3ZSBmaW5kIG9uZSBoZWFkZXIgdGhhdCBkb2Vzbid0IGZpdFxuICAgICAgLy8gd2UgYXNzdW1lIGFsbCB0aGUgcmVzdCB3b24ndCBhcyB3ZWxsLiBUaGlzIGlzIHRvIGF2b2lkIGdldHRpbmcgaW50byBhIHNpdHVhdGlvblxuICAgICAgLy8gd2hlcmUgd2UgaGF2ZSBhIHZlcnkgc21hbGwgcmVtYWluaW5nIGNhcGFjaXR5IGJ1dCBubyBoZWFkZXJzIHdpbGwgZXZlciBmaXQgYW5kIHdlIGVuZFxuICAgICAgLy8gdXAgY29uc3RhbnRseSB0cnlpbmcgdG8gc2VlIGlmIHRoZSBuZXh0IHJlc291cmNlIG1pZ2h0IG1ha2UgaXQuIEluIHRoZSBmdXR1cmUgd2UgY2FuXG4gICAgICAvLyBtYWtlIHRoaXMgYmVoYXZpb3IgZGlmZmVyZW50IGJldHdlZW4gcmVuZGVyIGFuZCBwcmVyZW5kZXIgc2luY2UgaW4gdGhlIGxhdHRlciBjYXNlXG4gICAgICAvLyB3ZSBhcmUgbGVzcyBzZW5zaXRpdmUgdG8gdGhlIGN1cnJlbnQgcmVxdWVzdHMgcnVudGltZSBwZXIgYW5kIG1vcmUgc2Vuc2l0aXZlIHRvIG1heGltaXppbmdcbiAgICAgIC8vIGhlYWRlcnMuXG4gICAgICAoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoKSA+PSAyKSkge1xuICAgICAgICAvLyBJZiB3ZSBwb3N0cG9uZSBpbiB0aGUgc2hlbGwgd2Ugd2lsbCBzdGlsbCBlbWl0IHRoaXMgcHJlbG9hZCBzbyB3ZSB0cmFja1xuICAgICAgICAvLyBpdCB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgcmVzZXQgaXQuXG4gICAgICAgIHJlbmRlclN0YXRlLnJlc2V0cy5pbWFnZVtrZXldID0gUFJFTE9BRF9OT19DUkVEUztcblxuICAgICAgICBpZiAoaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2Fkcykge1xuICAgICAgICAgIGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgKz0gJywgJztcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl06IHdlIGFzc2lnbiBoZWFkZXIgZHVyaW5nIHRoZSBpZiBjb25kaXRpb25cblxuXG4gICAgICAgIGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgKz0gaGVhZGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb3VyY2UgPSBbXTtcbiAgICAgICAgcHVzaExpbmtJbXBsKHJlc291cmNlLCB7XG4gICAgICAgICAgcmVsOiAncHJlbG9hZCcsXG4gICAgICAgICAgYXM6ICdpbWFnZScsXG4gICAgICAgICAgLy8gVGhlcmUgaXMgYSBidWcgaW4gU2FmYXJpIHdoZXJlIGltYWdlU3JjU2V0IGlzIG5vdCByZXNwZWN0ZWQgb24gcHJlbG9hZCBsaW5rc1xuICAgICAgICAgIC8vIHNvIHdlIG9taXQgdGhlIGhyZWYgaGVyZSBpZiB3ZSBoYXZlIGltYWdlU3JjU2V0IGIvYyBzYWZhcmkgd2lsbCBsb2FkIHRoZSB3cm9uZyBpbWFnZS5cbiAgICAgICAgICAvLyBUaGlzIGhhcm1zIG9sZGVyIGJyb3dlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpbWFnZVNyY1NldCBieSBtYWtpbmcgdGhlaXIgcHJlbG9hZHMgbm90IHdvcmtcbiAgICAgICAgICAvLyBidXQgdGhpcyBwb3B1bGF0aW9uIGlzIHNocmlua2luZyBmYXN0IGFuZCBpcyBhbHJlYWR5IHNtYWxsIHNvIHdlIGFjY2VwdCB0aGlzIHRyYWRlb2ZmLlxuICAgICAgICAgIGhyZWY6IHNyY1NldCA/IHVuZGVmaW5lZCA6IHNyYyxcbiAgICAgICAgICBpbWFnZVNyY1NldDogc3JjU2V0LFxuICAgICAgICAgIGltYWdlU2l6ZXM6IHNpemVzLFxuICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICBpbnRlZ3JpdHk6IHByb3BzLmludGVncml0eSxcbiAgICAgICAgICB0eXBlOiBwcm9wcy50eXBlLFxuICAgICAgICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgICAgICAgcmVmZXJyZXJQb2xpY3k6IHByb3BzLnJlZmVycmVyUG9saWN5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwcm9wcy5mZXRjaFByaW9yaXR5ID09PSAnaGlnaCcgfHwgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuc2l6ZSA8IDEwKSB7XG4gICAgICAgICAgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuYWRkKHJlc291cmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKHJlc291cmNlKTsgLy8gV2UgY2FuIGJ1bXAgdGhlIHByaW9yaXR5IHVwIGlmIHRoZSBzYW1lIGltZyBpcyByZW5kZXJlZCBsYXRlclxuICAgICAgICAgIC8vIHdpdGggZmV0Y2hQcmlvcml0eT1cImhpZ2hcIlxuXG4gICAgICAgICAgcHJvbW90YWJsZVByZWxvYWRzLnNldChrZXksIHJlc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0LCBwcm9wcywgJ2ltZycpO1xufVxuXG5mdW5jdGlvbiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGFnICsgXCIgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIiArICd1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRNZW51SXRlbSh0YXJnZXQsIHByb3BzKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ21lbnVpdGVtJykpO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZW51aXRlbXMgY2Fubm90IGhhdmUgYGNoaWxkcmVuYCBub3IgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFRpdGxlKHRhcmdldCwgcHJvcHMsIHJlbmRlclN0YXRlLCBpbnNlcnRpb25Nb2RlLCBub3NjcmlwdFRhZ0luU2NvcGUpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAnY2hpbGRyZW4nKSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgY2hpbGQgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLmxlbmd0aCA8IDIgPyBjaGlsZHJlblswXSA6IG51bGwgOiBjaGlsZHJlbjtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZXJyb3IoJ1JlYWN0IGV4cGVjdHMgdGhlIGBjaGlsZHJlbmAgcHJvcCBvZiA8dGl0bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgYW4gQXJyYXkgd2l0aCBsZW5ndGggJXMgaW5zdGVhZC4nICsgJyBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0byBiZSBhYmxlIHRvIGNvbnZlcnQgYGNoaWxkcmVuYCBvZiA8dGl0bGU+IHRhZ3MgdG8gYSBzaW5nbGUgc3RyaW5nIHZhbHVlJyArICcgd2hpY2ggaXMgd2h5IEFycmF5cyBvZiBsZW5ndGggZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCBzdXBwb3J0ZWQuIFdoZW4gdXNpbmcgSlNYIGl0IGNhbiBiZSBjb21tb25nIHRvIGNvbWJpbmUgdGV4dCBub2RlcyBhbmQgdmFsdWUgbm9kZXMuJyArICcgRm9yIGV4YW1wbGU6IDx0aXRsZT5oZWxsbyB7bmFtZU9mVXNlcn08L3RpdGxlPi4gV2hpbGUgbm90IGltbWVkaWF0ZWx5IGFwcGFyZW50LCBgY2hpbGRyZW5gIGluIHRoaXMgY2FzZSBpcyBhbiBBcnJheSB3aXRoIGxlbmd0aCAyLiBJZiB5b3VyIGBjaGlsZHJlbmAgcHJvcCcgKyAnIGlzIHVzaW5nIHRoaXMgZm9ybSB0cnkgcmV3cml0aW5nIGl0IHVzaW5nIGEgdGVtcGxhdGUgc3RyaW5nOiA8dGl0bGU+e2BoZWxsbyAke25hbWVPZlVzZXJ9YH08L3RpdGxlPi4nLCBjaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGNoaWxkID09PSAnc3ltYm9sJykge1xuICAgICAgICB2YXIgY2hpbGRUeXBlID0gdHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nID8gJ2EgRnVuY3Rpb24nIDogJ2EgU3libW9sJztcblxuICAgICAgICBlcnJvcignUmVhY3QgZXhwZWN0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBvciBvYmplY3Qgd2l0aCBhIG5vdmVsIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCAlcyBpbnN0ZWFkLicgKyAnIEJyb3dzZXJzIHRyZWF0IGFsbCBjaGlsZCBOb2RlcyBvZiA8dGl0bGU+IHRhZ3MgYXMgVGV4dCBjb250ZW50IGFuZCBSZWFjdCBleHBlY3RzIHRvIGJlIGFibGUgdG8gY29udmVydCBjaGlsZHJlbiBvZiA8dGl0bGU+JyArICcgdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUuJywgY2hpbGRUeXBlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQgJiYgY2hpbGQudG9TdHJpbmcgPT09IHt9LnRvU3RyaW5nKSB7XG4gICAgICAgIGlmIChjaGlsZC4kJHR5cGVvZiAhPSBudWxsKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IGV4cGVjdHMgdGhlIGBjaGlsZHJlbmAgcHJvcCBvZiA8dGl0bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgYW4gb2JqZWN0IHRoYXQgYXBwZWFycyB0byBiZScgKyAnIGEgUmVhY3QgZWxlbWVudCB3aGljaCBuZXZlciBpbXBsZW1lbnRzIGEgc3VpdGFibGUgYHRvU3RyaW5nYCBtZXRob2QuIEJyb3dzZXJzIHRyZWF0IGFsbCBjaGlsZCBOb2RlcyBvZiA8dGl0bGU+IHRhZ3MgYXMgVGV4dCBjb250ZW50IGFuZCBSZWFjdCBleHBlY3RzIHRvJyArICcgYmUgYWJsZSB0byBjb252ZXJ0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncyB0byBhIHNpbmdsZSBzdHJpbmcgdmFsdWUgd2hpY2ggaXMgd2h5IHJlbmRlcmluZyBSZWFjdCBlbGVtZW50cyBpcyBub3Qgc3VwcG9ydGVkLiBJZiB0aGUgYGNoaWxkcmVuYCBvZiA8dGl0bGU+IGlzJyArICcgYSBSZWFjdCBDb21wb25lbnQgdHJ5IG1vdmluZyB0aGUgPHRpdGxlPiB0YWcgaW50byB0aGF0IGNvbXBvbmVudC4gSWYgdGhlIGBjaGlsZHJlbmAgb2YgPHRpdGxlPiBpcyBzb21lIEhUTUwgbWFya3VwIGNoYW5nZSBpdCB0byBiZSBUZXh0IG9ubHkgdG8gYmUgdmFsaWQgSFRNTC4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QgZXhwZWN0cyB0aGUgYGNoaWxkcmVuYCBwcm9wIG9mIDx0aXRsZT4gdGFncyB0byBiZSBhIHN0cmluZywgbnVtYmVyLCBvciBvYmplY3Qgd2l0aCBhIG5vdmVsIGB0b1N0cmluZ2AgbWV0aG9kIGJ1dCBmb3VuZCBhbiBvYmplY3QgdGhhdCBkb2VzIG5vdCBpbXBsZW1lbnQnICsgJyBhIHN1aXRhYmxlIGB0b1N0cmluZ2AgbWV0aG9kLiBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0byBiZSBhYmxlIHRvIGNvbnZlcnQgY2hpbGRyZW4gb2YgPHRpdGxlPiB0YWdzJyArICcgdG8gYSBzaW5nbGUgc3RyaW5nIHZhbHVlLiBVc2luZyB0aGUgZGVmYXVsdCBgdG9TdHJpbmdgIG1ldGhvZCBhdmFpbGFibGUgb24gZXZlcnkgb2JqZWN0IGlzIGFsbW9zdCBjZXJ0YWlubHkgYW4gZXJyb3IuIENvbnNpZGVyIHdoZXRoZXIgdGhlIGBjaGlsZHJlbmAgb2YgdGhpcyA8dGl0bGU+JyArICcgaXMgYW4gb2JqZWN0IGluIGVycm9yIGFuZCBjaGFuZ2UgaXQgdG8gYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIGlmIHNvLiBPdGhlcndpc2UgaW1wbGVtZW50IGEgYHRvU3RyaW5nYCBtZXRob2QgdGhhdCBSZWFjdCBjYW4gdXNlIHRvIHByb2R1Y2UgYSB2YWxpZCA8dGl0bGU+LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChpbnNlcnRpb25Nb2RlICE9PSBTVkdfTU9ERSAmJiAhbm9zY3JpcHRUYWdJblNjb3BlICYmIHByb3BzLml0ZW1Qcm9wID09IG51bGwpIHtcbiAgICAgIHB1c2hUaXRsZUltcGwocmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLCBwcm9wcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHB1c2hUaXRsZUltcGwodGFyZ2V0LCBwcm9wcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hUaXRsZUltcGwodGFyZ2V0LCBwcm9wcykge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCd0aXRsZScpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICB2YXIgY2hpbGQgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLmxlbmd0aCA8IDIgPyBjaGlsZHJlblswXSA6IG51bGwgOiBjaGlsZHJlbjtcblxuICBpZiAodHlwZW9mIGNoaWxkICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjaGlsZCAhPT0gJ3N5bWJvbCcgJiYgY2hpbGQgIT09IG51bGwgJiYgY2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoJycgKyBjaGlsZCkpKTtcbiAgfVxuXG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgdGFyZ2V0LnB1c2goZW5kQ2h1bmtGb3JUYWcoJ3RpdGxlJykpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0SGVhZCh0YXJnZXQsIHByb3BzLCByZW5kZXJTdGF0ZSwgaW5zZXJ0aW9uTW9kZSkge1xuICB7XG4gICAgaWYgKGluc2VydGlvbk1vZGUgPCBIVE1MX01PREUgJiYgcmVuZGVyU3RhdGUuaGVhZENodW5rcyA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyA8aGVhZD4gaXMgdGhlIERvY3VtZW50LmhlYWQgYW5kIHNob3VsZCBiZSBwYXJ0IG9mIHRoZSBwcmVhbWJsZVxuICAgICAgcmVuZGVyU3RhdGUuaGVhZENodW5rcyA9IFtdO1xuICAgICAgcmV0dXJuIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHJlbmRlclN0YXRlLmhlYWRDaHVua3MsIHByb3BzLCAnaGVhZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIDxoZWFkPiBpcyBkZWVwIGFuZCBpcyBsaWtlbHkganVzdCBhbiBlcnJvci4gd2UgZW1pdCBpdCBpbmxpbmUgdGhvdWdoLlxuICAgICAgLy8gVmFsaWRhdGlvbiBzaG91bGQgd2FybiB0aGF0IHRoaXMgdGFnIGlzIHRoZSB0aGUgd3Jvbmcgc3BvdC5cbiAgICAgIHJldHVybiBwdXNoU3RhcnRHZW5lcmljRWxlbWVudCh0YXJnZXQsIHByb3BzLCAnaGVhZCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRIdG1sKHRhcmdldCwgcHJvcHMsIHJlbmRlclN0YXRlLCBpbnNlcnRpb25Nb2RlKSB7XG4gIHtcbiAgICBpZiAoaW5zZXJ0aW9uTW9kZSA9PT0gUk9PVF9IVE1MX01PREUgJiYgcmVuZGVyU3RhdGUuaHRtbENodW5rcyA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyA8aHRtbD4gaXMgdGhlIERvY3VtZW50LmRvY3VtZW50RWxlbWVudCBhbmQgc2hvdWxkIGJlIHBhcnQgb2YgdGhlIHByZWFtYmxlXG4gICAgICByZW5kZXJTdGF0ZS5odG1sQ2h1bmtzID0gW2RvY3R5cGVDaHVua107XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQocmVuZGVyU3RhdGUuaHRtbENodW5rcywgcHJvcHMsICdodG1sJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgPGh0bWw+IGlzIGRlZXAgYW5kIGlzIGxpa2VseSBqdXN0IGFuIGVycm9yLiB3ZSBlbWl0IGl0IGlubGluZSB0aG91Z2guXG4gICAgICAvLyBWYWxpZGF0aW9uIHNob3VsZCB3YXJuIHRoYXQgdGhpcyB0YWcgaXMgdGhlIHRoZSB3cm9uZyBzcG90LlxuICAgICAgcmV0dXJuIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHRhcmdldCwgcHJvcHMsICdodG1sJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hTY3JpcHQodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQsIGluc2VydGlvbk1vZGUsIG5vc2NyaXB0VGFnSW5TY29wZSkge1xuICB7XG4gICAgdmFyIGFzeW5jUHJvcCA9IHByb3BzLmFzeW5jO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9wcy5zcmMgIT09ICdzdHJpbmcnIHx8ICFwcm9wcy5zcmMgfHwgIShhc3luY1Byb3AgJiYgdHlwZW9mIGFzeW5jUHJvcCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYXN5bmNQcm9wICE9PSAnc3ltYm9sJykgfHwgcHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3IgfHwgaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHwgbm9zY3JpcHRUYWdJblNjb3BlIHx8IHByb3BzLml0ZW1Qcm9wICE9IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgc2NyaXB0IHdpbGwgbm90IGJlIGEgcmVzb3VyY2UsIHdlIGJhaWxvdXQgZWFybHkgYW5kIGVtaXQgaXQgaW4gcGxhY2UuXG4gICAgICByZXR1cm4gcHVzaFNjcmlwdEltcGwodGFyZ2V0LCBwcm9wcyk7XG4gICAgfVxuXG4gICAgdmFyIHNyYyA9IHByb3BzLnNyYztcbiAgICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoc3JjKTsgLy8gV2UgY2FuIG1ha2UgdGhpcyA8c2NyaXB0PiBpbnRvIGEgU2NyaXB0UmVzb3VyY2VcblxuICAgIHZhciByZXNvdXJjZXMsIHByZWxvYWRzO1xuXG4gICAgaWYgKHByb3BzLnR5cGUgPT09ICdtb2R1bGUnKSB7XG4gICAgICByZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXM7XG4gICAgICBwcmVsb2FkcyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLm1vZHVsZVNjcmlwdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc291cmNlcyA9IHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcztcbiAgICAgIHByZWxvYWRzID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuc2NyaXB0cztcbiAgICB9XG5cbiAgICB2YXIgaGFzS2V5ID0gcmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgdmFyIHJlc291cmNlU3RhdGUgPSBoYXNLZXkgPyByZXNvdXJjZXNba2V5XSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChyZXNvdXJjZVN0YXRlICE9PSBFWElTVFMpIHtcbiAgICAgIC8vIFdlIGFyZSBnb2luZyB0byBjcmVhdGUgdGhpcyByZXNvdXJjZSBub3cgc28gaXQgaXMgbWFya2VkIGFzIEV4aXN0c1xuICAgICAgcmVzb3VyY2VzW2tleV0gPSBFWElTVFM7XG4gICAgICB2YXIgc2NyaXB0UHJvcHMgPSBwcm9wcztcblxuICAgICAgaWYgKHJlc291cmNlU3RhdGUpIHtcbiAgICAgICAgLy8gV2hlbiByZXNvdXJjZVN0YXRlIGlzIHRydXR5IGl0IGlzIGEgUHJlbG9hZCBzdGF0ZS4gV2UgY2FzdCBpdCBmb3IgY2xhcml0eVxuICAgICAgICB2YXIgcHJlbG9hZFN0YXRlID0gcmVzb3VyY2VTdGF0ZTtcblxuICAgICAgICBpZiAocHJlbG9hZFN0YXRlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHNjcmlwdFByb3BzID0gYXNzaWduKHt9LCBwcm9wcyk7XG4gICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMoc2NyaXB0UHJvcHMsIHByZWxvYWRTdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlbG9hZFJlc291cmNlID0gcHJlbG9hZHMuZ2V0KGtleSk7XG5cbiAgICAgICAgaWYgKHByZWxvYWRSZXNvdXJjZSkge1xuICAgICAgICAgIC8vIHRoZSBwcmVsb2FkIHJlc291cmNlIGV4aXN0cyB3YXMgY3JlYXRlZCBpbiB0aGlzIHJlbmRlci4gTm93IHRoYXQgd2UgaGF2ZVxuICAgICAgICAgIC8vIGEgc2NyaXB0IHJlc291cmNlIHdoaWNoIHdpbGwgZW1pdCBlYXJsaWVyIHRoYW4gYSBwcmVsb2FkIHdvdWxkIGlmIGl0XG4gICAgICAgICAgLy8gaGFzbid0IGFscmVhZHkgZmx1c2hlZCB3ZSBwcmV2ZW50IGl0IGZyb20gZmx1c2hpbmcgYnkgemVyb2luZyB0aGUgbGVuZ3RoXG4gICAgICAgICAgcHJlbG9hZFJlc291cmNlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJlc291cmNlID0gW107IC8vIEFkZCB0byB0aGUgc2NyaXB0IGZsdXNoaW5nIHF1ZXVlXG5cbiAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHJlc291cmNlKTsgLy8gZW5jb2RlIHRoZSB0YWcgYXMgQ2h1bmtzXG5cbiAgICAgIHB1c2hTY3JpcHRJbXBsKHJlc291cmNlLCBzY3JpcHRQcm9wcyk7XG4gICAgfVxuXG4gICAgaWYgKHRleHRFbWJlZGRlZCkge1xuICAgICAgLy8gVGhpcyBzY3JpcHQgZm9sbG93cyB0ZXh0IGJ1dCB3ZSBhcmVuJ3Qgd3JpdGluZyBhIHRhZy4gd2hpbGUgbm90IGFzIGVmZmljaWVudCBhcyBwb3NzaWJsZSB3ZSBuZWVkXG4gICAgICAvLyB0byBiZSBzYWZlIGFuZCBhc3N1bWUgdGV4dCB3aWxsIGZvbGxvdyBieSBpbnNlcnRpbmcgYSB0ZXh0U2VwYXJhdG9yXG4gICAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoU2NyaXB0SW1wbCh0YXJnZXQsIHByb3BzKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ3NjcmlwdCcpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuXG4gIHtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCAmJiB0eXBlb2YgY2hpbGRyZW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgZGVzY3JpcHRpdmVTdGF0ZW1lbnQgPSB0eXBlb2YgY2hpbGRyZW4gPT09ICdudW1iZXInID8gJ2EgbnVtYmVyIGZvciBjaGlsZHJlbicgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/ICdhbiBhcnJheSBmb3IgY2hpbGRyZW4nIDogJ3NvbWV0aGluZyB1bmV4cGVjdGVkIGZvciBjaGlsZHJlbic7XG5cbiAgICAgIGVycm9yKCdBIHNjcmlwdCBlbGVtZW50IHdhcyByZW5kZXJlZCB3aXRoICVzLiBJZiBzY3JpcHQgZWxlbWVudCBoYXMgY2hpbGRyZW4gaXQgbXVzdCBiZSBhIHNpbmdsZSBzdHJpbmcuJyArICcgQ29uc2lkZXIgdXNpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgb3IgcGFzc2luZyBhIHBsYWluIHN0cmluZyBhcyBjaGlsZHJlbi4nLCBkZXNjcmlwdGl2ZVN0YXRlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUoY2hpbGRyZW4pKSk7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRDaHVua0ZvclRhZygnc2NyaXB0JykpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGNoaWxkcmVuIGFzIGEgc3RyaW5nIHRvIGF2b2lkIHRoZSB1bm5lY2Vzc2FyeSBjb21tZW50LlxuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBhZnRlciB0aGUgZ2VuZXJhbCBvcHRpbWl6YXRpb24gaXMgaW4gcGxhY2UuXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUoY2hpbGRyZW4pKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydEN1c3RvbUVsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BLZXk7XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgcHVzaFN0eWxlQXR0cmlidXRlKHRhcmdldCwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnOlxuICAgICAgICBjYXNlICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnOlxuICAgICAgICAgIC8vIElnbm9yZWQuIFRoZXNlIGFyZSBidWlsdC1pbiB0byBSZWFjdCBvbiB0aGUgY2xpZW50LlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NsYXNzTmFtZSc6XG5cbiAgICAgICAgLy8gaW50ZW50aW9uYWwgZmFsbHRocm91Z2hcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKHByb3BLZXkpICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N5bWJvbCcpIHtcblxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKGF0dHJpYnV0ZU5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIocHJvcFZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG52YXIgbGVhZGluZ05ld2xpbmUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1xcbicpO1xuXG5mdW5jdGlvbiBwdXNoU3RhcnRQcmVmb3JtYXR0ZWRFbGVtZW50KHRhcmdldCwgcHJvcHMsIHRhZykge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7IC8vIHRleHQvaHRtbCBpZ25vcmVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlc2UgdGFncyBpZiBpdCdzIGEgbmV3bGluZVxuICAvLyBQcmVmZXIgdG8gYnJlYWsgYXBwbGljYXRpb24veG1sIG92ZXIgdGV4dC9odG1sIChmb3Igbm93KSBieSBhZGRpbmdcbiAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAvLyB0ZXh0YXJlYXMsIHJlcGxhY2luZyBcIl5cXG5cIiB3aXRoIFwiXFxyXFxuXCIgZG9lc24ndCBnZXQgZWF0ZW4sIGFuZCB0aGUgZmlyc3RcbiAgLy8gXFxyIGlzIG5vcm1hbGl6ZWQgb3V0IGJ5IEhUTUxUZXh0QXJlYUVsZW1lbnQjdmFsdWUuKVxuICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNlbGVtZW50LXJlc3RyaWN0aW9ucz5cbiAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjbmV3bGluZXM+XG4gIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgLy8gIGZyb20gPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHk+XG4gIC8vIFRPRE86IFRoaXMgZG9lc24ndCBkZWFsIHdpdGggdGhlIGNhc2Ugd2hlcmUgdGhlIGNoaWxkIGlzIGFuIGFycmF5XG4gIC8vIG9yIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBzdHJpbmcuXG5cbiAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbm5lckhUTUwgIT09ICdvYmplY3QnIHx8ICEoJ19faHRtbCcgaW4gaW5uZXJIVE1MKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiAnICsgJ1BsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgJyArICdmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgaHRtbCA9IGlubmVySFRNTC5fX2h0bWw7XG5cbiAgICBpZiAoaHRtbCAhPT0gbnVsbCAmJiBodG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgaHRtbCA9PT0gJ3N0cmluZycgJiYgaHRtbC5sZW5ndGggPiAwICYmIGh0bWxbMF0gPT09ICdcXG4nKSB7XG4gICAgICAgIHRhcmdldC5wdXNoKGxlYWRpbmdOZXdsaW5lLCBzdHJpbmdUb0NodW5rKGh0bWwpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihodG1sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoJycgKyBodG1sKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycgJiYgY2hpbGRyZW5bMF0gPT09ICdcXG4nKSB7XG4gICAgdGFyZ2V0LnB1c2gobGVhZGluZ05ld2xpbmUpO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufSAvLyBXZSBhY2NlcHQgYW55IHRhZyB0byBiZSByZW5kZXJlZCBidXQgc2luY2UgdGhpcyBnZXRzIGluamVjdGVkIGludG8gYXJiaXRyYXJ5XG4vLyBIVE1MLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3MgYSBzYWZlIHRhZy5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVcblxuXG52YXIgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC87IC8vIFNpbXBsaWZpZWQgc3Vic2V0XG5cbnZhciB2YWxpZGF0ZWRUYWdDYWNoZSA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gc3RhcnRDaHVua0ZvclRhZyh0YWcpIHtcbiAgdmFyIHRhZ1N0YXJ0Q2h1bmsgPSB2YWxpZGF0ZWRUYWdDYWNoZS5nZXQodGFnKTtcblxuICBpZiAodGFnU3RhcnRDaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRhZzogXCIgKyB0YWcpO1xuICAgIH1cblxuICAgIHRhZ1N0YXJ0Q2h1bmsgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwnICsgdGFnKTtcbiAgICB2YWxpZGF0ZWRUYWdDYWNoZS5zZXQodGFnLCB0YWdTdGFydENodW5rKTtcbiAgfVxuXG4gIHJldHVybiB0YWdTdGFydENodW5rO1xufVxuZnVuY3Rpb24gcHVzaFN0YXJ0SW5zdGFuY2UodGFyZ2V0LCB0eXBlLCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBmb3JtYXRDb250ZXh0LCB0ZXh0RW1iZWRkZWQpIHtcbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBudWxsKTtcblxuICAgIGlmICghcHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nICYmIHByb3BzLmNvbnRlbnRFZGl0YWJsZSAmJiBwcm9wcy5jaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgIT09IFNWR19NT0RFICYmIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSAhPT0gTUFUSE1MX01PREUpIHtcbiAgICAgIGlmICh0eXBlLmluZGV4T2YoJy0nKSA9PT0gLTEgJiYgdHlwZS50b0xvd2VyQ2FzZSgpICE9PSB0eXBlKSB7XG4gICAgICAgIGVycm9yKCc8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gJyArICdVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgJyArICdvciBsb3dlcmNhc2UgZm9yIEhUTUwgZWxlbWVudHMuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnZGl2JzpcbiAgICBjYXNlICdzcGFuJzpcbiAgICBjYXNlICdzdmcnOlxuICAgIGNhc2UgJ3BhdGgnOlxuICAgIGNhc2UgJ2EnOlxuICAgIGNhc2UgJ2cnOlxuICAgIGNhc2UgJ3AnOlxuICAgIGNhc2UgJ2xpJzpcbiAgICAgIC8vIEZhc3QgdHJhY2sgdmVyeSBjb21tb24gdGFnc1xuICAgICAgYnJlYWs7XG4gICAgLy8gU3BlY2lhbCB0YWdzXG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydFNlbGVjdCh0YXJnZXQsIHByb3BzKTtcblxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0T3B0aW9uKHRhcmdldCwgcHJvcHMsIGZvcm1hdENvbnRleHQpO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydFRleHRBcmVhKHRhcmdldCwgcHJvcHMpO1xuXG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgcmV0dXJuIHB1c2hJbnB1dCh0YXJnZXQsIHByb3BzLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUpO1xuXG4gICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgIHJldHVybiBwdXNoU3RhcnRCdXR0b24odGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKTtcblxuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydEZvcm0odGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlKTtcblxuICAgIGNhc2UgJ21lbnVpdGVtJzpcbiAgICAgIHJldHVybiBwdXNoU3RhcnRNZW51SXRlbSh0YXJnZXQsIHByb3BzKTtcblxuICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgIHJldHVybiBwdXNoVGl0bGUodGFyZ2V0LCBwcm9wcywgcmVuZGVyU3RhdGUsIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSwgISEoZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIE5PU0NSSVBUX1NDT1BFKSkgO1xuXG4gICAgY2FzZSAnbGluayc6XG4gICAgICByZXR1cm4gcHVzaExpbmsodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQsIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSwgISEoZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIE5PU0NSSVBUX1NDT1BFKSk7XG5cbiAgICBjYXNlICdzY3JpcHQnOlxuICAgICAgcmV0dXJuIHB1c2hTY3JpcHQodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQsIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSwgISEoZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIE5PU0NSSVBUX1NDT1BFKSkgO1xuXG4gICAgY2FzZSAnc3R5bGUnOlxuICAgICAgcmV0dXJuIHB1c2hTdHlsZSh0YXJnZXQsIHByb3BzLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIHRleHRFbWJlZGRlZCwgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlLCAhIShmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgTk9TQ1JJUFRfU0NPUEUpKTtcblxuICAgIGNhc2UgJ21ldGEnOlxuICAgICAgcmV0dXJuIHB1c2hNZXRhKHRhcmdldCwgcHJvcHMsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQsIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSwgISEoZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIE5PU0NSSVBUX1NDT1BFKSk7XG4gICAgLy8gTmV3bGluZSBlYXRpbmcgdGFnc1xuXG4gICAgY2FzZSAnbGlzdGluZyc6XG4gICAgY2FzZSAncHJlJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHB1c2hTdGFydFByZWZvcm1hdHRlZEVsZW1lbnQodGFyZ2V0LCBwcm9wcywgdHlwZSk7XG4gICAgICB9XG5cbiAgICBjYXNlICdpbWcnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gcHVzaEltZyh0YXJnZXQsIHByb3BzLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsICEhKGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiBQSUNUVVJFX1NDT1BFKSkgO1xuICAgICAgfVxuICAgIC8vIE9taXR0ZWQgY2xvc2UgdGFnc1xuXG4gICAgY2FzZSAnYmFzZSc6XG4gICAgY2FzZSAnYXJlYSc6XG4gICAgY2FzZSAnYnInOlxuICAgIGNhc2UgJ2NvbCc6XG4gICAgY2FzZSAnZW1iZWQnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdrZXlnZW4nOlxuICAgIGNhc2UgJ3BhcmFtJzpcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgIGNhc2UgJ3RyYWNrJzpcbiAgICBjYXNlICd3YnInOlxuICAgICAge1xuICAgICAgICByZXR1cm4gcHVzaFNlbGZDbG9zaW5nKHRhcmdldCwgcHJvcHMsIHR5cGUpO1xuICAgICAgfVxuICAgIC8vIFRoZXNlIGFyZSByZXNlcnZlZCBTVkcgYW5kIE1hdGhNTCBlbGVtZW50cywgdGhhdCBhcmUgbmV2ZXIgY3VzdG9tIGVsZW1lbnRzLlxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuXG4gICAgY2FzZSAnYW5ub3RhdGlvbi14bWwnOlxuICAgIGNhc2UgJ2NvbG9yLXByb2ZpbGUnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXNyYyc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXVyaSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLWZvcm1hdCc6XG4gICAgY2FzZSAnZm9udC1mYWNlLW5hbWUnOlxuICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAvLyBQcmVhbWJsZSBzdGFydCB0YWdzXG5cbiAgICBjYXNlICdoZWFkJzpcbiAgICAgIHJldHVybiBwdXNoU3RhcnRIZWFkKHRhcmdldCwgcHJvcHMsIHJlbmRlclN0YXRlLCBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUpO1xuXG4gICAgY2FzZSAnaHRtbCc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBwdXNoU3RhcnRIdG1sKHRhcmdldCwgcHJvcHMsIHJlbmRlclN0YXRlLCBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUpO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGUuaW5kZXhPZignLScpICE9PSAtMSkge1xuICAgICAgICAgIC8vIEN1c3RvbSBlbGVtZW50XG4gICAgICAgICAgcmV0dXJuIHB1c2hTdGFydEN1c3RvbUVsZW1lbnQodGFyZ2V0LCBwcm9wcywgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfSAvLyBHZW5lcmljIGVsZW1lbnRcblxuXG4gIHJldHVybiBwdXNoU3RhcnRHZW5lcmljRWxlbWVudCh0YXJnZXQsIHByb3BzLCB0eXBlKTtcbn1cbnZhciBlbmRUYWdDYWNoZSA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gZW5kQ2h1bmtGb3JUYWcodGFnKSB7XG4gIHZhciBjaHVuayA9IGVuZFRhZ0NhY2hlLmdldCh0YWcpO1xuXG4gIGlmIChjaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2h1bmsgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvJyArIHRhZyArICc+Jyk7XG4gICAgZW5kVGFnQ2FjaGUuc2V0KHRhZywgY2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5mdW5jdGlvbiBwdXNoRW5kSW5zdGFuY2UodGFyZ2V0LCB0eXBlLCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIGZvcm1hdENvbnRleHQpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgLy8gV2hlbiBmbG9hdCBpcyBvbiB3ZSBleHBlY3QgdGl0bGUgYW5kIHNjcmlwdCB0YWdzIHRvIGFsd2F5cyBiZSBwdXNoZWQgaW5cbiAgICAvLyBhIHVuaXQgYW5kIG5ldmVyIHJldHVybiBjaGlsZHJlbi4gd2hlbiB3ZSBlbmQgdXAgcHVzaGluZyB0aGUgZW5kIHRhZyB3ZVxuICAgIC8vIHdhbnQgdG8gZW5zdXJlIHRoZXJlIGlzIG5vIGV4dHJhIGNsb3NpbmcgdGFnIHB1c2hlZFxuICAgIGNhc2UgJ3RpdGxlJzpcbiAgICBjYXNlICdzdHlsZSc6XG4gICAgY2FzZSAnc2NyaXB0JzpcbiAgICAvLyBPbWl0dGVkIGNsb3NlIHRhZ3NcbiAgICAvLyBUT0RPOiBJbnN0ZWFkIG9mIHJlcGVhdGluZyB0aGlzIHN3aXRjaCB3ZSBjb3VsZCB0cnkgdG8gcGFzcyBhIGZsYWcgZnJvbSBhYm92ZS5cbiAgICAvLyBUaGF0IHdvdWxkIHJlcXVpcmUgcmV0dXJuaW5nIGEgdHVwbGUuIFdoaWNoIG1pZ2h0IGJlIG9rIGlmIGl0IGdldHMgaW5saW5lZC5cblxuICAgIGNhc2UgJ2FyZWEnOlxuICAgIGNhc2UgJ2Jhc2UnOlxuICAgIGNhc2UgJ2JyJzpcbiAgICBjYXNlICdjb2wnOlxuICAgIGNhc2UgJ2VtYmVkJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAna2V5Z2VuJzpcbiAgICBjYXNlICdsaW5rJzpcbiAgICBjYXNlICdtZXRhJzpcbiAgICBjYXNlICdwYXJhbSc6XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICBjYXNlICd0cmFjayc6XG4gICAgY2FzZSAnd2JyJzpcbiAgICAgIHtcbiAgICAgICAgLy8gTm8gY2xvc2UgdGFnIG5lZWRlZC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIC8vIFBvc3RhbWJsZSBlbmQgdGFnc1xuICAgIC8vIFdoZW4gZmxvYXQgaXMgZW5hYmxlZCB3ZSBvbWl0IHRoZSBlbmQgdGFncyBmb3IgYm9keSBhbmQgaHRtbCB3aGVuXG4gICAgLy8gdGhleSByZXByZXNlbnQgdGhlIERvY3VtZW50LmJvZHkgYW5kIERvY3VtZW50LmRvY3VtZW50RWxlbWVudCBOb2Rlcy5cbiAgICAvLyBUaGlzIGlzIHNvIHdlIGNhbiB3aXRoaG9sZCB0aGVtIHVudGlsIHRoZSBwb3N0YW1ibGUgd2hlbiB3ZSBrbm93XG4gICAgLy8gd2Ugd29uJ3QgZW1pdCBhbnkgbW9yZSB0YWdzXG5cbiAgICBjYXNlICdib2R5JzpcbiAgICAgIHtcbiAgICAgICAgaWYgKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA8PSBIVE1MX0hUTUxfTU9ERSkge1xuICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLmhhc0JvZHkgPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnaHRtbCc6XG4gICAgICBpZiAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBST09UX0hUTUxfTU9ERSkge1xuICAgICAgICByZXN1bWFibGVTdGF0ZS5oYXNIdG1sID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZENodW5rRm9yVGFnKHR5cGUpKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVCb290c3RyYXAoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlKSB7XG4gIHZhciBib290c3RyYXBDaHVua3MgPSByZW5kZXJTdGF0ZS5ib290c3RyYXBDaHVua3M7XG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IGJvb3RzdHJhcENodW5rcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBib290c3RyYXBDaHVua3NbaV0pO1xuICB9XG5cbiAgaWYgKGkgPCBib290c3RyYXBDaHVua3MubGVuZ3RoKSB7XG4gICAgdmFyIGxhc3RDaHVuayA9IGJvb3RzdHJhcENodW5rc1tpXTtcbiAgICBib290c3RyYXBDaHVua3MubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgbGFzdENodW5rKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3cml0ZUNvbXBsZXRlZFJvb3QoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlKSB7XG4gIHJldHVybiB3cml0ZUJvb3RzdHJhcChkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUpO1xufSAvLyBTdHJ1Y3R1cmFsIE5vZGVzXG4vLyBBIHBsYWNlaG9sZGVyIGlzIGEgbm9kZSBpbnNpZGUgYSBoaWRkZW4gcGFydGlhbCB0cmVlIHRoYXQgY2FuIGJlIGZpbGxlZCBpbiBsYXRlciwgYnV0IGJlZm9yZVxuLy8gZGlzcGxheS4gSXQncyBuZXZlciB2aXNpYmxlIHRvIHVzZXJzLiBXZSB1c2UgdGhlIHRlbXBsYXRlIHRhZyBiZWNhdXNlIGl0IGNhbiBiZSB1c2VkIGluIGV2ZXJ5XG4vLyB0eXBlIG9mIHBhcmVudC4gPHNjcmlwdD4gdGFncyBhbHNvIHdvcmsgaW4gZXZlcnkgb3RoZXIgdGFnIGV4Y2VwdCA8Y29sZ3JvdXA+LlxuXG52YXIgcGxhY2Vob2xkZXIxID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGVtcGxhdGUgaWQ9XCInKTtcbnZhciBwbGFjZWhvbGRlcjIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPjwvdGVtcGxhdGU+Jyk7XG5mdW5jdGlvbiB3cml0ZVBsYWNlaG9sZGVyKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSwgaWQpIHtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcGxhY2Vob2xkZXIxKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUucGxhY2Vob2xkZXJQcmVmaXgpO1xuICB2YXIgZm9ybWF0dGVkSUQgPSBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGZvcm1hdHRlZElEKTtcbiAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHBsYWNlaG9sZGVyMik7XG59IC8vIFN1c3BlbnNlIGJvdW5kYXJpZXMgYXJlIGVuY29kZWQgYXMgY29tbWVudHMuXG5cbnZhciBzdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhLS0kLS0+Jyk7XG52YXIgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhLS0kPy0tPjx0ZW1wbGF0ZSBpZD1cIicpO1xudmFyIHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj48L3RlbXBsYXRlPicpO1xudmFyIHN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tJCEtLT4nKTtcbnZhciBlbmRTdXNwZW5zZUJvdW5kYXJ5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tLyQtLT4nKTtcbnZhciBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZScpO1xudmFyIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCInKTtcbnZhciBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgZGF0YS1kZ3N0PVwiJyk7XG52YXIgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIGRhdGEtbXNnPVwiJyk7XG52YXIgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIGRhdGEtc3Rjaz1cIicpO1xudmFyIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPjwvdGVtcGxhdGU+Jyk7XG5mdW5jdGlvbiB3cml0ZVN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSQxKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSkge1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KTtcbn1cbmZ1bmN0aW9uIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUsIGlkKSB7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkxKTtcblxuICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIElEIG11c3QgaGF2ZSBiZWVuIGFzc2lnbmVkIGJlZm9yZSB3ZSBjYW4gY29tcGxldGUgdGhlIGJvdW5kYXJ5LicpO1xuICB9XG5cbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuYm91bmRhcnlQcmVmaXgpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTIpO1xufVxuZnVuY3Rpb24gd3JpdGVTdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSQxKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSwgZXJyb3JEaWdlc3QsIGVycm9yTWVzc3NhZ2UsIGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgdmFyIHJlc3VsdDtcbiAgcmVzdWx0ID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEpO1xuXG4gIGlmIChlcnJvckRpZ2VzdCkge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUEpO1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JEaWdlc3QpKSk7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoZXJyb3JNZXNzc2FnZSkge1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQik7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yTWVzc3NhZ2UpKSk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwpO1xuICAgIH1cblxuICAgIGlmIChlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFDKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JDb21wb25lbnRTdGFjaykpKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbCk7XG4gICAgfVxuICB9XG5cbiAgcmVzdWx0ID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHdyaXRlRW5kQ29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSQxKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSkge1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU3VzcGVuc2VCb3VuZGFyeSk7XG59XG5mdW5jdGlvbiB3cml0ZUVuZFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSkge1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU3VzcGVuc2VCb3VuZGFyeSk7XG59XG5mdW5jdGlvbiB3cml0ZUVuZENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSQxKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSkge1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU3VzcGVuc2VCb3VuZGFyeSk7XG59XG52YXIgc3RhcnRTZWdtZW50SFRNTCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPGRpdiBoaWRkZW4gaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRIVE1MMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudEhUTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvZGl2PicpO1xudmFyIHN0YXJ0U2VnbWVudFNWRyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50U1ZHMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudFNWRyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9zdmc+Jyk7XG52YXIgc3RhcnRTZWdtZW50TWF0aE1MID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8bWF0aCBhcmlhLWhpZGRlbj1cInRydWVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50TWF0aE1MMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudE1hdGhNTCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9tYXRoPicpO1xudmFyIHN0YXJ0U2VnbWVudFRhYmxlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGFibGUgaGlkZGVuIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50VGFibGUyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKTtcbnZhciBlbmRTZWdtZW50VGFibGUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvdGFibGU+Jyk7XG52YXIgc3RhcnRTZWdtZW50VGFibGVCb2R5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGFibGUgaGlkZGVuPjx0Ym9keSBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudFRhYmxlQm9keTIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRUYWJsZUJvZHkgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvdGJvZHk+PC90YWJsZT4nKTtcbnZhciBzdGFydFNlZ21lbnRUYWJsZVJvdyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbj48dHIgaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRUYWJsZVJvdzIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRUYWJsZVJvdyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC90cj48L3RhYmxlPicpO1xudmFyIHN0YXJ0U2VnbWVudENvbEdyb3VwID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGFibGUgaGlkZGVuPjxjb2xncm91cCBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudENvbEdyb3VwMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudENvbEdyb3VwID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L2NvbGdyb3VwPjwvdGFibGU+Jyk7XG5mdW5jdGlvbiB3cml0ZVN0YXJ0U2VnbWVudChkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUsIGZvcm1hdENvbnRleHQsIGlkKSB7XG4gIHN3aXRjaCAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKSB7XG4gICAgY2FzZSBST09UX0hUTUxfTU9ERTpcbiAgICBjYXNlIEhUTUxfSFRNTF9NT0RFOlxuICAgIGNhc2UgSFRNTF9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRIVE1MKTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRIVE1MMik7XG4gICAgICB9XG5cbiAgICBjYXNlIFNWR19NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRTVkcpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFNWRzIpO1xuICAgICAgfVxuXG4gICAgY2FzZSBNQVRITUxfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50TWF0aE1MKTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRNYXRoTUwyKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZSk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGUyKTtcbiAgICAgIH1cbiAgICAvLyBUT0RPOiBGb3IgdGhlIHJlc3Qgb2YgdGhlc2UsIHRoZXJlIHdpbGwgYmUgZXh0cmEgd3JhcHBlciBub2RlcyB0aGF0IG5ldmVyXG4gICAgLy8gZ2V0IGRlbGV0ZWQgZnJvbSB0aGUgZG9jdW1lbnQuIFdlIG5lZWQgdG8gZGVsZXRlIHRoZSB0YWJsZSB0b28gYXMgcGFydFxuICAgIC8vIG9mIHRoZSBpbmplY3RlZCBzY3JpcHRzLiBUaGV5IGFyZSBpbnZpc2libGUgdGhvdWdoIHNvIGl0J3Mgbm90IHRvbyB0ZXJyaWJsZVxuICAgIC8vIGFuZCBpdCdzIGtpbmQgb2YgYW4gZWRnZSBjYXNlIHRvIHN1c3BlbmQgaW4gYSB0YWJsZS4gVG90YWxseSBzdXBwb3J0ZWQgdGhvdWdoLlxuXG4gICAgY2FzZSBIVE1MX1RBQkxFX0JPRFlfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGVCb2R5KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZUJvZHkyKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9ST1dfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGVSb3cpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlUm93Mik7XG4gICAgICB9XG5cbiAgICBjYXNlIEhUTUxfQ09MR1JPVVBfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50Q29sR3JvdXApO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudENvbEdyb3VwMik7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaW5zZXJ0aW9uIG1vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHdyaXRlRW5kU2VnbWVudChkZXN0aW5hdGlvbiwgZm9ybWF0Q29udGV4dCkge1xuICBzd2l0Y2ggKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSkge1xuICAgIGNhc2UgUk9PVF9IVE1MX01PREU6XG4gICAgY2FzZSBIVE1MX0hUTUxfTU9ERTpcbiAgICBjYXNlIEhUTUxfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRIVE1MKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU1ZHX01PREU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50U1ZHKTtcbiAgICAgIH1cblxuICAgIGNhc2UgTUFUSE1MX01PREU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50TWF0aE1MKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9NT0RFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudFRhYmxlKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9CT0RZX01PREU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50VGFibGVCb2R5KTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9ST1dfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRUYWJsZVJvdyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEhUTUxfQ09MR1JPVVBfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRDb2xHcm91cCk7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaW5zZXJ0aW9uIG1vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gIH1cbn1cbnZhciBjb21wbGV0ZVNlZ21lbnRTY3JpcHQxRnVsbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjb21wbGV0ZVNlZ21lbnQgKyAnJFJTKFwiJyk7XG52YXIgY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyRSUyhcIicpO1xudmFyIGNvbXBsZXRlU2VnbWVudFNjcmlwdDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiLFwiJyk7XG52YXIgY29tcGxldGVTZWdtZW50U2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIik8L3NjcmlwdD4nKTtcbnZhciBjb21wbGV0ZVNlZ21lbnREYXRhMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlIGRhdGEtcnNpPVwiXCIgZGF0YS1zaWQ9XCInKTtcbnZhciBjb21wbGV0ZVNlZ21lbnREYXRhMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1waWQ9XCInKTtcbnZhciBjb21wbGV0ZVNlZ21lbnREYXRhRW5kID0gZGF0YUVsZW1lbnRRdW90ZWRFbmQ7XG5mdW5jdGlvbiB3cml0ZUNvbXBsZXRlZFNlZ21lbnRJbnN0cnVjdGlvbihkZXN0aW5hdGlvbiwgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBjb250ZW50U2VnbWVudElEKSB7XG4gIHZhciBzY3JpcHRGb3JtYXQgPSByZXN1bWFibGVTdGF0ZS5zdHJlYW1pbmdGb3JtYXQgPT09IFNjcmlwdFN0cmVhbWluZ0Zvcm1hdDtcblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc3RhcnRJbmxpbmVTY3JpcHQpO1xuXG4gICAgaWYgKChyZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgJiBTZW50Q29tcGxldGVTZWdtZW50RnVuY3Rpb24pID09PSBOb3RoaW5nU2VudCkge1xuICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgd2Ugd3JpdGUgdGhpcywgd2UnbGwgbmVlZCB0byBpbmNsdWRlIHRoZSBmdWxsIGltcGxlbWVudGF0aW9uLlxuICAgICAgcmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbjtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFGdWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRnV0dXJlIGNhbGxzIGNhbiBqdXN0IHJldXNlIHRoZSBzYW1lIGZ1bmN0aW9uLlxuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnREYXRhMSk7XG4gIH0gLy8gV3JpdGUgZnVuY3Rpb24gYXJndW1lbnRzLCB3aGljaCBhcmUgc3RyaW5nIGxpdGVyYWxzXG5cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgdmFyIGZvcm1hdHRlZElEID0gc3RyaW5nVG9DaHVuayhjb250ZW50U2VnbWVudElELnRvU3RyaW5nKDE2KSk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGZvcm1hdHRlZElEKTtcblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0Mik7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50RGF0YTIpO1xuICB9XG5cbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUucGxhY2Vob2xkZXJQcmVmaXgpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBmb3JtYXR0ZWRJRCk7XG5cbiAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnRTY3JpcHRFbmQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnREYXRhRW5kKTtcbiAgfVxufVxudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxRnVsbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjb21wbGV0ZUJvdW5kYXJ5ICsgJyRSQyhcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxUGFydGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnJFJDKFwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxRnVsbEJvdGggPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoY29tcGxldGVCb3VuZGFyeSArIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzICsgJyRSUihcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzICsgJyRSUihcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MVBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyRSUihcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIixcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIsJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVNjcmlwdDNiID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHRFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyk8L3NjcmlwdD4nKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5RGF0YTEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZSBkYXRhLXJjaT1cIlwiIGRhdGEtYmlkPVwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNEYXRhMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlIGRhdGEtcnJpPVwiXCIgZGF0YS1iaWQ9XCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5RGF0YTIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtc2lkPVwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeURhdGEzYSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1zdHk9XCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5RGF0YUVuZCA9IGRhdGFFbGVtZW50UXVvdGVkRW5kO1xuZnVuY3Rpb24gd3JpdGVDb21wbGV0ZWRCb3VuZGFyeUluc3RydWN0aW9uKGRlc3RpbmF0aW9uLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIGlkLCBib3VuZGFyeVJlc291cmNlcykge1xuICB2YXIgcmVxdWlyZXNTdHlsZUluc2VydGlvbjtcblxuICB7XG4gICAgcmVxdWlyZXNTdHlsZUluc2VydGlvbiA9IHJlbmRlclN0YXRlLnN0eWxlc1RvSG9pc3Q7IC8vIElmIG5lY2Vzc2FyeSBzdHlsZXNoZWV0cyB3aWxsIGJlIGZsdXNoZWQgd2l0aCB0aGlzIGluc3RydWN0aW9uLlxuICAgIC8vIEFueSBzdHlsZSB0YWdzIG5vdCB5ZXQgaG9pc3RlZCBpbiB0aGUgRG9jdW1lbnQgd2lsbCBhbHNvIGJlIGhvaXN0ZWQuXG4gICAgLy8gV2UgcmVzZXQgdGhpcyBzdGF0ZSBzaW5jZSBhZnRlciB0aGlzIGluc3RydWN0aW9uIGV4ZWN1dGVzIGFsbCBzdHlsZXNcbiAgICAvLyB1cCB0byB0aGlzIHBvaW50IHdpbGwgaGF2ZSBiZWVuIGhvaXN0ZWRcblxuICAgIHJlbmRlclN0YXRlLnN0eWxlc1RvSG9pc3QgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBzY3JpcHRGb3JtYXQgPSByZXN1bWFibGVTdGF0ZS5zdHJlYW1pbmdGb3JtYXQgPT09IFNjcmlwdFN0cmVhbWluZ0Zvcm1hdDtcblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc3RhcnRJbmxpbmVTY3JpcHQpO1xuXG4gICAgaWYgKHJlcXVpcmVzU3R5bGVJbnNlcnRpb24pIHtcbiAgICAgIGlmICgocmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zICYgU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbikgPT09IE5vdGhpbmdTZW50KSB7XG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyB8PSBTZW50U3R5bGVJbnNlcnRpb25GdW5jdGlvbiB8IFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb247XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsb25lUHJlY29tcHV0ZWRDaHVuayhjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsQm90aCkpO1xuICAgICAgfSBlbHNlIGlmICgocmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zICYgU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24pID09PSBOb3RoaW5nU2VudCkge1xuICAgICAgICByZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb247XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxQYXJ0aWFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MVBhcnRpYWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24pID09PSBOb3RoaW5nU2VudCkge1xuICAgICAgICByZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbjtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFGdWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxUGFydGlhbCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChyZXF1aXJlc1N0eWxlSW5zZXJ0aW9uKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc0RhdGExKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeURhdGExKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaWRDaHVuayA9IHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuYm91bmRhcnlQcmVmaXgpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBpZENodW5rKTsgLy8gV3JpdGUgZnVuY3Rpb24gYXJndW1lbnRzLCB3aGljaCBhcmUgc3RyaW5nIGFuZCBhcnJheSBsaXRlcmFsc1xuXG4gIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0Mik7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeURhdGEyKTtcbiAgfVxuXG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBpZENodW5rKTtcblxuICBpZiAocmVxdWlyZXNTdHlsZUluc2VydGlvbikge1xuICAgIC8vIFNjcmlwdCBhbmQgZGF0YSB3cml0ZXJzIG11c3QgZm9ybWF0IHRoaXMgZGlmZmVyZW50bHk6XG4gICAgLy8gIC0gc2NyaXB0IHdyaXRlciBlbWl0cyBhbiBhcnJheSBsaXRlcmFsLCB3aG9zZSBzdHJpbmcgZWxlbWVudHMgYXJlXG4gICAgLy8gICAgZXNjYXBlZCBmb3IgamF2YXNjcmlwdCAgZS5nLiBbXCJBXCIsIFwiQlwiXVxuICAgIC8vICAtIGRhdGEgd3JpdGVyIGVtaXRzIGEgc3RyaW5nIGxpdGVyYWwsIHdoaWNoIGlzIGVzY2FwZWQgYXMgaHRtbFxuICAgIC8vICAgIGUuZy4gWyYjMzQ7QSYjMzQ7LCAmIzM0O0ImIzM0O11cbiAgICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2EpOyAvLyBib3VuZGFyeVJlc291cmNlcyBlbmNvZGVzIGFuIGFycmF5IGxpdGVyYWxcblxuICAgICAgd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5KUyhkZXN0aW5hdGlvbiwgYm91bmRhcnlSZXNvdXJjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5RGF0YTNhKTtcbiAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY2llc0luQXR0cihkZXN0aW5hdGlvbiwgYm91bmRhcnlSZXNvdXJjZXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2IpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB3cml0ZU1vcmU7XG5cbiAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgIHdyaXRlTW9yZSA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHRFbmQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlTW9yZSA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlEYXRhRW5kKTtcbiAgfVxuXG4gIHJldHVybiB3cml0ZUJvb3RzdHJhcChkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUpICYmIHdyaXRlTW9yZTtcbn1cbnZhciBjbGllbnRSZW5kZXJTY3JpcHQxRnVsbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjbGllbnRSZW5kZXJCb3VuZGFyeSArICc7JFJYKFwiJyk7XG52YXIgY2xpZW50UmVuZGVyU2NyaXB0MVBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyRSWChcIicpO1xudmFyIGNsaWVudFJlbmRlclNjcmlwdDFBID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIicpO1xudmFyIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcsJyk7XG52YXIgY2xpZW50UmVuZGVyU2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcpPC9zY3JpcHQ+Jyk7XG52YXIgY2xpZW50UmVuZGVyRGF0YTEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZSBkYXRhLXJ4aT1cIlwiIGRhdGEtYmlkPVwiJyk7XG52YXIgY2xpZW50UmVuZGVyRGF0YTIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtZGdzdD1cIicpO1xudmFyIGNsaWVudFJlbmRlckRhdGEzID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLW1zZz1cIicpO1xudmFyIGNsaWVudFJlbmRlckRhdGE0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLXN0Y2s9XCInKTtcbnZhciBjbGllbnRSZW5kZXJEYXRhRW5kID0gZGF0YUVsZW1lbnRRdW90ZWRFbmQ7XG5mdW5jdGlvbiB3cml0ZUNsaWVudFJlbmRlckJvdW5kYXJ5SW5zdHJ1Y3Rpb24oZGVzdGluYXRpb24sIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgaWQsIGVycm9yRGlnZXN0LCBlcnJvck1lc3NhZ2UsIGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgdmFyIHNjcmlwdEZvcm1hdCA9IHJlc3VtYWJsZVN0YXRlLnN0cmVhbWluZ0Zvcm1hdCA9PT0gU2NyaXB0U3RyZWFtaW5nRm9ybWF0O1xuXG4gIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zdGFydElubGluZVNjcmlwdCk7XG5cbiAgICBpZiAoKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbikgPT09IE5vdGhpbmdTZW50KSB7XG4gICAgICAvLyBUaGUgZmlyc3QgdGltZSB3ZSB3cml0ZSB0aGlzLCB3ZSdsbCBuZWVkIHRvIGluY2x1ZGUgdGhlIGZ1bGwgaW1wbGVtZW50YXRpb24uXG4gICAgICByZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudENsaWVudFJlbmRlckZ1bmN0aW9uO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyU2NyaXB0MUZ1bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGdXR1cmUgY2FsbHMgY2FuIGp1c3QgcmV1c2UgdGhlIHNhbWUgZnVuY3Rpb24uXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJTY3JpcHQxUGFydGlhbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIDx0ZW1wbGF0ZSBkYXRhLXJ4aT1cIlwiIGRhdGEtYmlkPVwiXG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyRGF0YTEpO1xuICB9XG5cbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuYm91bmRhcnlQcmVmaXgpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuXG4gIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICAvLyBcIiBuZWVkcyB0byBiZSBpbnNlcnRlZCBmb3Igc2NyaXB0cywgc2luY2UgQXJnSW50ZXJzdGl0dWFsIGRvZXMgbm90IGNvbnRhaW5cbiAgICAvLyBsZWFkaW5nIG9yIHRyYWlsaW5nIHF1b3Rlc1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlclNjcmlwdDFBKTtcbiAgfVxuXG4gIGlmIChlcnJvckRpZ2VzdCB8fCBlcnJvck1lc3NhZ2UgfHwgZXJyb3JDb21wb25lbnRTdGFjaykge1xuICAgIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICAgIC8vICxcIkpTT05TdHJpbmdcIlxuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWwpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoZXJyb3JEaWdlc3QgfHwgJycpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFwiIGRhdGEtZGdzdD1cIkhUTUxTdHJpbmdcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlckRhdGEyKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JEaWdlc3QgfHwgJycpKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVycm9yTWVzc2FnZSB8fCBlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gICAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgICAgLy8gLFwiSlNPTlN0cmluZ1wiXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvck1lc3NhZ2UgfHwgJycpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFwiIGRhdGEtbXNnPVwiSFRNTFN0cmluZ1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyRGF0YTMpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvck1lc3NhZ2UgfHwgJycpKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgICAvLyAsXCJKU09OU3RyaW5nXCJcbiAgICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvckNvbXBvbmVudFN0YWNrKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBcIiBkYXRhLXN0Y2s9XCJIVE1MU3RyaW5nXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJEYXRhNCk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yQ29tcG9uZW50U3RhY2spKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgIC8vID48L3NjcmlwdD5cbiAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyU2NyaXB0RW5kKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBcIj48L3RlbXBsYXRlPlxuICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJEYXRhRW5kKTtcbiAgfVxufVxudmFyIHJlZ2V4Rm9ySlNTdHJpbmdzSW5JbnN0cnVjdGlvblNjcmlwdHMgPSAvWzxcXHUyMDI4XFx1MjAyOV0vZztcblxuZnVuY3Rpb24gZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGlucHV0KSB7XG4gIHZhciBlc2NhcGVkID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICByZXR1cm4gZXNjYXBlZC5yZXBsYWNlKHJlZ2V4Rm9ySlNTdHJpbmdzSW5JbnN0cnVjdGlvblNjcmlwdHMsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgIC8vIHNhbnRpemluZyBicmVha2luZyBvdXQgb2Ygc3RyaW5ncyBhbmQgc2NyaXB0IHRhZ3NcbiAgICAgIGNhc2UgJzwnOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTAwM2NcIjtcblxuICAgICAgY2FzZSBcIlxcdTIwMjhcIjpcbiAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI4XCI7XG5cbiAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgIHJldHVybiBcIlxcXFx1MjAyOVwiO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbnZhciByZWdleEZvckpTU3RyaW5nc0luU2NyaXB0cyA9IC9bJj48XFx1MjAyOFxcdTIwMjldL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGlucHV0KSB7XG4gIHZhciBlc2NhcGVkID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICByZXR1cm4gZXNjYXBlZC5yZXBsYWNlKHJlZ2V4Rm9ySlNTdHJpbmdzSW5TY3JpcHRzLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICAvLyBzYW50aXppbmcgYnJlYWtpbmcgb3V0IG9mIHN0cmluZ3MgYW5kIHNjcmlwdCB0YWdzXG4gICAgICBjYXNlICcmJzpcbiAgICAgICAgcmV0dXJuIFwiXFxcXHUwMDI2XCI7XG5cbiAgICAgIGNhc2UgJz4nOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTAwM2VcIjtcblxuICAgICAgY2FzZSAnPCc6XG4gICAgICAgIHJldHVybiBcIlxcXFx1MDAzY1wiO1xuXG4gICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjhcIjtcblxuICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI5XCI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMgZW5jb3VudGVyZWQgYSBtYXRjaCBpdCBkb2VzIG5vdCBrbm93IGhvdyB0byByZXBsYWNlLiB0aGlzIG1lYW5zIHRoZSBtYXRjaCByZWdleCBhbmQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgYXJlIG5vIGxvbmdlciBpbiBzeW5jLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG52YXIgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHN0eWxlIG1lZGlhPVwibm90IGFsbFwiIGRhdGEtcHJlY2VkZW5jZT1cIicpO1xudmFyIGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtaHJlZj1cIicpO1xudmFyIGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjMgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGxhdGVTdHlsZVRhZ1RlbXBsYXRlQ2xvc2UgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvc3R5bGU+Jyk7IC8vIFRyYWNrcyB3aGV0aGVyIHRoZSBib3VuZGFyeSBjdXJyZW50bHkgZmx1c2hpbmcgaXMgZmx1c2hpZ24gc3R5bGUgdGFncyBvciBoYXMgYW55XG4vLyBzdHlsZXNoZWV0IGRlcGVuZGVuY2llcyBub3QgZmx1c2hlZCBpbiB0aGUgUHJlYW1ibGUuXG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgPSBmYWxzZTsgLy8gQWN0cyBhcyBhIHJldHVybiB2YWx1ZSBmb3IgdGhlIGZvckVhY2ggZXhlY3V0aW9uIG9mIHN0eWxlIHRhZyBmbHVzaGluZy5cblxudmFyIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkgPSB0cnVlO1xuXG5mdW5jdGlvbiBmbHVzaFN0eWxlVGFnc0xhdGVGb3JCb3VuZGFyeShzdHlsZVF1ZXVlKSB7XG4gIHZhciBydWxlcyA9IHN0eWxlUXVldWUucnVsZXM7XG4gIHZhciBocmVmcyA9IHN0eWxlUXVldWUuaHJlZnM7XG5cbiAge1xuICAgIGlmIChydWxlcy5sZW5ndGggPiAwICYmIGhyZWZzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZXJyb3IoJ1JlYWN0IGV4cGVjdGVkIHRvIGhhdmUgYXQgbGVhc3Qgb25lIGhyZWYgZm9yIGFuIGEgaG9pc3RhYmxlIHN0eWxlIGJ1dCBmb3VuZCBub25lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpID0gMDtcblxuICBpZiAoaHJlZnMubGVuZ3RoKSB7XG4gICAgd3JpdGVDaHVuayh0aGlzLCBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xKTtcbiAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlUXVldWUucHJlY2VkZW5jZSk7XG4gICAgd3JpdGVDaHVuayh0aGlzLCBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4yKTtcblxuICAgIGZvciAoOyBpIDwgaHJlZnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB3cml0ZUNodW5rKHRoaXMsIGhyZWZzW2ldKTtcbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3BhY2VTZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIHdyaXRlQ2h1bmsodGhpcywgaHJlZnNbaV0pO1xuICAgIHdyaXRlQ2h1bmsodGhpcywgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMyk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgcnVsZXNbaV0pO1xuICAgIH1cblxuICAgIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkgPSB3cml0ZUNodW5rQW5kUmV0dXJuKHRoaXMsIGxhdGVTdHlsZVRhZ1RlbXBsYXRlQ2xvc2UpOyAvLyBXZSB3cm90ZSBzdHlsZSB0YWdzIGZvciB0aGlzIGJvdW5kYXJ5IGFuZCB3ZSBtYXkgbmVlZCB0byBlbWl0IGEgc2NyaXB0XG4gICAgLy8gdG8gaG9pc3QgdGhlbS5cblxuICAgIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9IHRydWU7IC8vIHN0eWxlIHJlc291cmNlcyBjYW4gZmx1c2ggY29udGludW91c2x5IHNpbmNlIG1vcmUgcnVsZXMgbWF5IGJlIHdyaXR0ZW4gaW50b1xuICAgIC8vIHRoZW0gd2l0aCBuZXcgaHJlZnMuIEluc3RlYWQgb2YgbWFya2luZyBpdCBmbHVzaGVkLCB3ZSBzaW1wbHkgcmVzZXQgdGhlIGNodW5rc1xuICAgIC8vIGFuZCBocmVmc1xuXG4gICAgcnVsZXMubGVuZ3RoID0gMDtcbiAgICBocmVmcy5sZW5ndGggPSAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1N0eWxlc1RvSG9pc3Qoc3R5bGVzaGVldCkge1xuICAvLyBXZSBuZWVkIHRvIHJldmVhbCBib3VuZGFyaWVzIHdpdGggc3R5bGVzIHdoZW5ldmVyIGEgc3R5bGVzaGVldCBpdCBkZXBlbmRzIG9uIGlzIGVpdGhlclxuICAvLyBub3QgZmx1c2hlZCBvciBmbHVzaGVkIGFmdGVyIHRoZSBwcmVhbWJsZSAoc2hlbGwpLlxuICBpZiAoc3R5bGVzaGVldC5zdGF0ZSAhPT0gUFJFQU1CTEUpIHtcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3cml0ZVJlc291cmNlc0ZvckJvdW5kYXJ5KGRlc3RpbmF0aW9uLCBib3VuZGFyeVJlc291cmNlcywgcmVuZGVyU3RhdGUpIHtcbiAgLy8gUmVzZXQgdGhlc2Ugb24gZWFjaCBpbnZvY2F0aW9uLCB0aGV5IGFyZSBvbmx5IHNhZmUgdG8gcmVhZCBpbiB0aGlzIGZ1bmN0aW9uXG4gIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9IGZhbHNlO1xuICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5ID0gdHJ1ZTsgLy8gRmx1c2ggc3R5bGUgdGFncyBmb3IgZWFjaCBwcmVjZWRlbmNlIHRoaXMgYm91bmRhcnkgZGVwZW5kcyBvblxuXG4gIGJvdW5kYXJ5UmVzb3VyY2VzLnN0eWxlcy5mb3JFYWNoKGZsdXNoU3R5bGVUYWdzTGF0ZUZvckJvdW5kYXJ5LCBkZXN0aW5hdGlvbik7IC8vIERldGVybWluZSBpZiB0aGlzIGJvdW5kYXJ5IGhhcyBzdHlsZXNoZWV0cyB0aGF0IG5lZWQgdG8gYmUgYXdhaXRlZCB1cG9uIGNvbXBsZXRpb25cblxuICBib3VuZGFyeVJlc291cmNlcy5zdHlsZXNoZWV0cy5mb3JFYWNoKGhhc1N0eWxlc1RvSG9pc3QpO1xuXG4gIGlmIChjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QpIHtcbiAgICByZW5kZXJTdGF0ZS5zdHlsZXNUb0hvaXN0ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5O1xufVxuXG5mdW5jdGlvbiBmbHVzaFJlc291cmNlKHJlc291cmNlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICB3cml0ZUNodW5rKHRoaXMsIHJlc291cmNlW2ldKTtcbiAgfVxuXG4gIHJlc291cmNlLmxlbmd0aCA9IDA7XG59XG5cbnZhciBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZSA9IFtdO1xuXG5mdW5jdGlvbiBmbHVzaFN0eWxlSW5QcmVhbWJsZShzdHlsZXNoZWV0LCBrZXksIG1hcCkge1xuICAvLyBXZSBzdGlsbCBuZWVkIHRvIGVuY29kZSBzdHlsZXNoZWV0IGNodW5rc1xuICAvLyBiZWNhdXNlIHVubGlrZSBtb3N0IEhvaXN0YWJsZXMgYW5kIFJlc291cmNlcyB3ZSBkbyBub3QgZWFnZXJseSBlbmNvZGVcbiAgLy8gdGhlbSBkdXJpbmcgcmVuZGVyLiBUaGlzIGlzIGJlY2F1c2UgaWYgd2UgZmx1c2ggbGF0ZSB3ZSBoYXZlIHRvIHNlbmQgYVxuICAvLyBkaWZmZXJlbnQgZW5jb2RpbmcgYW5kIHdlIGRvbid0IHdhbnQgdG8gZW5jb2RlIG11bHRpcGxlIHRpbWVzXG4gIHB1c2hMaW5rSW1wbChzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZSwgc3R5bGVzaGVldC5wcm9wcyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVzaGVldEZsdXNoaW5nUXVldWVbaV0pO1xuICB9XG5cbiAgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoID0gMDtcbiAgc3R5bGVzaGVldC5zdGF0ZSA9IFBSRUFNQkxFO1xufVxuXG52YXIgc3R5bGVUYWdSZXNvdXJjZU9wZW4xID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8c3R5bGUgZGF0YS1wcmVjZWRlbmNlPVwiJyk7XG52YXIgc3R5bGVUYWdSZXNvdXJjZU9wZW4yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLWhyZWY9XCInKTtcbnZhciBzcGFjZVNlcGFyYXRvciA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnICcpO1xudmFyIHN0eWxlVGFnUmVzb3VyY2VPcGVuMyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgc3R5bGVUYWdSZXNvdXJjZUNsb3NlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3N0eWxlPicpO1xuXG5mdW5jdGlvbiBmbHVzaFN0eWxlc0luUHJlYW1ibGUoc3R5bGVRdWV1ZSwgcHJlY2VkZW5jZSkge1xuICB2YXIgaGFzU3R5bGVzaGVldHMgPSBzdHlsZVF1ZXVlLnNoZWV0cy5zaXplID4gMDtcbiAgc3R5bGVRdWV1ZS5zaGVldHMuZm9yRWFjaChmbHVzaFN0eWxlSW5QcmVhbWJsZSwgdGhpcyk7XG4gIHN0eWxlUXVldWUuc2hlZXRzLmNsZWFyKCk7XG4gIHZhciBydWxlcyA9IHN0eWxlUXVldWUucnVsZXM7XG4gIHZhciBocmVmcyA9IHN0eWxlUXVldWUuaHJlZnM7IC8vIElmIHdlIGRvbid0IGVtaXQgYW55IHN0eWxlc2hlZXRzIGF0IHRoaXMgcHJlY2VkZW5jZSB3ZSBzdGlsbCBuZWVkIHRvIG1haW50YWluIHRoZSBwcmVjZWRlbmNlXG4gIC8vIG9yZGVyIHNvIGV2ZW4gaWYgdGhlcmUgYXJlIG5vIHJ1bGVzIGZvciBzdHlsZSB0YWdzIGF0IHRoaXMgcHJlY2VkZW5jZSB3ZSBlbWl0IGFuIGVtcHR5IHN0eWxlXG4gIC8vIHRhZyB3aXRoIHRoZSBkYXRhLXByZWNlZGVuY2UgYXR0cmlidXRlXG5cbiAgaWYgKCFoYXNTdHlsZXNoZWV0cyB8fCBocmVmcy5sZW5ndGgpIHtcbiAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlVGFnUmVzb3VyY2VPcGVuMSk7XG4gICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZVF1ZXVlLnByZWNlZGVuY2UpO1xuICAgIHZhciBpID0gMDtcblxuICAgIGlmIChocmVmcy5sZW5ndGgpIHtcbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVUYWdSZXNvdXJjZU9wZW4yKTtcblxuICAgICAgZm9yICg7IGkgPCBocmVmcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBocmVmc1tpXSk7XG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3BhY2VTZXBhcmF0b3IpO1xuICAgICAgfVxuXG4gICAgICB3cml0ZUNodW5rKHRoaXMsIGhyZWZzW2ldKTtcbiAgICB9XG5cbiAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlVGFnUmVzb3VyY2VPcGVuMyk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgcnVsZXNbaV0pO1xuICAgIH1cblxuICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVUYWdSZXNvdXJjZUNsb3NlKTsgLy8gc3R5bGUgcmVzb3VyY2VzIGNhbiBmbHVzaCBjb250aW51b3VzbHkgc2luY2UgbW9yZSBydWxlcyBtYXkgYmUgd3JpdHRlbiBpbnRvXG4gICAgLy8gdGhlbSB3aXRoIG5ldyBocmVmcy4gSW5zdGVhZCBvZiBtYXJraW5nIGl0IGZsdXNoZWQsIHdlIHNpbXBseSByZXNldCB0aGUgY2h1bmtzXG4gICAgLy8gYW5kIGhyZWZzXG5cbiAgICBydWxlcy5sZW5ndGggPSAwO1xuICAgIGhyZWZzLmxlbmd0aCA9IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlbG9hZExhdGVTdHlsZShzdHlsZXNoZWV0KSB7XG4gIGlmIChzdHlsZXNoZWV0LnN0YXRlID09PSBQRU5ESU5HJDEpIHtcbiAgICBzdHlsZXNoZWV0LnN0YXRlID0gUFJFTE9BREVEO1xuICAgIHZhciBwcmVsb2FkUHJvcHMgPSBwcmVsb2FkQXNTdHlsZVByb3BzRnJvbVByb3BzKHN0eWxlc2hlZXQucHJvcHMuaHJlZiwgc3R5bGVzaGVldC5wcm9wcyk7XG4gICAgcHVzaExpbmtJbXBsKHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLCBwcmVsb2FkUHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZVtpXSk7XG4gICAgfVxuXG4gICAgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVsb2FkTGF0ZVN0eWxlcyhzdHlsZVF1ZXVlKSB7XG4gIHN0eWxlUXVldWUuc2hlZXRzLmZvckVhY2gocHJlbG9hZExhdGVTdHlsZSwgdGhpcyk7XG4gIHN0eWxlUXVldWUuc2hlZXRzLmNsZWFyKCk7XG59IC8vIFdlIGRvbid0IGJvdGhlciByZXBvcnRpbmcgYmFja3ByZXNzdXJlIGF0IHRoZSBtb21lbnQgYmVjYXVzZSB3ZSBleHBlY3QgdG9cbi8vIGZsdXNoIHRoZSBlbnRpcmUgcHJlYW1ibGUgaW4gYSBzaW5nbGUgcGFzcy4gVGhpcyBwcm9iYWJseSBzaG91bGQgYmUgbW9kaWZpZWRcbi8vIGluIHRoZSBmdXR1cmUgdG8gYmUgYmFja3ByZXNzdXJlIHNlbnNpdGl2ZSBidXQgdGhhdCByZXF1aXJlcyBhIGxhcmdlciByZWZhY3RvclxuLy8gb2YgdGhlIGZsdXNoaW5nIGNvZGUgaW4gRml6ei5cblxuXG5mdW5jdGlvbiB3cml0ZVByZWFtYmxlKGRlc3RpbmF0aW9uLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIHdpbGxGbHVzaEFsbFNlZ21lbnRzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgZXhhY3RseSBvbmNlIG9uIGV2ZXJ5IHJlcXVlc3RcbiAgaWYgKCF3aWxsRmx1c2hBbGxTZWdtZW50cyAmJiByZW5kZXJTdGF0ZS5leHRlcm5hbFJ1bnRpbWVTY3JpcHQpIHtcbiAgICAvLyBJZiB0aGUgcm9vdCBzZWdtZW50IGlzIGluY29tcGxldGUgZHVlIHRvIHN1c3BlbmRlZCB0YXNrc1xuICAgIC8vIChlLmcuIHdpbGxGbHVzaEFsbFNlZ21lbnRzID0gZmFsc2UpIGFuZCB3ZSBhcmUgdXNpbmcgZGF0YVxuICAgIC8vIHN0cmVhbWluZyBmb3JtYXQsIGVuc3VyZSB0aGUgZXh0ZXJuYWwgcnVudGltZSBpcyBzZW50LlxuICAgIC8vIChVc2VyIGNvZGUgY291bGQgY2hvb3NlIHRvIHNlbmQgdGhpcyBldmVuIGVhcmxpZXIgYnkgY2FsbGluZ1xuICAgIC8vICBwcmVpbml0KC4uLiksIGlmIHRoZXkga25vdyB0aGV5IHdpbGwgc3VzcGVuZCkuXG4gICAgdmFyIF9yZW5kZXJTdGF0ZSRleHRlcm5hbCA9IHJlbmRlclN0YXRlLmV4dGVybmFsUnVudGltZVNjcmlwdCxcbiAgICAgICAgc3JjID0gX3JlbmRlclN0YXRlJGV4dGVybmFsLnNyYyxcbiAgICAgICAgY2h1bmtzID0gX3JlbmRlclN0YXRlJGV4dGVybmFsLmNodW5rcztcbiAgICBpbnRlcm5hbFByZWluaXRTY3JpcHQocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBzcmMsIGNodW5rcyk7XG4gIH1cblxuICB2YXIgaHRtbENodW5rcyA9IHJlbmRlclN0YXRlLmh0bWxDaHVua3M7XG4gIHZhciBoZWFkQ2h1bmtzID0gcmVuZGVyU3RhdGUuaGVhZENodW5rcztcbiAgdmFyIGkgPSAwOyAvLyBFbWl0IG9wZW4gdGFncyBiZWZvcmUgSG9pc3RhYmxlcyBhbmQgUmVzb3VyY2VzXG5cbiAgaWYgKGh0bWxDaHVua3MpIHtcbiAgICAvLyBXZSBoYXZlIGFuIDxodG1sPiB0byBlbWl0IGFzIHBhcnQgb2YgdGhlIHByZWFtYmxlXG4gICAgZm9yIChpID0gMDsgaSA8IGh0bWxDaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGh0bWxDaHVua3NbaV0pO1xuICAgIH1cblxuICAgIGlmIChoZWFkQ2h1bmtzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaGVhZENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBoZWFkQ2h1bmtzW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgZGlkIG5vdCByZW5kZXIgYSBoZWFkIGJ1dCB3ZSBlbWl0dGVkIGFuIDxodG1sPiBzbyB3ZSBlbWl0IG9uZSBub3dcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0Q2h1bmtGb3JUYWcoJ2hlYWQnKSk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRPZlN0YXJ0VGFnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaGVhZENodW5rcykge1xuICAgIC8vIFdlIGRvIG5vdCBoYXZlIGFuIDxodG1sPiBidXQgd2UgZG8gaGF2ZSBhIDxoZWFkPlxuICAgIGZvciAoaSA9IDA7IGkgPCBoZWFkQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBoZWFkQ2h1bmtzW2ldKTtcbiAgICB9XG4gIH0gLy8gRW1pdCBoaWdoIHByaW9yaXR5IEhvaXN0YWJsZXNcblxuXG4gIHZhciBjaGFyc2V0Q2h1bmtzID0gcmVuZGVyU3RhdGUuY2hhcnNldENodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgY2hhcnNldENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNoYXJzZXRDaHVua3NbaV0pO1xuICB9XG5cbiAgY2hhcnNldENodW5rcy5sZW5ndGggPSAwOyAvLyBlbWl0IHByZWNvbm5lY3QgcmVzb3VyY2VzXG5cbiAgcmVuZGVyU3RhdGUucHJlY29ubmVjdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmNsZWFyKCk7XG4gIHZhciBwcmVjb25uZWN0Q2h1bmtzID0gcmVuZGVyU3RhdGUucHJlY29ubmVjdENodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgcHJlY29ubmVjdENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHByZWNvbm5lY3RDaHVua3NbaV0pO1xuICB9XG5cbiAgcHJlY29ubmVjdENodW5rcy5sZW5ndGggPSAwO1xuICByZW5kZXJTdGF0ZS5mb250UHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJlbmRlclN0YXRlLmZvbnRQcmVsb2Fkcy5jbGVhcigpO1xuICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuY2xlYXIoKTsgLy8gRmx1c2ggdW5ibG9ja2VkIHN0eWxlc2hlZXRzIGJ5IHByZWNlZGVuY2VcblxuICByZW5kZXJTdGF0ZS5zdHlsZXMuZm9yRWFjaChmbHVzaFN0eWxlc0luUHJlYW1ibGUsIGRlc3RpbmF0aW9uKTtcbiAgdmFyIGltcG9ydE1hcENodW5rcyA9IHJlbmRlclN0YXRlLmltcG9ydE1hcENodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaW1wb3J0TWFwQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgaW1wb3J0TWFwQ2h1bmtzW2ldKTtcbiAgfVxuXG4gIGltcG9ydE1hcENodW5rcy5sZW5ndGggPSAwO1xuICByZW5kZXJTdGF0ZS5ib290c3RyYXBTY3JpcHRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZW5kZXJTdGF0ZS5zY3JpcHRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZW5kZXJTdGF0ZS5zY3JpcHRzLmNsZWFyKCk7XG4gIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmNsZWFyKCk7IC8vIFdyaXRlIGVtYmVkZGluZyBwcmVsb2FkQ2h1bmtzXG5cbiAgdmFyIHByZWxvYWRDaHVua3MgPSByZW5kZXJTdGF0ZS5wcmVsb2FkQ2h1bmtzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwcmVsb2FkQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcHJlbG9hZENodW5rc1tpXSk7XG4gIH1cblxuICBwcmVsb2FkQ2h1bmtzLmxlbmd0aCA9IDA7IC8vIFdyaXRlIGVtYmVkZGluZyBob2lzdGFibGVDaHVua3NcblxuICB2YXIgaG9pc3RhYmxlQ2h1bmtzID0gcmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob2lzdGFibGVDaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBob2lzdGFibGVDaHVua3NbaV0pO1xuICB9XG5cbiAgaG9pc3RhYmxlQ2h1bmtzLmxlbmd0aCA9IDA7IC8vIEZsdXNoIGNsb3NpbmcgaGVhZCBpZiBuZWNlc3NhcnlcblxuICBpZiAoaHRtbENodW5rcyAmJiBoZWFkQ2h1bmtzID09PSBudWxsKSB7XG4gICAgLy8gV2UgaGF2ZSBhbiA8aHRtbD4gcmVuZGVyZWQgYnV0IG5vIDxoZWFkPiByZW5kZXJlZC4gV2UgaG93ZXZlciBpbnNlcnRlZFxuICAgIC8vIGEgPGhlYWQ+IHVwIGFib3ZlIHNvIHdlIG5lZWQgdG8gZW1pdCB0aGUgPC9oZWFkPiBub3cuIFRoaXMgaXMgc2FmZSBiZWNhdXNlXG4gICAgLy8gaWYgdGhlIG1haW4gY29udGVudCBjb250YWluZWQgdGhlIDwvaGVhZD4gaXQgd291bGQgYWxzbyBoYXZlIHByb3ZpZGVkIGFcbiAgICAvLyA8aGVhZD4uIFRoaXMgbWVhbnMgdGhhdCBhbGwgdGhlIGNvbnRlbnQgaW5zaWRlIDxodG1sPiBpcyBlaXRoZXIgPGJvZHk+IG9yXG4gICAgLy8gaW52YWxpZCBIVE1MXG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZW5kQ2h1bmtGb3JUYWcoJ2hlYWQnKSk7XG4gIH1cbn0gLy8gV2UgZG9uJ3QgYm90aGVyIHJlcG9ydGluZyBiYWNrcHJlc3N1cmUgYXQgdGhlIG1vbWVudCBiZWNhdXNlIHdlIGV4cGVjdCB0b1xuLy8gZmx1c2ggdGhlIGVudGlyZSBwcmVhbWJsZSBpbiBhIHNpbmdsZSBwYXNzLiBUaGlzIHByb2JhYmx5IHNob3VsZCBiZSBtb2RpZmllZFxuLy8gaW4gdGhlIGZ1dHVyZSB0byBiZSBiYWNrcHJlc3N1cmUgc2Vuc2l0aXZlIGJ1dCB0aGF0IHJlcXVpcmVzIGEgbGFyZ2VyIHJlZmFjdG9yXG4vLyBvZiB0aGUgZmx1c2hpbmcgY29kZSBpbiBGaXp6LlxuXG5mdW5jdGlvbiB3cml0ZUhvaXN0YWJsZXMoZGVzdGluYXRpb24sIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSkge1xuICB2YXIgaSA9IDA7IC8vIEVtaXQgaGlnaCBwcmlvcml0eSBIb2lzdGFibGVzXG4gIC8vIFdlIG9taXQgY2hhcnNldENodW5rcyBiZWNhdXNlIHdlIGhhdmUgYWxyZWFkeSBzZW50IHRoZSBzaGVsbCBhbmQgaWYgaXQgd2Fzbid0XG4gIC8vIGFscmVhZHkgc2VudCBpdCBpcyB0b28gbGF0ZSBub3cuXG5cbiAgcmVuZGVyU3RhdGUucHJlY29ubmVjdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmNsZWFyKCk7XG4gIHZhciBwcmVjb25uZWN0Q2h1bmtzID0gcmVuZGVyU3RhdGUucHJlY29ubmVjdENodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgcHJlY29ubmVjdENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHByZWNvbm5lY3RDaHVua3NbaV0pO1xuICB9XG5cbiAgcHJlY29ubmVjdENodW5rcy5sZW5ndGggPSAwO1xuICByZW5kZXJTdGF0ZS5mb250UHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJlbmRlclN0YXRlLmZvbnRQcmVsb2Fkcy5jbGVhcigpO1xuICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuY2xlYXIoKTsgLy8gUHJlbG9hZCBhbnkgc3R5bGVzaGVldHMuIHRoZXNlIHdpbGwgZW1pdCBpbiBhIHJlbmRlciBpbnN0cnVjdGlvbiB0aGF0IGZvbGxvd3MgdGhpc1xuICAvLyBidXQgd2Ugd2FudCB0byBraWNrIG9mZiBwcmVsb2FkaW5nIGFzIHNvb24gYXMgcG9zc2libGVcblxuICByZW5kZXJTdGF0ZS5zdHlsZXMuZm9yRWFjaChwcmVsb2FkTGF0ZVN0eWxlcywgZGVzdGluYXRpb24pOyAvLyBXZSBvbmx5IGhvaXN0IGltcG9ydG1hcHMgdGhhdCBhcmUgY29uZmlndXJlZCB0aHJvdWdoIGNyZWF0ZVJlc3BvbnNlIGFuZCB0aGF0IHdpbGxcbiAgLy8gYWx3YXlzIGZsdXNoIGluIHRoZSBwcmVhbWJsZS4gR2VuZXJhbGx5IHdlIGRvbid0IGV4cGVjdCBwZW9wbGUgdG8gcmVuZGVyIHRoZW0gYXNcbiAgLy8gdGFncyB3aGVuIHVzaW5nIFJlYWN0IGJ1dCBpZiB5b3UgZG8gdGhleSBhcmUgZ29pbmcgdG8gYmUgdHJlYXRlZCBsaWtlIHJlZ3VsYXIgaW5saW5lXG4gIC8vIHNjcmlwdHMgYW5kIGZsdXNoIGFmdGVyIG90aGVyIGhvaXN0YWJsZXMgd2hpY2ggaXMgcHJvYmxlbWF0aWNcbiAgLy8gYm9vdHN0cmFwIHNjcmlwdHMgc2hvdWxkIGZsdXNoIGFib3ZlIHNjcmlwdCBwcmlvcml0eSBidXQgdGhlc2UgY2FuIG9ubHkgZmx1c2ggaW4gdGhlIHByZWFtYmxlXG4gIC8vIHNvIHdlIGVsaWRlIHRoZSBjb2RlIGhlcmUgZm9yIHBlcmZvcm1hbmNlXG5cbiAgcmVuZGVyU3RhdGUuc2NyaXB0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmVuZGVyU3RhdGUuc2NyaXB0cy5jbGVhcigpO1xuICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5jbGVhcigpOyAvLyBXcml0ZSBlbWJlZGRpbmcgcHJlbG9hZENodW5rc1xuXG4gIHZhciBwcmVsb2FkQ2h1bmtzID0gcmVuZGVyU3RhdGUucHJlbG9hZENodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgcHJlbG9hZENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHByZWxvYWRDaHVua3NbaV0pO1xuICB9XG5cbiAgcHJlbG9hZENodW5rcy5sZW5ndGggPSAwOyAvLyBXcml0ZSBlbWJlZGRpbmcgaG9pc3RhYmxlQ2h1bmtzXG5cbiAgdmFyIGhvaXN0YWJsZUNodW5rcyA9IHJlbmRlclN0YXRlLmhvaXN0YWJsZUNodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9pc3RhYmxlQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgaG9pc3RhYmxlQ2h1bmtzW2ldKTtcbiAgfVxuXG4gIGhvaXN0YWJsZUNodW5rcy5sZW5ndGggPSAwO1xufVxuZnVuY3Rpb24gd3JpdGVQb3N0YW1ibGUoZGVzdGluYXRpb24sIHJlc3VtYWJsZVN0YXRlKSB7XG4gIGlmIChyZXN1bWFibGVTdGF0ZS5oYXNCb2R5KSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZW5kQ2h1bmtGb3JUYWcoJ2JvZHknKSk7XG4gIH1cblxuICBpZiAocmVzdW1hYmxlU3RhdGUuaGFzSHRtbCkge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGVuZENodW5rRm9yVGFnKCdodG1sJykpO1xuICB9XG59XG52YXIgYXJyYXlGaXJzdE9wZW5CcmFja2V0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdbJyk7XG52YXIgYXJyYXlTdWJzZXF1ZW50T3BlbkJyYWNrZXQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyxbJyk7XG52YXIgYXJyYXlJbnRlcnN0aXRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJywnKTtcbnZhciBhcnJheUNsb3NlQnJhY2tldCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXScpOyAvLyBUaGlzIGZ1bmN0aW9uIHdyaXRlcyBhIDJEIGFycmF5IG9mIHN0cmluZ3MgdG8gYmUgZW1iZWRkZWQgaW4gamF2YXNjcmlwdC5cbi8vIEUuZy5cbi8vICBbW1wiSlNfZXNjYXBlZF9zdHJpbmcxXCIsIFwiSlNfZXNjYXBlZF9zdHJpbmcyXCJdXVxuXG5mdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmNpZXNJbkpTKGRlc3RpbmF0aW9uLCBib3VuZGFyeVJlc291cmNlcykge1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUZpcnN0T3BlbkJyYWNrZXQpO1xuICB2YXIgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheUZpcnN0T3BlbkJyYWNrZXQ7XG4gIGJvdW5kYXJ5UmVzb3VyY2VzLnN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHJlc291cmNlKSB7XG4gICAgaWYgKHJlc291cmNlLnN0YXRlID09PSBQUkVBTUJMRSkgOyBlbHNlIGlmIChyZXNvdXJjZS5zdGF0ZSA9PT0gTEFURSkge1xuICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIGVtaXQgdGhlIGhyZWYgYmVjYXVzZSB0aGlzIHJlc291cmNlIGZsdXNoZWQgaW4gYW4gZWFybGllclxuICAgICAgLy8gYm91bmRhcnkgYWxyZWFkeSB3aGljaCBlbmNvZGVkIHRoZSBhdHRyaWJ1dGVzIG5lY2Vzc2FyeSB0byBjb25zdHJ1Y3RcbiAgICAgIC8vIHRoZSByZXNvdXJjZSBpbnN0YW5jZSBvbiB0aGUgY2xpZW50LlxuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmspO1xuICAgICAgd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUhyZWZPbmx5SW5KUyhkZXN0aW5hdGlvbiwgcmVzb3VyY2UucHJvcHMuaHJlZik7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG4gICAgICBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGVtaXQgdGhlIHdob2xlIHJlc291cmNlIGZvciBpbnNlcnRpb24gb24gdGhlIGNsaWVudFxuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmspO1xuICAgICAgd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUluSlMoZGVzdGluYXRpb24sIHJlc291cmNlLnByb3BzLmhyZWYsIHJlc291cmNlLnByb3BzWydkYXRhLXByZWNlZGVuY2UnXSwgcmVzb3VyY2UucHJvcHMpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlDbG9zZUJyYWNrZXQpO1xuICAgICAgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldDtcbiAgICAgIHJlc291cmNlLnN0YXRlID0gTEFURTtcbiAgICB9XG4gIH0pO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG59XG4vKiBIZWxwZXIgZnVuY3Rpb25zICovXG5cblxuZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUhyZWZPbmx5SW5KUyhkZXN0aW5hdGlvbiwgaHJlZikge1xuICAvLyBXZSBzaG91bGQgYWN0dWFsbHkgZW5mb3JjZSB0aGlzIGVhcmxpZXIgd2hlbiB0aGUgcmVzb3VyY2UgaXMgY3JlYXRlZCBidXQgZm9yXG4gIC8vIG5vdyB3ZSBtYWtlIHN1cmUgd2UgYXJlIGFjdHVhbGx5IGRlYWxpbmcgd2l0aCBhIHN0cmluZyBoZXJlLlxuICB7XG4gICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihocmVmLCAnaHJlZicpO1xuICB9XG5cbiAgdmFyIGNvZXJjZWRIcmVmID0gJycgKyBocmVmO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGNvZXJjZWRIcmVmKSkpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SW5KUyhkZXN0aW5hdGlvbiwgaHJlZiwgcHJlY2VkZW5jZSwgcHJvcHMpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHZhciBjb2VyY2VkSHJlZiA9IHNhbml0aXplVVJMKCcnICsgaHJlZik7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoY29lcmNlZEhyZWYpKSk7XG5cbiAge1xuICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24ocHJlY2VkZW5jZSwgJ3ByZWNlZGVuY2UnKTtcbiAgfVxuXG4gIHZhciBjb2VyY2VkUHJlY2VkZW5jZSA9ICcnICsgcHJlY2VkZW5jZTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlJbnRlcnN0aXRpYWwpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGNvZXJjZWRQcmVjZWRlbmNlKSkpO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnaHJlZic6XG4gICAgICAgIGNhc2UgJ3JlbCc6XG4gICAgICAgIGNhc2UgJ3ByZWNlZGVuY2UnOlxuICAgICAgICBjYXNlICdkYXRhLXByZWNlZGVuY2UnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpbmsnICsgXCIgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIiArICd1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluSlMoZGVzdGluYXRpb24sIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluSlMoZGVzdGluYXRpb24sIG5hbWUsIHZhbHVlKSAvLyBub3QgbnVsbCBvciB1bmRlZmluZWRcbntcbiAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBhdHRyaWJ1dGVWYWx1ZTtcblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgLy8gUmVzZXJ2ZWQgbmFtZXNcbiAgICBjYXNlICdpbm5lckhUTUwnOlxuICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICBjYXNlICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnOlxuICAgIGNhc2UgJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc6XG4gICAgY2FzZSAnc3R5bGUnOlxuICAgICAgLy8gSWdub3JlZFxuICAgICAgcmV0dXJuO1xuICAgIC8vIEF0dHJpYnV0ZSByZW5hbWVzXG5cbiAgICBjYXNlICdjbGFzc05hbWUnOlxuICAgICAge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lID0gJ2NsYXNzJztcblxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIEJvb2xlYW5zXG5cbiAgICBjYXNlICdoaWRkZW4nOlxuICAgICAge1xuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy8gU2FudGl6ZWQgVVJMc1xuXG4gICAgY2FzZSAnc3JjJzpcbiAgICBjYXNlICdocmVmJzpcbiAgICAgIHtcbiAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVVSTCh2YWx1ZSk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGlmICggLy8gdW5yZWNvZ25pemVkIGV2ZW50IGhhbmRsZXJzIGFyZSBub3QgU1NSJ2QgYW5kIHdlIChhcHBhcmVudGx5KVxuICAgICAgICAvLyB1c2Ugb24qIGFzIGh1ZXJpc3RpYyBmb3IgdGhlc2UgaGFuZGxlciBwcm9wc1xuICAgICAgICBuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIH1cbiAgfVxuXG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5SW50ZXJzdGl0aWFsKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhhdHRyaWJ1dGVOYW1lKSkpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUludGVyc3RpdGlhbCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoYXR0cmlidXRlVmFsdWUpKSk7XG59IC8vIFRoaXMgZnVuY3Rpb24gd3JpdGVzIGEgMkQgYXJyYXkgb2Ygc3RyaW5ncyB0byBiZSBlbWJlZGRlZCBpbiBhbiBhdHRyaWJ1dGVcbi8vIHZhbHVlIGFuZCByZWFkIHdpdGggSlNPTi5wYXJzZSBpbiBSZWFjdERPTVNlcnZlckV4dGVybmFsUnVudGltZS5qc1xuLy8gRS5nLlxuLy8gIFtbJnF1b3Q7SlNPTl9lc2NhcGVkX3N0cmluZzEmcXVvdDssICZxdW90O0pTT05fZXNjYXBlZF9zdHJpbmcyJnF1b3Q7XV1cblxuXG5mdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmNpZXNJbkF0dHIoZGVzdGluYXRpb24sIGJvdW5kYXJ5UmVzb3VyY2VzKSB7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5Rmlyc3RPcGVuQnJhY2tldCk7XG4gIHZhciBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5Rmlyc3RPcGVuQnJhY2tldDtcbiAgYm91bmRhcnlSZXNvdXJjZXMuc3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAocmVzb3VyY2UpIHtcbiAgICBpZiAocmVzb3VyY2Uuc3RhdGUgPT09IFBSRUFNQkxFKSA7IGVsc2UgaWYgKHJlc291cmNlLnN0YXRlID09PSBMQVRFKSB7XG4gICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gZW1pdCB0aGUgaHJlZiBiZWNhdXNlIHRoaXMgcmVzb3VyY2UgZmx1c2hlZCBpbiBhbiBlYXJsaWVyXG4gICAgICAvLyBib3VuZGFyeSBhbHJlYWR5IHdoaWNoIGVuY29kZWQgdGhlIGF0dHJpYnV0ZXMgbmVjZXNzYXJ5IHRvIGNvbnN0cnVjdFxuICAgICAgLy8gdGhlIHJlc291cmNlIGluc3RhbmNlIG9uIHRoZSBjbGllbnQuXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayk7XG4gICAgICB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SHJlZk9ubHlJbkF0dHIoZGVzdGluYXRpb24sIHJlc291cmNlLnByb3BzLmhyZWYpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlDbG9zZUJyYWNrZXQpO1xuICAgICAgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgbmVlZCB0byBlbWl0IHRoZSB3aG9sZSByZXNvdXJjZSBmb3IgaW5zZXJ0aW9uIG9uIHRoZSBjbGllbnRcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIG5leHRBcnJheU9wZW5CcmFja0NodW5rKTtcbiAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lJbkF0dHIoZGVzdGluYXRpb24sIHJlc291cmNlLnByb3BzLmhyZWYsIHJlc291cmNlLnByb3BzWydkYXRhLXByZWNlZGVuY2UnXSwgcmVzb3VyY2UucHJvcHMpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlDbG9zZUJyYWNrZXQpO1xuICAgICAgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldDtcbiAgICAgIHJlc291cmNlLnN0YXRlID0gTEFURTtcbiAgICB9XG4gIH0pO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG59XG4vKiBIZWxwZXIgZnVuY3Rpb25zICovXG5cblxuZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUhyZWZPbmx5SW5BdHRyKGRlc3RpbmF0aW9uLCBocmVmKSB7XG4gIC8vIFdlIHNob3VsZCBhY3R1YWxseSBlbmZvcmNlIHRoaXMgZWFybGllciB3aGVuIHRoZSByZXNvdXJjZSBpcyBjcmVhdGVkIGJ1dCBmb3JcbiAgLy8gbm93IHdlIG1ha2Ugc3VyZSB3ZSBhcmUgYWN0dWFsbHkgZGVhbGluZyB3aXRoIGEgc3RyaW5nIGhlcmUuXG4gIHtcbiAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKGhyZWYsICdocmVmJyk7XG4gIH1cblxuICB2YXIgY29lcmNlZEhyZWYgPSAnJyArIGhyZWY7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoSlNPTi5zdHJpbmdpZnkoY29lcmNlZEhyZWYpKSkpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SW5BdHRyKGRlc3RpbmF0aW9uLCBocmVmLCBwcmVjZWRlbmNlLCBwcm9wcykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgdmFyIGNvZXJjZWRIcmVmID0gc2FuaXRpemVVUkwoJycgKyBocmVmKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihKU09OLnN0cmluZ2lmeShjb2VyY2VkSHJlZikpKSk7XG5cbiAge1xuICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24ocHJlY2VkZW5jZSwgJ3ByZWNlZGVuY2UnKTtcbiAgfVxuXG4gIHZhciBjb2VyY2VkUHJlY2VkZW5jZSA9ICcnICsgcHJlY2VkZW5jZTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlJbnRlcnN0aXRpYWwpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKEpTT04uc3RyaW5naWZ5KGNvZXJjZWRQcmVjZWRlbmNlKSkpKTtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2hyZWYnOlxuICAgICAgICBjYXNlICdyZWwnOlxuICAgICAgICBjYXNlICdwcmVjZWRlbmNlJzpcbiAgICAgICAgY2FzZSAnZGF0YS1wcmVjZWRlbmNlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW5rJyArIFwiIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgXCIgKyAndXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB3cml0ZVN0eWxlUmVzb3VyY2VBdHRyaWJ1dGVJbkF0dHIoZGVzdGluYXRpb24sIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluQXR0cihkZXN0aW5hdGlvbiwgbmFtZSwgdmFsdWUpIC8vIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxue1xuICB2YXIgYXR0cmlidXRlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGF0dHJpYnV0ZVZhbHVlO1xuXG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAvLyBSZXNlcnZlZCBuYW1lc1xuICAgIGNhc2UgJ2lubmVySFRNTCc6XG4gICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgIGNhc2UgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc6XG4gICAgY2FzZSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJzpcbiAgICBjYXNlICdzdHlsZSc6XG4gICAgICAvLyBJZ25vcmVkXG4gICAgICByZXR1cm47XG4gICAgLy8gQXR0cmlidXRlIHJlbmFtZXNcblxuICAgIGNhc2UgJ2NsYXNzTmFtZSc6XG4gICAgICB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWUgPSAnY2xhc3MnO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy8gQm9vbGVhbnNcblxuICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgICB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAvLyBTYW50aXplZCBVUkxzXG5cbiAgICBjYXNlICdzcmMnOlxuICAgIGNhc2UgJ2hyZWYnOlxuICAgICAge1xuICAgICAgICB2YWx1ZSA9IHNhbml0aXplVVJMKHZhbHVlKTtcblxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCAvLyB1bnJlY29nbml6ZWQgZXZlbnQgaGFuZGxlcnMgYXJlIG5vdCBTU1InZCBhbmQgd2UgKGFwcGFyZW50bHkpXG4gICAgICAgIC8vIHVzZSBvbiogYXMgaHVlcmlzdGljIGZvciB0aGVzZSBoYW5kbGVyIHByb3BzXG4gICAgICAgIG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICB9XG5cbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlJbnRlcnN0aXRpYWwpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKEpTT04uc3RyaW5naWZ5KGF0dHJpYnV0ZU5hbWUpKSkpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUludGVyc3RpdGlhbCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoSlNPTi5zdHJpbmdpZnkoYXR0cmlidXRlVmFsdWUpKSkpO1xufVxuLyoqXG4gKiBSZXNvdXJjZXNcbiAqL1xuXG5cbnZhciBQRU5ESU5HJDEgPSAwO1xudmFyIFBSRUxPQURFRCA9IDE7XG52YXIgUFJFQU1CTEUgPSAyO1xudmFyIExBVEUgPSAzO1xuZnVuY3Rpb24gY3JlYXRlQm91bmRhcnlSZXNvdXJjZXMoKSB7XG4gIHJldHVybiB7XG4gICAgc3R5bGVzOiBuZXcgU2V0KCksXG4gICAgc3R5bGVzaGVldHM6IG5ldyBTZXQoKVxuICB9O1xufVxuZnVuY3Rpb24gc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVuZGVyU3RhdGUsIGJvdW5kYXJ5UmVzb3VyY2VzKSB7XG4gIHJlbmRlclN0YXRlLmJvdW5kYXJ5UmVzb3VyY2VzID0gYm91bmRhcnlSZXNvdXJjZXM7XG59XG5cbmZ1bmN0aW9uIGdldFJlc291cmNlS2V5KGhyZWYpIHtcbiAgcmV0dXJuIGhyZWY7XG59XG5cbmZ1bmN0aW9uIGdldEltYWdlUmVzb3VyY2VLZXkoaHJlZiwgaW1hZ2VTcmNTZXQsIGltYWdlU2l6ZXMpIHtcbiAgaWYgKGltYWdlU3JjU2V0KSB7XG4gICAgcmV0dXJuIGltYWdlU3JjU2V0ICsgJ1xcbicgKyAoaW1hZ2VTaXplcyB8fCAnJyk7XG4gIH1cblxuICByZXR1cm4gaHJlZjtcbn1cblxuZnVuY3Rpb24gcHJlZmV0Y2hETlMoaHJlZikge1xuXG4gIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcblxuICBpZiAoIXJlcXVlc3QpIHtcbiAgICAvLyBJbiBhc3luYyBjb250ZXh0cyB3ZSBjYW4gc29tZXRpbWVzIHJlc29sdmUgcmVzb3VyY2VzIGZyb20gQXN5bmNMb2NhbFN0b3JhZ2UuIElmIHdlIGNhbid0IHdlIGNhbiBhbHNvXG4gICAgLy8gcG9zc2libHkgZ2V0IHRoZW0gZnJvbSB0aGUgc3RhY2sgaWYgd2UgYXJlIG5vdCBpbiBhbiBhc3luYyBjb250ZXh0LiBTaW5jZSB3ZSB3ZXJlIG5vdCBhYmxlIHRvIHJlc29sdmVcbiAgICAvLyB0aGUgcmVzb3VyY2VzIGZvciB0aGlzIGNhbGwgaW4gZWl0aGVyIGNhc2Ugd2Ugb3B0IHRvIGRvIG5vdGhpbmcuIFdlIGNhbiBjb25zaWRlciBtYWtpbmcgdGhpcyBhIHdhcm5pbmdcbiAgICAvLyBidXQgdGhlcmUgbWF5IGJlIHRpbWVzIHdoZXJlIGNhbGxpbmcgYSBmdW5jdGlvbiBvdXRzaWRlIG9mIHJlbmRlciBpcyBpbnRlbnRpb25hbCAoaS5lLiB0byB3YXJtIHVwIGRhdGFcbiAgICAvLyBmZXRjaGluZykgYW5kIHdlIGRvbid0IHdhbnQgdG8gd2FybiBpbiB0aG9zZSBjYXNlcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVzdW1hYmxlU3RhdGUgPSBnZXRSZXN1bWFibGVTdGF0ZShyZXF1ZXN0KTtcbiAgdmFyIHJlbmRlclN0YXRlID0gZ2V0UmVuZGVyU3RhdGUocmVxdWVzdCk7XG5cbiAgaWYgKHR5cGVvZiBocmVmID09PSAnc3RyaW5nJyAmJiBocmVmKSB7XG4gICAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KGhyZWYpO1xuXG4gICAgaWYgKCFyZXN1bWFibGVTdGF0ZS5kbnNSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmVzdW1hYmxlU3RhdGUuZG5zUmVzb3VyY2VzW2tleV0gPSBFWElTVFM7XG4gICAgICB2YXIgaGVhZGVycyA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICB2YXIgaGVhZGVyO1xuXG4gICAgICBpZiAoaGVhZGVycyAmJiBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ID4gMCAmJiAoIC8vIENvbXB1dGUgdGhlIGhlYWRlciBzaW5jZSB3ZSBtaWdodCBiZSBhYmxlIHRvIGZpdCBpdCBpbiB0aGUgbWF4IGxlbmd0aFxuICAgICAgaGVhZGVyID0gZ2V0UHJlZmV0Y2hETlNBc0hlYWRlcihocmVmKSwgLy8gV2UgYWx3YXlzIGNvbnN1bWUgdGhlIGhlYWRlciBsZW5ndGggc2luY2Ugb25jZSB3ZSBmaW5kIG9uZSBoZWFkZXIgdGhhdCBkb2Vzbid0IGZpdFxuICAgICAgLy8gd2UgYXNzdW1lIGFsbCB0aGUgcmVzdCB3b24ndCBhcyB3ZWxsLiBUaGlzIGlzIHRvIGF2b2lkIGdldHRpbmcgaW50byBhIHNpdHVhdGlvblxuICAgICAgLy8gd2hlcmUgd2UgaGF2ZSBhIHZlcnkgc21hbGwgcmVtYWluaW5nIGNhcGFjaXR5IGJ1dCBubyBoZWFkZXJzIHdpbGwgZXZlciBmaXQgYW5kIHdlIGVuZFxuICAgICAgLy8gdXAgY29uc3RhbnRseSB0cnlpbmcgdG8gc2VlIGlmIHRoZSBuZXh0IHJlc291cmNlIG1pZ2h0IG1ha2UgaXQuIEluIHRoZSBmdXR1cmUgd2UgY2FuXG4gICAgICAvLyBtYWtlIHRoaXMgYmVoYXZpb3IgZGlmZmVyZW50IGJldHdlZW4gcmVuZGVyIGFuZCBwcmVyZW5kZXIgc2luY2UgaW4gdGhlIGxhdHRlciBjYXNlXG4gICAgICAvLyB3ZSBhcmUgbGVzcyBzZW5zaXRpdmUgdG8gdGhlIGN1cnJlbnQgcmVxdWVzdHMgcnVudGltZSBwZXIgYW5kIG1vcmUgc2Vuc2l0aXZlIHRvIG1heGltaXppbmdcbiAgICAgIC8vIGhlYWRlcnMuXG4gICAgICAoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoKSA+PSAyKSkge1xuICAgICAgICAvLyBTdG9yZSB0aGlzIGFzIHJlc2V0dGFibGUgaW4gY2FzZSB3ZSBhcmUgcHJlcmVuZGVyaW5nIGFuZCBwb3N0cG9uZSBpbiB0aGUgU2hlbGxcbiAgICAgICAgcmVuZGVyU3RhdGUucmVzZXRzLmRuc1trZXldID0gRVhJU1RTO1xuXG4gICAgICAgIGlmIChoZWFkZXJzLnByZWNvbm5lY3RzKSB7XG4gICAgICAgICAgaGVhZGVycy5wcmVjb25uZWN0cyArPSAnLCAnO1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXTogd2UgYXNzaWduIGhlYWRlciBkdXJpbmcgdGhlIGlmIGNvbmRpdGlvblxuXG5cbiAgICAgICAgaGVhZGVycy5wcmVjb25uZWN0cyArPSBoZWFkZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFbmNvZGUgYXMgZWxlbWVudFxuICAgICAgICB2YXIgcmVzb3VyY2UgPSBbXTtcbiAgICAgICAgcHVzaExpbmtJbXBsKHJlc291cmNlLCB7XG4gICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICByZWw6ICdkbnMtcHJlZmV0Y2gnXG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5hZGQocmVzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZsdXNoUmVzb3VyY2VzKHJlcXVlc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZWNvbm5lY3QoaHJlZiwgY3Jvc3NPcmlnaW4pIHtcblxuICB2YXIgcmVxdWVzdCA9IHJlc29sdmVSZXF1ZXN0KCk7XG5cbiAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgLy8gSW4gYXN5bmMgY29udGV4dHMgd2UgY2FuIHNvbWV0aW1lcyByZXNvbHZlIHJlc291cmNlcyBmcm9tIEFzeW5jTG9jYWxTdG9yYWdlLiBJZiB3ZSBjYW4ndCB3ZSBjYW4gYWxzb1xuICAgIC8vIHBvc3NpYmx5IGdldCB0aGVtIGZyb20gdGhlIHN0YWNrIGlmIHdlIGFyZSBub3QgaW4gYW4gYXN5bmMgY29udGV4dC4gU2luY2Ugd2Ugd2VyZSBub3QgYWJsZSB0byByZXNvbHZlXG4gICAgLy8gdGhlIHJlc291cmNlcyBmb3IgdGhpcyBjYWxsIGluIGVpdGhlciBjYXNlIHdlIG9wdCB0byBkbyBub3RoaW5nLiBXZSBjYW4gY29uc2lkZXIgbWFraW5nIHRoaXMgYSB3YXJuaW5nXG4gICAgLy8gYnV0IHRoZXJlIG1heSBiZSB0aW1lcyB3aGVyZSBjYWxsaW5nIGEgZnVuY3Rpb24gb3V0c2lkZSBvZiByZW5kZXIgaXMgaW50ZW50aW9uYWwgKGkuZS4gdG8gd2FybSB1cCBkYXRhXG4gICAgLy8gZmV0Y2hpbmcpIGFuZCB3ZSBkb24ndCB3YW50IHRvIHdhcm4gaW4gdGhvc2UgY2FzZXMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlc3VtYWJsZVN0YXRlID0gZ2V0UmVzdW1hYmxlU3RhdGUocmVxdWVzdCk7XG4gIHZhciByZW5kZXJTdGF0ZSA9IGdldFJlbmRlclN0YXRlKHJlcXVlc3QpO1xuXG4gIGlmICh0eXBlb2YgaHJlZiA9PT0gJ3N0cmluZycgJiYgaHJlZikge1xuICAgIHZhciBidWNrZXQgPSBjcm9zc09yaWdpbiA9PT0gJ3VzZS1jcmVkZW50aWFscycgPyAnY3JlZGVudGlhbHMnIDogdHlwZW9mIGNyb3NzT3JpZ2luID09PSAnc3RyaW5nJyA/ICdhbm9ueW1vdXMnIDogJ2RlZmF1bHQnO1xuICAgIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleShocmVmKTtcblxuICAgIGlmICghcmVzdW1hYmxlU3RhdGUuY29ubmVjdFJlc291cmNlc1tidWNrZXRdLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJlc3VtYWJsZVN0YXRlLmNvbm5lY3RSZXNvdXJjZXNbYnVja2V0XVtrZXldID0gRVhJU1RTO1xuICAgICAgdmFyIGhlYWRlcnMgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgdmFyIGhlYWRlcjtcblxuICAgICAgaWYgKGhlYWRlcnMgJiYgaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSA+IDAgJiYgKCAvLyBDb21wdXRlIHRoZSBoZWFkZXIgc2luY2Ugd2UgbWlnaHQgYmUgYWJsZSB0byBmaXQgaXQgaW4gdGhlIG1heCBsZW5ndGhcbiAgICAgIGhlYWRlciA9IGdldFByZWNvbm5lY3RBc0hlYWRlcihocmVmLCBjcm9zc09yaWdpbiksIC8vIFdlIGFsd2F5cyBjb25zdW1lIHRoZSBoZWFkZXIgbGVuZ3RoIHNpbmNlIG9uY2Ugd2UgZmluZCBvbmUgaGVhZGVyIHRoYXQgZG9lc24ndCBmaXRcbiAgICAgIC8vIHdlIGFzc3VtZSBhbGwgdGhlIHJlc3Qgd29uJ3QgYXMgd2VsbC4gVGhpcyBpcyB0byBhdm9pZCBnZXR0aW5nIGludG8gYSBzaXR1YXRpb25cbiAgICAgIC8vIHdoZXJlIHdlIGhhdmUgYSB2ZXJ5IHNtYWxsIHJlbWFpbmluZyBjYXBhY2l0eSBidXQgbm8gaGVhZGVycyB3aWxsIGV2ZXIgZml0IGFuZCB3ZSBlbmRcbiAgICAgIC8vIHVwIGNvbnN0YW50bHkgdHJ5aW5nIHRvIHNlZSBpZiB0aGUgbmV4dCByZXNvdXJjZSBtaWdodCBtYWtlIGl0LiBJbiB0aGUgZnV0dXJlIHdlIGNhblxuICAgICAgLy8gbWFrZSB0aGlzIGJlaGF2aW9yIGRpZmZlcmVudCBiZXR3ZWVuIHJlbmRlciBhbmQgcHJlcmVuZGVyIHNpbmNlIGluIHRoZSBsYXR0ZXIgY2FzZVxuICAgICAgLy8gd2UgYXJlIGxlc3Mgc2Vuc2l0aXZlIHRvIHRoZSBjdXJyZW50IHJlcXVlc3RzIHJ1bnRpbWUgcGVyIGFuZCBtb3JlIHNlbnNpdGl2ZSB0byBtYXhpbWl6aW5nXG4gICAgICAvLyBoZWFkZXJzLlxuICAgICAgKGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgLT0gaGVhZGVyLmxlbmd0aCkgPj0gMikpIHtcbiAgICAgICAgLy8gU3RvcmUgdGhpcyBpbiByZXNldHRhYmxlU3RhdGUgaW4gY2FzZSB3ZSBhcmUgcHJlcmVuZGluZyBhbmQgcG9zdHBvbmUgaW4gdGhlIFNoZWxsXG4gICAgICAgIHJlbmRlclN0YXRlLnJlc2V0cy5jb25uZWN0W2J1Y2tldF1ba2V5XSA9IEVYSVNUUztcblxuICAgICAgICBpZiAoaGVhZGVycy5wcmVjb25uZWN0cykge1xuICAgICAgICAgIGhlYWRlcnMucHJlY29ubmVjdHMgKz0gJywgJztcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl06IHdlIGFzc2lnbiBoZWFkZXIgZHVyaW5nIHRoZSBpZiBjb25kaXRpb25cblxuXG4gICAgICAgIGhlYWRlcnMucHJlY29ubmVjdHMgKz0gaGVhZGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc291cmNlID0gW107XG4gICAgICAgIHB1c2hMaW5rSW1wbChyZXNvdXJjZSwge1xuICAgICAgICAgIHJlbDogJ3ByZWNvbm5lY3QnLFxuICAgICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luXG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5hZGQocmVzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZsdXNoUmVzb3VyY2VzKHJlcXVlc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZWxvYWQoaHJlZiwgYXMsIG9wdGlvbnMpIHtcblxuICB2YXIgcmVxdWVzdCA9IHJlc29sdmVSZXF1ZXN0KCk7XG5cbiAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgLy8gSW4gYXN5bmMgY29udGV4dHMgd2UgY2FuIHNvbWV0aW1lcyByZXNvbHZlIHJlc291cmNlcyBmcm9tIEFzeW5jTG9jYWxTdG9yYWdlLiBJZiB3ZSBjYW4ndCB3ZSBjYW4gYWxzb1xuICAgIC8vIHBvc3NpYmx5IGdldCB0aGVtIGZyb20gdGhlIHN0YWNrIGlmIHdlIGFyZSBub3QgaW4gYW4gYXN5bmMgY29udGV4dC4gU2luY2Ugd2Ugd2VyZSBub3QgYWJsZSB0byByZXNvbHZlXG4gICAgLy8gdGhlIHJlc291cmNlcyBmb3IgdGhpcyBjYWxsIGluIGVpdGhlciBjYXNlIHdlIG9wdCB0byBkbyBub3RoaW5nLiBXZSBjYW4gY29uc2lkZXIgbWFraW5nIHRoaXMgYSB3YXJuaW5nXG4gICAgLy8gYnV0IHRoZXJlIG1heSBiZSB0aW1lcyB3aGVyZSBjYWxsaW5nIGEgZnVuY3Rpb24gb3V0c2lkZSBvZiByZW5kZXIgaXMgaW50ZW50aW9uYWwgKGkuZS4gdG8gd2FybSB1cCBkYXRhXG4gICAgLy8gZmV0Y2hpbmcpIGFuZCB3ZSBkb24ndCB3YW50IHRvIHdhcm4gaW4gdGhvc2UgY2FzZXMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlc3VtYWJsZVN0YXRlID0gZ2V0UmVzdW1hYmxlU3RhdGUocmVxdWVzdCk7XG4gIHZhciByZW5kZXJTdGF0ZSA9IGdldFJlbmRlclN0YXRlKHJlcXVlc3QpO1xuXG4gIGlmIChhcyAmJiBocmVmKSB7XG4gICAgc3dpdGNoIChhcykge1xuICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGltYWdlU3JjU2V0LCBpbWFnZVNpemVzLCBmZXRjaFByaW9yaXR5O1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGltYWdlU3JjU2V0ID0gb3B0aW9ucy5pbWFnZVNyY1NldDtcbiAgICAgICAgICAgIGltYWdlU2l6ZXMgPSBvcHRpb25zLmltYWdlU2l6ZXM7XG4gICAgICAgICAgICBmZXRjaFByaW9yaXR5ID0gb3B0aW9ucy5mZXRjaFByaW9yaXR5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBrZXkgPSBnZXRJbWFnZVJlc291cmNlS2V5KGhyZWYsIGltYWdlU3JjU2V0LCBpbWFnZVNpemVzKTtcblxuICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5pbWFnZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAvLyB3ZSBjYW4gcmV0dXJuIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGlzIHJlc291cmNlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXNba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgdmFyIGhlYWRlcnMgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgICAgIHZhciBoZWFkZXI7XG5cbiAgICAgICAgICBpZiAoaGVhZGVycyAmJiBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ID4gMCAmJiBmZXRjaFByaW9yaXR5ID09PSAnaGlnaCcgJiYgKCAvLyBDb21wdXRlIHRoZSBoZWFkZXIgc2luY2Ugd2UgbWlnaHQgYmUgYWJsZSB0byBmaXQgaXQgaW4gdGhlIG1heCBsZW5ndGhcbiAgICAgICAgICBoZWFkZXIgPSBnZXRQcmVsb2FkQXNIZWFkZXIoaHJlZiwgYXMsIG9wdGlvbnMpLCAvLyBXZSBhbHdheXMgY29uc3VtZSB0aGUgaGVhZGVyIGxlbmd0aCBzaW5jZSBvbmNlIHdlIGZpbmQgb25lIGhlYWRlciB0aGF0IGRvZXNuJ3QgZml0XG4gICAgICAgICAgLy8gd2UgYXNzdW1lIGFsbCB0aGUgcmVzdCB3b24ndCBhcyB3ZWxsLiBUaGlzIGlzIHRvIGF2b2lkIGdldHRpbmcgaW50byBhIHNpdHVhdGlvblxuICAgICAgICAgIC8vIHdoZXJlIHdlIGhhdmUgYSB2ZXJ5IHNtYWxsIHJlbWFpbmluZyBjYXBhY2l0eSBidXQgbm8gaGVhZGVycyB3aWxsIGV2ZXIgZml0IGFuZCB3ZSBlbmRcbiAgICAgICAgICAvLyB1cCBjb25zdGFudGx5IHRyeWluZyB0byBzZWUgaWYgdGhlIG5leHQgcmVzb3VyY2UgbWlnaHQgbWFrZSBpdC4gSW4gdGhlIGZ1dHVyZSB3ZSBjYW5cbiAgICAgICAgICAvLyBtYWtlIHRoaXMgYmVoYXZpb3IgZGlmZmVyZW50IGJldHdlZW4gcmVuZGVyIGFuZCBwcmVyZW5kZXIgc2luY2UgaW4gdGhlIGxhdHRlciBjYXNlXG4gICAgICAgICAgLy8gd2UgYXJlIGxlc3Mgc2Vuc2l0aXZlIHRvIHRoZSBjdXJyZW50IHJlcXVlc3RzIHJ1bnRpbWUgcGVyIGFuZCBtb3JlIHNlbnNpdGl2ZSB0byBtYXhpbWl6aW5nXG4gICAgICAgICAgLy8gaGVhZGVycy5cbiAgICAgICAgICAoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoKSA+PSAyKSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgcG9zdHBvbmUgaW4gdGhlIHNoZWxsIHdlIHdpbGwgc3RpbGwgZW1pdCBhIHByZWxvYWQgYXMgYSBoZWFkZXIgc28gd2VcbiAgICAgICAgICAgIC8vIHRyYWNrIHRoaXMgdG8gbWFrZSBzdXJlIHdlIGRvbid0IHJlc2V0IGl0LlxuICAgICAgICAgICAgcmVuZGVyU3RhdGUucmVzZXRzLmltYWdlW2tleV0gPSBQUkVMT0FEX05PX0NSRURTO1xuXG4gICAgICAgICAgICBpZiAoaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2Fkcykge1xuICAgICAgICAgICAgICBoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzICs9ICcsICc7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXTogd2UgYXNzaWduIGhlYWRlciBkdXJpbmcgdGhlIGlmIGNvbmRpdGlvblxuXG5cbiAgICAgICAgICAgIGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgKz0gaGVhZGVyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGhlYWRlcnMgdG8gd3JpdGUgdG8gd2UgaGF2ZSB0byBlbmNvZGUgYXMgZWxlbWVudHMgdG8gZmx1c2ggaW4gdGhlIGhlYWRcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgaGF2ZSBpbWFnZVNyY1NldCB0aGUgYnJvd3NlciBwcm9iYWJseSBjYW5ub3QgbG9hZCB0aGUgcmlnaHQgdmVyc2lvbiBmcm9tIGhlYWRlcnNcbiAgICAgICAgICAgIC8vICh0aGlzIHNob3VsZCBiZSB2ZXJpZmllZCBieSB0ZXN0aW5nKS4gRm9yIG5vdyB3ZSBhc3N1bWUgdGhlc2UgbmVlZCB0byBnbyBpbiB0aGUgaGVhZFxuICAgICAgICAgICAgLy8gYXMgZWxlbWVudHMgZXZlbiBpZiBoZWFkZXJzIGFyZSBhdmFpbGFibGUuXG4gICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBbXTtcbiAgICAgICAgICAgIHB1c2hMaW5rSW1wbChyZXNvdXJjZSwgYXNzaWduKHtcbiAgICAgICAgICAgICAgcmVsOiAncHJlbG9hZCcsXG4gICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgYnVnIGluIFNhZmFyaSB3aGVyZSBpbWFnZVNyY1NldCBpcyBub3QgcmVzcGVjdGVkIG9uIHByZWxvYWQgbGlua3NcbiAgICAgICAgICAgICAgLy8gc28gd2Ugb21pdCB0aGUgaHJlZiBoZXJlIGlmIHdlIGhhdmUgaW1hZ2VTcmNTZXQgYi9jIHNhZmFyaSB3aWxsIGxvYWQgdGhlIHdyb25nIGltYWdlLlxuICAgICAgICAgICAgICAvLyBUaGlzIGhhcm1zIG9sZGVyIGJyb3dlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpbWFnZVNyY1NldCBieSBtYWtpbmcgdGhlaXIgcHJlbG9hZHMgbm90IHdvcmtcbiAgICAgICAgICAgICAgLy8gYnV0IHRoaXMgcG9wdWxhdGlvbiBpcyBzaHJpbmtpbmcgZmFzdCBhbmQgaXMgYWxyZWFkeSBzbWFsbCBzbyB3ZSBhY2NlcHQgdGhpcyB0cmFkZW9mZi5cbiAgICAgICAgICAgICAgaHJlZjogaW1hZ2VTcmNTZXQgPyB1bmRlZmluZWQgOiBocmVmLFxuICAgICAgICAgICAgICBhczogYXNcbiAgICAgICAgICAgIH0sIG9wdGlvbnMpKTtcblxuICAgICAgICAgICAgaWYgKGZldGNoUHJpb3JpdHkgPT09ICdoaWdoJykge1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5hZGQocmVzb3VyY2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChyZXNvdXJjZSk7IC8vIFN0YXNoIHRoZSByZXNvdXJjZSBpbiBjYXNlIHdlIG5lZWQgdG8gcHJvbW90ZSBpdCB0byBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgICAgLy8gd2hlbiBhbiBpbWcgdGFnIGlzIHJlbmRlcmVkXG5cbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMuaW1hZ2VzLnNldChrZXksIHJlc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2tleSA9IGdldFJlc291cmNlS2V5KGhyZWYpO1xuXG4gICAgICAgICAgaWYgKHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KF9rZXkpKSB7XG4gICAgICAgICAgICAvLyB3ZSBjYW4gcmV0dXJuIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGlzIHJlc291cmNlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yZXNvdXJjZTIgPSBbXTtcbiAgICAgICAgICBwdXNoTGlua0ltcGwoX3Jlc291cmNlMiwgYXNzaWduKHtcbiAgICAgICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgIGFzOiBhc1xuICAgICAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1tfa2V5XSA9IG9wdGlvbnMgJiYgKHR5cGVvZiBvcHRpb25zLmNyb3NzT3JpZ2luID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkgPT09ICdzdHJpbmcnKSA/IFtvcHRpb25zLmNyb3NzT3JpZ2luLCBvcHRpb25zLmludGVncml0eV0gOiBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICAgIHJlbmRlclN0YXRlLnByZWxvYWRzLnN0eWxlc2hlZXRzLnNldChfa2V5LCBfcmVzb3VyY2UyKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKF9yZXNvdXJjZTIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NjcmlwdCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2tleTIgPSBnZXRSZXNvdXJjZUtleShocmVmKTtcblxuICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoX2tleTIpKSB7XG4gICAgICAgICAgICAvLyB3ZSBjYW4gcmV0dXJuIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGlzIHJlc291cmNlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yZXNvdXJjZTMgPSBbXTtcbiAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zY3JpcHRzLnNldChfa2V5MiwgX3Jlc291cmNlMyk7XG4gICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChfcmVzb3VyY2UzKTtcbiAgICAgICAgICBwdXNoTGlua0ltcGwoX3Jlc291cmNlMywgYXNzaWduKHtcbiAgICAgICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgIGFzOiBhc1xuICAgICAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNbX2tleTJdID0gb3B0aW9ucyAmJiAodHlwZW9mIG9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBvcHRpb25zLmludGVncml0eSA9PT0gJ3N0cmluZycpID8gW29wdGlvbnMuY3Jvc3NPcmlnaW4sIG9wdGlvbnMuaW50ZWdyaXR5XSA6IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfa2V5MyA9IGdldFJlc291cmNlS2V5KGhyZWYpO1xuXG4gICAgICAgICAgdmFyIGhhc0FzVHlwZSA9IHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoYXMpO1xuICAgICAgICAgIHZhciByZXNvdXJjZXM7XG5cbiAgICAgICAgICBpZiAoaGFzQXNUeXBlKSB7XG4gICAgICAgICAgICByZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS51bmtub3duUmVzb3VyY2VzW2FzXTtcblxuICAgICAgICAgICAgaWYgKHJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShfa2V5MykpIHtcbiAgICAgICAgICAgICAgLy8gd2UgY2FuIHJldHVybiBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhpcyByZXNvdXJjZVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc291cmNlcyA9IHt9O1xuICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUudW5rbm93blJlc291cmNlc1thc10gPSByZXNvdXJjZXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb3VyY2VzW19rZXkzXSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgdmFyIF9oZWFkZXJzID0gcmVuZGVyU3RhdGUuaGVhZGVycztcblxuICAgICAgICAgIHZhciBfaGVhZGVyO1xuXG4gICAgICAgICAgaWYgKF9oZWFkZXJzICYmIF9oZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ID4gMCAmJiBhcyA9PT0gJ2ZvbnQnICYmICggLy8gV2UgY29tcHV0ZSB0aGUgaGVhZGVyIGhlcmUgYmVjYXVzZSB3ZSBtaWdodCBiZSBhYmxlIHRvIGZpdCBpdCBpbiB0aGUgbWF4IGxlbmd0aFxuICAgICAgICAgIF9oZWFkZXIgPSBnZXRQcmVsb2FkQXNIZWFkZXIoaHJlZiwgYXMsIG9wdGlvbnMpLCAvLyBXZSBhbHdheXMgY29uc3VtZSB0aGUgaGVhZGVyIGxlbmd0aCBzaW5jZSBvbmNlIHdlIGZpbmQgb25lIGhlYWRlciB0aGF0IGRvZXNuJ3QgZml0XG4gICAgICAgICAgLy8gd2UgYXNzdW1lIGFsbCB0aGUgcmVzdCB3b24ndCBhcyB3ZWxsLiBUaGlzIGlzIHRvIGF2b2lkIGdldHRpbmcgaW50byBhIHNpdHVhdGlvblxuICAgICAgICAgIC8vIHdoZXJlIHdlIGhhdmUgYSB2ZXJ5IHNtYWxsIHJlbWFpbmluZyBjYXBhY2l0eSBidXQgbm8gaGVhZGVycyB3aWxsIGV2ZXIgZml0IGFuZCB3ZSBlbmRcbiAgICAgICAgICAvLyB1cCBjb25zdGFudGx5IHRyeWluZyB0byBzZWUgaWYgdGhlIG5leHQgcmVzb3VyY2UgbWlnaHQgbWFrZSBpdC4gSW4gdGhlIGZ1dHVyZSB3ZSBjYW5cbiAgICAgICAgICAvLyBtYWtlIHRoaXMgYmVoYXZpb3IgZGlmZmVyZW50IGJldHdlZW4gcmVuZGVyIGFuZCBwcmVyZW5kZXIgc2luY2UgaW4gdGhlIGxhdHRlciBjYXNlXG4gICAgICAgICAgLy8gd2UgYXJlIGxlc3Mgc2Vuc2l0aXZlIHRvIHRoZSBjdXJyZW50IHJlcXVlc3RzIHJ1bnRpbWUgcGVyIGFuZCBtb3JlIHNlbnNpdGl2ZSB0byBtYXhpbWl6aW5nXG4gICAgICAgICAgLy8gaGVhZGVycy5cbiAgICAgICAgICAoX2hlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgLT0gX2hlYWRlci5sZW5ndGgpID49IDIpKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBwb3N0cG9uZSBpbiB0aGUgc2hlbGwgd2Ugd2lsbCBzdGlsbCBlbWl0IHRoaXMgcHJlbG9hZCBzbyB3ZVxuICAgICAgICAgICAgLy8gdHJhY2sgaXQgaGVyZSB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVzZXQuXG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5yZXNldHMuZm9udFtfa2V5M10gPSBQUkVMT0FEX05PX0NSRURTO1xuXG4gICAgICAgICAgICBpZiAoX2hlYWRlcnMuZm9udFByZWxvYWRzKSB7XG4gICAgICAgICAgICAgIF9oZWFkZXJzLmZvbnRQcmVsb2FkcyArPSAnLCAnO1xuICAgICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl06IHdlIGFzc2lnbiBoZWFkZXIgZHVyaW5nIHRoZSBpZiBjb25kaXRpb25cblxuXG4gICAgICAgICAgICBfaGVhZGVycy5mb250UHJlbG9hZHMgKz0gX2hlYWRlcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgZWl0aGVyIGRvbid0IGhhdmUgaGVhZGVycyBvciB3ZSBhcmUgcHJlbG9hZGluZyBzb21ldGhpbmcgdGhhdCBkb2VzXG4gICAgICAgICAgICAvLyBub3Qgd2FycmFudCBlbGV2YXRlZCBwcmlvcml0eSBzbyB3ZSBlbmNvZGUgYXMgYW4gZWxlbWVudC5cbiAgICAgICAgICAgIHZhciBfcmVzb3VyY2U0ID0gW107XG5cbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFzc2lnbih7XG4gICAgICAgICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgICAgICBhczogYXNcbiAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICBwdXNoTGlua0ltcGwoX3Jlc291cmNlNCwgcHJvcHMpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGFzKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2ZvbnQnOlxuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmZvbnRQcmVsb2Fkcy5hZGQoX3Jlc291cmNlNCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChfcmVzb3VyY2U0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IC8vIElmIHdlIGdvdCB0aGlzIGZhciB3ZSBjcmVhdGVkIGEgbmV3IHJlc291cmNlXG5cblxuICAgIGZsdXNoUmVzb3VyY2VzKHJlcXVlc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZWxvYWRNb2R1bGUoaHJlZiwgb3B0aW9ucykge1xuXG4gIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcblxuICBpZiAoIXJlcXVlc3QpIHtcbiAgICAvLyBJbiBhc3luYyBjb250ZXh0cyB3ZSBjYW4gc29tZXRpbWVzIHJlc29sdmUgcmVzb3VyY2VzIGZyb20gQXN5bmNMb2NhbFN0b3JhZ2UuIElmIHdlIGNhbid0IHdlIGNhbiBhbHNvXG4gICAgLy8gcG9zc2libHkgZ2V0IHRoZW0gZnJvbSB0aGUgc3RhY2sgaWYgd2UgYXJlIG5vdCBpbiBhbiBhc3luYyBjb250ZXh0LiBTaW5jZSB3ZSB3ZXJlIG5vdCBhYmxlIHRvIHJlc29sdmVcbiAgICAvLyB0aGUgcmVzb3VyY2VzIGZvciB0aGlzIGNhbGwgaW4gZWl0aGVyIGNhc2Ugd2Ugb3B0IHRvIGRvIG5vdGhpbmcuIFdlIGNhbiBjb25zaWRlciBtYWtpbmcgdGhpcyBhIHdhcm5pbmdcbiAgICAvLyBidXQgdGhlcmUgbWF5IGJlIHRpbWVzIHdoZXJlIGNhbGxpbmcgYSBmdW5jdGlvbiBvdXRzaWRlIG9mIHJlbmRlciBpcyBpbnRlbnRpb25hbCAoaS5lLiB0byB3YXJtIHVwIGRhdGFcbiAgICAvLyBmZXRjaGluZykgYW5kIHdlIGRvbid0IHdhbnQgdG8gd2FybiBpbiB0aG9zZSBjYXNlcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVzdW1hYmxlU3RhdGUgPSBnZXRSZXN1bWFibGVTdGF0ZShyZXF1ZXN0KTtcbiAgdmFyIHJlbmRlclN0YXRlID0gZ2V0UmVuZGVyU3RhdGUocmVxdWVzdCk7XG5cbiAgaWYgKGhyZWYpIHtcbiAgICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoaHJlZik7XG4gICAgdmFyIGFzID0gb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5hcyA9PT0gJ3N0cmluZycgPyBvcHRpb25zLmFzIDogJ3NjcmlwdCc7XG4gICAgdmFyIHJlc291cmNlO1xuXG4gICAgc3dpdGNoIChhcykge1xuICAgICAgY2FzZSAnc2NyaXB0JzpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgLy8gd2UgY2FuIHJldHVybiBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhpcyByZXNvdXJjZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc291cmNlID0gW107XG4gICAgICAgICAgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW2tleV0gPSBvcHRpb25zICYmICh0eXBlb2Ygb3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5ID09PSAnc3RyaW5nJykgPyBbb3B0aW9ucy5jcm9zc09yaWdpbiwgb3B0aW9ucy5pbnRlZ3JpdHldIDogUFJFTE9BRF9OT19DUkVEUztcbiAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5tb2R1bGVTY3JpcHRzLnNldChrZXksIHJlc291cmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGhhc0FzVHlwZSA9IHJlc3VtYWJsZVN0YXRlLm1vZHVsZVVua25vd25SZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoYXMpO1xuICAgICAgICAgIHZhciByZXNvdXJjZXM7XG5cbiAgICAgICAgICBpZiAoaGFzQXNUeXBlKSB7XG4gICAgICAgICAgICByZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS51bmtub3duUmVzb3VyY2VzW2FzXTtcblxuICAgICAgICAgICAgaWYgKHJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgIC8vIHdlIGNhbiByZXR1cm4gaWYgd2UgYWxyZWFkeSBoYXZlIHRoaXMgcmVzb3VyY2VcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvdXJjZXMgPSB7fTtcbiAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLm1vZHVsZVVua25vd25SZXNvdXJjZXNbYXNdID0gcmVzb3VyY2VzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc291cmNlID0gW107XG4gICAgICAgICAgcmVzb3VyY2VzW2tleV0gPSBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVzaExpbmtJbXBsKHJlc291cmNlLCBhc3NpZ24oe1xuICAgICAgcmVsOiAnbW9kdWxlcHJlbG9hZCcsXG4gICAgICBocmVmOiBocmVmXG4gICAgfSwgb3B0aW9ucykpO1xuICAgIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5hZGQocmVzb3VyY2UpOyAvLyBJZiB3ZSBnb3QgdGhpcyBmYXIgd2UgY3JlYXRlZCBhIG5ldyByZXNvdXJjZVxuXG4gICAgZmx1c2hSZXNvdXJjZXMocmVxdWVzdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlaW5pdFN0eWxlKGhyZWYsIHByZWNlZGVuY2UsIG9wdGlvbnMpIHtcblxuICB2YXIgcmVxdWVzdCA9IHJlc29sdmVSZXF1ZXN0KCk7XG5cbiAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgLy8gSW4gYXN5bmMgY29udGV4dHMgd2UgY2FuIHNvbWV0aW1lcyByZXNvbHZlIHJlc291cmNlcyBmcm9tIEFzeW5jTG9jYWxTdG9yYWdlLiBJZiB3ZSBjYW4ndCB3ZSBjYW4gYWxzb1xuICAgIC8vIHBvc3NpYmx5IGdldCB0aGVtIGZyb20gdGhlIHN0YWNrIGlmIHdlIGFyZSBub3QgaW4gYW4gYXN5bmMgY29udGV4dC4gU2luY2Ugd2Ugd2VyZSBub3QgYWJsZSB0byByZXNvbHZlXG4gICAgLy8gdGhlIHJlc291cmNlcyBmb3IgdGhpcyBjYWxsIGluIGVpdGhlciBjYXNlIHdlIG9wdCB0byBkbyBub3RoaW5nLiBXZSBjYW4gY29uc2lkZXIgbWFraW5nIHRoaXMgYSB3YXJuaW5nXG4gICAgLy8gYnV0IHRoZXJlIG1heSBiZSB0aW1lcyB3aGVyZSBjYWxsaW5nIGEgZnVuY3Rpb24gb3V0c2lkZSBvZiByZW5kZXIgaXMgaW50ZW50aW9uYWwgKGkuZS4gdG8gd2FybSB1cCBkYXRhXG4gICAgLy8gZmV0Y2hpbmcpIGFuZCB3ZSBkb24ndCB3YW50IHRvIHdhcm4gaW4gdGhvc2UgY2FzZXMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlc3VtYWJsZVN0YXRlID0gZ2V0UmVzdW1hYmxlU3RhdGUocmVxdWVzdCk7XG4gIHZhciByZW5kZXJTdGF0ZSA9IGdldFJlbmRlclN0YXRlKHJlcXVlc3QpO1xuXG4gIGlmIChocmVmKSB7XG4gICAgcHJlY2VkZW5jZSA9IHByZWNlZGVuY2UgfHwgJ2RlZmF1bHQnO1xuICAgIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleShocmVmKTtcbiAgICB2YXIgc3R5bGVRdWV1ZSA9IHJlbmRlclN0YXRlLnN0eWxlcy5nZXQocHJlY2VkZW5jZSk7XG4gICAgdmFyIGhhc0tleSA9IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgdmFyIHJlc291cmNlU3RhdGUgPSBoYXNLZXkgPyByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1trZXldIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHJlc291cmNlU3RhdGUgIT09IEVYSVNUUykge1xuICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIGNyZWF0ZSB0aGlzIHJlc291cmNlIG5vdyBzbyBpdCBpcyBtYXJrZWQgYXMgRXhpc3RzXG4gICAgICByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1trZXldID0gRVhJU1RTOyAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHdlJ3ZlIGVuY291bnRlcmVkIHRoaXMgcHJlY2VkZW5jZSB3ZSBuZWVkXG4gICAgICAvLyB0byBjcmVhdGUgYSBTdHlsZVF1ZXVlXG5cbiAgICAgIGlmICghc3R5bGVRdWV1ZSkge1xuICAgICAgICBzdHlsZVF1ZXVlID0ge1xuICAgICAgICAgIHByZWNlZGVuY2U6IHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSkpLFxuICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICBocmVmczogW10sXG4gICAgICAgICAgc2hlZXRzOiBuZXcgTWFwKClcbiAgICAgICAgfTtcbiAgICAgICAgcmVuZGVyU3RhdGUuc3R5bGVzLnNldChwcmVjZWRlbmNlLCBzdHlsZVF1ZXVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc291cmNlID0ge1xuICAgICAgICBzdGF0ZTogUEVORElORyQxLFxuICAgICAgICBwcm9wczogYXNzaWduKHtcbiAgICAgICAgICByZWw6ICdzdHlsZXNoZWV0JyxcbiAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgICdkYXRhLXByZWNlZGVuY2UnOiBwcmVjZWRlbmNlXG4gICAgICAgIH0sIG9wdGlvbnMpXG4gICAgICB9O1xuXG4gICAgICBpZiAocmVzb3VyY2VTdGF0ZSkge1xuICAgICAgICAvLyBXaGVuIHJlc291cmNlU3RhdGUgaXMgdHJ1dHkgaXQgaXMgYSBQcmVsb2FkIHN0YXRlLiBXZSBjYXN0IGl0IGZvciBjbGFyaXR5XG4gICAgICAgIHZhciBwcmVsb2FkU3RhdGUgPSByZXNvdXJjZVN0YXRlO1xuXG4gICAgICAgIGlmIChwcmVsb2FkU3RhdGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMocmVzb3VyY2UucHJvcHMsIHByZWxvYWRTdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlbG9hZFJlc291cmNlID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuc3R5bGVzaGVldHMuZ2V0KGtleSk7XG5cbiAgICAgICAgaWYgKHByZWxvYWRSZXNvdXJjZSAmJiBwcmVsb2FkUmVzb3VyY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIFRoZSBQcmVsb2FkIGZvciB0aGlzIHJlc291cmNlIHdhcyBjcmVhdGVkIGluIHRoaXMgcmVuZGVyIHBhc3MgYW5kIGhhcyBub3QgZmx1c2hlZCB5ZXQgc29cbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNsZWFyIGl0IHRvIGF2b2lkIGl0IGZsdXNoaW5nLlxuICAgICAgICAgIHByZWxvYWRSZXNvdXJjZS5sZW5ndGggPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEVpdGhlciB0aGUgcHJlbG9hZCByZXNvdXJjZSBmcm9tIHRoaXMgcmVuZGVyIGFscmVhZHkgZmx1c2hlZCBpbiB0aGlzIHJlbmRlciBwYXNzXG4gICAgICAgICAgLy8gb3IgdGhlIHByZWxvYWQgZmx1c2hlZCBpbiBhIHByaW9yIHBhc3MgKHByZXJlbmRlcikuIEluIGVpdGhlciBjYXNlIHdlIG5lZWQgdG8gbWFya1xuICAgICAgICAgIC8vIHRoaXMgcmVzb3VyY2UgYXMgYWxyZWFkeSBoYXZpbmcgYmVlbiBwcmVsb2FkZWQuXG4gICAgICAgICAgcmVzb3VyY2Uuc3RhdGUgPSBQUkVMT0FERUQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gV2UgYWRkIHRoZSBuZXdseSBjcmVhdGVkIHJlc291cmNlIHRvIG91ciBTdHlsZVF1ZXVlIGFuZCBpZiBuZWNlc3NhcnlcbiAgICAgIC8vIHRyYWNrIHRoZSByZXNvdXJjZSB3aXRoIHRoZSBjdXJyZW50bHkgcmVuZGVyaW5nIGJvdW5kYXJ5XG5cblxuICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuc2V0KGtleSwgcmVzb3VyY2UpOyAvLyBOb3RpZnkgdGhlIHJlcXVlc3QgdGhhdCB0aGVyZSBhcmUgcmVzb3VyY2VzIHRvIGZsdXNoIGV2ZW4gaWYgbm8gd29yayBpcyBjdXJyZW50bHkgaGFwcGVuaW5nXG5cbiAgICAgIGZsdXNoUmVzb3VyY2VzKHJlcXVlc3QpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVpbml0U2NyaXB0KHNyYywgb3B0aW9ucykge1xuXG4gIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcblxuICBpZiAoIXJlcXVlc3QpIHtcbiAgICAvLyBJbiBhc3luYyBjb250ZXh0cyB3ZSBjYW4gc29tZXRpbWVzIHJlc29sdmUgcmVzb3VyY2VzIGZyb20gQXN5bmNMb2NhbFN0b3JhZ2UuIElmIHdlIGNhbid0IHdlIGNhbiBhbHNvXG4gICAgLy8gcG9zc2libHkgZ2V0IHRoZW0gZnJvbSB0aGUgc3RhY2sgaWYgd2UgYXJlIG5vdCBpbiBhbiBhc3luYyBjb250ZXh0LiBTaW5jZSB3ZSB3ZXJlIG5vdCBhYmxlIHRvIHJlc29sdmVcbiAgICAvLyB0aGUgcmVzb3VyY2VzIGZvciB0aGlzIGNhbGwgaW4gZWl0aGVyIGNhc2Ugd2Ugb3B0IHRvIGRvIG5vdGhpbmcuIFdlIGNhbiBjb25zaWRlciBtYWtpbmcgdGhpcyBhIHdhcm5pbmdcbiAgICAvLyBidXQgdGhlcmUgbWF5IGJlIHRpbWVzIHdoZXJlIGNhbGxpbmcgYSBmdW5jdGlvbiBvdXRzaWRlIG9mIHJlbmRlciBpcyBpbnRlbnRpb25hbCAoaS5lLiB0byB3YXJtIHVwIGRhdGFcbiAgICAvLyBmZXRjaGluZykgYW5kIHdlIGRvbid0IHdhbnQgdG8gd2FybiBpbiB0aG9zZSBjYXNlcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVzdW1hYmxlU3RhdGUgPSBnZXRSZXN1bWFibGVTdGF0ZShyZXF1ZXN0KTtcbiAgdmFyIHJlbmRlclN0YXRlID0gZ2V0UmVuZGVyU3RhdGUocmVxdWVzdCk7XG5cbiAgaWYgKHNyYykge1xuICAgIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleShzcmMpO1xuICAgIHZhciBoYXNLZXkgPSByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICB2YXIgcmVzb3VyY2VTdGF0ZSA9IGhhc0tleSA/IHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1trZXldIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHJlc291cmNlU3RhdGUgIT09IEVYSVNUUykge1xuICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIGNyZWF0ZSB0aGlzIHJlc291cmNlIG5vdyBzbyBpdCBpcyBtYXJrZWQgYXMgRXhpc3RzXG4gICAgICByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNba2V5XSA9IEVYSVNUUztcblxuICAgICAgdmFyIHByb3BzID0gYXNzaWduKHtcbiAgICAgICAgc3JjOiBzcmMsXG4gICAgICAgIGFzeW5jOiB0cnVlXG4gICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgaWYgKHJlc291cmNlU3RhdGUpIHtcbiAgICAgICAgLy8gV2hlbiByZXNvdXJjZVN0YXRlIGlzIHRydXR5IGl0IGlzIGEgUHJlbG9hZCBzdGF0ZS4gV2UgY2FzdCBpdCBmb3IgY2xhcml0eVxuICAgICAgICB2YXIgcHJlbG9hZFN0YXRlID0gcmVzb3VyY2VTdGF0ZTtcblxuICAgICAgICBpZiAocHJlbG9hZFN0YXRlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKHByb3BzLCBwcmVsb2FkU3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZWxvYWRSZXNvdXJjZSA9IHJlbmRlclN0YXRlLnByZWxvYWRzLnNjcmlwdHMuZ2V0KGtleSk7XG5cbiAgICAgICAgaWYgKHByZWxvYWRSZXNvdXJjZSkge1xuICAgICAgICAgIC8vIHRoZSBwcmVsb2FkIHJlc291cmNlIGV4aXN0cyB3YXMgY3JlYXRlZCBpbiB0aGlzIHJlbmRlci4gTm93IHRoYXQgd2UgaGF2ZVxuICAgICAgICAgIC8vIGEgc2NyaXB0IHJlc291cmNlIHdoaWNoIHdpbGwgZW1pdCBlYXJsaWVyIHRoYW4gYSBwcmVsb2FkIHdvdWxkIGlmIGl0XG4gICAgICAgICAgLy8gaGFzbid0IGFscmVhZHkgZmx1c2hlZCB3ZSBwcmV2ZW50IGl0IGZyb20gZmx1c2hpbmcgYnkgemVyb2luZyB0aGUgbGVuZ3RoXG4gICAgICAgICAgcHJlbG9hZFJlc291cmNlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJlc291cmNlID0gW107IC8vIEFkZCB0byB0aGUgc2NyaXB0IGZsdXNoaW5nIHF1ZXVlXG5cbiAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHJlc291cmNlKTsgLy8gZW5jb2RlIHRoZSB0YWcgYXMgQ2h1bmtzXG5cbiAgICAgIHB1c2hTY3JpcHRJbXBsKHJlc291cmNlLCBwcm9wcyk7IC8vIE5vdGlmeSB0aGUgcmVxdWVzdCB0aGF0IHRoZXJlIGFyZSByZXNvdXJjZXMgdG8gZmx1c2ggZXZlbiBpZiBubyB3b3JrIGlzIGN1cnJlbnRseSBoYXBwZW5pbmdcblxuICAgICAgZmx1c2hSZXNvdXJjZXMocmVxdWVzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZWluaXRNb2R1bGVTY3JpcHQoc3JjLCBvcHRpb25zKSB7XG5cbiAgdmFyIHJlcXVlc3QgPSByZXNvbHZlUmVxdWVzdCgpO1xuXG4gIGlmICghcmVxdWVzdCkge1xuICAgIC8vIEluIGFzeW5jIGNvbnRleHRzIHdlIGNhbiBzb21ldGltZXMgcmVzb2x2ZSByZXNvdXJjZXMgZnJvbSBBc3luY0xvY2FsU3RvcmFnZS4gSWYgd2UgY2FuJ3Qgd2UgY2FuIGFsc29cbiAgICAvLyBwb3NzaWJseSBnZXQgdGhlbSBmcm9tIHRoZSBzdGFjayBpZiB3ZSBhcmUgbm90IGluIGFuIGFzeW5jIGNvbnRleHQuIFNpbmNlIHdlIHdlcmUgbm90IGFibGUgdG8gcmVzb2x2ZVxuICAgIC8vIHRoZSByZXNvdXJjZXMgZm9yIHRoaXMgY2FsbCBpbiBlaXRoZXIgY2FzZSB3ZSBvcHQgdG8gZG8gbm90aGluZy4gV2UgY2FuIGNvbnNpZGVyIG1ha2luZyB0aGlzIGEgd2FybmluZ1xuICAgIC8vIGJ1dCB0aGVyZSBtYXkgYmUgdGltZXMgd2hlcmUgY2FsbGluZyBhIGZ1bmN0aW9uIG91dHNpZGUgb2YgcmVuZGVyIGlzIGludGVudGlvbmFsIChpLmUuIHRvIHdhcm0gdXAgZGF0YVxuICAgIC8vIGZldGNoaW5nKSBhbmQgd2UgZG9uJ3Qgd2FudCB0byB3YXJuIGluIHRob3NlIGNhc2VzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZXN1bWFibGVTdGF0ZSA9IGdldFJlc3VtYWJsZVN0YXRlKHJlcXVlc3QpO1xuICB2YXIgcmVuZGVyU3RhdGUgPSBnZXRSZW5kZXJTdGF0ZShyZXF1ZXN0KTtcblxuICBpZiAoc3JjKSB7XG4gICAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KHNyYyk7XG4gICAgdmFyIGhhc0tleSA9IHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgIHZhciByZXNvdXJjZVN0YXRlID0gaGFzS2V5ID8gcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW2tleV0gOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAocmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTKSB7XG4gICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gY3JlYXRlIHRoaXMgcmVzb3VyY2Ugbm93IHNvIGl0IGlzIG1hcmtlZCBhcyBFeGlzdHNcbiAgICAgIHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlc1trZXldID0gRVhJU1RTO1xuXG4gICAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe1xuICAgICAgICBzcmM6IHNyYyxcbiAgICAgICAgdHlwZTogJ21vZHVsZScsXG4gICAgICAgIGFzeW5jOiB0cnVlXG4gICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgaWYgKHJlc291cmNlU3RhdGUpIHtcbiAgICAgICAgLy8gV2hlbiByZXNvdXJjZVN0YXRlIGlzIHRydXR5IGl0IGlzIGEgUHJlbG9hZCBzdGF0ZS4gV2UgY2FzdCBpdCBmb3IgY2xhcml0eVxuICAgICAgICB2YXIgcHJlbG9hZFN0YXRlID0gcmVzb3VyY2VTdGF0ZTtcblxuICAgICAgICBpZiAocHJlbG9hZFN0YXRlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKHByb3BzLCBwcmVsb2FkU3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZWxvYWRSZXNvdXJjZSA9IHJlbmRlclN0YXRlLnByZWxvYWRzLm1vZHVsZVNjcmlwdHMuZ2V0KGtleSk7XG5cbiAgICAgICAgaWYgKHByZWxvYWRSZXNvdXJjZSkge1xuICAgICAgICAgIC8vIHRoZSBwcmVsb2FkIHJlc291cmNlIGV4aXN0cyB3YXMgY3JlYXRlZCBpbiB0aGlzIHJlbmRlci4gTm93IHRoYXQgd2UgaGF2ZVxuICAgICAgICAgIC8vIGEgc2NyaXB0IHJlc291cmNlIHdoaWNoIHdpbGwgZW1pdCBlYXJsaWVyIHRoYW4gYSBwcmVsb2FkIHdvdWxkIGlmIGl0XG4gICAgICAgICAgLy8gaGFzbid0IGFscmVhZHkgZmx1c2hlZCB3ZSBwcmV2ZW50IGl0IGZyb20gZmx1c2hpbmcgYnkgemVyb2luZyB0aGUgbGVuZ3RoXG4gICAgICAgICAgcHJlbG9hZFJlc291cmNlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJlc291cmNlID0gW107IC8vIEFkZCB0byB0aGUgc2NyaXB0IGZsdXNoaW5nIHF1ZXVlXG5cbiAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHJlc291cmNlKTsgLy8gZW5jb2RlIHRoZSB0YWcgYXMgQ2h1bmtzXG5cbiAgICAgIHB1c2hTY3JpcHRJbXBsKHJlc291cmNlLCBwcm9wcyk7IC8vIE5vdGlmeSB0aGUgcmVxdWVzdCB0aGF0IHRoZXJlIGFyZSByZXNvdXJjZXMgdG8gZmx1c2ggZXZlbiBpZiBubyB3b3JrIGlzIGN1cnJlbnRseSBoYXBwZW5pbmdcblxuICAgICAgZmx1c2hSZXNvdXJjZXMocmVxdWVzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG59IC8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBzYWZlIHRvIGNhbGwgYXQgUmVxdWVzdCBzdGFydCB0aW1lIHNpbmNlIGl0IGFzc3VtZXNcbi8vIHRoYXQgZWFjaCBtb2R1bGUgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcHJlbG9hZGVkLiBJZiB3ZSBmaW5kIGEgbmVlZCB0byBwcmVsb2FkXG4vLyBzY3JpcHRzIGF0IGFueSBvdGhlciBwb2ludCBpbiB0aW1lIHdlIHdpbGwgbmVlZCB0byBjaGVjayB3aGV0aGVyIHRoZSBwcmVsb2FkXG4vLyBhbHJlYWR5IGV4aXN0cyBhbmQgbm90IGFzc3VtZSBpdFxuXG5cbmZ1bmN0aW9uIHByZWxvYWRCb290c3RyYXBTY3JpcHRPck1vZHVsZShyZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIGhyZWYsIHByb3BzKSB7XG5cbiAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KGhyZWYpO1xuXG4gIHtcbiAgICBpZiAocmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSkgfHwgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgY29kZWQgYXMgYSBSZWFjdCBlcnJvciBiZWNhdXNlIGl0IHNob3VsZCBiZSBpbXBvc3NpYmxlIGZvciBhIHVzZXJzcGFjZSBwcmVsb2FkIHRvIHByZWVtcHQgdGhpcyBjYWxsXG4gICAgICAvLyBJZiBhIHVzZXJzcGFjZSBwcmVsb2FkIGNhbiBwcmVlbXB0IGl0IHRoZW4gdGhpcyBhc3N1bXB0aW9uIGlzIGJyb2tlbiBhbmQgd2UgbmVlZCB0byByZWNvbnNpZGVyIHRoaXMgc3RyYXRlZ3lcbiAgICAgIC8vIHJhdGhlciB0aGFuIGluc3RydWN0IHRoZSB1c2VyIHRvIG5vdCBwcmVsb2FkIHRoZWlyIGJvb3RzdHJhcCBzY3JpcHRzIHRoZW1zZWx2ZXNcbiAgICAgIGVycm9yKCdJbnRlcm5hbCBSZWFjdCBFcnJvcjogUmVhY3QgZXhwZWN0ZWQgYm9vdHN0cmFwIHNjcmlwdCBvciBtb2R1bGUgd2l0aCBzcmMgXCIlc1wiIHRvIG5vdCBoYXZlIGJlZW4gcHJlbG9hZGVkIGFscmVhZHkuIHBsZWFzZSBmaWxlIGFuIGlzc3VlJywgaHJlZik7XG4gICAgfVxuICB9IC8vIFRoZSBocmVmIHVzZWQgZm9yIGJvb3RzdHJhcCBzY3JpcHRzIGFuZCBib290c3RyYXAgbW9kdWxlcyBzaG91bGQgbmV2ZXIgYmVcbiAgLy8gdXNlZCB0byBwcmVpbml0IHRoZSByZXNvdXJjZS4gSWYgYSBzY3JpcHQgY2FuIGJlIHByZWluaXRlZCB0aGVuIGl0IHNob3VsZG4ndFxuICAvLyBiZSBhIGJvb3RzdHJhcCBzY3JpcHQvbW9kdWxlIGFuZCBpZiBpdCBpcyBhIGJvb3RzdHJhcCBzY3JpcHQvbW9kdWxlIHRoZW4gaXRcbiAgLy8gbXVzdCBub3QgYmUgc2FmZSB0byBlbWl0IGVhcmx5LiBUbyBhdm9pZCBwb3NzaWJseSBhbGxvd2luZyBmb3IgcHJlaW5pdHMgb2ZcbiAgLy8gYm9vdHN0cmFwIHNjcmlwdHMvbW9kdWxlcyB3ZSBvY2NsdWRlIHRoZXNlIGtleXMuXG5cblxuICByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNba2V5XSA9IEVYSVNUUztcbiAgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW2tleV0gPSBFWElTVFM7XG4gIHZhciByZXNvdXJjZSA9IFtdO1xuICBwdXNoTGlua0ltcGwocmVzb3VyY2UsIHByb3BzKTtcbiAgcmVuZGVyU3RhdGUuYm9vdHN0cmFwU2NyaXB0cy5hZGQocmVzb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBpbnRlcm5hbFByZWluaXRTY3JpcHQocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBzcmMsIGNodW5rcykge1xuICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoc3JjKTtcblxuICBpZiAoIXJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgdmFyIHJlc291cmNlID0gY2h1bmtzO1xuICAgIHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1trZXldID0gRVhJU1RTO1xuICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHJlc291cmNlKTtcbiAgfVxuXG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gcHJlbG9hZEFzU3R5bGVQcm9wc0Zyb21Qcm9wcyhocmVmLCBwcm9wcykge1xuICByZXR1cm4ge1xuICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgIGFzOiAnc3R5bGUnLFxuICAgIGhyZWY6IGhyZWYsXG4gICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luLFxuICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgaW50ZWdyaXR5OiBwcm9wcy5pbnRlZ3JpdHksXG4gICAgbWVkaWE6IHByb3BzLm1lZGlhLFxuICAgIGhyZWZMYW5nOiBwcm9wcy5ocmVmTGFuZyxcbiAgICByZWZlcnJlclBvbGljeTogcHJvcHMucmVmZXJyZXJQb2xpY3lcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVzaGVldFByb3BzRnJvbVJhd1Byb3BzKHJhd1Byb3BzKSB7XG4gIHJldHVybiBhc3NpZ24oe30sIHJhd1Byb3BzLCB7XG4gICAgJ2RhdGEtcHJlY2VkZW5jZSc6IHJhd1Byb3BzLnByZWNlZGVuY2UsXG4gICAgcHJlY2VkZW5jZTogbnVsbFxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHModGFyZ2V0LCBwcmVsb2FkU3RhdGUpIHtcbiAgaWYgKHRhcmdldC5jcm9zc09yaWdpbiA9PSBudWxsKSB0YXJnZXQuY3Jvc3NPcmlnaW4gPSBwcmVsb2FkU3RhdGVbMF07XG4gIGlmICh0YXJnZXQuaW50ZWdyaXR5ID09IG51bGwpIHRhcmdldC5pbnRlZ3JpdHkgPSBwcmVsb2FkU3RhdGVbMV07XG59XG5cbmZ1bmN0aW9uIGdldFByZWZldGNoRE5TQXNIZWFkZXIoaHJlZikge1xuICB2YXIgZXNjYXBlZEhyZWYgPSBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHQoaHJlZik7XG4gIHJldHVybiBcIjxcIiArIGVzY2FwZWRIcmVmICsgXCI+OyByZWw9ZG5zLXByZWZldGNoXCI7XG59XG5cbmZ1bmN0aW9uIGdldFByZWNvbm5lY3RBc0hlYWRlcihocmVmLCBjcm9zc09yaWdpbikge1xuICB2YXIgZXNjYXBlZEhyZWYgPSBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHQoaHJlZik7XG4gIHZhciB2YWx1ZSA9IFwiPFwiICsgZXNjYXBlZEhyZWYgKyBcIj47IHJlbD1wcmVjb25uZWN0XCI7XG5cbiAgaWYgKHR5cGVvZiBjcm9zc09yaWdpbiA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgZXNjYXBlZENyb3NzT3JpZ2luID0gZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0KGNyb3NzT3JpZ2luLCAnY3Jvc3NPcmlnaW4nKTtcbiAgICB2YWx1ZSArPSBcIjsgY3Jvc3NvcmlnaW49XFxcIlwiICsgZXNjYXBlZENyb3NzT3JpZ2luICsgXCJcXFwiXCI7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldFByZWxvYWRBc0hlYWRlcihocmVmLCBhcywgcGFyYW1zKSB7XG4gIHZhciBlc2NhcGVkSHJlZiA9IGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dChocmVmKTtcbiAgdmFyIGVzY2FwZWRBcyA9IGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dChhcywgJ2FzJyk7XG4gIHZhciB2YWx1ZSA9IFwiPFwiICsgZXNjYXBlZEhyZWYgKyBcIj47IHJlbD1wcmVsb2FkOyBhcz1cXFwiXCIgKyBlc2NhcGVkQXMgKyBcIlxcXCJcIjtcblxuICBmb3IgKHZhciBwYXJhbU5hbWUgaW4gcGFyYW1zKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCBwYXJhbU5hbWUpKSB7XG4gICAgICB2YXIgcGFyYW1WYWx1ZSA9IHBhcmFtc1twYXJhbU5hbWVdO1xuXG4gICAgICBpZiAodHlwZW9mIHBhcmFtVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbHVlICs9IFwiOyBcIiArIHBhcmFtTmFtZS50b0xvd2VyQ2FzZSgpICsgXCI9XFxcIlwiICsgZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0KHBhcmFtVmFsdWUsIHBhcmFtTmFtZSkgKyBcIlxcXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldFN0eWxlc2hlZXRQcmVsb2FkQXNIZWFkZXIoc3R5bGVzaGVldCkge1xuICB2YXIgcHJvcHMgPSBzdHlsZXNoZWV0LnByb3BzO1xuICB2YXIgcHJlbG9hZE9wdGlvbnMgPSB7XG4gICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luLFxuICAgIGludGVncml0eTogcHJvcHMuaW50ZWdyaXR5LFxuICAgIG5vbmNlOiBwcm9wcy5ub25jZSxcbiAgICB0eXBlOiBwcm9wcy50eXBlLFxuICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgcmVmZXJyZXJQb2xpY3k6IHByb3BzLnJlZmVycmVyUG9saWN5LFxuICAgIG1lZGlhOiBwcm9wcy5tZWRpYVxuICB9O1xuICByZXR1cm4gZ2V0UHJlbG9hZEFzSGVhZGVyKHByb3BzLmhyZWYsICdzdHlsZScsIHByZWxvYWRPcHRpb25zKTtcbn0gLy8gVGhpcyBlc2NhcGluZyBmdW5jdGlvbiBpcyBvbmx5IHNhZmUgdG8gdXNlIGZvciBocmVmIHZhbHVlcyBiZWluZyB3cml0dGVuIGludG9cbi8vIGEgXCJMaW5rXCIgaGVhZGVyIGluIGJldHdlZW4gYDxgIGFuZCBgPmAgY2hhcmFjdGVycy4gVGhlIHByaW1hcnkgY29uY2VybiB3aXRoIHRoZSBocmVmIGlzXG4vLyB0byBlc2NhcGUgdGhlIGJvdW5kaW5nIGNoYXJhY3RlcnMgYXMgd2VsbCBhcyBuZXcgbGluZXMuIFRoaXMgaXMgdW5zYWZlIHRvIHVzZSBpbiBhbnkgb3RoZXJcbi8vIGNvbnRleHRcblxuXG52YXIgcmVnZXhGb3JIcmVmSW5MaW5rSGVhZGVyVVJMQ29udGV4dCA9IC9bPD5cXHJcXG5dL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dChocmVmSW5wdXQpIHtcbiAge1xuICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oaHJlZklucHV0LCAnaHJlZicpO1xuICB9XG5cbiAgdmFyIGNvZXJjZWRIcmVmID0gJycgKyBocmVmSW5wdXQ7XG4gIHJldHVybiBjb2VyY2VkSHJlZi5yZXBsYWNlKHJlZ2V4Rm9ySHJlZkluTGlua0hlYWRlclVSTENvbnRleHQsIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dFJlcGxhY2VyKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0UmVwbGFjZXIobWF0Y2gpIHtcbiAgc3dpdGNoIChtYXRjaCkge1xuICAgIGNhc2UgJzwnOlxuICAgICAgcmV0dXJuICclM0MnO1xuXG4gICAgY2FzZSAnPic6XG4gICAgICByZXR1cm4gJyUzRSc7XG5cbiAgICBjYXNlICdcXG4nOlxuICAgICAgcmV0dXJuICclMEEnO1xuXG4gICAgY2FzZSAnXFxyJzpcbiAgICAgIHJldHVybiAnJTBEJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXNjYXBlTGlua0hyZWZGb3JIZWFkZXJDb250ZXh0UmVwbGFjZXIgZW5jb3VudGVyZWQgYSBtYXRjaCBpdCBkb2VzIG5vdCBrbm93IGhvdyB0byByZXBsYWNlLiB0aGlzIG1lYW5zIHRoZSBtYXRjaCByZWdleCBhbmQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgYXJlIG5vIGxvbmdlciBpbiBzeW5jLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0Jyk7XG4gICAgICB9XG4gIH1cbn0gLy8gVGhpcyBlc2NhcGluZyBmdW5jdGlvbiBpcyBvbmx5IHNhZmUgdG8gdXNlIGZvciBxdW90ZWQgcGFyYW0gdmFsdWVzIGluIGFuIEhUVFAgaGVhZGVyLlxuLy8gSXQgaXMgdW5zYWZlIHRvIHVzZSBmb3IgYW55IHZhbHVlIG5vdCBpbnNpZGUgcXVvdGUgbWFya3MgaW4gcGFyYXRlciB2YWx1ZSBwb3NpdGlvbi5cblxuXG52YXIgcmVnZXhGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQgPSAvW1wiJzssXFxyXFxuXS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQodmFsdWUsIG5hbWUpIHtcbiAge1xuICAgIGNoZWNrT3B0aW9uU3RyaW5nQ29lcmNpb24odmFsdWUsIG5hbWUpO1xuICB9XG5cbiAgdmFyIGNvZXJjZWQgPSAnJyArIHZhbHVlO1xuICByZXR1cm4gY29lcmNlZC5yZXBsYWNlKHJlZ2V4Rm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0LCBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHRSZXBsYWNlcik7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dFJlcGxhY2VyKG1hdGNoKSB7XG4gIHN3aXRjaCAobWF0Y2gpIHtcbiAgICBjYXNlICdcIic6XG4gICAgICByZXR1cm4gJyUyMic7XG5cbiAgICBjYXNlIFwiJ1wiOlxuICAgICAgcmV0dXJuICclMjcnO1xuXG4gICAgY2FzZSAnOyc6XG4gICAgICByZXR1cm4gJyUzQic7XG5cbiAgICBjYXNlICcsJzpcbiAgICAgIHJldHVybiAnJTJDJztcblxuICAgIGNhc2UgJ1xcbic6XG4gICAgICByZXR1cm4gJyUwQSc7XG5cbiAgICBjYXNlICdcXHInOlxuICAgICAgcmV0dXJuICclMEQnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHRSZXBsYWNlciBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QnKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBob2lzdFN0eWxlUXVldWVEZXBlbmRlbmN5KHN0eWxlUXVldWUpIHtcbiAgdGhpcy5zdHlsZXMuYWRkKHN0eWxlUXVldWUpO1xufVxuXG5mdW5jdGlvbiBob2lzdFN0eWxlc2hlZXREZXBlbmRlbmN5KHN0eWxlc2hlZXQpIHtcbiAgdGhpcy5zdHlsZXNoZWV0cy5hZGQoc3R5bGVzaGVldCk7XG59XG5cbmZ1bmN0aW9uIGhvaXN0UmVzb3VyY2VzKHJlbmRlclN0YXRlLCBzb3VyY2UpIHtcbiAgdmFyIGN1cnJlbnRCb3VuZGFyeVJlc291cmNlcyA9IHJlbmRlclN0YXRlLmJvdW5kYXJ5UmVzb3VyY2VzO1xuXG4gIGlmIChjdXJyZW50Qm91bmRhcnlSZXNvdXJjZXMpIHtcbiAgICBzb3VyY2Uuc3R5bGVzLmZvckVhY2goaG9pc3RTdHlsZVF1ZXVlRGVwZW5kZW5jeSwgY3VycmVudEJvdW5kYXJ5UmVzb3VyY2VzKTtcbiAgICBzb3VyY2Uuc3R5bGVzaGVldHMuZm9yRWFjaChob2lzdFN0eWxlc2hlZXREZXBlbmRlbmN5LCBjdXJyZW50Qm91bmRhcnlSZXNvdXJjZXMpO1xuICB9XG59IC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGF0IHZhcmlvdXMgdGltZXMgZGVwZW5kaW5nIG9uIHdoZXRoZXIgd2UgYXJlIHJlbmRlcmluZ1xuLy8gb3IgcHJlcmVuZGVyaW5nLiBJbiB0aGlzIGltcGxlbWVudGF0aW9uIHdlIG9ubHkgYWN0dWFsbHkgZW1pdCBoZWFkZXJzIG9uY2UgYW5kXG4vLyBzdWJzZXF1ZW50IGNhbGxzIGFyZSBpZ25vcmVkLiBXZSB0cmFjayB3aGV0aGVyIHRoZSByZXF1ZXN0IGhhcyBhIGNvbXBsZXRlZCBzaGVsbFxuLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2Ugd2lsbCBmb2xsb3cgaGVhZGVycyB3aXRoIGEgZmx1c2ggaW5jbHVkaW5nIHN0eWxlc2hlZXRzLlxuLy8gSW4gdGhlIGNvbnRleHQgb2YgcHJlcnJlbmRlciB3ZSBkb24ndCBoYXZlIGEgY29tcGxldGVkIHNoZWxsIHdoZW4gdGhlIHJlcXVlc3QgZmluaXNoZXNcbi8vIHdpdGggYSBwb3N0cG9uZSBpbiB0aGUgc2hlbGwuIEluIHRoZSBjb250ZXh0IG9mIGEgcmVuZGVyIHdlIGRvbid0IGhhdmUgYSBjb21wbGV0ZWQgc2hlbGxcbi8vIGlmIHRoaXMgaXMgY2FsbGVkIGJlZm9yZSB0aGUgc2hlbGwgZmluaXNoZXMgcmVuZGVyaW5nIHdoaWNoIHVzdWFsbHkgd2lsbCBoYXBwZW4gYW55dGltZVxuLy8gYW55dGhpbmcgc3VzcGVuZHMgaW4gdGhlIHNoZWxsLlxuXG5mdW5jdGlvbiBlbWl0RWFybHlQcmVsb2FkcyhyZW5kZXJTdGF0ZSwgcmVzdW1hYmxlU3RhdGUsIHNoZWxsQ29tcGxldGUpIHtcbiAgdmFyIG9uSGVhZGVycyA9IHJlbmRlclN0YXRlLm9uSGVhZGVycztcblxuICBpZiAob25IZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuXG4gICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgIC8vIEV2ZW4gaWYgb25IZWFkZXJzIHRocm93cyB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhpcyBhZ2FpbiBzb1xuICAgICAgLy8gd2UgZHJvcCB0aGUgaGVhZGVycyBzdGF0ZSBmcm9tIHRoaXMgcG9pbnQgb253YXJkcy5cbiAgICAgIHJlbmRlclN0YXRlLmhlYWRlcnMgPSBudWxsO1xuICAgICAgdmFyIGxpbmtIZWFkZXIgPSBoZWFkZXJzLnByZWNvbm5lY3RzO1xuXG4gICAgICBpZiAoaGVhZGVycy5mb250UHJlbG9hZHMpIHtcbiAgICAgICAgaWYgKGxpbmtIZWFkZXIpIHtcbiAgICAgICAgICBsaW5rSGVhZGVyICs9ICcsICc7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5rSGVhZGVyICs9IGhlYWRlcnMuZm9udFByZWxvYWRzO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2Fkcykge1xuICAgICAgICBpZiAobGlua0hlYWRlcikge1xuICAgICAgICAgIGxpbmtIZWFkZXIgKz0gJywgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmtIZWFkZXIgKz0gaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2FkcztcbiAgICAgIH1cblxuICAgICAgaWYgKCFzaGVsbENvbXBsZXRlKSB7XG4gICAgICAgIC8vIFdlIHVzZSByYXcgaXRlcmF0b3JzIGJlY2F1c2Ugd2Ugd2FudCB0byBiZSBhYmxlIHRvIGhhbHQgaXRlcmF0aW9uXG4gICAgICAgIC8vIFdlIGNvdWxkIHJlZmFjdG9yIHJlbmRlclN0YXRlIHRvIHN0b3JlIHRoZXNlIGR1YWxseSBpbiBhcnJheXMgdG9cbiAgICAgICAgLy8gbWFrZSB0aGlzIG1vcmUgZWZmaWNpZW50IGF0IHRoZSBjb3N0IG9mIGFkZGl0aW9uYWwgbWVtb3J5IGFuZFxuICAgICAgICAvLyB3cml0ZSBvdmVyaGVhZC4gSG93ZXZlciB0aGlzIGNvZGUgb25seSBydW5zIG9uY2UgcGVyIHJlcXVlc3Qgc29cbiAgICAgICAgLy8gZm9yIG5vdyBJIGNvbnNpZGVyIHRoaXMgc3VmZmljaWVudC5cbiAgICAgICAgdmFyIHF1ZXVlSXRlciA9IHJlbmRlclN0YXRlLnN0eWxlcy52YWx1ZXMoKTtcblxuICAgICAgICBvdXRlcjogZm9yICh2YXIgcXVldWVTdGVwID0gcXVldWVJdGVyLm5leHQoKTsgaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSA+IDAgJiYgIXF1ZXVlU3RlcC5kb25lOyBxdWV1ZVN0ZXAgPSBxdWV1ZUl0ZXIubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIHNoZWV0cyA9IHF1ZXVlU3RlcC52YWx1ZS5zaGVldHM7XG4gICAgICAgICAgdmFyIHNoZWV0SXRlciA9IHNoZWV0cy52YWx1ZXMoKTtcblxuICAgICAgICAgIGZvciAodmFyIHNoZWV0U3RlcCA9IHNoZWV0SXRlci5uZXh0KCk7IGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgPiAwICYmICFzaGVldFN0ZXAuZG9uZTsgc2hlZXRTdGVwID0gc2hlZXRJdGVyLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHNoZWV0ID0gc2hlZXRTdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHByb3BzID0gc2hlZXQucHJvcHM7XG4gICAgICAgICAgICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkocHJvcHMuaHJlZik7XG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gZ2V0U3R5bGVzaGVldFByZWxvYWRBc0hlYWRlcihzaGVldCk7IC8vIFdlIG11dGF0ZSB0aGUgY2FwYWNpdHkgYi9jIHdlIGRvbid0IHdhbnQgdG8ga2VlcCBjaGVja2luZyBpZiBsYXRlciBoZWFkZXJzIHdpbGwgZml0LlxuICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IGEgcGFydGljdWxhcmx5IGxvbmcgaGVhZGVyIG1pZ2h0IGNsb3NlIG91dCB0aGUgaGVhZGVyIHF1ZXVlIHdoZXJlIGxhdGVyXG4gICAgICAgICAgICAvLyBoZWFkZXJzIGNvdWxkIHN0aWxsIGZpdC4gV2UgY291bGQgaW4gdGhlIGZ1dHVyZSBhbHRlciB0aGUgYmVoYXZpb3IgaGVyZSBiYXNlZCBvbiBwcmVyZW5kZXIgdnMgcmVuZGVyXG4gICAgICAgICAgICAvLyBzaW5jZSBkdXJpbmcgcHJlcmVuZGVyIHdlIGFyZW4ndCBhcyBjb25jZXJuZWQgd2l0aCBwdXJlIHJ1bnRpbWUgcGVyZm9ybWFuY2UuXG5cbiAgICAgICAgICAgIGlmICgoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoKSA+PSAyKSB7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnJlc2V0cy5zdHlsZVtrZXldID0gUFJFTE9BRF9OT19DUkVEUztcblxuICAgICAgICAgICAgICBpZiAobGlua0hlYWRlcikge1xuICAgICAgICAgICAgICAgIGxpbmtIZWFkZXIgKz0gJywgJztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxpbmtIZWFkZXIgKz0gaGVhZGVyOyAvLyBXZSBhbHJlYWR5IHRyYWNrIHRoYXQgdGhlIHJlc291cmNlIGV4aXN0cyBpbiByZXN1bWFibGVTdGF0ZSBob3dldmVyXG4gICAgICAgICAgICAgIC8vIGlmIHRoZSByZXN1bWFibGVTdGF0ZSByZXNldHMgYmVjYXVzZSB3ZSBwb3N0cG9uZWQgaW4gdGhlIHNoZWxsXG4gICAgICAgICAgICAgIC8vIHdoaWNoIGlzIHdoYXQgaXMgaGFwcGVuaW5nIGluIHRoaXMgYnJhbmNoIGlmIHdlIGFyZSBwcmVyZW5kZXJpbmdcbiAgICAgICAgICAgICAgLy8gdGhlbiB3ZSB3aWxsIGVuZCB1cCByZXNldHRpbmcgdGhlIHJlc3VtYWJsZVN0YXRlLiBXaGVuIGl0IHJlc2V0cyB3ZVxuICAgICAgICAgICAgICAvLyB3YW50IHRvIHJlY29yZCB0aGUgZmFjdCB0aGF0IHRoaXMgc3R5bGVzaGVldCB3YXMgYWxyZWFkeSBwcmVsb2FkZWRcblxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5yZXNldHMuc3R5bGVba2V5XSA9IHR5cGVvZiBwcm9wcy5jcm9zc09yaWdpbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmludGVncml0eSA9PT0gJ3N0cmluZycgPyBbcHJvcHMuY3Jvc3NPcmlnaW4sIHByb3BzLmludGVncml0eV0gOiBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW5rSGVhZGVyKSB7XG4gICAgICAgIG9uSGVhZGVycyh7XG4gICAgICAgICAgTGluazogbGlua0hlYWRlclxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIHN0aWxsIGNhbGwgdGhpcyB3aXRoIG5vIGhlYWRlcnMgYmVjYXVzZSBhIHVzZXIgbWF5IGJlIHVzaW5nIGl0IGFzIGEgc2lnbmFsIHRoYXRcbiAgICAgICAgLy8gaXQgUmVhY3Qgd2lsbCBub3QgcHJvdmlkZSBhbnkgaGVhZGVyc1xuICAgICAgICBvbkhlYWRlcnMoe30pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlclN0YXRlKHJlc3VtYWJsZVN0YXRlLCBnZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICB2YXIgcmVuZGVyU3RhdGUgPSBjcmVhdGVSZW5kZXJTdGF0ZSQxKHJlc3VtYWJsZVN0YXRlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gIHJldHVybiB7XG4gICAgLy8gS2VlcCB0aGlzIGluIHN5bmMgd2l0aCBSZWFjdEZpenpDb25maWdET01cbiAgICBwbGFjZWhvbGRlclByZWZpeDogcmVuZGVyU3RhdGUucGxhY2Vob2xkZXJQcmVmaXgsXG4gICAgc2VnbWVudFByZWZpeDogcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCxcbiAgICBib3VuZGFyeVByZWZpeDogcmVuZGVyU3RhdGUuYm91bmRhcnlQcmVmaXgsXG4gICAgc3RhcnRJbmxpbmVTY3JpcHQ6IHJlbmRlclN0YXRlLnN0YXJ0SW5saW5lU2NyaXB0LFxuICAgIGh0bWxDaHVua3M6IHJlbmRlclN0YXRlLmh0bWxDaHVua3MsXG4gICAgaGVhZENodW5rczogcmVuZGVyU3RhdGUuaGVhZENodW5rcyxcbiAgICBleHRlcm5hbFJ1bnRpbWVTY3JpcHQ6IHJlbmRlclN0YXRlLmV4dGVybmFsUnVudGltZVNjcmlwdCxcbiAgICBib290c3RyYXBDaHVua3M6IHJlbmRlclN0YXRlLmJvb3RzdHJhcENodW5rcyxcbiAgICBvbkhlYWRlcnM6IHJlbmRlclN0YXRlLm9uSGVhZGVycyxcbiAgICBoZWFkZXJzOiByZW5kZXJTdGF0ZS5oZWFkZXJzLFxuICAgIHJlc2V0czogcmVuZGVyU3RhdGUucmVzZXRzLFxuICAgIGNoYXJzZXRDaHVua3M6IHJlbmRlclN0YXRlLmNoYXJzZXRDaHVua3MsXG4gICAgcHJlY29ubmVjdENodW5rczogcmVuZGVyU3RhdGUucHJlY29ubmVjdENodW5rcyxcbiAgICBpbXBvcnRNYXBDaHVua3M6IHJlbmRlclN0YXRlLmltcG9ydE1hcENodW5rcyxcbiAgICBwcmVsb2FkQ2h1bmtzOiByZW5kZXJTdGF0ZS5wcmVsb2FkQ2h1bmtzLFxuICAgIGhvaXN0YWJsZUNodW5rczogcmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzLFxuICAgIHByZWNvbm5lY3RzOiByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cyxcbiAgICBmb250UHJlbG9hZHM6IHJlbmRlclN0YXRlLmZvbnRQcmVsb2FkcyxcbiAgICBoaWdoSW1hZ2VQcmVsb2FkczogcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMsXG4gICAgLy8gdXNlZEltYWdlUHJlbG9hZHM6IHJlbmRlclN0YXRlLnVzZWRJbWFnZVByZWxvYWRzLFxuICAgIHN0eWxlczogcmVuZGVyU3RhdGUuc3R5bGVzLFxuICAgIGJvb3RzdHJhcFNjcmlwdHM6IHJlbmRlclN0YXRlLmJvb3RzdHJhcFNjcmlwdHMsXG4gICAgc2NyaXB0czogcmVuZGVyU3RhdGUuc2NyaXB0cyxcbiAgICBidWxrUHJlbG9hZHM6IHJlbmRlclN0YXRlLmJ1bGtQcmVsb2FkcyxcbiAgICBwcmVsb2FkczogcmVuZGVyU3RhdGUucHJlbG9hZHMsXG4gICAgYm91bmRhcnlSZXNvdXJjZXM6IHJlbmRlclN0YXRlLmJvdW5kYXJ5UmVzb3VyY2VzLFxuICAgIHN0eWxlc1RvSG9pc3Q6IHJlbmRlclN0YXRlLnN0eWxlc1RvSG9pc3QsXG4gICAgLy8gVGhpcyBpcyBhbiBleHRyYSBmaWVsZCBmb3IgdGhlIGxlZ2FjeSByZW5kZXJlclxuICAgIGdlbmVyYXRlU3RhdGljTWFya3VwOiBnZW5lcmF0ZVN0YXRpY01hcmt1cFxuICB9O1xufVxuXG52YXIgZG9jdHlwZUNodW5rID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcnKTtcbmZ1bmN0aW9uIHB1c2hUZXh0SW5zdGFuY2UodGFyZ2V0LCB0ZXh0LCByZW5kZXJTdGF0ZSwgdGV4dEVtYmVkZGVkKSB7XG4gIGlmIChyZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCkpKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHB1c2hUZXh0SW5zdGFuY2UkMSh0YXJnZXQsIHRleHQsIHJlbmRlclN0YXRlLCB0ZXh0RW1iZWRkZWQpO1xuICB9XG59XG5mdW5jdGlvbiBwdXNoU2VnbWVudEZpbmFsZSh0YXJnZXQsIHJlbmRlclN0YXRlLCBsYXN0UHVzaGVkVGV4dCwgdGV4dEVtYmVkZGVkKSB7XG4gIGlmIChyZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHVzaFNlZ21lbnRGaW5hbGUkMSh0YXJnZXQsIHJlbmRlclN0YXRlLCBsYXN0UHVzaGVkVGV4dCwgdGV4dEVtYmVkZGVkKTtcbiAgfVxufVxuZnVuY3Rpb24gd3JpdGVTdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlKSB7XG4gIGlmIChyZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICAgIC8vIEEgY29tcGxldGVkIGJvdW5kYXJ5IGlzIGRvbmUgYW5kIGRvZXNuJ3QgbmVlZCBhIHJlcHJlc2VudGF0aW9uIGluIHRoZSBIVE1MXG4gICAgLy8gaWYgd2UncmUgbm90IGdvaW5nIHRvIGJlIGh5ZHJhdGluZyBpdC5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB3cml0ZVN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSQxKGRlc3RpbmF0aW9uKTtcbn1cbmZ1bmN0aW9uIHdyaXRlU3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLCAvLyBmbHVzaGluZyB0aGVzZSBlcnJvciBhcmd1bWVudHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGluIHRoaXMgbGVnYWN5IHN0cmVhbWluZyBmb3JtYXQuXG5lcnJvckRpZ2VzdCwgZXJyb3JNZXNzYWdlLCBlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gIGlmIChyZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICAgIC8vIEEgY2xpZW50IHJlbmRlcmVkIGJvdW5kYXJ5IGlzIGRvbmUgYW5kIGRvZXNuJ3QgbmVlZCBhIHJlcHJlc2VudGF0aW9uIGluIHRoZSBIVE1MXG4gICAgLy8gc2luY2Ugd2UnbGwgbmV2ZXIgaHlkcmF0ZSBpdC4gVGhpcyBpcyBhcmd1YWJseSBhbiBlcnJvciBpbiBzdGF0aWMgZ2VuZXJhdGlvbi5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB3cml0ZVN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5JDEoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLCBlcnJvckRpZ2VzdCwgZXJyb3JNZXNzYWdlLCBlcnJvckNvbXBvbmVudFN0YWNrKTtcbn1cbmZ1bmN0aW9uIHdyaXRlRW5kQ29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUpIHtcbiAgaWYgKHJlbmRlclN0YXRlLmdlbmVyYXRlU3RhdGljTWFya3VwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gd3JpdGVFbmRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5JDEoZGVzdGluYXRpb24pO1xufVxuZnVuY3Rpb24gd3JpdGVFbmRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlKSB7XG4gIGlmIChyZW5kZXJTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHdyaXRlRW5kQ2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5JDEoZGVzdGluYXRpb24pO1xufVxudmFyIE5vdFBlbmRpbmdUcmFuc2l0aW9uID0gTm90UGVuZGluZztcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNlcnZlcl9jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJyk7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEID0gU3ltYm9sLmZvcigncmVhY3QuZGVmYXVsdF92YWx1ZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTsgLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuLyoqXG4gKiBMZXZlcmFnZXMgbmF0aXZlIGJyb3dzZXIvVk0gc3RhY2sgZnJhbWVzIHRvIGdldCBwcm9wZXIgZGV0YWlscyAoZS5nLlxuICogZmlsZW5hbWUsIGxpbmUgKyBjb2wgbnVtYmVyKSBmb3IgYSBzaW5nbGUgY29tcG9uZW50IGluIGEgY29tcG9uZW50IHN0YWNrLiBXZVxuICogZG8gdGhpcyBieTpcbiAqICAgKDEpIHRocm93aW5nIGFuZCBjYXRjaGluZyBhbiBlcnJvciBpbiB0aGUgZnVuY3Rpb24gLSB0aGlzIHdpbGwgYmUgb3VyXG4gKiAgICAgICBjb250cm9sIGVycm9yLlxuICogICAoMikgY2FsbGluZyB0aGUgY29tcG9uZW50IHdoaWNoIHdpbGwgZXZlbnR1YWxseSB0aHJvdyBhbiBlcnJvciB0aGF0IHdlJ2xsXG4gKiAgICAgICBjYXRjaCAtIHRoaXMgd2lsbCBiZSBvdXIgc2FtcGxlIGVycm9yLlxuICogICAoMykgZGlmZmluZyB0aGUgY29udHJvbCBhbmQgc2FtcGxlIGVycm9yIHN0YWNrcyB0byBmaW5kIHRoZSBzdGFjayBmcmFtZVxuICogICAgICAgd2hpY2ggcmVwcmVzZW50cyBvdXIgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoY3Rvciwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShjdG9yLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QkMSh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dDtcblxue1xuICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcbn1cblxudmFyIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gZ2V0TWFza2VkQ29udGV4dCh0eXBlLCB1bm1hc2tlZENvbnRleHQpIHtcbiAge1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcblxuICAgIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgICByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICBjb250ZXh0W2tleV0gPSB1bm1hc2tlZENvbnRleHRba2V5XTtcbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnVW5rbm93bic7XG4gICAgICBjaGVja1Byb3BUeXBlcyhjb250ZXh0VHlwZXMsIGNvbnRleHQsICdjb250ZXh0JywgbmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoaW5zdGFuY2UsIHR5cGUsIHBhcmVudENvbnRleHQsIGNoaWxkQ29udGV4dFR5cGVzKSB7XG4gIHtcbiAgICAvLyBUT0RPIChidmF1Z2huKSBSZXBsYWNlIHRoaXMgYmVoYXZpb3Igd2l0aCBhbiBpbnZhcmlhbnQoKSBpbiB0aGUgZnV0dXJlLlxuICAgIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgaWYgKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50Q29udGV4dDtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0KCk7XG5cbiAgICBmb3IgKHZhciBjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgaWYgKCEoY29udGV4dEtleSBpbiBjaGlsZENvbnRleHRUeXBlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nKSArIFwiLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXFxcIlwiICsgY29udGV4dEtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgJ2NoaWxkIGNvbnRleHQnLCBuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXNzaWduKHt9LCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICB9XG59XG5cbnZhciByZW5kZXJlclNpZ2lsO1xuXG57XG4gIC8vIFVzZSB0aGlzIHRvIGRldGVjdCBtdWx0aXBsZSByZW5kZXJlcnMgdXNpbmcgdGhlIHNhbWUgY29udGV4dFxuICByZW5kZXJlclNpZ2lsID0ge307XG59IC8vIFVzZWQgdG8gc3RvcmUgdGhlIHBhcmVudCBwYXRoIG9mIGFsbCBjb250ZXh0IG92ZXJyaWRlcyBpbiBhIHNoYXJlZCBsaW5rZWQgbGlzdC5cbi8vIEZvcm1pbmcgYSByZXZlcnNlIHRyZWUuXG4vLyBUaGUgc3RydWN0dXJlIG9mIGEgY29udGV4dCBzbmFwc2hvdCBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZpbGUuXG4vLyBDdXJyZW50bHksIGl0J3MgaW1wbGVtZW50ZWQgYXMgdHJhY2tpbmcgdGhlIGN1cnJlbnQgYWN0aXZlIG5vZGUuXG5cblxudmFyIHJvb3RDb250ZXh0U25hcHNob3QgPSBudWxsOyAvLyBXZSBhc3N1bWUgdGhhdCB0aGlzIHJ1bnRpbWUgb3ducyB0aGUgXCJjdXJyZW50XCIgZmllbGQgb24gYWxsIFJlYWN0Q29udGV4dCBpbnN0YW5jZXMuXG4vLyBUaGlzIGdsb2JhbCAoYWN0dWFsbHkgdGhyZWFkIGxvY2FsKSBzdGF0ZSByZXByZXNlbnRzIHdoYXQgc3RhdGUgYWxsIHRob3NlIFwiY3VycmVudFwiLFxuLy8gZmllbGRzIGFyZSBjdXJyZW50bHkgaW4uXG5cbnZhciBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBudWxsO1xuXG5mdW5jdGlvbiBwb3BOb2RlKHByZXYpIHtcbiAge1xuICAgIHByZXYuY29udGV4dC5fY3VycmVudFZhbHVlMiA9IHByZXYucGFyZW50VmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaE5vZGUobmV4dCkge1xuICB7XG4gICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dC52YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwcmV2LCBuZXh0KSB7XG4gIGlmIChwcmV2ID09PSBuZXh0KSA7IGVsc2Uge1xuICAgIHBvcE5vZGUocHJldik7XG4gICAgdmFyIHBhcmVudFByZXYgPSBwcmV2LnBhcmVudDtcbiAgICB2YXIgcGFyZW50TmV4dCA9IG5leHQucGFyZW50O1xuXG4gICAgaWYgKHBhcmVudFByZXYgPT09IG51bGwpIHtcbiAgICAgIGlmIChwYXJlbnROZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN0YWNrcyBtdXN0IHJlYWNoIHRoZSByb290IGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXJlbnROZXh0ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN0YWNrcyBtdXN0IHJlYWNoIHRoZSByb290IGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHBhcmVudFByZXYsIHBhcmVudE5leHQpO1xuICAgIH0gLy8gT24gdGhlIHdheSBiYWNrLCB3ZSBwdXNoIHRoZSBuZXcgb25lcyB0aGF0IHdlcmVuJ3QgY29tbW9uLlxuXG5cbiAgICBwdXNoTm9kZShuZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BBbGxQcmV2aW91cyhwcmV2KSB7XG4gIHBvcE5vZGUocHJldik7XG4gIHZhciBwYXJlbnRQcmV2ID0gcHJldi5wYXJlbnQ7XG5cbiAgaWYgKHBhcmVudFByZXYgIT09IG51bGwpIHtcbiAgICBwb3BBbGxQcmV2aW91cyhwYXJlbnRQcmV2KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoQWxsTmV4dChuZXh0KSB7XG4gIHZhciBwYXJlbnROZXh0ID0gbmV4dC5wYXJlbnQ7XG5cbiAgaWYgKHBhcmVudE5leHQgIT09IG51bGwpIHtcbiAgICBwdXNoQWxsTmV4dChwYXJlbnROZXh0KTtcbiAgfVxuXG4gIHB1c2hOb2RlKG5leHQpO1xufVxuXG5mdW5jdGlvbiBwb3BQcmV2aW91c1RvQ29tbW9uTGV2ZWwocHJldiwgbmV4dCkge1xuICBwb3BOb2RlKHByZXYpO1xuICB2YXIgcGFyZW50UHJldiA9IHByZXYucGFyZW50O1xuXG4gIGlmIChwYXJlbnRQcmV2ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGVwdGggbXVzdCBlcXVhbCBhdCBsZWFzdCBhdCB6ZXJvIGJlZm9yZSByZWFjaGluZyB0aGUgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgfVxuXG4gIGlmIChwYXJlbnRQcmV2LmRlcHRoID09PSBuZXh0LmRlcHRoKSB7XG4gICAgLy8gV2UgZm91bmQgdGhlIHNhbWUgbGV2ZWwuIE5vdyB3ZSBqdXN0IG5lZWQgdG8gZmluZCBhIHNoYXJlZCBhbmNlc3Rvci5cbiAgICBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwYXJlbnRQcmV2LCBuZXh0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBtdXN0IHN0aWxsIGJlIGRlZXBlci5cbiAgICBwb3BQcmV2aW91c1RvQ29tbW9uTGV2ZWwocGFyZW50UHJldiwgbmV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wTmV4dFRvQ29tbW9uTGV2ZWwocHJldiwgbmV4dCkge1xuICB2YXIgcGFyZW50TmV4dCA9IG5leHQucGFyZW50O1xuXG4gIGlmIChwYXJlbnROZXh0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGVwdGggbXVzdCBlcXVhbCBhdCBsZWFzdCBhdCB6ZXJvIGJlZm9yZSByZWFjaGluZyB0aGUgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgfVxuXG4gIGlmIChwcmV2LmRlcHRoID09PSBwYXJlbnROZXh0LmRlcHRoKSB7XG4gICAgLy8gV2UgZm91bmQgdGhlIHNhbWUgbGV2ZWwuIE5vdyB3ZSBqdXN0IG5lZWQgdG8gZmluZCBhIHNoYXJlZCBhbmNlc3Rvci5cbiAgICBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwcmV2LCBwYXJlbnROZXh0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBtdXN0IHN0aWxsIGJlIGRlZXBlci5cbiAgICBwb3BOZXh0VG9Db21tb25MZXZlbChwcmV2LCBwYXJlbnROZXh0KTtcbiAgfVxuXG4gIHB1c2hOb2RlKG5leHQpO1xufSAvLyBQZXJmb3JtIGNvbnRleHQgc3dpdGNoaW5nIHRvIHRoZSBuZXcgc25hcHNob3QuXG4vLyBUbyBtYWtlIGl0IGNoZWFwIHRvIHJlYWQgbWFueSBjb250ZXh0cywgd2hpbGUgbm90IHN1c3BlbmRpbmcsIHdlIG1ha2UgdGhlIHN3aXRjaCBlYWdlcmx5IGJ5XG4vLyB1cGRhdGluZyBhbGwgdGhlIGNvbnRleHQncyBjdXJyZW50IHZhbHVlcy4gVGhhdCB3YXkgcmVhZHMsIGFsd2F5cyBqdXN0IHJlYWQgdGhlIGN1cnJlbnQgdmFsdWUuXG4vLyBBdCB0aGUgY29zdCBvZiB1cGRhdGluZyBjb250ZXh0cyBldmVuIGlmIHRoZXkncmUgbmV2ZXIgcmVhZCBieSB0aGlzIHN1YnRyZWUuXG5cblxuZnVuY3Rpb24gc3dpdGNoQ29udGV4dChuZXdTbmFwc2hvdCkge1xuICAvLyBUaGUgYmFzaWMgYWxnb3JpdGhtIHdlIG5lZWQgdG8gZG8gaXMgdG8gcG9wIGJhY2sgYW55IGNvbnRleHRzIHRoYXQgYXJlIG5vIGxvbmdlciBvbiB0aGUgc3RhY2suXG4gIC8vIFdlIGFsc28gbmVlZCB0byB1cGRhdGUgYW55IG5ldyBjb250ZXh0cyB0aGF0IGFyZSBub3cgb24gdGhlIHN0YWNrIHdpdGggdGhlIGRlZXBlc3QgdmFsdWUuXG4gIC8vIFRoZSBlYXNpZXN0IHdheSB0byB1cGRhdGUgbmV3IGNvbnRleHRzIGlzIHRvIGp1c3QgcmVhcHBseSB0aGVtIGluIHJldmVyc2Ugb3JkZXIgZnJvbSB0aGVcbiAgLy8gcGVyc3BlY3RpdmUgb2YgdGhlIGJhY2twb2ludGVycy4gVG8gYXZvaWQgYWxsb2NhdGluZyBhIGxvdCB3aGVuIHN3aXRjaGluZywgd2UgdXNlIHRoZSBzdGFja1xuICAvLyBmb3IgdGhhdC4gVGhlcmVmb3JlIHRoaXMgYWxnb3JpdGhtIGlzIHJlY3Vyc2l2ZS5cbiAgLy8gMSkgRmlyc3Qgd2UgcG9wIHdoaWNoIGV2ZXIgc25hcHNob3QgdHJlZSB3YXMgZGVlcGVzdC4gUG9wcGluZyBvbGQgY29udGV4dHMgYXMgd2UgZ28uXG4gIC8vIDIpIFRoZW4gd2UgZmluZCB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgZnJvbSB0aGVyZS4gUG9wcGluZyBvbGQgY29udGV4dHMgYXMgd2UgZ28uXG4gIC8vIDMpIFRoZW4gd2UgcmVhcHBseSBuZXcgY29udGV4dHMgb24gdGhlIHdheSBiYWNrIHVwIHRoZSBzdGFjay5cbiAgdmFyIHByZXYgPSBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG4gIHZhciBuZXh0ID0gbmV3U25hcHNob3Q7XG5cbiAgaWYgKHByZXYgIT09IG5leHQpIHtcbiAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IFRoaXMgaGFzIHRvIGJlIG5vbi1udWxsIHNpbmNlIGl0J3Mgbm90IGVxdWFsIHRvIHByZXYuXG4gICAgICBwdXNoQWxsTmV4dChuZXh0KTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgIHBvcEFsbFByZXZpb3VzKHByZXYpO1xuICAgIH0gZWxzZSBpZiAocHJldi5kZXB0aCA9PT0gbmV4dC5kZXB0aCkge1xuICAgICAgcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgbmV4dCk7XG4gICAgfSBlbHNlIGlmIChwcmV2LmRlcHRoID4gbmV4dC5kZXB0aCkge1xuICAgICAgcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3BOZXh0VG9Db21tb25MZXZlbChwcmV2LCBuZXh0KTtcbiAgICB9XG5cbiAgICBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBuZXh0O1xuICB9XG59XG5mdW5jdGlvbiBwdXNoUHJvdmlkZXIoY29udGV4dCwgbmV4dFZhbHVlKSB7XG4gIHZhciBwcmV2VmFsdWU7XG5cbiAge1xuICAgIHByZXZWYWx1ZSA9IGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IG5leHRWYWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSB1bmRlZmluZWQgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAhPT0gbnVsbCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSByZW5kZXJlclNpZ2lsKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJldk5vZGUgPSBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG4gIHZhciBuZXdOb2RlID0ge1xuICAgIHBhcmVudDogcHJldk5vZGUsXG4gICAgZGVwdGg6IHByZXZOb2RlID09PSBudWxsID8gMCA6IHByZXZOb2RlLmRlcHRoICsgMSxcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIHBhcmVudFZhbHVlOiBwcmV2VmFsdWUsXG4gICAgdmFsdWU6IG5leHRWYWx1ZVxuICB9O1xuICBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBuZXdOb2RlO1xuICByZXR1cm4gbmV3Tm9kZTtcbn1cbmZ1bmN0aW9uIHBvcFByb3ZpZGVyKGNvbnRleHQpIHtcbiAgdmFyIHByZXZTbmFwc2hvdCA9IGN1cnJlbnRBY3RpdmVTbmFwc2hvdDtcblxuICBpZiAocHJldlNuYXBzaG90ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmllZCB0byBwb3AgYSBDb250ZXh0IGF0IHRoZSByb290IG9mIHRoZSBhcHAuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICB7XG4gICAgaWYgKHByZXZTbmFwc2hvdC5jb250ZXh0ICE9PSBjb250ZXh0KSB7XG4gICAgICBlcnJvcignVGhlIHBhcmVudCBjb250ZXh0IGlzIG5vdCB0aGUgZXhwZWN0ZWQgY29udGV4dC4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgdmFyIF92YWx1ZSA9IHByZXZTbmFwc2hvdC5wYXJlbnRWYWx1ZTtcblxuICAgIGlmIChfdmFsdWUgPT09IFJFQUNUX1NFUlZFUl9DT05URVhUX0RFRkFVTFRfVkFMVUVfTk9UX0xPQURFRCkge1xuICAgICAgcHJldlNuYXBzaG90LmNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBwcmV2U25hcHNob3QuY29udGV4dC5fZGVmYXVsdFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2U25hcHNob3QuY29udGV4dC5fY3VycmVudFZhbHVlMiA9IF92YWx1ZTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgIT09IG51bGwgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAhPT0gcmVuZGVyZXJTaWdpbCkge1xuICAgICAgICBlcnJvcignRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlICcgKyAnc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IHJlbmRlcmVyU2lnaWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRBY3RpdmVTbmFwc2hvdCA9IHByZXZTbmFwc2hvdC5wYXJlbnQ7XG59XG5mdW5jdGlvbiBnZXRBY3RpdmVDb250ZXh0KCkge1xuICByZXR1cm4gY3VycmVudEFjdGl2ZVNuYXBzaG90O1xufVxuZnVuY3Rpb24gcmVhZENvbnRleHQkMShjb250ZXh0KSB7XG4gIHZhciB2YWx1ZSA9IGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBgUmVhY3RJbnN0YW5jZU1hcGAgbWFpbnRhaW5zIGEgbWFwcGluZyBmcm9tIGEgcHVibGljIGZhY2luZyBzdGF0ZWZ1bFxuICogaW5zdGFuY2UgKGtleSkgYW5kIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiAodmFsdWUpLiBUaGlzIGFsbG93cyBwdWJsaWNcbiAqIG1ldGhvZHMgdG8gYWNjZXB0IHRoZSB1c2VyIGZhY2luZyBpbnN0YW5jZSBhcyBhbiBhcmd1bWVudCBhbmQgbWFwIHRoZW0gYmFja1xuICogdG8gaW50ZXJuYWwgbWV0aG9kcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBtb2R1bGUgaXMgY3VycmVudGx5IHNoYXJlZCBhbmQgYXNzdW1lZCB0byBiZSBzdGF0ZWxlc3MuXG4gKiBJZiB0aGlzIGJlY29tZXMgYW4gYWN0dWFsIE1hcCwgdGhhdCB3aWxsIGJyZWFrLlxuICovXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxzO1xufVxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAga2V5Ll9yZWFjdEludGVybmFscyA9IHZhbHVlO1xufVxuXG52YXIgZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudCA9IHt9O1xudmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlO1xudmFyIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlO1xudmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzO1xudmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZTtcbnZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2s7XG5cbntcbiAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjayA9IG5ldyBTZXQoKTtcbn1cblxuZnVuY3Rpb24gd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IGNhbGxlck5hbWUgKyAnXycgKyBjYWxsYmFjaztcblxuICAgIGlmICghZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmhhcyhrZXkpKSB7XG4gICAgICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSk7XG5cbiAgICAgIGVycm9yKCclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUodHlwZSwgcGFydGlhbFN0YXRlKSB7XG4gIHtcbiAgICBpZiAocGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoX2NvbnN0cnVjdG9yKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgJy4nICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXJyb3IoJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG91dHNpZGUgY29tcG9uZW50V2lsbE1vdW50KCkgb24gdGhlIHNlcnZlci4gJyArICdUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cblxudmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlciA9IHtcbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBpbnRlcm5hbHMgPSBnZXQoaW5zdCk7XG5cbiAgICBpZiAoaW50ZXJuYWxzLnF1ZXVlID09PSBudWxsKSB7XG4gICAgICB3YXJuTm9vcChpbnN0LCAnc2V0U3RhdGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJuYWxzLnF1ZXVlLnB1c2gocGF5bG9hZCk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaW50ZXJuYWxzID0gZ2V0KGluc3QpO1xuICAgIGludGVybmFscy5yZXBsYWNlID0gdHJ1ZTtcbiAgICBpbnRlcm5hbHMucXVldWUgPSBbcGF5bG9hZF07XG5cbiAgICB7XG4gICAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChpbnN0LCBjYWxsYmFjaykge1xuICAgIHZhciBpbnRlcm5hbHMgPSBnZXQoaW5zdCk7XG5cbiAgICBpZiAoaW50ZXJuYWxzLnF1ZXVlID09PSBudWxsKSB7XG4gICAgICB3YXJuTm9vcChpbnN0LCAnZm9yY2VVcGRhdGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKGluc3RhbmNlLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIHByZXZTdGF0ZSwgbmV4dFByb3BzKSB7XG4gIHZhciBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuXG4gIHtcbiAgICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUoY3RvciwgcGFydGlhbFN0YXRlKTtcbiAgfSAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuXG5cbiAgdmFyIG5ld1N0YXRlID0gcGFydGlhbFN0YXRlID09PSBudWxsIHx8IHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkID8gcHJldlN0YXRlIDogYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0Q2xhc3NJbnN0YW5jZShjdG9yLCBwcm9wcywgbWFza2VkTGVnYWN5Q29udGV4dCkge1xuICB2YXIgY29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuICB7XG4gICAgaWYgKCdjb250ZXh0VHlwZScgaW4gY3Rvcikge1xuICAgICAgdmFyIGlzVmFsaWQgPSAvLyBBbGxvdyBudWxsIGZvciBjb25kaXRpb25hbCBkZWNsYXJhdGlvblxuICAgICAgY29udGV4dFR5cGUgPT09IG51bGwgfHwgY29udGV4dFR5cGUgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFICYmIGNvbnRleHRUeXBlLl9jb250ZXh0ID09PSB1bmRlZmluZWQ7IC8vIE5vdCBhIDxDb250ZXh0LkNvbnN1bWVyPlxuXG4gICAgICBpZiAoIWlzVmFsaWQgJiYgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZChjdG9yKTtcbiAgICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG5cbiAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gJyArICdUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiAnICsgJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcgKyAndHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHRUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSAnICsgdHlwZW9mIGNvbnRleHRUeXBlICsgJy4nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuUHJvdmlkZXIgaW5zdGVhZD8nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLl9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyA8Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY29udGV4dFR5cGUpLmpvaW4oJywgJykgKyAnfS4nO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3IoJyVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gJyArICdjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lcycsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JywgYWRkZW5kdW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgY29udGV4dCA9IHJlYWRDb250ZXh0JDEoY29udGV4dFR5cGUpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQgPSBtYXNrZWRMZWdhY3lDb250ZXh0O1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nICYmIChpbnN0YW5jZS5zdGF0ZSA9PT0gbnVsbCB8fCBpbnN0YW5jZS5zdGF0ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCdgJXNgIHVzZXMgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYnV0IGl0cyBpbml0aWFsIHN0YXRlIGlzICcgKyAnJXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkLiBJbnN0ZWFkLCBkZWZpbmUgdGhlIGluaXRpYWwgc3RhdGUgYnkgJyArICdhc3NpZ25pbmcgYW4gb2JqZWN0IHRvIGB0aGlzLnN0YXRlYCBpbiB0aGUgY29uc3RydWN0b3Igb2YgYCVzYC4gJyArICdUaGlzIGVuc3VyZXMgdGhhdCBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBhcmd1bWVudHMgaGF2ZSBhIGNvbnNpc3RlbnQgc2hhcGUuJywgY29tcG9uZW50TmFtZSwgaW5zdGFuY2Uuc3RhdGUgPT09IG51bGwgPyAnbnVsbCcgOiAndW5kZWZpbmVkJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfSAvLyBJZiBuZXcgY29tcG9uZW50IEFQSXMgYXJlIGRlZmluZWQsIFwidW5zYWZlXCIgbGlmZWN5Y2xlcyB3b24ndCBiZSBjYWxsZWQuXG4gICAgLy8gV2FybiBhYm91dCB0aGVzZSBsaWZlY3ljbGVzIGlmIHRoZXkgYXJlIHByZXNlbnQuXG4gICAgLy8gRG9uJ3Qgd2FybiBhYm91dCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIG1ldGhvZHMgdGhvdWdoLlxuXG5cbiAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGZvdW5kV2lsbE1vdW50TmFtZSA9IG51bGw7XG4gICAgICB2YXIgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9IG51bGw7XG4gICAgICB2YXIgZm91bmRXaWxsVXBkYXRlTmFtZSA9IG51bGw7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdjb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJztcbiAgICAgIH1cblxuICAgICAgaWYgKGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsIHx8IGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICAgIHZhciBuZXdBcGlOYW1lID0gdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nID8gJ2dldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpJyA6ICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpJztcblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuaGFzKF9jb21wb25lbnROYW1lKSkge1xuICAgICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuYWRkKF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICAgIGVycm9yKCdVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4nICsgJyVzIHVzZXMgJXMgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczolcyVzJXNcXG5cXG4nICsgJ1RoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbicgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcycsIF9jb21wb25lbnROYW1lLCBuZXdBcGlOYW1lLCBmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxNb3VudE5hbWUgOiAnJywgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgOiAnJywgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQ2xhc3NJbnN0YW5jZShpbnN0YW5jZSwgY3RvciwgbmV3UHJvcHMpIHtcbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuXG4gICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgdHlwZW9mIGN0b3IucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj8nLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlICYmICFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiYgIWluc3RhbmNlLnN0YXRlKSB7XG4gICAgICBlcnJvcignZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgJiYgIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wVHlwZXMpIHtcbiAgICAgIGVycm9yKCdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuY29udGV4dFR5cGUpIHtcbiAgICAgIGVycm9yKCdjb250ZXh0VHlwZSB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlcykge1xuICAgICAgICBlcnJvcignY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdG9yLmNvbnRleHRUeXBlICYmIGN0b3IuY29udGV4dFR5cGVzICYmICFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcy5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuYWRkKGN0b3IpO1xuXG4gICAgICAgIGVycm9yKCclcyBkZWNsYXJlcyBib3RoIGNvbnRleHRUeXBlcyBhbmQgY29udGV4dFR5cGUgc3RhdGljIHByb3BlcnRpZXMuICcgKyAnVGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmIHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdBIHB1cmUgY29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRSZWNlaXZlUHJvcHMoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgJyArICd1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciAnICsgJ3J1biBzaWRlLWVmZmVjdHMgb3IgbXV0YXRpb25zIGFmdGVyIFJlYWN0IGhhcyB1cGRhdGVkIHRoZSBVSSwgdXNlIGNvbXBvbmVudERpZFVwZGF0ZSgpLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IG5ld1Byb3BzO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSB1bmRlZmluZWQgJiYgaGFzTXV0YXRlZFByb3BzKSB7XG4gICAgICBlcnJvcignJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGVycm9yKCdTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuJyArICcgSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy4nLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgIT09ICdmdW5jdGlvbicgJiYgIWRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5oYXMoY3RvcikpIHtcbiAgICAgIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5hZGQoY3Rvcik7XG5cbiAgICAgIGVycm9yKCclczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBzaG91bGQgYmUgdXNlZCB3aXRoIGNvbXBvbmVudERpZFVwZGF0ZSgpLiAnICsgJ1RoaXMgY29tcG9uZW50IGRlZmluZXMgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBvbmx5LicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgICBpZiAoc3RhdGUgJiYgKHR5cGVvZiBzdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheShzdGF0ZSkpKSB7XG4gICAgICBlcnJvcignJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGN0b3IuY2hpbGRDb250ZXh0VHlwZXMgIT09ICdvYmplY3QnKSB7XG4gICAgICBlcnJvcignJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBuYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxNb3VudCh0eXBlLCBpbnN0YW5jZSkge1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIGlmIChpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybiggLy8ga2VlcCB0aGlzIHdhcm5pbmcgaW4gc3luYyB3aXRoIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmcuanNcbiAgICAgICAgICAnY29tcG9uZW50V2lsbE1vdW50IGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBjb2RlIGZyb20gY29tcG9uZW50V2lsbE1vdW50IHRvIGNvbXBvbmVudERpZE1vdW50IChwcmVmZXJyZWQgaW4gbW9zdCBjYXNlcykgJyArICdvciB0aGUgY29uc3RydWN0b3IuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cblxuICBpZiAob2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyAnICsgXCJkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ0NvbXBvbmVudCcpO1xuICAgIH1cblxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGludGVybmFsSW5zdGFuY2UsIGluc3QsIHByb3BzLCBtYXNrZWRMZWdhY3lDb250ZXh0KSB7XG4gIGlmIChpbnRlcm5hbEluc3RhbmNlLnF1ZXVlICE9PSBudWxsICYmIGludGVybmFsSW5zdGFuY2UucXVldWUubGVuZ3RoID4gMCkge1xuICAgIHZhciBvbGRRdWV1ZSA9IGludGVybmFsSW5zdGFuY2UucXVldWU7XG4gICAgdmFyIG9sZFJlcGxhY2UgPSBpbnRlcm5hbEluc3RhbmNlLnJlcGxhY2U7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSA9IG51bGw7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5yZXBsYWNlID0gZmFsc2U7XG5cbiAgICBpZiAob2xkUmVwbGFjZSAmJiBvbGRRdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGluc3Quc3RhdGUgPSBvbGRRdWV1ZVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRTdGF0ZSA9IG9sZFJlcGxhY2UgPyBvbGRRdWV1ZVswXSA6IGluc3Quc3RhdGU7XG4gICAgICB2YXIgZG9udE11dGF0ZSA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSBvbGRSZXBsYWNlID8gMSA6IDA7IGkgPCBvbGRRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFydGlhbCA9IG9sZFF1ZXVlW2ldO1xuICAgICAgICB2YXIgcGFydGlhbFN0YXRlID0gdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgPyBwYXJ0aWFsLmNhbGwoaW5zdCwgbmV4dFN0YXRlLCBwcm9wcywgbWFza2VkTGVnYWN5Q29udGV4dCkgOiBwYXJ0aWFsO1xuXG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChkb250TXV0YXRlKSB7XG4gICAgICAgICAgICBkb250TXV0YXRlID0gZmFsc2U7XG4gICAgICAgICAgICBuZXh0U3RhdGUgPSBhc3NpZ24oe30sIG5leHRTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXNzaWduKG5leHRTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSA9IG51bGw7XG4gIH1cbn0gLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuXG5cbmZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZShpbnN0YW5jZSwgY3RvciwgbmV3UHJvcHMsIG1hc2tlZExlZ2FjeUNvbnRleHQpIHtcbiAge1xuICAgIGNoZWNrQ2xhc3NJbnN0YW5jZShpbnN0YW5jZSwgY3RvciwgbmV3UHJvcHMpO1xuICB9XG5cbiAgdmFyIGluaXRpYWxTdGF0ZSA9IGluc3RhbmNlLnN0YXRlICE9PSB1bmRlZmluZWQgPyBpbnN0YW5jZS5zdGF0ZSA6IG51bGw7XG4gIGluc3RhbmNlLnVwZGF0ZXIgPSBjbGFzc0NvbXBvbmVudFVwZGF0ZXI7XG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gaW5pdGlhbFN0YXRlOyAvLyBXZSBkb24ndCBib3RoZXIgaW5pdGlhbGl6aW5nIHRoZSByZWZzIG9iamVjdCBvbiB0aGUgc2VydmVyLCBzaW5jZSB3ZSdyZSBub3QgZ29pbmcgdG8gcmVzb2x2ZSB0aGVtIGFueXdheS5cbiAgLy8gVGhlIGludGVybmFsIGluc3RhbmNlIHdpbGwgYmUgdXNlZCB0byBtYW5hZ2UgdXBkYXRlcyB0aGF0IGhhcHBlbiBkdXJpbmcgdGhpcyBtb3VudC5cblxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IHtcbiAgICBxdWV1ZTogW10sXG4gICAgcmVwbGFjZTogZmFsc2VcbiAgfTtcbiAgc2V0KGluc3RhbmNlLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSByZWFkQ29udGV4dCQxKGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gbWFza2VkTGVnYWN5Q29udGV4dDtcbiAgfVxuXG4gIHtcbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgPT09IG5ld1Byb3BzKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclczogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGFzc2lnbiBwcm9wcyBkaXJlY3RseSB0byBzdGF0ZSAnICsgXCJiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBcIiArICdJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHByb3BzIGRpcmVjdGx5LicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLnN0YXRlID0gYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMoaW5zdGFuY2UsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgaW5pdGlhbFN0YXRlLCBuZXdQcm9wcyk7XG4gIH0gLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cblxuICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KGN0b3IsIGluc3RhbmNlKTsgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgIC8vIHByb2Nlc3MgdGhlbSBub3cuXG5cbiAgICBwcm9jZXNzVXBkYXRlUXVldWUoaW50ZXJuYWxJbnN0YW5jZSwgaW5zdGFuY2UsIG5ld1Byb3BzLCBtYXNrZWRMZWdhY3lDb250ZXh0KTtcbiAgfVxufVxuXG4vLyBJZHMgYXJlIGJhc2UgMzIgc3RyaW5ncyB3aG9zZSBiaW5hcnkgcmVwcmVzZW50YXRpb24gY29ycmVzcG9uZHMgdG8gdGhlXG4vLyBwb3NpdGlvbiBvZiBhIG5vZGUgaW4gYSB0cmVlLlxuLy8gRXZlcnkgdGltZSB0aGUgdHJlZSBmb3JrcyBpbnRvIG11bHRpcGxlIGNoaWxkcmVuLCB3ZSBhZGQgYWRkaXRpb25hbCBiaXRzIHRvXG4vLyB0aGUgbGVmdCBvZiB0aGUgc2VxdWVuY2UgdGhhdCByZXByZXNlbnQgdGhlIHBvc2l0aW9uIG9mIHRoZSBjaGlsZCB3aXRoaW4gdGhlXG4vLyBjdXJyZW50IGxldmVsIG9mIGNoaWxkcmVuLlxuLy9cbi8vICAgICAgMDAxMDEgICAgICAgMDAwMTAwMDEwMTEwMTAxMDFcbi8vICAgICAg4pWw4pSA4pSs4pSA4pWvICAgICAgIOKVsOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKVr1xuLy8gICBGb3JrIDUgb2YgMjAgICAgICAgUGFyZW50IGlkXG4vL1xuLy8gVGhlIGxlYWRpbmcgMHMgYXJlIGltcG9ydGFudC4gSW4gdGhlIGFib3ZlIGV4YW1wbGUsIHlvdSBvbmx5IG5lZWQgMyBiaXRzIHRvXG4vLyByZXByZXNlbnQgc2xvdCA1LiBIb3dldmVyLCB5b3UgbmVlZCA1IGJpdHMgdG8gcmVwcmVzZW50IGFsbCB0aGUgZm9ya3MgYXRcbi8vIHRoZSBjdXJyZW50IGxldmVsLCBzbyB3ZSBtdXN0IGFjY291bnQgZm9yIHRoZSBlbXB0eSBiaXRzIGF0IHRoZSBlbmQuXG4vL1xuLy8gRm9yIHRoaXMgc2FtZSByZWFzb24sIHNsb3RzIGFyZSAxLWluZGV4ZWQgaW5zdGVhZCBvZiAwLWluZGV4ZWQuIE90aGVyd2lzZSxcbi8vIHRoZSB6ZXJvdGggaWQgYXQgYSBsZXZlbCB3b3VsZCBiZSBpbmRpc3Rpbmd1aXNoYWJsZSBmcm9tIGl0cyBwYXJlbnQuXG4vL1xuLy8gSWYgYSBub2RlIGhhcyBvbmx5IG9uZSBjaGlsZCwgYW5kIGRvZXMgbm90IG1hdGVyaWFsaXplIGFuIGlkIChpLmUuIGRvZXMgbm90XG4vLyBjb250YWluIGEgdXNlSWQgaG9vayksIHRoZW4gd2UgZG9uJ3QgbmVlZCB0byBhbGxvY2F0ZSBhbnkgc3BhY2UgaW4gdGhlXG4vLyBzZXF1ZW5jZS4gSXQncyB0cmVhdGVkIGFzIGEgdHJhbnNwYXJlbnQgaW5kaXJlY3Rpb24uIEZvciBleGFtcGxlLCB0aGVzZSB0d29cbi8vIHRyZWVzIHByb2R1Y2UgdGhlIHNhbWUgaWRzOlxuLy9cbi8vIDw+ICAgICAgICAgICAgICAgICAgICAgICAgICA8PlxuLy8gICA8SW5kaXJlY3Rpb24+ICAgICAgICAgICAgICAgPEEgLz5cbi8vICAgICA8QSAvPiAgICAgICAgICAgICAgICAgICAgIDxCIC8+XG4vLyAgIDwvSW5kaXJlY3Rpb24+ICAgICAgICAgICAgPC8+XG4vLyAgIDxCIC8+XG4vLyA8Lz5cbi8vXG4vLyBIb3dldmVyLCB3ZSBjYW5ub3Qgc2tpcCBhbnkgbm9kZSB0aGF0IG1hdGVyaWFsaXplcyBhbiBpZC4gT3RoZXJ3aXNlLCBhIHBhcmVudFxuLy8gaWQgdGhhdCBkb2VzIG5vdCBmb3JrIHdvdWxkIGJlIGluZGlzdGluZ3Vpc2hhYmxlIGZyb20gaXRzIGNoaWxkIGlkLiBGb3Jcbi8vIGV4YW1wbGUsIHRoaXMgdHJlZSBkb2VzIG5vdCBmb3JrLCBidXQgdGhlIHBhcmVudCBhbmQgY2hpbGQgbXVzdCBoYXZlXG4vLyBkaWZmZXJlbnQgaWRzLlxuLy9cbi8vIDxQYXJlbnQ+XG4vLyAgIDxDaGlsZCAvPlxuLy8gPC9QYXJlbnQ+XG4vL1xuLy8gVG8gaGFuZGxlIHRoaXMgc2NlbmFyaW8sIGV2ZXJ5IHRpbWUgd2UgbWF0ZXJpYWxpemUgYW4gaWQsIHdlIGFsbG9jYXRlIGFcbi8vIG5ldyBsZXZlbCB3aXRoIGEgc2luZ2xlIHNsb3QuIFlvdSBjYW4gdGhpbmsgb2YgdGhpcyBhcyBhIGZvcmsgd2l0aCBvbmx5IG9uZVxuLy8gcHJvbmcsIG9yIGFuIGFycmF5IG9mIGNoaWxkcmVuIHdpdGggbGVuZ3RoIDEuXG4vL1xuLy8gSXQncyBwb3NzaWJsZSBmb3IgdGhlIHNpemUgb2YgdGhlIHNlcXVlbmNlIHRvIGV4Y2VlZCAzMiBiaXRzLCB0aGUgbWF4XG4vLyBzaXplIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMuIFdoZW4gdGhpcyBoYXBwZW5zLCB3ZSBtYWtlIG1vcmUgcm9vbSBieVxuLy8gY29udmVydGluZyB0aGUgcmlnaHQgcGFydCBvZiB0aGUgaWQgdG8gYSBzdHJpbmcgYW5kIHN0b3JpbmcgaXQgaW4gYW4gb3ZlcmZsb3dcbi8vIHZhcmlhYmxlLiBXZSB1c2UgYSBiYXNlIDMyIHN0cmluZyByZXByZXNlbnRhdGlvbiwgYmVjYXVzZSAzMiBpcyB0aGUgbGFyZ2VzdFxuLy8gcG93ZXIgb2YgMiB0aGF0IGlzIHN1cHBvcnRlZCBieSB0b1N0cmluZygpLiBXZSB3YW50IHRoZSBiYXNlIHRvIGJlIGxhcmdlIHNvXG4vLyB0aGF0IHRoZSByZXN1bHRpbmcgaWRzIGFyZSBjb21wYWN0LCBhbmQgd2Ugd2FudCB0aGUgYmFzZSB0byBiZSBhIHBvd2VyIG9mIDJcbi8vIGJlY2F1c2UgZXZlcnkgbG9nMihiYXNlKSBiaXRzIGNvcnJlc3BvbmRzIHRvIGEgc2luZ2xlIGNoYXJhY3RlciwgaS5lLiBldmVyeVxuLy8gbG9nMigzMikgPSA1IGJpdHMuIFRoYXQgbWVhbnMgd2UgY2FuIGxvcCBiaXRzIG9mZiB0aGUgZW5kIDUgYXQgYSB0aW1lIHdpdGhvdXRcbi8vIGFmZmVjdGluZyB0aGUgZmluYWwgcmVzdWx0LlxudmFyIGVtcHR5VHJlZUNvbnRleHQgPSB7XG4gIGlkOiAxLFxuICBvdmVyZmxvdzogJydcbn07XG5mdW5jdGlvbiBnZXRUcmVlSWQoY29udGV4dCkge1xuICB2YXIgb3ZlcmZsb3cgPSBjb250ZXh0Lm92ZXJmbG93O1xuICB2YXIgaWRXaXRoTGVhZGluZ0JpdCA9IGNvbnRleHQuaWQ7XG4gIHZhciBpZCA9IGlkV2l0aExlYWRpbmdCaXQgJiB+Z2V0TGVhZGluZ0JpdChpZFdpdGhMZWFkaW5nQml0KTtcbiAgcmV0dXJuIGlkLnRvU3RyaW5nKDMyKSArIG92ZXJmbG93O1xufVxuZnVuY3Rpb24gcHVzaFRyZWVDb250ZXh0KGJhc2VDb250ZXh0LCB0b3RhbENoaWxkcmVuLCBpbmRleCkge1xuICB2YXIgYmFzZUlkV2l0aExlYWRpbmdCaXQgPSBiYXNlQ29udGV4dC5pZDtcbiAgdmFyIGJhc2VPdmVyZmxvdyA9IGJhc2VDb250ZXh0Lm92ZXJmbG93OyAvLyBUaGUgbGVmdG1vc3QgMSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZSwgbm9uLWluY2x1c2l2ZS4gSXQncyBub3QgcGFydFxuICAvLyBvZiB0aGUgaWQ7IHdlIHVzZSBpdCB0byBhY2NvdW50IGZvciBsZWFkaW5nIDBzLlxuXG4gIHZhciBiYXNlTGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKGJhc2VJZFdpdGhMZWFkaW5nQml0KSAtIDE7XG4gIHZhciBiYXNlSWQgPSBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmIH4oMSA8PCBiYXNlTGVuZ3RoKTtcbiAgdmFyIHNsb3QgPSBpbmRleCArIDE7XG4gIHZhciBsZW5ndGggPSBnZXRCaXRMZW5ndGgodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoOyAvLyAzMCBpcyB0aGUgbWF4IGxlbmd0aCB3ZSBjYW4gc3RvcmUgd2l0aG91dCBvdmVyZmxvd2luZywgdGFraW5nIGludG9cbiAgLy8gY29uc2lkZXJhdGlvbiB0aGUgbGVhZGluZyAxIHdlIHVzZSB0byBtYXJrIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLlxuXG4gIGlmIChsZW5ndGggPiAzMCkge1xuICAgIC8vIFdlIG92ZXJmbG93ZWQgdGhlIGJpdHdpc2Utc2FmZSByYW5nZS4gRmFsbCBiYWNrIHRvIHNsb3dlciBhbGdvcml0aG0uXG4gICAgLy8gVGhpcyBicmFuY2ggYXNzdW1lcyB0aGUgbGVuZ3RoIG9mIHRoZSBiYXNlIGlkIGlzIGdyZWF0ZXIgdGhhbiA1OyBpdCB3b24ndFxuICAgIC8vIHdvcmsgZm9yIHNtYWxsZXIgaWRzLCBiZWNhdXNlIHlvdSBuZWVkIDUgYml0cyBwZXIgY2hhcmFjdGVyLlxuICAgIC8vXG4gICAgLy8gV2UgZW5jb2RlIHRoZSBpZCBpbiBtdWx0aXBsZSBzdGVwczogZmlyc3QgdGhlIGJhc2UgaWQsIHRoZW4gdGhlXG4gICAgLy8gcmVtYWluaW5nIGRpZ2l0cy5cbiAgICAvL1xuICAgIC8vIEVhY2ggNSBiaXQgc2VxdWVuY2UgY29ycmVzcG9uZHMgdG8gYSBzaW5nbGUgYmFzZSAzMiBjaGFyYWN0ZXIuIFNvIGZvclxuICAgIC8vIGV4YW1wbGUsIGlmIHRoZSBjdXJyZW50IGlkIGlzIDIzIGJpdHMgbG9uZywgd2UgY2FuIGNvbnZlcnQgMjAgb2YgdGhvc2VcbiAgICAvLyBiaXRzIGludG8gYSBzdHJpbmcgb2YgNCBjaGFyYWN0ZXJzLCB3aXRoIDMgYml0cyBsZWZ0IG92ZXIuXG4gICAgLy9cbiAgICAvLyBGaXJzdCBjYWxjdWxhdGUgaG93IG1hbnkgYml0cyBpbiB0aGUgYmFzZSBpZCByZXByZXNlbnQgYSBjb21wbGV0ZVxuICAgIC8vIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMuXG4gICAgdmFyIG51bWJlck9mT3ZlcmZsb3dCaXRzID0gYmFzZUxlbmd0aCAtIGJhc2VMZW5ndGggJSA1OyAvLyBUaGVuIGNyZWF0ZSBhIGJpdG1hc2sgdGhhdCBzZWxlY3RzIG9ubHkgdGhvc2UgYml0cy5cblxuICAgIHZhciBuZXdPdmVyZmxvd0JpdHMgPSAoMSA8PCBudW1iZXJPZk92ZXJmbG93Qml0cykgLSAxOyAvLyBTZWxlY3QgdGhlIGJpdHMsIGFuZCBjb252ZXJ0IHRoZW0gdG8gYSBiYXNlIDMyIHN0cmluZy5cblxuICAgIHZhciBuZXdPdmVyZmxvdyA9IChiYXNlSWQgJiBuZXdPdmVyZmxvd0JpdHMpLnRvU3RyaW5nKDMyKTsgLy8gTm93IHdlIGNhbiByZW1vdmUgdGhvc2UgYml0cyBmcm9tIHRoZSBiYXNlIGlkLlxuXG4gICAgdmFyIHJlc3RPZkJhc2VJZCA9IGJhc2VJZCA+PiBudW1iZXJPZk92ZXJmbG93Qml0cztcbiAgICB2YXIgcmVzdE9mQmFzZUxlbmd0aCA9IGJhc2VMZW5ndGggLSBudW1iZXJPZk92ZXJmbG93Qml0czsgLy8gRmluYWxseSwgZW5jb2RlIHRoZSByZXN0IG9mIHRoZSBiaXRzIHVzaW5nIHRoZSBub3JtYWwgYWxnb3JpdGhtLiBCZWNhdXNlXG4gICAgLy8gd2UgbWFkZSBtb3JlIHJvb20sIHRoaXMgdGltZSBpdCB3b24ndCBvdmVyZmxvdy5cblxuICAgIHZhciByZXN0T2ZMZW5ndGggPSBnZXRCaXRMZW5ndGgodG90YWxDaGlsZHJlbikgKyByZXN0T2ZCYXNlTGVuZ3RoO1xuICAgIHZhciByZXN0T2ZOZXdCaXRzID0gc2xvdCA8PCByZXN0T2ZCYXNlTGVuZ3RoO1xuICAgIHZhciBpZCA9IHJlc3RPZk5ld0JpdHMgfCByZXN0T2ZCYXNlSWQ7XG4gICAgdmFyIG92ZXJmbG93ID0gbmV3T3ZlcmZsb3cgKyBiYXNlT3ZlcmZsb3c7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiAxIDw8IHJlc3RPZkxlbmd0aCB8IGlkLFxuICAgICAgb3ZlcmZsb3c6IG92ZXJmbG93XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBOb3JtYWwgcGF0aFxuICAgIHZhciBuZXdCaXRzID0gc2xvdCA8PCBiYXNlTGVuZ3RoO1xuXG4gICAgdmFyIF9pZCA9IG5ld0JpdHMgfCBiYXNlSWQ7XG5cbiAgICB2YXIgX292ZXJmbG93ID0gYmFzZU92ZXJmbG93O1xuICAgIHJldHVybiB7XG4gICAgICBpZDogMSA8PCBsZW5ndGggfCBfaWQsXG4gICAgICBvdmVyZmxvdzogX292ZXJmbG93XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaXRMZW5ndGgobnVtYmVyKSB7XG4gIHJldHVybiAzMiAtIGNsejMyKG51bWJlcik7XG59XG5cbmZ1bmN0aW9uIGdldExlYWRpbmdCaXQoaWQpIHtcbiAgcmV0dXJuIDEgPDwgZ2V0Qml0TGVuZ3RoKGlkKSAtIDE7XG59IC8vIFRPRE86IE1hdGguY2x6MzIgaXMgc3VwcG9ydGVkIGluIE5vZGUgMTIrLiBNYXliZSB3ZSBjYW4gZHJvcCB0aGUgZmFsbGJhY2suXG5cblxudmFyIGNsejMyID0gTWF0aC5jbHozMiA/IE1hdGguY2x6MzIgOiBjbHozMkZhbGxiYWNrOyAvLyBDb3VudCBsZWFkaW5nIHplcm9zLlxuLy8gQmFzZWQgb246XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2NsejMyXG5cbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBMTjIgPSBNYXRoLkxOMjtcblxuZnVuY3Rpb24gY2x6MzJGYWxsYmFjayh4KSB7XG4gIHZhciBhc1VpbnQgPSB4ID4+PiAwO1xuXG4gIGlmIChhc1VpbnQgPT09IDApIHtcbiAgICByZXR1cm4gMzI7XG4gIH1cblxuICByZXR1cm4gMzEgLSAobG9nKGFzVWludCkgLyBMTjIgfCAwKSB8IDA7XG59XG5cbi8vIENvcnJlc3BvbmRzIHRvIFJlYWN0RmliZXJXYWtlYWJsZSBhbmQgUmVhY3RGbGlnaHRXYWtlYWJsZSBtb2R1bGVzLiBHZW5lcmFsbHksXG4vLyBjaGFuZ2VzIHRvIG9uZSBtb2R1bGUgc2hvdWxkIGJlIHJlZmxlY3RlZCBpbiB0aGUgb3RoZXJzLlxuLy8gVE9ETzogUmVuYW1lIHRoaXMgbW9kdWxlIGFuZCB0aGUgY29ycmVzcG9uZGluZyBGaWJlciBvbmUgdG8gXCJUaGVuYWJsZVwiXG4vLyBpbnN0ZWFkIG9mIFwiV2FrZWFibGVcIi4gT3Igc29tZSBvdGhlciBtb3JlIGFwcHJvcHJpYXRlIG5hbWUuXG4vLyBBbiBlcnJvciB0aGF0IGlzIHRocm93biAoZS5nLiBieSBgdXNlYCkgdG8gdHJpZ2dlciBTdXNwZW5zZS4gSWYgd2Vcbi8vIGRldGVjdCB0aGlzIGlzIGNhdWdodCBieSB1c2Vyc3BhY2UsIHdlJ2xsIGxvZyBhIHdhcm5pbmcgaW4gZGV2ZWxvcG1lbnQuXG52YXIgU3VzcGVuc2VFeGNlcHRpb24gPSBuZXcgRXJyb3IoXCJTdXNwZW5zZSBFeGNlcHRpb246IFRoaXMgaXMgbm90IGEgcmVhbCBlcnJvciEgSXQncyBhbiBpbXBsZW1lbnRhdGlvbiBcIiArICdkZXRhaWwgb2YgYHVzZWAgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IHJlbmRlci4gWW91IG11c3QgZWl0aGVyICcgKyAncmV0aHJvdyBpdCBpbW1lZGlhdGVseSwgb3IgbW92ZSB0aGUgYHVzZWAgY2FsbCBvdXRzaWRlIG9mIHRoZSAnICsgJ2B0cnkvY2F0Y2hgIGJsb2NrLiBDYXB0dXJpbmcgd2l0aG91dCByZXRocm93aW5nIHdpbGwgbGVhZCB0byAnICsgJ3VuZXhwZWN0ZWQgYmVoYXZpb3IuXFxuXFxuJyArICdUbyBoYW5kbGUgYXN5bmMgZXJyb3JzLCB3cmFwIHlvdXIgY29tcG9uZW50IGluIGFuIGVycm9yIGJvdW5kYXJ5LCBvciAnICsgXCJjYWxsIHRoZSBwcm9taXNlJ3MgYC5jYXRjaGAgbWV0aG9kIGFuZCBwYXNzIHRoZSByZXN1bHQgdG8gYHVzZWBcIik7XG5mdW5jdGlvbiBjcmVhdGVUaGVuYWJsZVN0YXRlKCkge1xuICAvLyBUaGUgVGhlbmFibGVTdGF0ZSBpcyBjcmVhdGVkIHRoZSBmaXJzdCB0aW1lIGEgY29tcG9uZW50IHN1c3BlbmRzLiBJZiBpdFxuICAvLyBzdXNwZW5kcyBhZ2Fpbiwgd2UnbGwgcmV1c2UgdGhlIHNhbWUgc3RhdGUuXG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gbm9vcCQyKCkge31cblxuZnVuY3Rpb24gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KSB7XG4gIHZhciBwcmV2aW91cyA9IHRoZW5hYmxlU3RhdGVbaW5kZXhdO1xuXG4gIGlmIChwcmV2aW91cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhlbmFibGVTdGF0ZS5wdXNoKHRoZW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJldmlvdXMgIT09IHRoZW5hYmxlKSB7XG4gICAgICAvLyBSZXVzZSB0aGUgcHJldmlvdXMgdGhlbmFibGUsIGFuZCBkcm9wIHRoZSBuZXcgb25lLiBXZSBjYW4gYXNzdW1lXG4gICAgICAvLyB0aGV5IHJlcHJlc2VudCB0aGUgc2FtZSB2YWx1ZSwgYmVjYXVzZSBjb21wb25lbnRzIGFyZSBpZGVtcG90ZW50LlxuICAgICAgLy8gQXZvaWQgYW4gdW5oYW5kbGVkIHJlamVjdGlvbiBlcnJvcnMgZm9yIHRoZSBQcm9taXNlcyB0aGF0IHdlJ2xsXG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGlnbm9yZS5cbiAgICAgIHRoZW5hYmxlLnRoZW4obm9vcCQyLCBub29wJDIpO1xuICAgICAgdGhlbmFibGUgPSBwcmV2aW91cztcbiAgICB9XG4gIH0gLy8gV2UgdXNlIGFuIGV4cGFuZG8gdG8gdHJhY2sgdGhlIHN0YXR1cyBhbmQgcmVzdWx0IG9mIGEgdGhlbmFibGUgc28gdGhhdCB3ZVxuICAvLyBjYW4gc3luY2hyb25vdXNseSB1bndyYXAgdGhlIHZhbHVlLiBUaGluayBvZiB0aGlzIGFzIGFuIGV4dGVuc2lvbiBvZiB0aGVcbiAgLy8gUHJvbWlzZSBBUEksIG9yIGEgY3VzdG9tIGludGVyZmFjZSB0aGF0IGlzIGEgc3VwZXJzZXQgb2YgVGhlbmFibGUuXG4gIC8vXG4gIC8vIElmIHRoZSB0aGVuYWJsZSBkb2Vzbid0IGhhdmUgYSBzdGF0dXMsIHNldCBpdCB0byBcInBlbmRpbmdcIiBhbmQgYXR0YWNoXG4gIC8vIGEgbGlzdGVuZXIgdGhhdCB3aWxsIHVwZGF0ZSBpdHMgc3RhdHVzIGFuZCByZXN1bHQgd2hlbiBpdCByZXNvbHZlcy5cblxuXG4gIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgY2FzZSAnZnVsZmlsbGVkJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZ1bGZpbGxlZFZhbHVlID0gdGhlbmFibGUudmFsdWU7XG4gICAgICAgIHJldHVybiBmdWxmaWxsZWRWYWx1ZTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHJlamVjdGVkRXJyb3IgPSB0aGVuYWJsZS5yZWFzb247XG4gICAgICAgIHRocm93IHJlamVjdGVkRXJyb3I7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIHRoZW5hYmxlLnN0YXR1cyA9PT0gJ3N0cmluZycpIDsgZWxzZSB7XG4gICAgICAgICAgdmFyIHBlbmRpbmdUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgIHBlbmRpbmdUaGVuYWJsZS5zdGF0dXMgPSAncGVuZGluZyc7XG4gICAgICAgICAgcGVuZGluZ1RoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKGZ1bGZpbGxlZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhlbmFibGUuc3RhdHVzID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnN0YXR1cyA9ICdmdWxmaWxsZWQnO1xuICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS52YWx1ZSA9IGZ1bGZpbGxlZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHRoZW5hYmxlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUuc3RhdHVzID0gJ3JlamVjdGVkJztcbiAgICAgICAgICAgICAgcmVqZWN0ZWRUaGVuYWJsZS5yZWFzb24gPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTsgLy8gQ2hlY2sgb25lIG1vcmUgdGltZSBpbiBjYXNlIHRoZSB0aGVuYWJsZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG5cbiAgICAgICAgICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSAnZnVsZmlsbGVkJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBmdWxmaWxsZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWRUaGVuYWJsZS52YWx1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICAgIHRocm93IHJlamVjdGVkVGhlbmFibGUucmVhc29uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFN1c3BlbmQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRocm93aW5nIGhlcmUgaXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIHRoYXQgYWxsb3dzIHVzIHRvIHVud2luZCB0aGVcbiAgICAgICAgLy8gY2FsbCBzdGFjay4gQnV0IHdlIHNob3VsZG4ndCBhbGxvdyBpdCB0byBsZWFrIGludG8gdXNlcnNwYWNlLiBUaHJvdyBhblxuICAgICAgICAvLyBvcGFxdWUgcGxhY2Vob2xkZXIgdmFsdWUgaW5zdGVhZCBvZiB0aGUgYWN0dWFsIHRoZW5hYmxlLiBJZiBpdCBkb2Vzbid0XG4gICAgICAgIC8vIGdldCBjYXB0dXJlZCBieSB0aGUgd29yayBsb29wLCBsb2cgYSB3YXJuaW5nLCBiZWNhdXNlIHRoYXQgbWVhbnNcbiAgICAgICAgLy8gc29tZXRoaW5nIGluIHVzZXJzcGFjZSBtdXN0IGhhdmUgY2F1Z2h0IGl0LlxuXG5cbiAgICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgdGhyb3cgU3VzcGVuc2VFeGNlcHRpb247XG4gICAgICB9XG4gIH1cbn0gLy8gVGhpcyBpcyB1c2VkIHRvIHRyYWNrIHRoZSBhY3R1YWwgdGhlbmFibGUgdGhhdCBzdXNwZW5kZWQgc28gaXQgY2FuIGJlXG4vLyBwYXNzZWQgdG8gdGhlIHJlc3Qgb2YgdGhlIFN1c3BlbnNlIGltcGxlbWVudGF0aW9uIOKAlCB3aGljaCwgZm9yIGhpc3RvcmljYWxcbi8vIHJlYXNvbnMsIGV4cGVjdHMgdG8gcmVjZWl2ZSBhIHRoZW5hYmxlLlxuXG52YXIgc3VzcGVuZGVkVGhlbmFibGUgPSBudWxsO1xuZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSB7XG4gIC8vIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIGB1c2VgIHN1c3BlbmRzIGJ5IHRocm93aW5nIGFuIGV4Y2VwdGlvbi4gYHVzZWBcbiAgLy8gdGhyb3dzIGFuIG9wYXF1ZSB2YWx1ZSBpbnN0ZWFkIG9mIHRoZSB0aGVuYWJsZSBpdHNlbGYgc28gdGhhdCBpdCBjYW4ndCBiZVxuICAvLyBjYXVnaHQgaW4gdXNlcnNwYWNlLiBUaGVuIHRoZSB3b3JrIGxvb3AgYWNjZXNzZXMgdGhlIGFjdHVhbCB0aGVuYWJsZSB1c2luZ1xuICAvLyB0aGlzIGZ1bmN0aW9uLlxuICBpZiAoc3VzcGVuZGVkVGhlbmFibGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgc3VzcGVuZGVkIHRoZW5hYmxlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSAnICsgJ2FuIGlzc3VlLicpO1xuICB9XG5cbiAgdmFyIHRoZW5hYmxlID0gc3VzcGVuZGVkVGhlbmFibGU7XG4gIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbiAgcmV0dXJuIHRoZW5hYmxlO1xufVxuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIDtcbn1cblxudmFyIG9iamVjdElzID0gLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxudHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGlzO1xuXG52YXIgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gbnVsbDtcbnZhciBjdXJyZW50bHlSZW5kZXJpbmdUYXNrID0gbnVsbDtcbnZhciBjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0ID0gbnVsbDtcbnZhciBjdXJyZW50bHlSZW5kZXJpbmdLZXlQYXRoID0gbnVsbDtcbnZhciBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG52YXIgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDsgLy8gV2hldGhlciB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rIGlzIGEgcmUtcmVuZGVyZWQgaG9va1xuXG52YXIgaXNSZVJlbmRlciA9IGZhbHNlOyAvLyBXaGV0aGVyIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGR1cmluZyB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyByZW5kZXIgcGFzcy5cblxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTsgLy8gQ291bnRzIHRoZSBudW1iZXIgb2YgdXNlSWQgaG9va3MgaW4gdGhpcyBjb21wb25lbnRcblxudmFyIGxvY2FsSWRDb3VudGVyID0gMDsgLy8gQ2h1bmtzIHRoYXQgc2hvdWxkIGJlIHB1c2hlZCB0byB0aGUgc3RyZWFtIG9uY2UgdGhlIGNvbXBvbmVudFxuLy8gZmluaXNoZXMgcmVuZGVyaW5nLlxuLy8gQ291bnRzIHRoZSBudW1iZXIgb2YgdXNlRm9ybVN0YXRlIGNhbGxzIGluIHRoaXMgY29tcG9uZW50XG5cbnZhciBmb3JtU3RhdGVDb3VudGVyID0gMDsgLy8gVGhlIGluZGV4IG9mIHRoZSB1c2VGb3JtU3RhdGUgaG9vayB0aGF0IG1hdGNoZXMgdGhlIG9uZSBwYXNzZWQgaW4gYXQgdGhlXG4vLyByb290IGR1cmluZyBhbiBNUEEgbmF2aWdhdGlvbiwgaWYgYW55LlxuXG52YXIgZm9ybVN0YXRlTWF0Y2hpbmdJbmRleCA9IC0xOyAvLyBDb3VudHMgdGhlIG51bWJlciBvZiB1c2UodGhlbmFibGUpIGNhbGxzIGluIHRoaXMgY29tcG9uZW50XG5cbnZhciB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG52YXIgdGhlbmFibGVTdGF0ZSA9IG51bGw7IC8vIExhemlseSBjcmVhdGVkIG1hcCBvZiByZW5kZXItcGhhc2UgdXBkYXRlc1xuXG52YXIgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDsgLy8gQ291bnRlciB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlxuXG52YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xudmFyIFJFX1JFTkRFUl9MSU1JVCA9IDI1O1xudmFyIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlOyAvLyBJbiBERVYsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcHJpbWl0aXZlIGhvb2tcblxudmFyIGN1cnJlbnRIb29rTmFtZUluRGV2O1xuXG5mdW5jdGlvbiByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCkge1xuICBpZiAoY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yJyArICcgb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4nICsgJzEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbicgKyAnMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbicgKyAnMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcbicgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uJyk7XG4gIH1cblxuICB7XG4gICAgaWYgKGlzSW5Ib29rVXNlckNvZGVJbkRldikge1xuICAgICAgZXJyb3IoJ0RvIG5vdCBjYWxsIEhvb2tzIGluc2lkZSB1c2VFZmZlY3QoLi4uKSwgdXNlTWVtbyguLi4pLCBvciBvdGhlciBidWlsdC1pbiBIb29rcy4gJyArICdZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQ7XG59XG5cbmZ1bmN0aW9uIGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpIHtcbiAgaWYgKHByZXZEZXBzID09PSBudWxsKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyAnICsgJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJyArICdpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy4nLCBjdXJyZW50SG9va05hbWVJbkRldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcgbGVuZ3RocyBpbiBwcm9kIGJlY2F1c2UgdGhlc2UgYXJyYXlzIHNob3VsZCBiZVxuICAgIC8vIHBhc3NlZCBpbmxpbmUuXG4gICAgaWYgKG5leHREZXBzLmxlbmd0aCAhPT0gcHJldkRlcHMubGVuZ3RoKSB7XG4gICAgICBlcnJvcignVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgJyArICdvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcbicgKyAnUHJldmlvdXM6ICVzXFxuJyArICdJbmNvbWluZzogJXMnLCBjdXJyZW50SG9va05hbWVJbkRldiwgXCJbXCIgKyBuZXh0RGVwcy5qb2luKCcsICcpICsgXCJdXCIsIFwiW1wiICsgcHJldkRlcHMuam9pbignLCAnKSArIFwiXVwiKTtcbiAgICB9XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICBpZiAob2JqZWN0SXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhvb2soKSB7XG4gIGlmIChudW1iZXJPZlJlUmVuZGVycyA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlcicpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIHF1ZXVlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgaG9vayBpbiB0aGUgbGlzdFxuICAgIGlmIChmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgICAgaXNSZVJlbmRlciA9IGZhbHNlO1xuICAgICAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVIb29rKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgICAgaXNSZVJlbmRlciA9IHRydWU7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBmaXJzdFdvcmtJblByb2dyZXNzSG9vaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID09PSBudWxsKSB7XG4gICAgICBpc1JlUmVuZGVyID0gZmFsc2U7IC8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0XG5cbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gY3JlYXRlSG9vaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSB3b3JrLWluLXByb2dyZXNzLiBSZXVzZSBpdC5cbiAgICAgIGlzUmVSZW5kZXIgPSB0cnVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvVXNlSG9va3MocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgY29tcG9uZW50SWRlbnRpdHksIHByZXZUaGVuYWJsZVN0YXRlKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IGNvbXBvbmVudElkZW50aXR5O1xuICBjdXJyZW50bHlSZW5kZXJpbmdUYXNrID0gdGFzaztcbiAgY3VycmVudGx5UmVuZGVyaW5nUmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0tleVBhdGggPSBrZXlQYXRoO1xuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfSAvLyBUaGUgZm9sbG93aW5nIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiByZXNldFxuICAvLyBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIC8vIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgLy8gbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICAvLyByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuICAvLyB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuXG5cbiAgbG9jYWxJZENvdW50ZXIgPSAwO1xuICBmb3JtU3RhdGVDb3VudGVyID0gMDtcbiAgZm9ybVN0YXRlTWF0Y2hpbmdJbmRleCA9IC0xO1xuICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gIHRoZW5hYmxlU3RhdGUgPSBwcmV2VGhlbmFibGVTdGF0ZTtcbn1cbmZ1bmN0aW9uIGZpbmlzaEhvb2tzKENvbXBvbmVudCwgcHJvcHMsIGNoaWxkcmVuLCByZWZPckNvbnRleHQpIHtcbiAgLy8gVGhpcyBtdXN0IGJlIGNhbGxlZCBhZnRlciBldmVyeSBmdW5jdGlvbiBjb21wb25lbnQgdG8gcHJldmVudCBob29rcyBmcm9tXG4gIC8vIGJlaW5nIHVzZWQgaW4gY2xhc3Nlcy5cbiAgd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAvLyBVcGRhdGVzIHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLiBUaGV5IGFyZSBzdG9yZWQgaW5cbiAgICAvLyB0aGUgYHJlbmRlclBoYXNlVXBkYXRlc2AgbWFwLiBDYWxsIHRoZSBjb21wb25lbnQgYWdhaW4sIHJldXNpbmcgdGhlXG4gICAgLy8gd29yay1pbi1wcm9ncmVzcyBob29rcyBhbmQgYXBwbHlpbmcgdGhlIGFkZGl0aW9uYWwgdXBkYXRlcyBvbiB0b3AuIEtlZXBcbiAgICAvLyByZXN0YXJ0aW5nIHVudGlsIG5vIG1vcmUgdXBkYXRlcyBhcmUgc2NoZWR1bGVkLlxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgICBsb2NhbElkQ291bnRlciA9IDA7XG4gICAgZm9ybVN0YXRlQ291bnRlciA9IDA7XG4gICAgZm9ybVN0YXRlTWF0Y2hpbmdJbmRleCA9IC0xO1xuICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxOyAvLyBTdGFydCBvdmVyIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgICBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgcmVmT3JDb250ZXh0KTtcbiAgfVxuXG4gIHJlc2V0SG9va3NTdGF0ZSgpO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5mdW5jdGlvbiBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCkge1xuICB2YXIgc3RhdGUgPSB0aGVuYWJsZVN0YXRlO1xuICB0aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gY2hlY2tEaWRSZW5kZXJJZEhvb2soKSB7XG4gIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBldmVyeSBmaW5pc2hIb29rcyBjYWxsLlxuICAvLyBDb25jZXB0dWFsbHksIGl0J3MgcGFydCBvZiB0aGUgcmV0dXJuIHZhbHVlIG9mIGZpbmlzaEhvb2tzOyBpdCdzIG9ubHkgYVxuICAvLyBzZXBhcmF0ZSBmdW5jdGlvbiB0byBhdm9pZCB1c2luZyBhbiBhcnJheSB0dXBsZS5cbiAgdmFyIGRpZFJlbmRlcklkSG9vayA9IGxvY2FsSWRDb3VudGVyICE9PSAwO1xuICByZXR1cm4gZGlkUmVuZGVySWRIb29rO1xufVxuZnVuY3Rpb24gZ2V0Rm9ybVN0YXRlQ291bnQoKSB7XG4gIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBldmVyeSBmaW5pc2hIb29rcyBjYWxsLlxuICAvLyBDb25jZXB0dWFsbHksIGl0J3MgcGFydCBvZiB0aGUgcmV0dXJuIHZhbHVlIG9mIGZpbmlzaEhvb2tzOyBpdCdzIG9ubHkgYVxuICAvLyBzZXBhcmF0ZSBmdW5jdGlvbiB0byBhdm9pZCB1c2luZyBhbiBhcnJheSB0dXBsZS5cbiAgcmV0dXJuIGZvcm1TdGF0ZUNvdW50ZXI7XG59XG5mdW5jdGlvbiBnZXRGb3JtU3RhdGVNYXRjaGluZ0luZGV4KCkge1xuICAvLyBUaGlzIHNob3VsZCBiZSBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgZXZlcnkgZmluaXNoSG9va3MgY2FsbC5cbiAgLy8gQ29uY2VwdHVhbGx5LCBpdCdzIHBhcnQgb2YgdGhlIHJldHVybiB2YWx1ZSBvZiBmaW5pc2hIb29rczsgaXQncyBvbmx5IGFcbiAgLy8gc2VwYXJhdGUgZnVuY3Rpb24gdG8gYXZvaWQgdXNpbmcgYW4gYXJyYXkgdHVwbGUuXG4gIHJldHVybiBmb3JtU3RhdGVNYXRjaGluZ0luZGV4O1xufSAvLyBSZXNldCB0aGUgaW50ZXJuYWwgaG9va3Mgc3RhdGUgaWYgYW4gZXJyb3Igb2NjdXJzIHdoaWxlIHJlbmRlcmluZyBhIGNvbXBvbmVudFxuXG5mdW5jdGlvbiByZXNldEhvb2tzU3RhdGUoKSB7XG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfVxuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IG51bGw7XG4gIGN1cnJlbnRseVJlbmRlcmluZ1Rhc2sgPSBudWxsO1xuICBjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aCA9IG51bGw7XG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQpIHtcbiAge1xuICAgIGlmIChpc0luSG9va1VzZXJDb2RlSW5EZXYpIHtcbiAgICAgIGVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZENvbnRleHQkMShjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gdXNlQ29udGV4dChjb250ZXh0KSB7XG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgfVxuXG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgcmV0dXJuIHJlYWRDb250ZXh0JDEoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIGJhc2ljU3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXTogRmxvdyBkb2Vzbid0IGxpa2UgbWl4ZWQgdHlwZXNcbiAgcmV0dXJuIHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicgPyBhY3Rpb24oc3RhdGUpIDogYWN0aW9uO1xufVxuXG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAge1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgfVxuXG4gIHJldHVybiB1c2VSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyLCAvLyB1c2VSZWR1Y2VyIGhhcyBhIHNwZWNpYWwgY2FzZSB0byBzdXBwb3J0IGxhenkgdXNlU3RhdGUgaW5pdGlhbGl6ZXJzXG4gIGluaXRpYWxTdGF0ZSk7XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAge1xuICAgIGlmIChyZWR1Y2VyICE9PSBiYXNpY1N0YXRlUmVkdWNlcikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgfVxuICB9XG5cbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuICBpZiAoaXNSZVJlbmRlcikge1xuICAgIC8vIFRoaXMgaXMgYSByZS1yZW5kZXIuIEFwcGx5IHRoZSBuZXcgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG8gdGhlIHByZXZpb3VzXG4gICAgLy8gY3VycmVudCBob29rLlxuICAgIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZTtcbiAgICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcblxuICAgIGlmIChyZW5kZXJQaGFzZVVwZGF0ZXMgIT09IG51bGwpIHtcbiAgICAgIC8vIFJlbmRlciBwaGFzZSB1cGRhdGVzIGFyZSBzdG9yZWQgaW4gYSBtYXAgb2YgcXVldWUgLT4gbGlua2VkIGxpc3RcbiAgICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSk7XG5cbiAgICAgIGlmIChmaXJzdFJlbmRlclBoYXNlVXBkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5kZWxldGUocXVldWUpOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuICAgICAgICB2YXIgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGU7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8vIFByb2Nlc3MgdGhpcyByZW5kZXIgcGhhc2UgdXBkYXRlLiBXZSBkb24ndCBoYXZlIHRvIGNoZWNrIHRoZVxuICAgICAgICAgIC8vIHByaW9yaXR5IGJlY2F1c2UgaXQgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnRcbiAgICAgICAgICAvLyByZW5kZXIncy5cbiAgICAgICAgICB2YXIgYWN0aW9uID0gdXBkYXRlLmFjdGlvbjtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSB3ZSBiYWlsIG91dCB3aGVuIHdlIGdldCBhIG51bGxcblxuXG4gICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCk7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgcmV0dXJuIFtuZXdTdGF0ZSwgZGlzcGF0Y2hdO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgIHJldHVybiBbd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsU3RhdGU7XG5cbiAgICBpZiAocmVkdWNlciA9PT0gYmFzaWNTdGF0ZVJlZHVjZXIpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYHVzZVN0YXRlYC5cbiAgICAgIGluaXRpYWxTdGF0ZSA9IHR5cGVvZiBpbml0aWFsQXJnID09PSAnZnVuY3Rpb24nID8gaW5pdGlhbEFyZygpIDogaW5pdGlhbEFyZztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbFN0YXRlID0gaW5pdCAhPT0gdW5kZWZpbmVkID8gaW5pdChpbml0aWFsQXJnKSA6IGluaXRpYWxBcmc7XG4gICAgfVxuXG4gICAge1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsU3RhdGU7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG4gICAgdmFyIF9xdWV1ZSA9IHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZSA9IHtcbiAgICAgIGxhc3Q6IG51bGwsXG4gICAgICBkaXNwYXRjaDogbnVsbFxuICAgIH07XG5cbiAgICB2YXIgX2Rpc3BhdGNoID0gX3F1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2hBY3Rpb24uYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQsIF9xdWV1ZSk7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBfZGlzcGF0Y2hdO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcblxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuICAgICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IHRydWU7XG4gIH1cblxuICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBwcmV2aW91c1JlZiA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChwcmV2aW91c1JlZiA9PT0gbnVsbCkge1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiBpbml0aWFsVmFsdWVcbiAgICB9O1xuXG4gICAge1xuICAgICAgT2JqZWN0LnNlYWwocmVmKTtcbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IHJlZjtcbiAgICByZXR1cm4gcmVmO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmV2aW91c1JlZjtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihjb21wb25lbnRJZGVudGl0eSwgcXVldWUsIGFjdGlvbikge1xuICBpZiAobnVtYmVyT2ZSZVJlbmRlcnMgPj0gUkVfUkVOREVSX0xJTUlUKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgJyArICdhbiBpbmZpbml0ZSBsb29wLicpO1xuICB9XG5cbiAgaWYgKGNvbXBvbmVudElkZW50aXR5ID09PSBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gU3Rhc2ggaXQgaW4gYSBsYXppbHktY3JlYXRlZCBtYXAgb2ZcbiAgICAvLyBxdWV1ZSAtPiBsaW5rZWQgbGlzdCBvZiB1cGRhdGVzLiBBZnRlciB0aGlzIHJlbmRlciBwYXNzLCB3ZSdsbCByZXN0YXJ0XG4gICAgLy8gYW5kIGFwcGx5IHRoZSBzdGFzaGVkIHVwZGF0ZXMgb24gdG9wIG9mIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IHRydWU7XG4gICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KHF1ZXVlKTtcblxuICAgIGlmIChmaXJzdFJlbmRlclBoYXNlVXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLnNldChxdWV1ZSwgdXBkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgIHZhciBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgICB3aGlsZSAobGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICByZXR1cm4gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9LCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgaWYgKGdldFNlcnZlclNuYXBzaG90ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZ2V0U2VydmVyU25hcHNob3QsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciAnICsgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBXaWxsIHJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLicpO1xuICB9XG5cbiAgcmV0dXJuIGdldFNlcnZlclNuYXBzaG90KCk7XG59XG5cbmZ1bmN0aW9uIHVzZURlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG5cbiAge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN1cHBvcnRlZFN0YXJ0VHJhbnNpdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdzdGFydFRyYW5zaXRpb24gY2Fubm90IGJlIGNhbGxlZCBkdXJpbmcgc2VydmVyIHJlbmRlcmluZy4nKTtcbn1cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbigpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICByZXR1cm4gW2ZhbHNlLCB1bnN1cHBvcnRlZFN0YXJ0VHJhbnNpdGlvbl07XG59XG5cbmZ1bmN0aW9uIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzKCkge1xuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHJldHVybiBOb3RQZW5kaW5nVHJhbnNpdGlvbjtcbn1cblxuZnVuY3Rpb24gdW5zdXBwb3J0ZWRTZXRPcHRpbWlzdGljU3RhdGUoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVwZGF0ZSBvcHRpbWlzdGljIHN0YXRlIHdoaWxlIHJlbmRlcmluZy4nKTtcbn1cblxuZnVuY3Rpb24gdXNlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHJldHVybiBbcGFzc3Rocm91Z2gsIHVuc3VwcG9ydGVkU2V0T3B0aW1pc3RpY1N0YXRlXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9zdGJhY2tGb3JtU3RhdGVLZXkocGVybWFsaW5rLCBjb21wb25lbnRLZXlQYXRoLCBob29rSW5kZXgpIHtcbiAgaWYgKHBlcm1hbGluayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gRG9uJ3QgYm90aGVyIHRvIGhhc2ggYSBwZXJtYWxpbmstYmFzZWQga2V5IHNpbmNlIGl0J3MgYWxyZWFkeSBzaG9ydC5cbiAgICByZXR1cm4gJ3AnICsgcGVybWFsaW5rO1xuICB9IGVsc2Uge1xuICAgIC8vIEFwcGVuZCBhIG5vZGUgdG8gdGhlIGtleSBwYXRoIHRoYXQgcmVwcmVzZW50cyB0aGUgZm9ybSBzdGF0ZSBob29rLlxuICAgIHZhciBrZXlQYXRoID0gW2NvbXBvbmVudEtleVBhdGgsIG51bGwsIGhvb2tJbmRleF07IC8vIEtleSBwYXRocyBhcmUgaGFzaGVkIHRvIHJlZHVjZSB0aGUgc2l6ZS4gSXQgZG9lcyBub3QgbmVlZCB0byBiZSBzZWN1cmUsXG4gICAgLy8gYW5kIGl0J3MgbW9yZSBpbXBvcnRhbnQgdGhhdCBpdCdzIGZhc3QgdGhhbiB0aGF0IGl0J3MgY29tcGxldGVseVxuICAgIC8vIGNvbGxpc2lvbi1mcmVlLlxuXG4gICAgdmFyIGtleVBhdGhIYXNoID0gY3JlYXRlRmFzdEhhc2hKUyhKU09OLnN0cmluZ2lmeShrZXlQYXRoKSk7XG4gICAgcmV0dXJuICdrJyArIGtleVBhdGhIYXNoO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUZvcm1TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTsgLy8gQ291bnQgdGhlIG51bWJlciBvZiB1c2VGb3JtU3RhdGUgaG9va3MgcGVyIGNvbXBvbmVudC4gV2UgYWxzbyB1c2UgdGhpcyB0b1xuICAvLyB0cmFjayB0aGUgcG9zaXRpb24gb2YgdGhpcyB1c2VGb3JtU3RhdGUgaG9vayByZWxhdGl2ZSB0byB0aGUgb3RoZXIgb25lcyBpblxuICAvLyB0aGlzIGNvbXBvbmVudCwgc28gd2UgY2FuIGdlbmVyYXRlIGEgdW5pcXVlIGtleSBmb3IgZWFjaCBvbmUuXG5cbiAgdmFyIGZvcm1TdGF0ZUhvb2tJbmRleCA9IGZvcm1TdGF0ZUNvdW50ZXIrKztcbiAgdmFyIHJlcXVlc3QgPSBjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0OyAvLyAkRmxvd0lnbm9yZVtwcm9wLW1pc3NpbmddXG5cbiAgdmFyIGZvcm1BY3Rpb24gPSBhY3Rpb24uJCRGT1JNX0FDVElPTjtcblxuICBpZiAodHlwZW9mIGZvcm1BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUaGlzIGlzIGEgc2VydmVyIGFjdGlvbi4gVGhlc2UgaGF2ZSBhZGRpdGlvbmFsIGZlYXR1cmVzIHRvIGVuYWJsZVxuICAgIC8vIE1QQS1zdHlsZSBmb3JtIHN1Ym1pc3Npb25zIHdpdGggcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQuXG4gICAgLy8gVE9ETzogSWYgdGhlIHNhbWUgcGVybWFsaW5rIGlzIHBhc3NlZCB0byBtdWx0aXBsZSB1c2VGb3JtU3RhdGVzLCBhbmRcbiAgICAvLyB0aGV5IGFsbCBoYXZlIHRoZSBzYW1lIGFjdGlvbiBzaWduYXR1cmUsIEZpenogd2lsbCBwYXNzIHRoZSBwb3N0YmFja1xuICAgIC8vIHN0YXRlIHRvIGFsbCBvZiB0aGVtLiBXZSBzaG91bGQgcHJvYmFibHkgb25seSBwYXNzIGl0IHRvIHRoZSBmaXJzdCBvbmUsXG4gICAgLy8gYW5kL29yIHdhcm4uXG4gICAgLy8gVGhlIGtleSBpcyBsYXppbHkgZ2VuZXJhdGVkIGFuZCBkZWR1cGVkIHNvIHRoZSB0aGF0IHRoZSBrZXlwYXRoIGRvZXNuJ3RcbiAgICAvLyBnZXQgSlNPTi5zdHJpbmdpZnktZWQgdW5uZWNlc3NhcmlseSwgYW5kIGF0IG1vc3Qgb25jZS5cbiAgICB2YXIgbmV4dFBvc3RiYWNrU3RhdGVLZXkgPSBudWxsOyAvLyBEZXRlcm1pbmUgdGhlIGN1cnJlbnQgZm9ybSBzdGF0ZS4gSWYgd2UgcmVjZWl2ZWQgc3RhdGUgZHVyaW5nIGFuIE1QQSBmb3JtXG4gICAgLy8gc3VibWlzc2lvbiwgdGhlbiB3ZSB3aWxsIHJldXNlIHRoYXQsIGlmIHRoZSBhY3Rpb24gaWRlbnRpdHkgbWF0Y2hlcy5cbiAgICAvLyBPdGhlcndpc2Ugd2UnbGwgdXNlIHRoZSBpbml0aWFsIHN0YXRlIGFyZ3VtZW50LiBXZSB3aWxsIGVtaXQgYSBjb21tZW50XG4gICAgLy8gbWFya2VyIGludG8gdGhlIHN0cmVhbSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBzdGF0ZSB3YXMgcmV1c2VkLlxuXG4gICAgdmFyIHN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIHZhciBjb21wb25lbnRLZXlQYXRoID0gY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aDtcbiAgICB2YXIgcG9zdGJhY2tGb3JtU3RhdGUgPSBnZXRGb3JtU3RhdGUocmVxdWVzdCk7IC8vICRGbG93SWdub3JlW3Byb3AtbWlzc2luZ11cblxuICAgIHZhciBpc1NpZ25hdHVyZUVxdWFsID0gYWN0aW9uLiQkSVNfU0lHTkFUVVJFX0VRVUFMO1xuXG4gICAgaWYgKHBvc3RiYWNrRm9ybVN0YXRlICE9PSBudWxsICYmIHR5cGVvZiBpc1NpZ25hdHVyZUVxdWFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgcG9zdGJhY2tLZXkgPSBwb3N0YmFja0Zvcm1TdGF0ZVsxXTtcbiAgICAgIHZhciBwb3N0YmFja1JlZmVyZW5jZUlkID0gcG9zdGJhY2tGb3JtU3RhdGVbMl07XG4gICAgICB2YXIgcG9zdGJhY2tCb3VuZEFyaXR5ID0gcG9zdGJhY2tGb3JtU3RhdGVbM107XG5cbiAgICAgIGlmIChpc1NpZ25hdHVyZUVxdWFsLmNhbGwoYWN0aW9uLCBwb3N0YmFja1JlZmVyZW5jZUlkLCBwb3N0YmFja0JvdW5kQXJpdHkpKSB7XG4gICAgICAgIG5leHRQb3N0YmFja1N0YXRlS2V5ID0gY3JlYXRlUG9zdGJhY2tGb3JtU3RhdGVLZXkocGVybWFsaW5rLCBjb21wb25lbnRLZXlQYXRoLCBmb3JtU3RhdGVIb29rSW5kZXgpO1xuXG4gICAgICAgIGlmIChwb3N0YmFja0tleSA9PT0gbmV4dFBvc3RiYWNrU3RhdGVLZXkpIHtcbiAgICAgICAgICAvLyBUaGlzIHdhcyBhIG1hdGNoXG4gICAgICAgICAgZm9ybVN0YXRlTWF0Y2hpbmdJbmRleCA9IGZvcm1TdGF0ZUhvb2tJbmRleDsgLy8gUmV1c2UgdGhlIHN0YXRlIHRoYXQgd2FzIHN1Ym1pdHRlZCBieSB0aGUgZm9ybS5cblxuICAgICAgICAgIHN0YXRlID0gcG9zdGJhY2tGb3JtU3RhdGVbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEJpbmQgdGhlIHN0YXRlIHRvIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgYWN0aW9uLlxuXG5cbiAgICB2YXIgYm91bmRBY3Rpb24gPSBhY3Rpb24uYmluZChudWxsLCBzdGF0ZSk7IC8vIFdyYXAgdGhlIGFjdGlvbiBzbyB0aGUgcmV0dXJuIHZhbHVlIGlzIHZvaWQuXG5cbiAgICB2YXIgZGlzcGF0Y2ggPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgYm91bmRBY3Rpb24ocGF5bG9hZCk7XG4gICAgfTsgLy8gJEZsb3dJZ25vcmVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICBpZiAodHlwZW9mIGJvdW5kQWN0aW9uLiQkRk9STV9BQ1RJT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vICRGbG93SWdub3JlW3Byb3AtbWlzc2luZ11cbiAgICAgIGRpc3BhdGNoLiQkRk9STV9BQ1RJT04gPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IGJvdW5kQWN0aW9uLiQkRk9STV9BQ1RJT04ocHJlZml4KTsgLy8gT3ZlcnJpZGUgdGhlIGFjdGlvbiBVUkxcblxuICAgICAgICBpZiAocGVybWFsaW5rICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHBlcm1hbGluaywgJ3RhcmdldCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBlcm1hbGluayArPSAnJztcbiAgICAgICAgICBtZXRhZGF0YS5hY3Rpb24gPSBwZXJtYWxpbms7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZm9ybURhdGEgPSBtZXRhZGF0YS5kYXRhO1xuXG4gICAgICAgIGlmIChmb3JtRGF0YSkge1xuICAgICAgICAgIGlmIChuZXh0UG9zdGJhY2tTdGF0ZUtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbmV4dFBvc3RiYWNrU3RhdGVLZXkgPSBjcmVhdGVQb3N0YmFja0Zvcm1TdGF0ZUtleShwZXJtYWxpbmssIGNvbXBvbmVudEtleVBhdGgsIGZvcm1TdGF0ZUhvb2tJbmRleCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKCckQUNUSU9OX0tFWScsIG5leHRQb3N0YmFja1N0YXRlS2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtzdGF0ZSwgZGlzcGF0Y2hdO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgbm90IGEgc2VydmVyIGFjdGlvbiwgc28gdGhlIGltcGxlbWVudGF0aW9uIGlzIG11Y2ggc2ltcGxlci5cbiAgICAvLyBCaW5kIHRoZSBzdGF0ZSB0byB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGFjdGlvbi5cbiAgICB2YXIgX2JvdW5kQWN0aW9uID0gYWN0aW9uLmJpbmQobnVsbCwgaW5pdGlhbFN0YXRlKTsgLy8gV3JhcCB0aGUgYWN0aW9uIHNvIHRoZSByZXR1cm4gdmFsdWUgaXMgdm9pZC5cblxuXG4gICAgdmFyIF9kaXNwYXRjaDIgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgX2JvdW5kQWN0aW9uKHBheWxvYWQpO1xuICAgIH07XG5cbiAgICByZXR1cm4gW2luaXRpYWxTdGF0ZSwgX2Rpc3BhdGNoMl07XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlSWQoKSB7XG4gIHZhciB0YXNrID0gY3VycmVudGx5UmVuZGVyaW5nVGFzaztcbiAgdmFyIHRyZWVJZCA9IGdldFRyZWVJZCh0YXNrLnRyZWVDb250ZXh0KTtcbiAgdmFyIHJlc3VtYWJsZVN0YXRlID0gY3VycmVudFJlc3VtYWJsZVN0YXRlO1xuXG4gIGlmIChyZXN1bWFibGVTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuJyk7XG4gIH1cblxuICB2YXIgbG9jYWxJZCA9IGxvY2FsSWRDb3VudGVyKys7XG4gIHJldHVybiBtYWtlSWQocmVzdW1hYmxlU3RhdGUsIHRyZWVJZCwgbG9jYWxJZCk7XG59XG5cbmZ1bmN0aW9uIHVzZSh1c2FibGUpIHtcbiAgaWYgKHVzYWJsZSAhPT0gbnVsbCAmJiB0eXBlb2YgdXNhYmxlID09PSAnb2JqZWN0Jykge1xuICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICBpZiAodHlwZW9mIHVzYWJsZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdGhlbmFibGUuXG4gICAgICB2YXIgdGhlbmFibGUgPSB1c2FibGU7XG4gICAgICByZXR1cm4gdW53cmFwVGhlbmFibGUodGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAodXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHVzYWJsZTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0FuIHVuc3VwcG9ydGVkIHR5cGUgd2FzIHBhc3NlZCB0byB1c2UoKTogJyArIFN0cmluZyh1c2FibGUpKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwVGhlbmFibGUodGhlbmFibGUpIHtcbiAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXI7XG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyICs9IDE7XG5cbiAgaWYgKHRoZW5hYmxlU3RhdGUgPT09IG51bGwpIHtcbiAgICB0aGVuYWJsZVN0YXRlID0gY3JlYXRlVGhlbmFibGVTdGF0ZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCk7XG59XG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkUmVmcmVzaCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDYWNoZSBjYW5ub3QgYmUgcmVmcmVzaGVkIGR1cmluZyBzZXJ2ZXIgcmVuZGVyaW5nLicpO1xufVxuXG5mdW5jdGlvbiB1c2VDYWNoZVJlZnJlc2goKSB7XG4gIHJldHVybiB1bnN1cHBvcnRlZFJlZnJlc2g7XG59XG5cbmZ1bmN0aW9uIG5vb3AkMSgpIHt9XG5cbnZhciBIb29rc0Rpc3BhdGNoZXIgPSB7XG4gIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgdXNlOiB1c2UsXG4gIHVzZUNvbnRleHQ6IHVzZUNvbnRleHQsXG4gIHVzZU1lbW86IHVzZU1lbW8sXG4gIHVzZVJlZHVjZXI6IHVzZVJlZHVjZXIsXG4gIHVzZVJlZjogdXNlUmVmLFxuICB1c2VTdGF0ZTogdXNlU3RhdGUsXG4gIHVzZUluc2VydGlvbkVmZmVjdDogbm9vcCQxLFxuICB1c2VMYXlvdXRFZmZlY3Q6IG5vb3AkMSxcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrLFxuICAvLyB1c2VJbXBlcmF0aXZlSGFuZGxlIGlzIG5vdCBydW4gaW4gdGhlIHNlcnZlciBlbnZpcm9ubWVudFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBub29wJDEsXG4gIC8vIEVmZmVjdHMgYXJlIG5vdCBydW4gaW4gdGhlIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgdXNlRWZmZWN0OiBub29wJDEsXG4gIC8vIERlYnVnZ2luZyBlZmZlY3RcbiAgdXNlRGVidWdWYWx1ZTogbm9vcCQxLFxuICB1c2VEZWZlcnJlZFZhbHVlOiB1c2VEZWZlcnJlZFZhbHVlLFxuICB1c2VUcmFuc2l0aW9uOiB1c2VUcmFuc2l0aW9uLFxuICB1c2VJZDogdXNlSWQsXG4gIC8vIFN1YnNjcmlwdGlvbnMgYXJlIG5vdCBzZXR1cCBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgdXNlU3luY0V4dGVybmFsU3RvcmU6IHVzZVN5bmNFeHRlcm5hbFN0b3JlXG59O1xuXG57XG4gIEhvb2tzRGlzcGF0Y2hlci51c2VDYWNoZVJlZnJlc2ggPSB1c2VDYWNoZVJlZnJlc2g7XG59XG5cbntcbiAgSG9va3NEaXNwYXRjaGVyLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG59XG5cbntcbiAgSG9va3NEaXNwYXRjaGVyLnVzZU9wdGltaXN0aWMgPSB1c2VPcHRpbWlzdGljO1xuICBIb29rc0Rpc3BhdGNoZXIudXNlRm9ybVN0YXRlID0gdXNlRm9ybVN0YXRlO1xufVxuXG52YXIgY3VycmVudFJlc3VtYWJsZVN0YXRlID0gbnVsbDtcbmZ1bmN0aW9uIHNldEN1cnJlbnRSZXN1bWFibGVTdGF0ZShyZXN1bWFibGVTdGF0ZSkge1xuICBjdXJyZW50UmVzdW1hYmxlU3RhdGUgPSByZXN1bWFibGVTdGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2FjaGVTaWduYWwoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLicpO1xufVxuXG5mdW5jdGlvbiBnZXRDYWNoZUZvclR5cGUocmVzb3VyY2VUeXBlKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLicpO1xufVxuXG52YXIgRGVmYXVsdENhY2hlRGlzcGF0Y2hlciA9IHtcbiAgZ2V0Q2FjaGVTaWduYWw6IGdldENhY2hlU2lnbmFsLFxuICBnZXRDYWNoZUZvclR5cGU6IGdldENhY2hlRm9yVHlwZVxufTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tCeUNvbXBvbmVudFN0YWNrTm9kZShjb21wb25lbnRTdGFjaykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgdmFyIG5vZGUgPSBjb21wb25lbnRTdGFjaztcblxuICAgIGRvIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGluZm8gKz0gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobm9kZS50eXBlLCBudWxsLCBudWxsKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaW5mbyArPSBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUobm9kZS50eXBlLCBudWxsLCBudWxsKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaW5mbyArPSBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUobm9kZS50eXBlLCBudWxsLCBudWxsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gd2UgYmFpbCBvdXQgd2hlbiB3ZSBnZXQgYSBudWxsXG5cblxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH0gd2hpbGUgKG5vZGUpO1xuXG4gICAgcmV0dXJuIGluZm87XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICByZXR1cm4gJ1xcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6ICcgKyB4Lm1lc3NhZ2UgKyAnXFxuJyArIHguc3RhY2s7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIFJlYWN0Q3VycmVudENhY2hlID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50Q2FjaGU7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7IC8vIExpbmtlZCBsaXN0IHJlcHJlc2VudGluZyB0aGUgaWRlbnRpdHkgb2YgYSBjb21wb25lbnQgZ2l2ZW4gdGhlIGNvbXBvbmVudC90YWcgbmFtZSBhbmQga2V5LlxuLy8gVGhlIG5hbWUgbWlnaHQgYmUgbWluaWZpZWQgYnV0IHdlIGFzc3VtZSB0aGF0IGl0J3MgZ29pbmcgdG8gYmUgdGhlIHNhbWUgZ2VuZXJhdGVkIG5hbWUuIFR5cGljYWxseVxuLy8gYmVjYXVzZSBpdCdzIGp1c3QgdGhlIHNhbWUgY29tcGlsZWQgb3V0cHV0IGluIHByYWN0aWNlLlxuLy8gcmVzdW1lIHdpdGggc2VnbWVudElEIGF0IHRoZSBpbmRleFxuXG52YXIgQ0xJRU5UX1JFTkRFUkVEID0gNDsgLy8gaWYgaXQgZXJyb3JzIG9yIGluZmluaXRlbHkgc3VzcGVuZHNcblxudmFyIFBFTkRJTkcgPSAwO1xudmFyIENPTVBMRVRFRCA9IDE7XG52YXIgRkxVU0hFRCA9IDI7XG52YXIgQUJPUlRFRCA9IDM7XG52YXIgRVJST1JFRCA9IDQ7XG52YXIgUE9TVFBPTkVEID0gNTtcbnZhciBPUEVOID0gMDtcbnZhciBDTE9TSU5HID0gMTtcbnZhciBDTE9TRUQgPSAyOyAvLyBUaGlzIGlzIGEgZGVmYXVsdCBoZXVyaXN0aWMgZm9yIGhvdyB0byBzcGxpdCB1cCB0aGUgSFRNTCBjb250ZW50IGludG8gcHJvZ3Jlc3NpdmVcbi8vIGxvYWRpbmcuIE91ciBnb2FsIGlzIHRvIGJlIGFibGUgdG8gZGlzcGxheSBhZGRpdGlvbmFsIG5ldyBjb250ZW50IGFib3V0IGV2ZXJ5IDUwMG1zLlxuLy8gRmFzdGVyIHRoYW4gdGhhdCBpcyB1bm5lY2Vzc2FyeSBhbmQgc2hvdWxkIGJlIHRocm90dGxlZCBvbiB0aGUgY2xpZW50LiBJdCBhbHNvXG4vLyBhZGRzIHVubmVjZXNzYXJ5IG92ZXJoZWFkIHRvIGRvIG1vcmUgc3BsaXRzLiBXZSBkb24ndCBrbm93IGlmIGl0J3MgYSBoaWdoZXIgb3IgbG93ZXJcbi8vIGVuZCBkZXZpY2UgYnV0IGhpZ2hlciBlbmQgc3VmZmVyIGxlc3MgZnJvbSB0aGUgb3ZlcmhlYWQgdGhhbiBsb3dlciBlbmQgZG9lcyBmcm9tXG4vLyBub3QgZ2V0dGluZyBzbWFsbCBlbm91Z2ggcGllY2VzLiBXZSBlcnJvciBvbiB0aGUgc2lkZSBvZiBsb3cgZW5kLlxuLy8gV2UgYmFzZSB0aGlzIG9uIGxvdyBlbmQgM0cgc3BlZWRzIHdoaWNoIGlzIGFib3V0IDUwMGtiaXRzIHBlciBzZWNvbmQuIFdlIGFzc3VtZVxuLy8gdGhhdCB0aGVyZSBjYW4gYmUgYSByZWFzb25hYmxlIGRyb3Agb2ZmIGZyb20gbWF4IGJhbmR3aWR0aCB3aGljaCBsZWF2ZXMgeW91IHdpdGhcbi8vIGFzIGxpdHRsZSBhcyA4MCUuIFdlIGNhbiByZWNlaXZlIGhhbGYgb2YgdGhhdCBlYWNoIDUwMG1zIC0gYXQgYmVzdC4gSW4gcHJhY3RpY2UsXG4vLyBhIGxpdHRsZSBiYW5kd2lkdGggaXMgbG9zdCB0byBwcm9jZXNzaW5nIGFuZCBjb250ZW50aW9uIC0gZS5nLiBDU1MgYW5kIGltYWdlcyB0aGF0XG4vLyBhcmUgZG93bmxvYWRlZCBhbG9uZyB3aXRoIHRoZSBtYWluIGNvbnRlbnQuIFNvIHdlIGVzdGltYXRlIGFib3V0IGhhbGYgb2YgdGhhdCB0byBiZVxuLy8gdGhlIGxvd2VyIGVuZCB0aHJvdWdocHV0LiBJbiBvdGhlciB3b3Jkcywgd2UgZXhwZWN0IHRoYXQgeW91IGNhbiBhdCBsZWFzdCBzaG93XG4vLyBhYm91dCAxMi41a2Igb2YgY29udGVudCBwZXIgNTAwbXMuIE5vdCBjb3VudGluZyBzdGFydGluZyBsYXRlbmN5IGZvciB0aGUgZmlyc3Rcbi8vIHBhaW50LlxuLy8gNTAwICogMTAyNCAvIDggKiAuOCAqIDAuNSAvIDJcblxudmFyIERFRkFVTFRfUFJPR1JFU1NJVkVfQ0hVTktfU0laRSA9IDEyODAwO1xuXG5mdW5jdGlvbiBkZWZhdWx0RXJyb3JIYW5kbGVyKGVycm9yKSB7XG4gIGNvbnNvbGVbJ2Vycm9yJ10oZXJyb3IpOyAvLyBEb24ndCB0cmFuc2Zvcm0gdG8gb3VyIHdyYXBwZXJcblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3QoY2hpbGRyZW4sIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgcm9vdEZvcm1hdENvbnRleHQsIHByb2dyZXNzaXZlQ2h1bmtTaXplLCBvbkVycm9yLCBvbkFsbFJlYWR5LCBvblNoZWxsUmVhZHksIG9uU2hlbGxFcnJvciwgb25GYXRhbEVycm9yLCBvblBvc3Rwb25lLCBmb3JtU3RhdGUpIHtcbiAgcHJlcGFyZUhvc3REaXNwYXRjaGVyKCk7XG4gIHZhciBwaW5nZWRUYXNrcyA9IFtdO1xuICB2YXIgYWJvcnRTZXQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXF1ZXN0ID0ge1xuICAgIGRlc3RpbmF0aW9uOiBudWxsLFxuICAgIGZsdXNoU2NoZWR1bGVkOiBmYWxzZSxcbiAgICByZXN1bWFibGVTdGF0ZTogcmVzdW1hYmxlU3RhdGUsXG4gICAgcmVuZGVyU3RhdGU6IHJlbmRlclN0YXRlLFxuICAgIHJvb3RGb3JtYXRDb250ZXh0OiByb290Rm9ybWF0Q29udGV4dCxcbiAgICBwcm9ncmVzc2l2ZUNodW5rU2l6ZTogcHJvZ3Jlc3NpdmVDaHVua1NpemUgPT09IHVuZGVmaW5lZCA/IERFRkFVTFRfUFJPR1JFU1NJVkVfQ0hVTktfU0laRSA6IHByb2dyZXNzaXZlQ2h1bmtTaXplLFxuICAgIHN0YXR1czogT1BFTixcbiAgICBmYXRhbEVycm9yOiBudWxsLFxuICAgIG5leHRTZWdtZW50SWQ6IDAsXG4gICAgYWxsUGVuZGluZ1Rhc2tzOiAwLFxuICAgIHBlbmRpbmdSb290VGFza3M6IDAsXG4gICAgY29tcGxldGVkUm9vdFNlZ21lbnQ6IG51bGwsXG4gICAgYWJvcnRhYmxlVGFza3M6IGFib3J0U2V0LFxuICAgIHBpbmdlZFRhc2tzOiBwaW5nZWRUYXNrcyxcbiAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXM6IFtdLFxuICAgIGNvbXBsZXRlZEJvdW5kYXJpZXM6IFtdLFxuICAgIHBhcnRpYWxCb3VuZGFyaWVzOiBbXSxcbiAgICB0cmFja2VkUG9zdHBvbmVzOiBudWxsLFxuICAgIG9uRXJyb3I6IG9uRXJyb3IgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRFcnJvckhhbmRsZXIgOiBvbkVycm9yLFxuICAgIG9uUG9zdHBvbmU6IG9uUG9zdHBvbmUgPT09IHVuZGVmaW5lZCA/IG5vb3AgOiBvblBvc3Rwb25lLFxuICAgIG9uQWxsUmVhZHk6IG9uQWxsUmVhZHkgPT09IHVuZGVmaW5lZCA/IG5vb3AgOiBvbkFsbFJlYWR5LFxuICAgIG9uU2hlbGxSZWFkeTogb25TaGVsbFJlYWR5ID09PSB1bmRlZmluZWQgPyBub29wIDogb25TaGVsbFJlYWR5LFxuICAgIG9uU2hlbGxFcnJvcjogb25TaGVsbEVycm9yID09PSB1bmRlZmluZWQgPyBub29wIDogb25TaGVsbEVycm9yLFxuICAgIG9uRmF0YWxFcnJvcjogb25GYXRhbEVycm9yID09PSB1bmRlZmluZWQgPyBub29wIDogb25GYXRhbEVycm9yLFxuICAgIGZvcm1TdGF0ZTogZm9ybVN0YXRlID09PSB1bmRlZmluZWQgPyBudWxsIDogZm9ybVN0YXRlXG4gIH07IC8vIFRoaXMgc2VnbWVudCByZXByZXNlbnRzIHRoZSByb290IGZhbGxiYWNrLlxuXG4gIHZhciByb290U2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KHJlcXVlc3QsIDAsIG51bGwsIHJvb3RGb3JtYXRDb250ZXh0LCAvLyBSb290IHNlZ21lbnRzIGFyZSBuZXZlciBlbWJlZGRlZCBpbiBUZXh0IG9uIGVpdGhlciBlZGdlXG4gIGZhbHNlLCBmYWxzZSk7IC8vIFRoZXJlIGlzIG5vIHBhcmVudCBzbyBjb25jZXB0dWFsbHksIHdlJ3JlIHVuYmxvY2tlZCB0byBmbHVzaCB0aGlzIHNlZ21lbnQuXG5cbiAgcm9vdFNlZ21lbnQucGFyZW50Rmx1c2hlZCA9IHRydWU7XG4gIHZhciByb290VGFzayA9IGNyZWF0ZVJlbmRlclRhc2socmVxdWVzdCwgbnVsbCwgY2hpbGRyZW4sIC0xLCBudWxsLCByb290U2VnbWVudCwgYWJvcnRTZXQsIG51bGwsIHJvb3RGb3JtYXRDb250ZXh0LCBlbXB0eUNvbnRleHRPYmplY3QsIHJvb3RDb250ZXh0U25hcHNob3QsIGVtcHR5VHJlZUNvbnRleHQsIG51bGwpO1xuICBwaW5nZWRUYXNrcy5wdXNoKHJvb3RUYXNrKTtcbiAgcmV0dXJuIHJlcXVlc3Q7XG59XG52YXIgY3VycmVudFJlcXVlc3QgPSBudWxsO1xuZnVuY3Rpb24gcmVzb2x2ZVJlcXVlc3QoKSB7XG4gIGlmIChjdXJyZW50UmVxdWVzdCkgcmV0dXJuIGN1cnJlbnRSZXF1ZXN0O1xuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwaW5nVGFzayhyZXF1ZXN0LCB0YXNrKSB7XG4gIHZhciBwaW5nZWRUYXNrcyA9IHJlcXVlc3QucGluZ2VkVGFza3M7XG4gIHBpbmdlZFRhc2tzLnB1c2godGFzayk7XG5cbiAgaWYgKHJlcXVlc3QucGluZ2VkVGFza3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9IHJlcXVlc3QuZGVzdGluYXRpb24gIT09IG51bGw7XG4gICAgc2NoZWR1bGVXb3JrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtV29yayhyZXF1ZXN0KTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHJlcXVlc3QsIGZhbGxiYWNrQWJvcnRhYmxlVGFza3MpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6IFBFTkRJTkcsXG4gICAgcm9vdFNlZ21lbnRJRDogLTEsXG4gICAgcGFyZW50Rmx1c2hlZDogZmFsc2UsXG4gICAgcGVuZGluZ1Rhc2tzOiAwLFxuICAgIGNvbXBsZXRlZFNlZ21lbnRzOiBbXSxcbiAgICBieXRlU2l6ZTogMCxcbiAgICBmYWxsYmFja0Fib3J0YWJsZVRhc2tzOiBmYWxsYmFja0Fib3J0YWJsZVRhc2tzLFxuICAgIGVycm9yRGlnZXN0OiBudWxsLFxuICAgIHJlc291cmNlczogY3JlYXRlQm91bmRhcnlSZXNvdXJjZXMoKSxcbiAgICB0cmFja2VkQ29udGVudEtleVBhdGg6IG51bGwsXG4gICAgdHJhY2tlZEZhbGxiYWNrTm9kZTogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJUYXNrKHJlcXVlc3QsIHRoZW5hYmxlU3RhdGUsIG5vZGUsIGNoaWxkSW5kZXgsIGJsb2NrZWRCb3VuZGFyeSwgYmxvY2tlZFNlZ21lbnQsIGFib3J0U2V0LCBrZXlQYXRoLCBmb3JtYXRDb250ZXh0LCBsZWdhY3lDb250ZXh0LCBjb250ZXh0LCB0cmVlQ29udGV4dCwgY29tcG9uZW50U3RhY2spIHtcbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MrKztcblxuICBpZiAoYmxvY2tlZEJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKys7XG4gIH0gZWxzZSB7XG4gICAgYmxvY2tlZEJvdW5kYXJ5LnBlbmRpbmdUYXNrcysrO1xuICB9XG5cbiAgdmFyIHRhc2sgPSB7XG4gICAgcmVwbGF5OiBudWxsLFxuICAgIG5vZGU6IG5vZGUsXG4gICAgY2hpbGRJbmRleDogY2hpbGRJbmRleCxcbiAgICBwaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGluZ1Rhc2socmVxdWVzdCwgdGFzayk7XG4gICAgfSxcbiAgICBibG9ja2VkQm91bmRhcnk6IGJsb2NrZWRCb3VuZGFyeSxcbiAgICBibG9ja2VkU2VnbWVudDogYmxvY2tlZFNlZ21lbnQsXG4gICAgYWJvcnRTZXQ6IGFib3J0U2V0LFxuICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgZm9ybWF0Q29udGV4dDogZm9ybWF0Q29udGV4dCxcbiAgICBsZWdhY3lDb250ZXh0OiBsZWdhY3lDb250ZXh0LFxuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgdHJlZUNvbnRleHQ6IHRyZWVDb250ZXh0LFxuICAgIGNvbXBvbmVudFN0YWNrOiBjb21wb25lbnRTdGFjayxcbiAgICB0aGVuYWJsZVN0YXRlOiB0aGVuYWJsZVN0YXRlXG4gIH07XG4gIGFib3J0U2V0LmFkZCh0YXNrKTtcbiAgcmV0dXJuIHRhc2s7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcGxheVRhc2socmVxdWVzdCwgdGhlbmFibGVTdGF0ZSwgcmVwbGF5LCBub2RlLCBjaGlsZEluZGV4LCBibG9ja2VkQm91bmRhcnksIGFib3J0U2V0LCBrZXlQYXRoLCBmb3JtYXRDb250ZXh0LCBsZWdhY3lDb250ZXh0LCBjb250ZXh0LCB0cmVlQ29udGV4dCwgY29tcG9uZW50U3RhY2spIHtcbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MrKztcblxuICBpZiAoYmxvY2tlZEJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKys7XG4gIH0gZWxzZSB7XG4gICAgYmxvY2tlZEJvdW5kYXJ5LnBlbmRpbmdUYXNrcysrO1xuICB9XG5cbiAgcmVwbGF5LnBlbmRpbmdUYXNrcysrO1xuICB2YXIgdGFzayA9IHtcbiAgICByZXBsYXk6IHJlcGxheSxcbiAgICBub2RlOiBub2RlLFxuICAgIGNoaWxkSW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgcGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBpbmdUYXNrKHJlcXVlc3QsIHRhc2spO1xuICAgIH0sXG4gICAgYmxvY2tlZEJvdW5kYXJ5OiBibG9ja2VkQm91bmRhcnksXG4gICAgYmxvY2tlZFNlZ21lbnQ6IG51bGwsXG4gICAgYWJvcnRTZXQ6IGFib3J0U2V0LFxuICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgZm9ybWF0Q29udGV4dDogZm9ybWF0Q29udGV4dCxcbiAgICBsZWdhY3lDb250ZXh0OiBsZWdhY3lDb250ZXh0LFxuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgdHJlZUNvbnRleHQ6IHRyZWVDb250ZXh0LFxuICAgIGNvbXBvbmVudFN0YWNrOiBjb21wb25lbnRTdGFjayxcbiAgICB0aGVuYWJsZVN0YXRlOiB0aGVuYWJsZVN0YXRlXG4gIH07XG4gIGFib3J0U2V0LmFkZCh0YXNrKTtcbiAgcmV0dXJuIHRhc2s7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBlbmRpbmdTZWdtZW50KHJlcXVlc3QsIGluZGV4LCBib3VuZGFyeSwgcGFyZW50Rm9ybWF0Q29udGV4dCwgbGFzdFB1c2hlZFRleHQsIHRleHRFbWJlZGRlZCkge1xuICByZXR1cm4ge1xuICAgIHN0YXR1czogUEVORElORyxcbiAgICBpZDogLTEsXG4gICAgLy8gbGF6aWx5IGFzc2lnbmVkIGxhdGVyXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIHBhcmVudEZsdXNoZWQ6IGZhbHNlLFxuICAgIGNodW5rczogW10sXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIHBhcmVudEZvcm1hdENvbnRleHQ6IHBhcmVudEZvcm1hdENvbnRleHQsXG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIGxhc3RQdXNoZWRUZXh0OiBsYXN0UHVzaGVkVGV4dCxcbiAgICB0ZXh0RW1iZWRkZWQ6IHRleHRFbWJlZGRlZFxuICB9O1xufSAvLyBERVYtb25seSBnbG9iYWwgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHRhc2tcblxuXG52YXIgY3VycmVudFRhc2tJbkRFViA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRTdGFja0luREVWKCkge1xuICB7XG4gICAgaWYgKGN1cnJlbnRUYXNrSW5ERVYgPT09IG51bGwgfHwgY3VycmVudFRhc2tJbkRFVi5jb21wb25lbnRTdGFjayA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRTdGFja0J5Q29tcG9uZW50U3RhY2tOb2RlKGN1cnJlbnRUYXNrSW5ERVYuY29tcG9uZW50U3RhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrRnJvbU5vZGUoc3RhY2tOb2RlKSB7XG4gIHJldHVybiBnZXRTdGFja0J5Q29tcG9uZW50U3RhY2tOb2RlKHN0YWNrTm9kZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1aWx0SW5Db21wb25lbnRTdGFjayh0YXNrLCB0eXBlKSB7XG4gIHJldHVybiB7XG4gICAgdGFnOiAwLFxuICAgIHBhcmVudDogdGFzay5jb21wb25lbnRTdGFjayxcbiAgICB0eXBlOiB0eXBlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50U3RhY2sodGFzaywgdHlwZSkge1xuICByZXR1cm4ge1xuICAgIHRhZzogMSxcbiAgICBwYXJlbnQ6IHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgdHlwZTogdHlwZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc0NvbXBvbmVudFN0YWNrKHRhc2ssIHR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0YWc6IDIsXG4gICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgIHR5cGU6IHR5cGVcbiAgfTtcbn0gLy8gV2hpbGUgd2UgdHJhY2sgY29tcG9uZW50IHN0YWNrcyBpbiBwcm9kIGFsbCB0aGUgdGltZSB3ZSBvbmx5IHByb2R1Y2UgYSByZWlmaWVkIHN0YWNrIGluIGRldiBhbmRcbi8vIGR1cmluZyBwcmVyZW5kZXIgaW4gUHJvZC4gVGhlIHJlYXNvbiBmb3IgdGhpcyBpcyB0aGF0IHRoZSBzdGFjayBpcyB1c2VmdWwgZm9yIHByZXJlbmRlciB3aGVyZSB0aGUgdGltZWxpbmVzc1xuLy8gb2YgdGhlIHJlcXVlc3QgaXMgbGVzcyBjcml0aWNhbCB0aGFuIHRoZSBvYnNlcnZhYmlsaXR5IG9mIHRoZSBleGVjdXRpb24uIEZvciByZW5kZXJzIGFuZCByZXN1bWVzIGhvd2V2ZXIgd2Vcbi8vIHByaW9yaXRpemUgc3BlZWQgb2YgdGhlIHJlcXVlc3QuXG5cblxuZnVuY3Rpb24gZ2V0VGhyb3duSW5mbyhyZXF1ZXN0LCBub2RlKSB7XG4gIGlmIChub2RlICYmICggLy8gQWx3YXlzIHByb2R1Y2UgYSBzdGFjayBpbiBkZXZcbiAgdHJ1ZSApKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBvbmVudFN0YWNrOiBnZXRTdGFja0Zyb21Ob2RlKG5vZGUpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShib3VuZGFyeSwgZGlnZXN0LCBlcnJvciwgdGhyb3duSW5mbykge1xuICBib3VuZGFyeS5lcnJvckRpZ2VzdCA9IGRpZ2VzdDtcblxuICB7XG4gICAgLy8gSW4gZGV2IHdlIGFkZGl0aW9uYWxseSBlbmNvZGUgdGhlIGVycm9yIG1lc3NhZ2UgYW5kIGNvbXBvbmVudCBzdGFjayBvbiB0aGUgYm91bmRhcnlcbiAgICB2YXIgZXJyb3JNZXNzYWdlO1xuXG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yO1xuICAgIH0gZWxzZSBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgIGVycm9yTWVzc2FnZSA9IFN0cmluZyhlcnJvcik7XG4gICAgfVxuXG4gICAgYm91bmRhcnkuZXJyb3JNZXNzYWdlID0gZXJyb3JNZXNzYWdlO1xuICAgIGJvdW5kYXJ5LmVycm9yQ29tcG9uZW50U3RhY2sgPSB0aHJvd25JbmZvLmNvbXBvbmVudFN0YWNrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IkMSwgZXJyb3JJbmZvKSB7XG4gIC8vIElmIHRoaXMgY2FsbGJhY2sgZXJyb3JzLCB3ZSBpbnRlbnRpb25hbGx5IGxldCB0aGF0IGVycm9yIGJ1YmJsZSB1cCB0byBiZWNvbWUgYSBmYXRhbCBlcnJvclxuICAvLyBzbyB0aGF0IHNvbWVvbmUgZml4ZXMgdGhlIGVycm9yIHJlcG9ydGluZyBpbnN0ZWFkIG9mIGhpZGluZyBpdC5cbiAgdmFyIGVycm9yRGlnZXN0ID0gcmVxdWVzdC5vbkVycm9yKGVycm9yJDEsIGVycm9ySW5mbyk7XG5cbiAgaWYgKGVycm9yRGlnZXN0ICE9IG51bGwgJiYgdHlwZW9mIGVycm9yRGlnZXN0ICE9PSAnc3RyaW5nJykge1xuICAgIC8vIFdlIHVzZWQgdG8gdGhyb3cgaGVyZSBidXQgc2luY2UgdGhpcyBnZXRzIGNhbGxlZCBmcm9tIGEgdmFyaWV0eSBvZiB1bnByb3RlY3RlZCBwbGFjZXMgaXRcbiAgICAvLyBzZWVtcyBiZXR0ZXIgdG8ganVzdCB3YXJuIGFuZCBkaXNjYXJkIHRoZSByZXR1cm5lZCB2YWx1ZS5cbiAgICB7XG4gICAgICBlcnJvcignb25FcnJvciByZXR1cm5lZCBzb21ldGhpbmcgd2l0aCBhIHR5cGUgb3RoZXIgdGhhbiBcInN0cmluZ1wiLiBvbkVycm9yIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgYW5kIG1heSByZXR1cm4gbnVsbCBvciB1bmRlZmluZWQgYnV0IG11c3Qgbm90IHJldHVybiBhbnl0aGluZyBlbHNlLiBJdCByZWNlaXZlZCBzb21ldGhpbmcgb2YgdHlwZSBcIiVzXCIgaW5zdGVhZCcsIHR5cGVvZiBlcnJvckRpZ2VzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGVycm9yRGlnZXN0O1xufVxuXG5mdW5jdGlvbiBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yKSB7XG4gIC8vIFRoaXMgaXMgY2FsbGVkIG91dHNpZGUgZXJyb3IgaGFuZGxpbmcgY29kZSBzdWNoIGFzIGlmIHRoZSByb290IGVycm9ycyBvdXRzaWRlXG4gIC8vIGEgc3VzcGVuc2UgYm91bmRhcnkgb3IgaWYgdGhlIHJvb3Qgc3VzcGVuc2UgYm91bmRhcnkncyBmYWxsYmFjayBlcnJvcnMuXG4gIC8vIEl0J3MgYWxzbyBjYWxsZWQgaWYgUmVhY3QgaXRzZWxmIG9yIGl0cyBob3N0IGNvbmZpZ3MgZXJyb3JzLlxuICB2YXIgb25TaGVsbEVycm9yID0gcmVxdWVzdC5vblNoZWxsRXJyb3I7XG4gIG9uU2hlbGxFcnJvcihlcnJvcik7XG4gIHZhciBvbkZhdGFsRXJyb3IgPSByZXF1ZXN0Lm9uRmF0YWxFcnJvcjtcbiAgb25GYXRhbEVycm9yKGVycm9yKTtcblxuICBpZiAocmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbCkge1xuICAgIHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEO1xuICAgIGNsb3NlV2l0aEVycm9yKHJlcXVlc3QuZGVzdGluYXRpb24sIGVycm9yKTtcbiAgfSBlbHNlIHtcbiAgICByZXF1ZXN0LnN0YXR1cyA9IENMT1NJTkc7XG4gICAgcmVxdWVzdC5mYXRhbEVycm9yID0gZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyU3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCBzb21lVGFzaywga2V5UGF0aCwgcHJvcHMpIHtcbiAgaWYgKHNvbWVUYXNrLnJlcGxheSAhPT0gbnVsbCkge1xuICAgIC8vIElmIHdlJ3JlIHJlcGxheWluZyB0aHJvdWdoIHRoaXMgcGFzcywgaXQgbWVhbnMgd2UncmUgcmVwbGF5aW5nIHRocm91Z2hcbiAgICAvLyBhbiBhbHJlYWR5IGNvbXBsZXRlZCBTdXNwZW5zZSBib3VuZGFyeS4gSXQncyB0b28gbGF0ZSB0byBkbyBhbnl0aGluZyBhYm91dCBpdFxuICAgIC8vIHNvIHdlIGNhbiBqdXN0IHJlbmRlciB0aHJvdWdoIGl0LlxuICAgIHZhciBfcHJldktleVBhdGggPSBzb21lVGFzay5rZXlQYXRoO1xuICAgIHNvbWVUYXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgIHZhciBfY29udGVudCA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgc29tZVRhc2ssIF9jb250ZW50LCAtMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNvbWVUYXNrLmtleVBhdGggPSBfcHJldktleVBhdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9IC8vICRGbG93Rml4TWU6IFJlZmluZWQuXG5cblxuICB2YXIgdGFzayA9IHNvbWVUYXNrO1xuICB2YXIgcHJldmlvdXNDb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2s7IC8vIElmIHdlIGVuZCB1cCBjcmVhdGluZyB0aGUgZmFsbGJhY2sgdGFzayB3ZSBuZWVkIGl0IHRvIGhhdmUgdGhlIGNvcnJlY3Qgc3RhY2sgd2hpY2ggaXNcbiAgLy8gdGhlIHN0YWNrIGZvciB0aGUgYm91bmRhcnkgaXRzZWxmLiBXZSBzdGFzaCBpdCBoZXJlIHNvIHdlIGNhbiB1c2UgaXQgaWYgbmVlZGVkIGxhdGVyXG5cbiAgdmFyIHN1c3BlbnNlQ29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrID0gY3JlYXRlQnVpbHRJbkNvbXBvbmVudFN0YWNrKHRhc2ssICdTdXNwZW5zZScpO1xuICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG4gIHZhciBwYXJlbnRCb3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICB2YXIgcGFyZW50U2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7IC8vIEVhY2ggdGltZSB3ZSBlbnRlciBhIHN1c3BlbnNlIGJvdW5kYXJ5LCB3ZSBzcGxpdCBvdXQgaW50byBhIG5ldyBzZWdtZW50IGZvclxuICAvLyB0aGUgZmFsbGJhY2sgc28gdGhhdCB3ZSBjYW4gbGF0ZXIgcmVwbGFjZSB0aGF0IHNlZ21lbnQgd2l0aCB0aGUgY29udGVudC5cbiAgLy8gVGhpcyBhbHNvIGxldHMgdXMgc3BsaXQgb3V0IHRoZSBtYWluIGNvbnRlbnQgZXZlbiBpZiBpdCBkb2Vzbid0IHN1c3BlbmQsXG4gIC8vIGluIGNhc2UgaXQgZW5kcyB1cCBnZW5lcmF0aW5nIGEgbGFyZ2Ugc3VidHJlZSBvZiBjb250ZW50LlxuXG4gIHZhciBmYWxsYmFjayA9IHByb3BzLmZhbGxiYWNrO1xuICB2YXIgY29udGVudCA9IHByb3BzLmNoaWxkcmVuO1xuICB2YXIgZmFsbGJhY2tBYm9ydFNldCA9IG5ldyBTZXQoKTtcbiAgdmFyIG5ld0JvdW5kYXJ5ID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCBmYWxsYmFja0Fib3J0U2V0KTtcblxuICBpZiAocmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICE9PSBudWxsKSB7XG4gICAgbmV3Qm91bmRhcnkudHJhY2tlZENvbnRlbnRLZXlQYXRoID0ga2V5UGF0aDtcbiAgfVxuXG4gIHZhciBpbnNlcnRpb25JbmRleCA9IHBhcmVudFNlZ21lbnQuY2h1bmtzLmxlbmd0aDsgLy8gVGhlIGNoaWxkcmVuIG9mIHRoZSBib3VuZGFyeSBzZWdtZW50IGlzIGFjdHVhbGx5IHRoZSBmYWxsYmFjay5cblxuICB2YXIgYm91bmRhcnlTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQocmVxdWVzdCwgaW5zZXJ0aW9uSW5kZXgsIG5ld0JvdW5kYXJ5LCB0YXNrLmZvcm1hdENvbnRleHQsIC8vIGJvdW5kYXJpZXMgbmV2ZXIgcmVxdWlyZSB0ZXh0IGVtYmVkZGluZyBhdCB0aGVpciBlZGdlcyBiZWNhdXNlIGNvbW1lbnQgbm9kZXMgYm91bmQgdGhlbVxuICBmYWxzZSwgZmFsc2UpO1xuICBwYXJlbnRTZWdtZW50LmNoaWxkcmVuLnB1c2goYm91bmRhcnlTZWdtZW50KTsgLy8gVGhlIHBhcmVudFNlZ21lbnQgaGFzIGEgY2hpbGQgU2VnbWVudCBhdCB0aGlzIGluZGV4IHNvIHdlIHJlc2V0IHRoZSBsYXN0UHVzaGVkVGV4dCBtYXJrZXIgb24gdGhlIHBhcmVudFxuXG4gIHBhcmVudFNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBmYWxzZTsgLy8gVGhpcyBzZWdtZW50IGlzIHRoZSBhY3R1YWwgY2hpbGQgY29udGVudC4gV2UgY2FuIHN0YXJ0IHJlbmRlcmluZyB0aGF0IGltbWVkaWF0ZWx5LlxuXG4gIHZhciBjb250ZW50Um9vdFNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChyZXF1ZXN0LCAwLCBudWxsLCB0YXNrLmZvcm1hdENvbnRleHQsIC8vIGJvdW5kYXJpZXMgbmV2ZXIgcmVxdWlyZSB0ZXh0IGVtYmVkZGluZyBhdCB0aGVpciBlZGdlcyBiZWNhdXNlIGNvbW1lbnQgbm9kZXMgYm91bmQgdGhlbVxuICBmYWxzZSwgZmFsc2UpOyAvLyBXZSBtYXJrIHRoZSByb290IHNlZ21lbnQgYXMgaGF2aW5nIGl0cyBwYXJlbnQgZmx1c2hlZC4gSXQncyBub3QgcmVhbGx5IGZsdXNoZWQgYnV0IHRoZXJlIGlzXG4gIC8vIG5vIHBhcmVudCBzZWdtZW50IHNvIHRoZXJlJ3Mgbm90aGluZyB0byB3YWl0IG9uLlxuXG4gIGNvbnRlbnRSb290U2VnbWVudC5wYXJlbnRGbHVzaGVkID0gdHJ1ZTsgLy8gQ3VycmVudGx5IHRoaXMgaXMgcnVubmluZyBzeW5jaHJvbm91c2x5LiBXZSBjb3VsZCBpbnN0ZWFkIHNjaGVkdWxlIHRoaXMgdG8gcGluZ2VkVGFza3MuXG4gIC8vIEkgc3VzcGVjdCB0aGF0IHRoZXJlIG1pZ2h0IGJlIHNvbWUgZWZmaWNpZW5jeSBiZW5lZml0cyBmcm9tIG5vdCBjcmVhdGluZyB0aGUgc3VzcGVuZGVkIHRhc2tcbiAgLy8gYW5kIGluc3RlYWQganVzdCB1c2luZyB0aGUgc3RhY2sgaWYgcG9zc2libGUuXG4gIC8vIFRPRE86IENhbGwgdGhpcyBkaXJlY3RseSBpbnN0ZWFkIG9mIG1lc3Npbmcgd2l0aCBzYXZpbmcgYW5kIHJlc3RvcmluZyBjb250ZXh0cy5cbiAgLy8gV2UgY2FuIHJldXNlIHRoZSBjdXJyZW50IGNvbnRleHQgYW5kIHRhc2sgdG8gcmVuZGVyIHRoZSBjb250ZW50IGltbWVkaWF0ZWx5IHdpdGhvdXRcbiAgLy8gY29udGV4dCBzd2l0Y2hpbmcuIFdlIGp1c3QgbmVlZCB0byB0ZW1wb3JhcmlseSBzd2l0Y2ggd2hpY2ggYm91bmRhcnkgYW5kIHdoaWNoIHNlZ21lbnRcbiAgLy8gd2UncmUgd3JpdGluZyB0by4gSWYgc29tZXRoaW5nIHN1c3BlbmRzLCBpdCdsbCBzcGF3biBuZXcgc3VzcGVuZGVkIHRhc2sgd2l0aCB0aGF0IGNvbnRleHQuXG5cbiAgdGFzay5ibG9ja2VkQm91bmRhcnkgPSBuZXdCb3VuZGFyeTtcbiAgdGFzay5ibG9ja2VkU2VnbWVudCA9IGNvbnRlbnRSb290U2VnbWVudDtcblxuICB7XG4gICAgc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVxdWVzdC5yZW5kZXJTdGF0ZSwgbmV3Qm91bmRhcnkucmVzb3VyY2VzKTtcbiAgfVxuXG4gIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG5cbiAgdHJ5IHtcbiAgICAvLyBXZSB1c2UgdGhlIHNhZmUgZm9ybSBiZWNhdXNlIHdlIGRvbid0IGhhbmRsZSBzdXNwZW5kaW5nIGhlcmUuIE9ubHkgZXJyb3IgaGFuZGxpbmcuXG4gICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjb250ZW50LCAtMSk7XG4gICAgcHVzaFNlZ21lbnRGaW5hbGUoY29udGVudFJvb3RTZWdtZW50LmNodW5rcywgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgY29udGVudFJvb3RTZWdtZW50Lmxhc3RQdXNoZWRUZXh0LCBjb250ZW50Um9vdFNlZ21lbnQudGV4dEVtYmVkZGVkKTtcbiAgICBjb250ZW50Um9vdFNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgIHF1ZXVlQ29tcGxldGVkU2VnbWVudChuZXdCb3VuZGFyeSwgY29udGVudFJvb3RTZWdtZW50KTtcblxuICAgIGlmIChuZXdCb3VuZGFyeS5wZW5kaW5nVGFza3MgPT09IDAgJiYgbmV3Qm91bmRhcnkuc3RhdHVzID09PSBQRU5ESU5HKSB7XG4gICAgICAvLyBUaGlzIG11c3QgaGF2ZSBiZWVuIHRoZSBsYXN0IHNlZ21lbnQgd2Ugd2VyZSB3YWl0aW5nIG9uLiBUaGlzIGJvdW5kYXJ5IGlzIG5vdyBjb21wbGV0ZS5cbiAgICAgIC8vIFRoZXJlZm9yZSB3ZSB3b24ndCBuZWVkIHRoZSBmYWxsYmFjay4gV2UgZWFybHkgcmV0dXJuIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjcmVhdGVcbiAgICAgIC8vIHRoZSBmYWxsYmFjay5cbiAgICAgIG5ld0JvdW5kYXJ5LnN0YXR1cyA9IENPTVBMRVRFRDsgLy8gV2UgYXJlIHJldHVybmluZyBlYXJseSBzbyB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlXG5cbiAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb250ZW50Um9vdFNlZ21lbnQuc3RhdHVzID0gRVJST1JFRDtcbiAgICBuZXdCb3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQ7XG4gICAgdmFyIHRocm93bkluZm8gPSBnZXRUaHJvd25JbmZvKHJlcXVlc3QsIHRhc2suY29tcG9uZW50U3RhY2spO1xuICAgIHZhciBlcnJvckRpZ2VzdDtcblxuICAgIHtcbiAgICAgIGVycm9yRGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgdGhyb3duSW5mbyk7XG4gICAgfVxuXG4gICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShuZXdCb3VuZGFyeSwgZXJyb3JEaWdlc3QsIGVycm9yLCB0aHJvd25JbmZvKTtcbiAgICB1bnRyYWNrQm91bmRhcnkocmVxdWVzdCwgbmV3Qm91bmRhcnkpOyAvLyBXZSBkb24ndCBuZWVkIHRvIGRlY3JlbWVudCBhbnkgdGFzayBudW1iZXJzIGJlY2F1c2Ugd2UgZGlkbid0IHNwYXduIGFueSBuZXcgdGFzay5cbiAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHNjaGVkdWxlIGFueSB0YXNrIGJlY2F1c2Ugd2Uga25vdyB0aGUgcGFyZW50IGhhcyB3cml0dGVuIHlldC5cbiAgICAvLyBXZSBkbyBuZWVkIHRvIGZhbGx0aHJvdWdoIHRvIGNyZWF0ZSB0aGUgZmFsbGJhY2sgdGhvdWdoLlxuICB9IGZpbmFsbHkge1xuICAgIHtcbiAgICAgIHNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0KHJlcXVlc3QucmVuZGVyU3RhdGUsIHBhcmVudEJvdW5kYXJ5ID8gcGFyZW50Qm91bmRhcnkucmVzb3VyY2VzIDogbnVsbCk7XG4gICAgfVxuXG4gICAgdGFzay5ibG9ja2VkQm91bmRhcnkgPSBwYXJlbnRCb3VuZGFyeTtcbiAgICB0YXNrLmJsb2NrZWRTZWdtZW50ID0gcGFyZW50U2VnbWVudDtcbiAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgfVxuXG4gIHZhciBmYWxsYmFja0tleVBhdGggPSBba2V5UGF0aFswXSwgJ1N1c3BlbnNlIEZhbGxiYWNrJywga2V5UGF0aFsyXV07XG4gIHZhciB0cmFja2VkUG9zdHBvbmVzID0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzO1xuXG4gIGlmICh0cmFja2VkUG9zdHBvbmVzICE9PSBudWxsKSB7XG4gICAgLy8gV2UgY3JlYXRlIGEgZGV0YWNoZWQgcmVwbGF5IG5vZGUgdG8gdHJhY2sgYW55IHBvc3Rwb25lcyBpbnNpZGUgdGhlIGZhbGxiYWNrLlxuICAgIHZhciBmYWxsYmFja1JlcGxheU5vZGUgPSBbZmFsbGJhY2tLZXlQYXRoWzFdLCBmYWxsYmFja0tleVBhdGhbMl0sIFtdLCBudWxsXTtcbiAgICB0cmFja2VkUG9zdHBvbmVzLndvcmtpbmdNYXAuc2V0KGZhbGxiYWNrS2V5UGF0aCwgZmFsbGJhY2tSZXBsYXlOb2RlKTtcblxuICAgIGlmIChuZXdCb3VuZGFyeS5zdGF0dXMgPT09IFBPU1RQT05FRCkge1xuICAgICAgLy8gVGhpcyBtdXN0IGV4aXN0IG5vdy5cbiAgICAgIHZhciBib3VuZGFyeVJlcGxheU5vZGUgPSB0cmFja2VkUG9zdHBvbmVzLndvcmtpbmdNYXAuZ2V0KGtleVBhdGgpO1xuICAgICAgYm91bmRhcnlSZXBsYXlOb2RlWzRdID0gZmFsbGJhY2tSZXBsYXlOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBtaWdodCBub3QgaW5qZWN0IGl0IGludG8gdGhlIHBvc3Rwb25lZCB0cmVlLCB1bmxlc3MgdGhlIGNvbnRlbnQgYWN0dWFsbHlcbiAgICAgIC8vIHBvc3Rwb25lcyB0b28uIFdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBpdCB1bnRpbCB0aGF0IGhhcHBwZW5zLlxuICAgICAgbmV3Qm91bmRhcnkudHJhY2tlZEZhbGxiYWNrTm9kZSA9IGZhbGxiYWNrUmVwbGF5Tm9kZTtcbiAgICB9XG4gIH0gLy8gV2UgY3JlYXRlIHN1c3BlbmRlZCB0YXNrIGZvciB0aGUgZmFsbGJhY2sgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGFjdHVhbGx5IHdvcmtcbiAgLy8gb24gaXQgeWV0IGluIGNhc2Ugd2UgZmluaXNoIHRoZSBtYWluIGNvbnRlbnQsIHNvIHdlIHF1ZXVlIGZvciBsYXRlci5cblxuXG4gIHZhciBzdXNwZW5kZWRGYWxsYmFja1Rhc2sgPSBjcmVhdGVSZW5kZXJUYXNrKHJlcXVlc3QsIG51bGwsIGZhbGxiYWNrLCAtMSwgcGFyZW50Qm91bmRhcnksIGJvdW5kYXJ5U2VnbWVudCwgZmFsbGJhY2tBYm9ydFNldCwgZmFsbGJhY2tLZXlQYXRoLCB0YXNrLmZvcm1hdENvbnRleHQsIHRhc2subGVnYWN5Q29udGV4dCwgdGFzay5jb250ZXh0LCB0YXNrLnRyZWVDb250ZXh0LCAvLyBUaGlzIHN0YWNrIHNob3VsZCBiZSB0aGUgU3VzcGVuc2UgYm91bmRhcnkgc3RhY2sgYmVjYXVzZSB3aGlsZSB0aGUgZmFsbGJhY2sgaXMgYWN0dWFsbHkgYSBjaGlsZCBzZWdtZW50XG4gIC8vIG9mIHRoZSBwYXJlbnQgYm91bmRhcnkgZnJvbSBhIGNvbXBvbmVudCBzdGFuZHBvaW50IHRoZSBmYWxsYmFjayBpcyBhIGNoaWxkIG9mIHRoZSBTdXNwZW5zZSBib3VuZGFyeSBpdHNlbGZcbiAgc3VzcGVuc2VDb21wb25lbnRTdGFjayk7IC8vIFRPRE86IFRoaXMgc2hvdWxkIGJlIHF1ZXVlZCBhdCBhIHNlcGFyYXRlIGxvd2VyIHByaW9yaXR5IHF1ZXVlIHNvIHRoYXQgd2Ugb25seSB3b3JrXG4gIC8vIG9uIHByZXBhcmluZyBmYWxsYmFja3MgaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBtYWluIGNvbnRlbnQgdG8gdGFzayBvbi5cblxuICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2goc3VzcGVuZGVkRmFsbGJhY2tUYXNrKTtcbn1cblxuZnVuY3Rpb24gcmVwbGF5U3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcm9wcywgaWQsIGNoaWxkTm9kZXMsIGNoaWxkU2xvdHMsIGZhbGxiYWNrTm9kZXMsIGZhbGxiYWNrU2xvdHMpIHtcbiAgdmFyIHByZXZpb3VzQ29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrOyAvLyBJZiB3ZSBlbmQgdXAgY3JlYXRpbmcgdGhlIGZhbGxiYWNrIHRhc2sgd2UgbmVlZCBpdCB0byBoYXZlIHRoZSBjb3JyZWN0IHN0YWNrIHdoaWNoIGlzXG4gIC8vIHRoZSBzdGFjayBmb3IgdGhlIGJvdW5kYXJ5IGl0c2VsZi4gV2Ugc3Rhc2ggaXQgaGVyZSBzbyB3ZSBjYW4gdXNlIGl0IGlmIG5lZWRlZCBsYXRlclxuXG4gIHZhciBzdXNwZW5zZUNvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjayA9IGNyZWF0ZUJ1aWx0SW5Db21wb25lbnRTdGFjayh0YXNrLCAnU3VzcGVuc2UnKTtcbiAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICB2YXIgcHJldmlvdXNSZXBsYXlTZXQgPSB0YXNrLnJlcGxheTtcbiAgdmFyIHBhcmVudEJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnk7XG4gIHZhciBjb250ZW50ID0gcHJvcHMuY2hpbGRyZW47XG4gIHZhciBmYWxsYmFjayA9IHByb3BzLmZhbGxiYWNrO1xuICB2YXIgZmFsbGJhY2tBYm9ydFNldCA9IG5ldyBTZXQoKTtcbiAgdmFyIHJlc3VtZWRCb3VuZGFyeSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgZmFsbGJhY2tBYm9ydFNldCk7XG4gIHJlc3VtZWRCb3VuZGFyeS5wYXJlbnRGbHVzaGVkID0gdHJ1ZTsgLy8gV2UgcmVzdG9yZSB0aGUgc2FtZSBpZCBvZiB0aGlzIGJvdW5kYXJ5IGFzIHdhcyB1c2VkIGR1cmluZyBwcmVyZW5kZXIuXG5cbiAgcmVzdW1lZEJvdW5kYXJ5LnJvb3RTZWdtZW50SUQgPSBpZDsgLy8gV2UgY2FuIHJldXNlIHRoZSBjdXJyZW50IGNvbnRleHQgYW5kIHRhc2sgdG8gcmVuZGVyIHRoZSBjb250ZW50IGltbWVkaWF0ZWx5IHdpdGhvdXRcbiAgLy8gY29udGV4dCBzd2l0Y2hpbmcuIFdlIGp1c3QgbmVlZCB0byB0ZW1wb3JhcmlseSBzd2l0Y2ggd2hpY2ggYm91bmRhcnkgYW5kIHJlcGxheSBub2RlXG4gIC8vIHdlJ3JlIHdyaXRpbmcgdG8uIElmIHNvbWV0aGluZyBzdXNwZW5kcywgaXQnbGwgc3Bhd24gbmV3IHN1c3BlbmRlZCB0YXNrIHdpdGggdGhhdCBjb250ZXh0LlxuXG4gIHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gcmVzdW1lZEJvdW5kYXJ5O1xuICB0YXNrLnJlcGxheSA9IHtcbiAgICBub2RlczogY2hpbGROb2RlcyxcbiAgICBzbG90czogY2hpbGRTbG90cyxcbiAgICBwZW5kaW5nVGFza3M6IDFcbiAgfTtcblxuICB7XG4gICAgc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVxdWVzdC5yZW5kZXJTdGF0ZSwgcmVzdW1lZEJvdW5kYXJ5LnJlc291cmNlcyk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFdlIHVzZSB0aGUgc2FmZSBmb3JtIGJlY2F1c2Ugd2UgZG9uJ3QgaGFuZGxlIHN1c3BlbmRpbmcgaGVyZS4gT25seSBlcnJvciBoYW5kbGluZy5cbiAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNvbnRlbnQsIC0xKTtcblxuICAgIGlmICh0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MgPT09IDEgJiYgdGFzay5yZXBsYXkubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBcIiArIFwiVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCIpO1xuICAgIH1cblxuICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuXG4gICAgaWYgKHJlc3VtZWRCb3VuZGFyeS5wZW5kaW5nVGFza3MgPT09IDAgJiYgcmVzdW1lZEJvdW5kYXJ5LnN0YXR1cyA9PT0gUEVORElORykge1xuICAgICAgLy8gVGhpcyBtdXN0IGhhdmUgYmVlbiB0aGUgbGFzdCBzZWdtZW50IHdlIHdlcmUgd2FpdGluZyBvbi4gVGhpcyBib3VuZGFyeSBpcyBub3cgY29tcGxldGUuXG4gICAgICAvLyBUaGVyZWZvcmUgd2Ugd29uJ3QgbmVlZCB0aGUgZmFsbGJhY2suIFdlIGVhcmx5IHJldHVybiBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY3JlYXRlXG4gICAgICAvLyB0aGUgZmFsbGJhY2suXG4gICAgICByZXN1bWVkQm91bmRhcnkuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2gocmVzdW1lZEJvdW5kYXJ5KTsgLy8gV2UgcmVzdG9yZSB0aGUgcGFyZW50IGNvbXBvbmVudFN0YWNrLiBTZW1hbnRpY2FsbHkgdGhpcyBpcyB0aGUgc2FtZSBhc1xuICAgICAgLy8gcG9wQ29tcG9uZW50U3RhY2sodGFzaykgYnV0IHdlIGRvIHRoaXMgaW5zdGVhZCBiZWNhdXNlIGl0IHNob3VsZCBiZSBzbGlnaHRseVxuICAgICAgLy8gZmFzdGVyXG5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVzdW1lZEJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDtcbiAgICB2YXIgdGhyb3duSW5mbyA9IGdldFRocm93bkluZm8ocmVxdWVzdCwgdGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgdmFyIGVycm9yRGlnZXN0O1xuXG4gICAge1xuICAgICAgZXJyb3JEaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCB0aHJvd25JbmZvKTtcbiAgICB9XG5cbiAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KHJlc3VtZWRCb3VuZGFyeSwgZXJyb3JEaWdlc3QsIGVycm9yLCB0aHJvd25JbmZvKTtcbiAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTsgLy8gVGhlIHBhcmVudCBhbHJlYWR5IGZsdXNoZWQgaW4gdGhlIHByZXJlbmRlciBzbyB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoaXMgdG8gYmUgZW1pdHRlZC5cblxuICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2gocmVzdW1lZEJvdW5kYXJ5KTsgLy8gV2UgZG9uJ3QgbmVlZCB0byBkZWNyZW1lbnQgYW55IHRhc2sgbnVtYmVycyBiZWNhdXNlIHdlIGRpZG4ndCBzcGF3biBhbnkgbmV3IHRhc2suXG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBzY2hlZHVsZSBhbnkgdGFzayBiZWNhdXNlIHdlIGtub3cgdGhlIHBhcmVudCBoYXMgd3JpdHRlbiB5ZXQuXG4gICAgLy8gV2UgZG8gbmVlZCB0byBmYWxsdGhyb3VnaCB0byBjcmVhdGUgdGhlIGZhbGxiYWNrIHRob3VnaC5cbiAgfSBmaW5hbGx5IHtcbiAgICB7XG4gICAgICBzZXRDdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeVJlc291cmNlc1RhcmdldChyZXF1ZXN0LnJlbmRlclN0YXRlLCBwYXJlbnRCb3VuZGFyeSA/IHBhcmVudEJvdW5kYXJ5LnJlc291cmNlcyA6IG51bGwpO1xuICAgIH1cblxuICAgIHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gcGFyZW50Qm91bmRhcnk7XG4gICAgdGFzay5yZXBsYXkgPSBwcmV2aW91c1JlcGxheVNldDtcbiAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgfVxuXG4gIHZhciBmYWxsYmFja0tleVBhdGggPSBba2V5UGF0aFswXSwgJ1N1c3BlbnNlIEZhbGxiYWNrJywga2V5UGF0aFsyXV07IC8vIFdlIGNyZWF0ZSBzdXNwZW5kZWQgdGFzayBmb3IgdGhlIGZhbGxiYWNrIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBhY3R1YWxseSB3b3JrXG4gIC8vIG9uIGl0IHlldCBpbiBjYXNlIHdlIGZpbmlzaCB0aGUgbWFpbiBjb250ZW50LCBzbyB3ZSBxdWV1ZSBmb3IgbGF0ZXIuXG5cbiAgdmFyIGZhbGxiYWNrUmVwbGF5ID0ge1xuICAgIG5vZGVzOiBmYWxsYmFja05vZGVzLFxuICAgIHNsb3RzOiBmYWxsYmFja1Nsb3RzLFxuICAgIHBlbmRpbmdUYXNrczogMFxuICB9O1xuICB2YXIgc3VzcGVuZGVkRmFsbGJhY2tUYXNrID0gY3JlYXRlUmVwbGF5VGFzayhyZXF1ZXN0LCBudWxsLCBmYWxsYmFja1JlcGxheSwgZmFsbGJhY2ssIC0xLCBwYXJlbnRCb3VuZGFyeSwgZmFsbGJhY2tBYm9ydFNldCwgZmFsbGJhY2tLZXlQYXRoLCB0YXNrLmZvcm1hdENvbnRleHQsIHRhc2subGVnYWN5Q29udGV4dCwgdGFzay5jb250ZXh0LCB0YXNrLnRyZWVDb250ZXh0LCAvLyBUaGlzIHN0YWNrIHNob3VsZCBiZSB0aGUgU3VzcGVuc2UgYm91bmRhcnkgc3RhY2sgYmVjYXVzZSB3aGlsZSB0aGUgZmFsbGJhY2sgaXMgYWN0dWFsbHkgYSBjaGlsZCBzZWdtZW50XG4gIC8vIG9mIHRoZSBwYXJlbnQgYm91bmRhcnkgZnJvbSBhIGNvbXBvbmVudCBzdGFuZHBvaW50IHRoZSBmYWxsYmFjayBpcyBhIGNoaWxkIG9mIHRoZSBTdXNwZW5zZSBib3VuZGFyeSBpdHNlbGZcbiAgc3VzcGVuc2VDb21wb25lbnRTdGFjayk7IC8vIFRPRE86IFRoaXMgc2hvdWxkIGJlIHF1ZXVlZCBhdCBhIHNlcGFyYXRlIGxvd2VyIHByaW9yaXR5IHF1ZXVlIHNvIHRoYXQgd2Ugb25seSB3b3JrXG4gIC8vIG9uIHByZXBhcmluZyBmYWxsYmFja3MgaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBtYWluIGNvbnRlbnQgdG8gdGFzayBvbi5cblxuICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2goc3VzcGVuZGVkRmFsbGJhY2tUYXNrKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVySG9zdEVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgdHlwZSwgcHJvcHMpIHtcbiAgdmFyIHByZXZpb3VzQ29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrO1xuICB0YXNrLmNvbXBvbmVudFN0YWNrID0gY3JlYXRlQnVpbHRJbkNvbXBvbmVudFN0YWNrKHRhc2ssIHR5cGUpO1xuICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG5cbiAgaWYgKHNlZ21lbnQgPT09IG51bGwpIHtcbiAgICAvLyBSZXBsYXlcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjsgLy8gVE9ETzogTWFrZSB0aGlzIGEgQ29uZmlnIGZvciByZXBsYXlpbmcuXG5cbiAgICB2YXIgcHJldkNvbnRleHQgPSB0YXNrLmZvcm1hdENvbnRleHQ7XG4gICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IGdldENoaWxkRm9ybWF0Q29udGV4dChwcmV2Q29udGV4dCwgdHlwZSwgcHJvcHMpO1xuICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7IC8vIFdlIHVzZSB0aGUgbm9uLWRlc3RydWN0aXZlIGZvcm0gYmVjYXVzZSBpZiBzb21ldGhpbmcgc3VzcGVuZHMsIHdlIHN0aWxsXG4gICAgLy8gbmVlZCB0byBwb3AgYmFjayB1cCBhbmQgZmluaXNoIHRoaXMgc3VidHJlZSBvZiBIVE1MLlxuXG4gICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpOyAvLyBXZSBleHBlY3QgdGhhdCBlcnJvcnMgd2lsbCBmYXRhbCB0aGUgd2hvbGUgdGFzayBhbmQgdGhhdCB3ZSBkb24ndCBuZWVkXG4gICAgLy8gdGhlIGNvcnJlY3QgY29udGV4dC4gVGhlcmVmb3JlIHRoaXMgaXMgbm90IGluIGEgZmluYWxseS5cblxuICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZDb250ZXh0O1xuICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICB9IGVsc2Uge1xuICAgIC8vIFJlbmRlclxuICAgIHZhciBfY2hpbGRyZW4gPSBwdXNoU3RhcnRJbnN0YW5jZShzZWdtZW50LmNodW5rcywgdHlwZSwgcHJvcHMsIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsIHJlcXVlc3QucmVuZGVyU3RhdGUsIHRhc2suZm9ybWF0Q29udGV4dCwgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCk7XG5cbiAgICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gZmFsc2U7XG4gICAgdmFyIF9wcmV2Q29udGV4dCA9IHRhc2suZm9ybWF0Q29udGV4dDtcbiAgICB2YXIgX3ByZXZLZXlQYXRoMiA9IHRhc2sua2V5UGF0aDtcbiAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBnZXRDaGlsZEZvcm1hdENvbnRleHQoX3ByZXZDb250ZXh0LCB0eXBlLCBwcm9wcyk7XG4gICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDsgLy8gV2UgdXNlIHRoZSBub24tZGVzdHJ1Y3RpdmUgZm9ybSBiZWNhdXNlIGlmIHNvbWV0aGluZyBzdXNwZW5kcywgd2Ugc3RpbGxcbiAgICAvLyBuZWVkIHRvIHBvcCBiYWNrIHVwIGFuZCBmaW5pc2ggdGhpcyBzdWJ0cmVlIG9mIEhUTUwuXG5cbiAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIF9jaGlsZHJlbiwgLTEpOyAvLyBXZSBleHBlY3QgdGhhdCBlcnJvcnMgd2lsbCBmYXRhbCB0aGUgd2hvbGUgdGFzayBhbmQgdGhhdCB3ZSBkb24ndCBuZWVkXG4gICAgLy8gdGhlIGNvcnJlY3QgY29udGV4dC4gVGhlcmVmb3JlIHRoaXMgaXMgbm90IGluIGEgZmluYWxseS5cblxuICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IF9wcmV2Q29udGV4dDtcbiAgICB0YXNrLmtleVBhdGggPSBfcHJldktleVBhdGgyO1xuICAgIHB1c2hFbmRJbnN0YW5jZShzZWdtZW50LmNodW5rcywgdHlwZSwgcHJvcHMsIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsIF9wcmV2Q29udGV4dCk7XG4gICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9IGZhbHNlO1xuICB9XG5cbiAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgcmV0dXJuIENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiByZW5kZXJXaXRoSG9va3MocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICB2YXIgY29tcG9uZW50SWRlbnRpdHkgPSB7fTtcbiAgcHJlcGFyZVRvVXNlSG9va3MocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgY29tcG9uZW50SWRlbnRpdHksIHByZXZUaGVuYWJsZVN0YXRlKTtcbiAgdmFyIHJlc3VsdCA9IENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTtcbiAgcmV0dXJuIGZpbmlzaEhvb2tzKENvbXBvbmVudCwgcHJvcHMsIHJlc3VsdCwgc2Vjb25kQXJnKTtcbn1cblxuZnVuY3Rpb24gZmluaXNoQ2xhc3NDb21wb25lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgaW5zdGFuY2UsIENvbXBvbmVudCwgcHJvcHMpIHtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IGluc3RhbmNlLnJlbmRlcigpO1xuXG4gIHtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IHByb3BzKSB7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgZXJyb3IoJ0l0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiAnICsgJ1RoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ2EgY29tcG9uZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgICBpZiAoY2hpbGRDb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHByZXZpb3VzQ29udGV4dCA9IHRhc2subGVnYWN5Q29udGV4dDtcbiAgICAgIHZhciBtZXJnZWRDb250ZXh0ID0gcHJvY2Vzc0NoaWxkQ29udGV4dChpbnN0YW5jZSwgQ29tcG9uZW50LCBwcmV2aW91c0NvbnRleHQsIGNoaWxkQ29udGV4dFR5cGVzKTtcbiAgICAgIHRhc2subGVnYWN5Q29udGV4dCA9IG1lcmdlZENvbnRleHQ7XG4gICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgbmV4dENoaWxkcmVuLCAtMSk7XG4gICAgICB0YXNrLmxlZ2FjeUNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgbmV4dENoaWxkcmVuLCAtMSk7XG4gIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzc0NvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBDb21wb25lbnQsIHByb3BzKSB7XG4gIHZhciBwcmV2aW91c0NvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgdGFzay5jb21wb25lbnRTdGFjayA9IGNyZWF0ZUNsYXNzQ29tcG9uZW50U3RhY2sodGFzaywgQ29tcG9uZW50KTtcbiAgdmFyIG1hc2tlZENvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KENvbXBvbmVudCwgdGFzay5sZWdhY3lDb250ZXh0KSA7XG4gIHZhciBpbnN0YW5jZSA9IGNvbnN0cnVjdENsYXNzSW5zdGFuY2UoQ29tcG9uZW50LCBwcm9wcywgbWFza2VkQ29udGV4dCk7XG4gIG1vdW50Q2xhc3NJbnN0YW5jZShpbnN0YW5jZSwgQ29tcG9uZW50LCBwcm9wcywgbWFza2VkQ29udGV4dCk7XG4gIGZpbmlzaENsYXNzQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIGluc3RhbmNlLCBDb21wb25lbnQsIHByb3BzKTtcbiAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG59XG5cbnZhciBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xudmFyIGRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9IGZhbHNlO1xudmFyIGRpZFdhcm5BYm91dERlZmF1bHRQcm9wc09uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xudmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IGZhbHNlOyAvLyBUaGlzIHdvdWxkIHR5cGljYWxseSBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCBidXQgd2Ugc3RpbGwgc3VwcG9ydCBtb2R1bGUgcGF0dGVyblxuLy8gY29tcG9uZW50cyBmb3Igc29tZSByZWFzb24uXG5cbmZ1bmN0aW9uIHJlbmRlckluZGV0ZXJtaW5hdGVDb21wb25lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIENvbXBvbmVudCwgcHJvcHMpIHtcbiAgdmFyIGxlZ2FjeUNvbnRleHQ7XG5cbiAge1xuICAgIGxlZ2FjeUNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KENvbXBvbmVudCwgdGFzay5sZWdhY3lDb250ZXh0KTtcbiAgfVxuXG4gIHZhciBwcmV2aW91c0NvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgdGFzay5jb21wb25lbnRTdGFjayA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50U3RhY2sodGFzaywgQ29tcG9uZW50KTtcblxuICB7XG4gICAgaWYgKENvbXBvbmVudC5wcm90b3R5cGUgJiYgdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcihcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFwiICsgJ1RoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCBDb21wb25lbnQsIHByb3BzLCBsZWdhY3lDb250ZXh0KTtcbiAgdmFyIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgdmFyIGZvcm1TdGF0ZUNvdW50ID0gZ2V0Rm9ybVN0YXRlQ291bnQoKTtcbiAgdmFyIGZvcm1TdGF0ZU1hdGNoaW5nSW5kZXggPSBnZXRGb3JtU3RhdGVNYXRjaGluZ0luZGV4KCk7XG5cbiAge1xuICAgIC8vIFN1cHBvcnQgZm9yIG1vZHVsZSBjb21wb25lbnRzIGlzIGRlcHJlY2F0ZWQgYW5kIGlzIHJlbW92ZWQgYmVoaW5kIGEgZmxhZy5cbiAgICAvLyBXaGV0aGVyIG9yIG5vdCBpdCB3b3VsZCBjcmFzaCBsYXRlciwgd2Ugd2FudCB0byBzaG93IGEgZ29vZCBtZXNzYWdlIGluIERFViBmaXJzdC5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZS4gJyArICdDaGFuZ2UgJXMgdG8gYSBjbGFzcyB0aGF0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuICcgKyBcIklmIHlvdSBjYW4ndCB1c2UgYSBjbGFzcyB0cnkgYXNzaWduaW5nIHRoZSBwcm90b3R5cGUgb24gdGhlIGZ1bmN0aW9uIGFzIGEgd29ya2Fyb3VuZC4gXCIgKyBcImAlcy5wcm90b3R5cGUgPSBSZWFjdC5Db21wb25lbnQucHJvdG90eXBlYC4gRG9uJ3QgdXNlIGFuIGFycm93IGZ1bmN0aW9uIHNpbmNlIGl0IFwiICsgJ2Nhbm5vdCBiZSBjYWxsZWQgd2l0aCBgbmV3YCBieSBSZWFjdC4nLCBfY29tcG9uZW50TmFtZSwgX2NvbXBvbmVudE5hbWUsIF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCAvLyBSdW4gdGhlc2UgY2hlY2tzIGluIHByb2R1Y3Rpb24gb25seSBpZiB0aGUgZmxhZyBpcyBvZmYuXG4gIC8vIEV2ZW50dWFsbHkgd2UnbGwgZGVsZXRlIHRoaXMgYnJhbmNoIGFsdG9nZXRoZXIuXG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lMiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIsIF9jb21wb25lbnROYW1lMik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb3VudENsYXNzSW5zdGFuY2UodmFsdWUsIENvbXBvbmVudCwgcHJvcHMsIGxlZ2FjeUNvbnRleHQpO1xuICAgIGZpbmlzaENsYXNzQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHZhbHVlLCBDb21wb25lbnQsIHByb3BzKTtcbiAgfSBlbHNlIHtcblxuICAgIHtcbiAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldihDb21wb25lbnQpO1xuICAgIH1cblxuICAgIGZpbmlzaEZ1bmN0aW9uQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHZhbHVlLCBoYXNJZCwgZm9ybVN0YXRlQ291bnQsIGZvcm1TdGF0ZU1hdGNoaW5nSW5kZXgpO1xuICB9XG5cbiAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaEZ1bmN0aW9uQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIGNoaWxkcmVuLCBoYXNJZCwgZm9ybVN0YXRlQ291bnQsIGZvcm1TdGF0ZU1hdGNoaW5nSW5kZXgpIHtcbiAgdmFyIGRpZEVtaXRGb3JtU3RhdGVNYXJrZXJzID0gZmFsc2U7XG5cbiAgaWYgKGZvcm1TdGF0ZUNvdW50ICE9PSAwICYmIHJlcXVlc3QuZm9ybVN0YXRlICE9PSBudWxsKSB7XG4gICAgLy8gRm9yIGVhY2ggdXNlRm9ybVN0YXRlIGhvb2ssIGVtaXQgYSBtYXJrZXIgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB3ZVxuICAgIC8vIHJlbmRlcmVkIHVzaW5nIHRoZSBmb3JtIHN0YXRlIHBhc3NlZCBhdCB0aGUgcm9vdC4gV2Ugb25seSBlbWl0IHRoZXNlXG4gICAgLy8gbWFya2VycyBpZiBmb3JtIHN0YXRlIGlzIHBhc3NlZCBhdCB0aGUgcm9vdC5cbiAgICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG5cbiAgICBpZiAoc2VnbWVudCA9PT0gbnVsbCkgOyBlbHNlIHtcbiAgICAgIGRpZEVtaXRGb3JtU3RhdGVNYXJrZXJzID0gdHJ1ZTtcbiAgICAgIHZhciB0YXJnZXQgPSBzZWdtZW50LmNodW5rcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JtU3RhdGVDb3VudDsgaSsrKSB7XG4gICAgICAgIGlmIChpID09PSBmb3JtU3RhdGVNYXRjaGluZ0luZGV4KSB7XG4gICAgICAgICAgcHVzaEZvcm1TdGF0ZU1hcmtlcklzTWF0Y2hpbmcodGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoRm9ybVN0YXRlTWFya2VySXNOb3RNYXRjaGluZyh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuXG4gIGlmIChoYXNJZCkge1xuICAgIC8vIFRoaXMgY29tcG9uZW50IG1hdGVyaWFsaXplZCBhbiBpZC4gV2UgdHJlYXQgdGhpcyBhcyBpdHMgb3duIGxldmVsLCB3aXRoXG4gICAgLy8gYSBzaW5nbGUgXCJjaGlsZFwiIHNsb3QuXG4gICAgdmFyIHByZXZUcmVlQ29udGV4dCA9IHRhc2sudHJlZUNvbnRleHQ7XG4gICAgdmFyIHRvdGFsQ2hpbGRyZW4gPSAxO1xuICAgIHZhciBpbmRleCA9IDA7IC8vIE1vZGlmeSB0aGUgaWQgY29udGV4dC4gQmVjYXVzZSB3ZSdsbCBuZWVkIHRvIHJlc2V0IHRoaXMgaWYgc29tZXRoaW5nXG4gICAgLy8gc3VzcGVuZHMgb3IgZXJyb3JzLCB3ZSdsbCB1c2UgdGhlIG5vbi1kZXN0cnVjdGl2ZSByZW5kZXIgcGF0aC5cblxuICAgIHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQocHJldlRyZWVDb250ZXh0LCB0b3RhbENoaWxkcmVuLCBpbmRleCk7XG4gICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpOyAvLyBMaWtlIHRoZSBvdGhlciBjb250ZXh0cywgdGhpcyBkb2VzIG5vdCBuZWVkIHRvIGJlIGluIGEgZmluYWxseSBibG9ja1xuICAgIC8vIGJlY2F1c2UgcmVuZGVyTm9kZSB0YWtlcyBjYXJlIG9mIHVud2luZGluZyB0aGUgc3RhY2suXG5cbiAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldlRyZWVDb250ZXh0O1xuICB9IGVsc2UgaWYgKGRpZEVtaXRGb3JtU3RhdGVNYXJrZXJzKSB7XG4gICAgLy8gSWYgdGhlcmUgd2VyZSBmb3JtU3RhdGUgaG9va3MsIHdlIG11c3QgdXNlIHRoZSBub24tZGVzdHJ1Y3RpdmUgcGF0aFxuICAgIC8vIGJlY2F1c2UgdGhpcyBjb21wb25lbnQgaXMgbm90IGEgcHVyZSBpbmRpcmVjdGlvbjsgd2UgZW1pdHRlZCBtYXJrZXJzXG4gICAgLy8gdG8gdGhlIHN0cmVhbS5cbiAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UncmUgbm93IHN1Y2Nlc3NmdWxseSBwYXN0IHRoaXMgdGFzaywgYW5kIHdlIGhhdmVuJ3QgbW9kaWZpZWQgdGhlXG4gICAgLy8gY29udGV4dCBzdGFjay4gV2UgZG9uJ3QgaGF2ZSB0byBwb3AgYmFjayB0byB0aGUgcHJldmlvdXMgdGFzayBldmVyeVxuICAgIC8vIGFnYWluLCBzbyB3ZSBjYW4gdXNlIHRoZSBkZXN0cnVjdGl2ZSByZWN1cnNpdmUgZm9ybS5cbiAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgY2hpbGRyZW4sIC0xKTtcbiAgfVxuXG4gIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYoQ29tcG9uZW50KSB7XG4gIHtcbiAgICBpZiAoQ29tcG9uZW50KSB7XG4gICAgICBpZiAoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChDb21wb25lbnQuZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dERlZmF1bHRQcm9wc09uRnVuY3Rpb25Db21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBTdXBwb3J0IGZvciBkZWZhdWx0UHJvcHMgd2lsbCBiZSByZW1vdmVkIGZyb20gZnVuY3Rpb24gY29tcG9uZW50cyAnICsgJ2luIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIFVzZSBKYXZhU2NyaXB0IGRlZmF1bHQgcGFyYW1ldGVycyBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dERlZmF1bHRQcm9wc09uRnVuY3Rpb25Db21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lMyA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4nLCBfY29tcG9uZW50TmFtZTMpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQuY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIENvbXBvbmVudC5jb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lNCA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWU0XSkge1xuICAgICAgICBlcnJvcignJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgY29udGV4dFR5cGUuJywgX2NvbXBvbmVudE5hbWU0KTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWU0XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEZWZhdWx0UHJvcHMoQ29tcG9uZW50LCBiYXNlUHJvcHMpIHtcbiAgaWYgKENvbXBvbmVudCAmJiBDb21wb25lbnQuZGVmYXVsdFByb3BzKSB7XG4gICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzLiBUYWtlbiBmcm9tIFJlYWN0RWxlbWVudFxuICAgIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgYmFzZVByb3BzKTtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gQ29tcG9uZW50LmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG5cbiAgcmV0dXJuIGJhc2VQcm9wcztcbn1cblxuZnVuY3Rpb24gcmVuZGVyRm9yd2FyZFJlZihyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZikge1xuICB2YXIgcHJldmlvdXNDb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2s7XG4gIHRhc2suY29tcG9uZW50U3RhY2sgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFN0YWNrKHRhc2ssIHR5cGUucmVuZGVyKTtcbiAgdmFyIGNoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCB0eXBlLnJlbmRlciwgcHJvcHMsIHJlZik7XG4gIHZhciBoYXNJZCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gIHZhciBmb3JtU3RhdGVDb3VudCA9IGdldEZvcm1TdGF0ZUNvdW50KCk7XG4gIHZhciBmb3JtU3RhdGVNYXRjaGluZ0luZGV4ID0gZ2V0Rm9ybVN0YXRlTWF0Y2hpbmdJbmRleCgpO1xuICBmaW5pc2hGdW5jdGlvbkNvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBjaGlsZHJlbiwgaGFzSWQsIGZvcm1TdGF0ZUNvdW50LCBmb3JtU3RhdGVNYXRjaGluZ0luZGV4KTtcbiAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1lbW8ocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIHR5cGUsIHByb3BzLCByZWYpIHtcbiAgdmFyIGlubmVyVHlwZSA9IHR5cGUudHlwZTtcbiAgdmFyIHJlc29sdmVkUHJvcHMgPSByZXNvbHZlRGVmYXVsdFByb3BzKGlubmVyVHlwZSwgcHJvcHMpO1xuICByZW5kZXJFbGVtZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCBpbm5lclR5cGUsIHJlc29sdmVkUHJvcHMsIHJlZik7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNvbnRleHRDb25zdW1lcihyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBjb250ZXh0LCBwcm9wcykge1xuICAvLyBUaGUgbG9naWMgYmVsb3cgZm9yIENvbnRleHQgZGlmZmVycyBkZXBlbmRpbmcgb24gUFJPRCBvciBERVYgbW9kZS4gSW5cbiAgLy8gREVWIG1vZGUsIHdlIGNyZWF0ZSBhIHNlcGFyYXRlIG9iamVjdCBmb3IgQ29udGV4dC5Db25zdW1lciB0aGF0IGFjdHNcbiAgLy8gbGlrZSBhIHByb3h5IHRvIENvbnRleHQuIFRoaXMgcHJveHkgb2JqZWN0IGFkZHMgdW5uZWNlc3NhcnkgY29kZSBpbiBQUk9EXG4gIC8vIHNvIHdlIHVzZSB0aGUgb2xkIGJlaGF2aW91ciAoQ29udGV4dC5Db25zdW1lciByZWZlcmVuY2VzIENvbnRleHQpIHRvXG4gIC8vIHJlZHVjZSBzaXplIGFuZCBvdmVyaGVhZC4gVGhlIHNlcGFyYXRlIG9iamVjdCByZWZlcmVuY2VzIGNvbnRleHQgdmlhXG4gIC8vIGEgcHJvcGVydHkgY2FsbGVkIFwiX2NvbnRleHRcIiwgd2hpY2ggYWxzbyBnaXZlcyB1cyB0aGUgYWJpbGl0eSB0byBjaGVja1xuICAvLyBpbiBERVYgbW9kZSBpZiB0aGlzIHByb3BlcnR5IGV4aXN0cyBvciBub3QgYW5kIHdhcm4gaWYgaXQgZG9lcyBub3QuXG4gIHtcbiAgICBpZiAoY29udGV4dC5fY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGlzIG1heSBiZSBiZWNhdXNlIGl0J3MgYSBDb250ZXh0IChyYXRoZXIgdGhhbiBhIENvbnN1bWVyKS5cbiAgICAgIC8vIE9yIGl0IG1heSBiZSBiZWNhdXNlIGl0J3Mgb2xkZXIgUmVhY3Qgd2hlcmUgdGhleSdyZSB0aGUgc2FtZSB0aGluZy5cbiAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB3YXJuIGlmIHdlJ3JlIHN1cmUgaXQncyBhIG5ldyBSZWFjdC5cbiAgICAgIGlmIChjb250ZXh0ICE9PSBjb250ZXh0LkNvbnN1bWVyKSB7XG4gICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyKSB7XG4gICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQ+IGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IGNvbnRleHQuX2NvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlbmRlciA9IHByb3BzLmNoaWxkcmVuO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0EgY29udGV4dCBjb25zdW1lciB3YXMgcmVuZGVyZWQgd2l0aCBtdWx0aXBsZSBjaGlsZHJlbiwgb3IgYSBjaGlsZCAnICsgXCJ0aGF0IGlzbid0IGEgZnVuY3Rpb24uIEEgY29udGV4dCBjb25zdW1lciBleHBlY3RzIGEgc2luZ2xlIGNoaWxkIFwiICsgJ3RoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSAnICsgJ2lzIG5vIHRyYWlsaW5nIG9yIGxlYWRpbmcgd2hpdGVzcGFjZSBhcm91bmQgaXQuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld1ZhbHVlID0gcmVhZENvbnRleHQkMShjb250ZXh0KTtcbiAgdmFyIG5ld0NoaWxkcmVuID0gcmVuZGVyKG5ld1ZhbHVlKTtcbiAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgbmV3Q2hpbGRyZW4sIC0xKTtcbiAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNvbnRleHRQcm92aWRlcihyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBwcm9wcykge1xuICB2YXIgY29udGV4dCA9IHR5cGUuX2NvbnRleHQ7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgdmFyIHByZXZTbmFwc2hvdDtcblxuICB7XG4gICAgcHJldlNuYXBzaG90ID0gdGFzay5jb250ZXh0O1xuICB9XG5cbiAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICB0YXNrLmNvbnRleHQgPSBwdXNoUHJvdmlkZXIoY29udGV4dCwgdmFsdWUpO1xuICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgY2hpbGRyZW4sIC0xKTtcbiAgdGFzay5jb250ZXh0ID0gcG9wUHJvdmlkZXIoY29udGV4dCk7XG4gIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuXG4gIHtcbiAgICBpZiAocHJldlNuYXBzaG90ICE9PSB0YXNrLmNvbnRleHQpIHtcbiAgICAgIGVycm9yKCdQb3BwaW5nIHRoZSBjb250ZXh0IHByb3ZpZGVyIGRpZCBub3QgcmV0dXJuIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHNuYXBzaG90LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJMYXp5Q29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCBsYXp5Q29tcG9uZW50LCBwcm9wcywgcmVmKSB7XG4gIHZhciBwcmV2aW91c0NvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgdGFzay5jb21wb25lbnRTdGFjayA9IGNyZWF0ZUJ1aWx0SW5Db21wb25lbnRTdGFjayh0YXNrLCAnTGF6eScpO1xuICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgdmFyIENvbXBvbmVudCA9IGluaXQocGF5bG9hZCk7XG4gIHZhciByZXNvbHZlZFByb3BzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQsIHByb3BzKTtcbiAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZWYpO1xuICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbn1cblxuZnVuY3Rpb24gcmVuZGVyT2Zmc2NyZWVuKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByb3BzKSB7XG4gIHZhciBtb2RlID0gcHJvcHMubW9kZTtcblxuICBpZiAobW9kZSA9PT0gJ2hpZGRlbicpIDsgZWxzZSB7XG4gICAgLy8gQSB2aXNpYmxlIE9mZnNjcmVlbiBib3VuZGFyeSBpcyB0cmVhdGVkIGV4YWN0bHkgbGlrZSBhIGZyYWdtZW50OiBhXG4gICAgLy8gcHVyZSBpbmRpcmVjdGlvbi5cbiAgICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG4gICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgcHJvcHMuY2hpbGRyZW4sIC0xKTtcbiAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJFbGVtZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCB0eXBlLCBwcm9wcywgcmVmKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChzaG91bGRDb25zdHJ1Y3QodHlwZSkpIHtcbiAgICAgIHJlbmRlckNsYXNzQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHR5cGUsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVySW5kZXRlcm1pbmF0ZUNvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZW5kZXJIb3N0RWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBwcm9wcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgLy8gTGVnYWN5SGlkZGVuIGFjdHMgdGhlIHNhbWUgYXMgYSBmcmFnbWVudC4gVGhpcyBvbmx5IHdvcmtzIGJlY2F1c2Ugd2VcbiAgICAvLyBjdXJyZW50bHkgYXNzdW1lIHRoYXQgZXZlcnkgaW5zdGFuY2Ugb2YgTGVnYWN5SGlkZGVuIGlzIGFjY29tcGFuaWVkIGJ5IGFcbiAgICAvLyBob3N0IGNvbXBvbmVudCB3cmFwcGVyLiBJbiB0aGUgaGlkZGVuIG1vZGUsIHRoZSBob3N0IGNvbXBvbmVudCBpcyBnaXZlbiBhXG4gICAgLy8gYGhpZGRlbmAgYXR0cmlidXRlLCB3aGljaCBlbnN1cmVzIHRoYXQgdGhlIGluaXRpYWwgSFRNTCBpcyBub3QgdmlzaWJsZS5cbiAgICAvLyBUbyBzdXBwb3J0IHRoZSB1c2Ugb2YgTGVnYWN5SGlkZGVuIGFzIGEgdHJ1ZSBmcmFnbWVudCwgd2l0aG91dCBhbiBleHRyYVxuICAgIC8vIERPTSBub2RlLCB3ZSB3b3VsZCBoYXZlIHRvIGhpZGUgdGhlIGluaXRpYWwgSFRNTCBpbiBzb21lIG90aGVyIHdheS5cbiAgICAvLyBUT0RPOiBEZWxldGUgaW4gTGVnYWN5SGlkZGVuLiBJdCdzIGFuIHVuc3RhYmxlIEFQSSBvbmx5IHVzZWQgaW4gdGhlXG4gICAgLy8gd3d3IGJ1aWxkLiBBcyBhIG1pZ3JhdGlvbiBzdGVwLCB3ZSBjb3VsZCBhZGQgYSBzcGVjaWFsIHByb3AgdG8gT2Zmc2NyZWVuXG4gICAgLy8gdGhhdCBzaW11bGF0ZXMgdGhlIG9sZCBiZWhhdmlvciAobm8gaGlkaW5nLCBubyBjaGFuZ2UgdG8gZWZmZWN0cykuXG4gICAgY2FzZSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEU6XG4gICAgY2FzZSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRTpcbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgcHJvcHMuY2hpbGRyZW4sIC0xKTtcbiAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJlbmRlck9mZnNjcmVlbihyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcm9wcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAge1xuICAgICAgICB2YXIgcHJlaW91c0NvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IGNyZWF0ZUJ1aWx0SW5Db21wb25lbnRTdGFjayh0YXNrLCAnU3VzcGVuc2VMaXN0Jyk7IC8vIFRPRE86IFN1c3BlbnNlTGlzdCBzaG91bGQgY29udHJvbCB0aGUgYm91bmRhcmllcy5cblxuICAgICAgICB2YXIgX3ByZXZLZXlQYXRoMyA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgICAgIHRhc2sua2V5UGF0aCA9IF9wcmV2S2V5UGF0aDM7XG4gICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmVpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgUkVBQ1RfU0NPUEVfVFlQRTpcbiAgICAgIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0RE9NU2VydmVyIGRvZXMgbm90IHlldCBzdXBwb3J0IHNjb3BlIGNvbXBvbmVudHMuJyk7XG4gICAgICB9XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJTdXNwZW5zZUJvdW5kYXJ5KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmVuZGVyRm9yd2FyZFJlZihyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmVuZGVyTWVtbyhyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHJlbmRlckNvbnRleHRQcm92aWRlcihyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmVuZGVyQ29udGV4dENvbnN1bWVyKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJMYXp5Q29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGluZm8gPSAnJztcblxuICB7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIFwiICsgJ25hbWVkIGltcG9ydHMuJztcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluICcgKyAnY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSAnICsgKFwiYnV0IGdvdDogXCIgKyAodHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlKSArIFwiLlwiICsgaW5mbykpO1xufVxuXG5mdW5jdGlvbiByZXN1bWVOb2RlKHJlcXVlc3QsIHRhc2ssIHNlZ21lbnRJZCwgbm9kZSwgY2hpbGRJbmRleCkge1xuICB2YXIgcHJldlJlcGxheSA9IHRhc2sucmVwbGF5O1xuICB2YXIgYmxvY2tlZEJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnk7XG4gIHZhciByZXN1bWVkU2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KHJlcXVlc3QsIDAsIG51bGwsIHRhc2suZm9ybWF0Q29udGV4dCwgZmFsc2UsIGZhbHNlKTtcbiAgcmVzdW1lZFNlZ21lbnQuaWQgPSBzZWdtZW50SWQ7XG4gIHJlc3VtZWRTZWdtZW50LnBhcmVudEZsdXNoZWQgPSB0cnVlO1xuXG4gIHRyeSB7XG4gICAgLy8gQ29udmVydCB0aGUgY3VycmVudCBSZXBsYXlUYXNrIHRvIGEgUmVuZGVyVGFzay5cbiAgICB2YXIgcmVuZGVyVGFzayA9IHRhc2s7XG4gICAgcmVuZGVyVGFzay5yZXBsYXkgPSBudWxsO1xuICAgIHJlbmRlclRhc2suYmxvY2tlZFNlZ21lbnQgPSByZXN1bWVkU2VnbWVudDtcbiAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgIHJlc3VtZWRTZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRDtcblxuICAgIGlmIChibG9ja2VkQm91bmRhcnkgPT09IG51bGwpIHtcbiAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQgPSByZXN1bWVkU2VnbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJsb2NrZWRCb3VuZGFyeSwgcmVzdW1lZFNlZ21lbnQpO1xuXG4gICAgICBpZiAoYmxvY2tlZEJvdW5kYXJ5LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcy5wdXNoKGJsb2NrZWRCb3VuZGFyeSk7XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIC8vIFJlc3RvcmUgdG8gYSBSZXBsYXlUYXNrLlxuICAgIHRhc2sucmVwbGF5ID0gcHJldlJlcGxheTtcbiAgICB0YXNrLmJsb2NrZWRTZWdtZW50ID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYXlFbGVtZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCBuYW1lLCBrZXlPckluZGV4LCBjaGlsZEluZGV4LCB0eXBlLCBwcm9wcywgcmVmLCByZXBsYXkpIHtcbiAgLy8gV2UncmUgcmVwbGF5aW5nLiBGaW5kIHRoZSBwYXRoIHRvIGZvbGxvdy5cbiAgdmFyIHJlcGxheU5vZGVzID0gcmVwbGF5Lm5vZGVzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwbGF5Tm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCByZWZpbmVtZW50IG9uIHR1cGxlcyBzbyB3ZSBkbyBpdCBtYW51YWxseSBoZXJlLlxuICAgIHZhciBub2RlID0gcmVwbGF5Tm9kZXNbaV07XG5cbiAgICBpZiAoa2V5T3JJbmRleCAhPT0gbm9kZVsxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUubGVuZ3RoID09PSA0KSB7XG4gICAgICAvLyBNYXRjaGVkIGEgcmVwbGF5YWJsZSBwYXRoLlxuICAgICAgLy8gTGV0J3MgZG91YmxlIGNoZWNrIHRoYXQgdGhlIGNvbXBvbmVudCBuYW1lIG1hdGNoZXMgYXMgYSBwcmVjYXV0aW9uLlxuICAgICAgaWYgKG5hbWUgIT09IG51bGwgJiYgbmFtZSAhPT0gbm9kZVswXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSByZXN1bWUgdG8gcmVuZGVyIDwnICsgbm9kZVswXSArICc+IGluIHRoaXMgc2xvdCBidXQgaW5zdGVhZCBpdCByZW5kZXJlZCA8JyArIG5hbWUgKyAnPi4gJyArIFwiVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGROb2RlcyA9IG5vZGVbMl07XG4gICAgICB2YXIgY2hpbGRTbG90cyA9IG5vZGVbM107XG4gICAgICB2YXIgY3VycmVudE5vZGUgPSB0YXNrLm5vZGU7XG4gICAgICB0YXNrLnJlcGxheSA9IHtcbiAgICAgICAgbm9kZXM6IGNoaWxkTm9kZXMsXG4gICAgICAgIHNsb3RzOiBjaGlsZFNsb3RzLFxuICAgICAgICBwZW5kaW5nVGFza3M6IDFcbiAgICAgIH07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIHR5cGUsIHByb3BzLCByZWYpO1xuXG4gICAgICAgIGlmICh0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MgPT09IDEgJiYgdGFzay5yZXBsYXkubm9kZXMubGVuZ3RoID4gMCAvLyBUT0RPIGNoZWNrIHJlbWFpbmluZyBzbG90c1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYWxsIHJlc3VtYWJsZSBzbG90cyBieSBrZXkvaW5kZXggZHVyaW5nIHJlcGxheWluZy4gXCIgKyBcIlRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCAmJiAoeCA9PT0gU3VzcGVuc2VFeGNlcHRpb24gfHwgdHlwZW9mIHgudGhlbiA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAvLyBTdXNwZW5kXG4gICAgICAgICAgaWYgKHRhc2subm9kZSA9PT0gY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgc2FtZSBlbGVtZW50IHN1c3BlbmRlZCBzbyB3ZSBuZWVkIHRvIHBvcCB0aGUgcmVwbGF5IHdlIGp1c3QgYWRkZWQuXG4gICAgICAgICAgICB0YXNrLnJlcGxheSA9IHJlcGxheTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyB4O1xuICAgICAgICB9XG5cbiAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07IC8vIFVubGlrZSByZWd1bGFyIHJlbmRlciwgd2UgZG9uJ3QgdGVybWluYXRlIHRoZSBzaWJsaW5ncyBpZiB3ZSBlcnJvclxuICAgICAgICAvLyBkdXJpbmcgYSByZXBsYXkuIFRoYXQncyBiZWNhdXNlIHRoaXMgY29tcG9uZW50IGRpZG4ndCBhY3R1YWxseSBlcnJvclxuICAgICAgICAvLyBpbiB0aGUgb3JpZ2luYWwgcHJlcmVuZGVyLiBXaGF0J3MgdW5hYmxlIHRvIGNvbXBsZXRlIGlzIHRoZSBjaGlsZFxuICAgICAgICAvLyByZXBsYXkgbm9kZXMgd2hpY2ggbWlnaHQgYmUgU3VzcGVuc2UgYm91bmRhcmllcyB3aGljaCBhcmUgYWJsZSB0b1xuICAgICAgICAvLyBhYnNvcmIgdGhlIGVycm9yIGFuZCB3ZSBjYW4gc3RpbGwgY29udGludWUgd2l0aCBzaWJsaW5ncy5cblxuICAgICAgICB2YXIgdGhyb3duSW5mbyA9IGdldFRocm93bkluZm8ocmVxdWVzdCwgdGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgICAgIGVycm9yZWRSZXBsYXkocmVxdWVzdCwgdGFzay5ibG9ja2VkQm91bmRhcnksIHgsIHRocm93bkluZm8sIGNoaWxkTm9kZXMsIGNoaWxkU2xvdHMpO1xuICAgICAgfVxuXG4gICAgICB0YXNrLnJlcGxheSA9IHJlcGxheTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGV0J3MgZG91YmxlIGNoZWNrIHRoYXQgdGhlIGNvbXBvbmVudCB0eXBlIG1hdGNoZXMuXG4gICAgICBpZiAodHlwZSAhPT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRUeXBlID0gJ1N1c3BlbnNlJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgcmVzdW1lIHRvIHJlbmRlciA8JyArIGV4cGVjdGVkVHlwZSArICc+IGluIHRoaXMgc2xvdCBidXQgaW5zdGVhZCBpdCByZW5kZXJlZCA8JyArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nKSArICc+LiAnICsgXCJUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIik7XG4gICAgICB9IC8vIE1hdGNoZWQgYSByZXBsYXlhYmxlIHBhdGguXG5cblxuICAgICAgcmVwbGF5U3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcm9wcywgbm9kZVs1XSwgbm9kZVsyXSwgbm9kZVszXSwgbm9kZVs0XSA9PT0gbnVsbCA/IFtdIDogbm9kZVs0XVsyXSwgbm9kZVs0XSA9PT0gbnVsbCA/IG51bGwgOiBub2RlWzRdWzNdKTtcbiAgICB9IC8vIFdlIGZpbmlzaGVkIHJlbmRlcmluZyB0aGlzIG5vZGUsIHNvIG5vdyB3ZSBjYW4gY29uc3VtZSB0aGlzXG4gICAgLy8gc2xvdC4gVGhpcyBtdXN0IGhhcHBlbiBhZnRlciBpbiBjYXNlIHdlIHJlcmVuZGVyIHRoaXMgdGFzay5cblxuXG4gICAgcmVwbGF5Tm9kZXMuc3BsaWNlKGksIDEpO1xuICAgIHJldHVybjtcbiAgfSAvLyBXZSBkaWRuJ3QgZmluZCBhbnkgbWF0Y2hpbmcgbm9kZXMuIFdlIGFzc3VtZSB0aGF0IHRoaXMgZWxlbWVudCB3YXMgYWxyZWFkeVxuICAvLyByZW5kZXJlZCBpbiB0aGUgcHJlbHVkZSBhbmQgc2tpcCBpdC5cblxufSAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVJdGVyYWJsZShpdGVyYWJsZSwgaXRlcmF0b3JGbikge1xuICB7XG4gICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCByZW5kZXJpbmcgR2VuZXJhdG9ycyBiZWNhdXNlIGl0J3MgYSBtdXRhdGlvbi5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjk5NVxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIGl0ZXJhYmxlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdHZW5lcmF0b3InKSB7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEdlbmVyYXRvcnMpIHtcbiAgICAgICAgZXJyb3IoJ1VzaW5nIEdlbmVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gJyArICdZb3UgbWF5IGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBgQXJyYXkuZnJvbSgpYCBvciB0aGUgJyArICdgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIEtlZXAgaW4gbWluZCAnICsgJ3lvdSBtaWdodCBuZWVkIHRvIHBvbHlmaWxsIHRoZXNlIGZlYXR1cmVzIGZvciBvbGRlciBicm93c2Vycy4nKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IHRydWU7XG4gICAgfSAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cblxuXG4gICAgaWYgKGl0ZXJhYmxlLmVudHJpZXMgPT09IGl0ZXJhdG9yRm4pIHtcbiAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICBlcnJvcignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgIH1cbiAgfVxufSAvLyBUaGlzIGZ1bmN0aW9uIGJ5IGl0IHNlbGYgcmVuZGVycyBhIG5vZGUgYW5kIGNvbnN1bWVzIHRoZSB0YXNrIGJ5IG11dGF0aW5nIGl0XG4vLyB0byB1cGRhdGUgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIHN0YXRlLlxuXG5cbmZ1bmN0aW9uIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCAvLyBUaGUgdGhlbmFibGUgc3RhdGUgcmV1c2VkIGZyb20gdGhlIHByZXZpb3VzIGF0dGVtcHQsIGlmIGFueS4gVGhpcyBpcyBhbG1vc3Rcbi8vIGFsd2F5cyBudWxsLCBleGNlcHQgd2hlbiBjYWxsZWQgYnkgcmV0cnlUYXNrLlxucHJldlRoZW5hYmxlU3RhdGUsIG5vZGUsIGNoaWxkSW5kZXgpIHtcbiAgaWYgKHRhc2sucmVwbGF5ICE9PSBudWxsICYmIHR5cGVvZiB0YXNrLnJlcGxheS5zbG90cyA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IGEgY2hlYXBlciBwbGFjZSB0aGFuIHRoaXMgaG90IHBhdGggdG8gZG8gdGhpcyBjaGVjay5cbiAgICB2YXIgcmVzdW1lU2VnbWVudElEID0gdGFzay5yZXBsYXkuc2xvdHM7XG4gICAgcmVzdW1lTm9kZShyZXF1ZXN0LCB0YXNrLCByZXN1bWVTZWdtZW50SUQsIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgIHJldHVybjtcbiAgfSAvLyBTdGFzaCB0aGUgbm9kZSB3ZSdyZSB3b3JraW5nIG9uLiBXZSdsbCBwaWNrIHVwIGZyb20gdGhpcyB0YXNrIGluIGNhc2VcbiAgLy8gc29tZXRoaW5nIHN1c3BlbmRzLlxuXG5cbiAgdGFzay5ub2RlID0gbm9kZTtcbiAgdGFzay5jaGlsZEluZGV4ID0gY2hpbGRJbmRleDsgLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuXG4gIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZSAhPT0gbnVsbCkge1xuICAgIHN3aXRjaCAobm9kZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IG5vZGU7XG4gICAgICAgICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgICAgICAgIHZhciBwcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gICAgICAgICAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAgICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICAgIHZhciBrZXlPckluZGV4ID0ga2V5ID09IG51bGwgPyBjaGlsZEluZGV4ID09PSAtMSA/IDAgOiBjaGlsZEluZGV4IDoga2V5O1xuICAgICAgICAgIHZhciBrZXlQYXRoID0gW3Rhc2sua2V5UGF0aCwgbmFtZSwga2V5T3JJbmRleF07XG5cbiAgICAgICAgICBpZiAodGFzay5yZXBsYXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlcGxheUVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIG5hbWUsIGtleU9ySW5kZXgsIGNoaWxkSW5kZXgsIHR5cGUsIHByb3BzLCByZWYsIHRhc2sucmVwbGF5KTsgLy8gTm8gbWF0Y2hlcyBmb3VuZCBmb3IgdGhpcyBub2RlLiBXZSBhc3N1bWUgaXQncyBhbHJlYWR5IGVtaXR0ZWQgaW4gdGhlXG4gICAgICAgICAgICAvLyBwcmVsdWRlIGFuZCBza2lwIGl0IGR1cmluZyB0aGUgcmVwbGF5LlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBkb2luZyBhIHBsYWluIHJlbmRlci5cbiAgICAgICAgICAgIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIHR5cGUsIHByb3BzLCByZWYpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnRhbHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHRoZSBzZXJ2ZXIgcmVuZGVyZXIuICcgKyAnUmVuZGVyIHRoZW0gY29uZGl0aW9uYWxseSBzbyB0aGF0IHRoZXkgb25seSBhcHBlYXIgb24gdGhlIGNsaWVudCByZW5kZXIuJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzQ29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrO1xuICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBjcmVhdGVCdWlsdEluQ29tcG9uZW50U3RhY2sodGFzaywgJ0xhenknKTtcbiAgICAgICAgICB2YXIgbGF6eU5vZGUgPSBub2RlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eU5vZGUuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Tm9kZS5faW5pdDtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWROb2RlID0gaW5pdChwYXlsb2FkKTsgLy8gV2UgcmVzdG9yZSB0aGUgc3RhY2sgYmVmb3JlIHJlbmRlcmluZyB0aGUgcmVzb2x2ZWQgbm9kZSBiZWNhdXNlIG9uY2UgdGhlIExhenlcbiAgICAgICAgICAvLyBoYXMgcmVzb2x2ZWQgYW55IGZ1dHVyZSBlcnJvcnNcblxuICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrOyAvLyBOb3cgd2UgcmVuZGVyIHRoZSByZXNvbHZlZCBub2RlXG5cbiAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgcmVzb2x2ZWROb2RlLCBjaGlsZEluZGV4KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAge1xuICAgICAgICB2YWxpZGF0ZUl0ZXJhYmxlKG5vZGUsIGl0ZXJhdG9yRm4pO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG5cbiAgICAgIGlmIChpdGVyYXRvcikge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGtub3cgaG93IG1hbnkgdG90YWwgY2hpbGRyZW4gYXJlIGluIHRoaXMgc2V0LCBzbyB0aGF0IHdlXG4gICAgICAgIC8vIGNhbiBhbGxvY2F0ZSBlbm91Z2ggaWQgc2xvdHMgdG8gYWNvbW1vZGF0ZSB0aGVtLiBTbyB3ZSBtdXN0IGV4aGF1c3RcbiAgICAgICAgLy8gdGhlIGl0ZXJhdG9yIGJlZm9yZSB3ZSBzdGFydCByZWN1cnNpdmVseSByZW5kZXJpbmcgdGhlIGNoaWxkcmVuLlxuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIG5vdCBncmVhdCBidXQgSSB0aGluayBpdCdzIGluaGVyZW50IHRvIHRoZSBpZFxuICAgICAgICAvLyBnZW5lcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7IC8vIElmIHRoZXJlIGFyZSBub3QgZW50cmllcywgd2UgbmVlZCB0byBwdXNoIGFuIGVtcHR5IHNvIHdlIHN0YXJ0IGJ5IGNoZWNraW5nIHRoYXQuXG5cbiAgICAgICAgaWYgKCFzdGVwLmRvbmUpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICAgICAgICBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIH0gd2hpbGUgKCFzdGVwLmRvbmUpO1xuXG4gICAgICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgY2hpbGRJbmRleCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gLy8gVXNhYmxlcyBhcmUgYSB2YWxpZCBSZWFjdCBub2RlIHR5cGUuIFdoZW4gUmVhY3QgZW5jb3VudGVycyBhIFVzYWJsZSBpblxuICAgIC8vIGEgY2hpbGQgcG9zaXRpb24sIGl0IHVud3JhcHMgaXQgdXNpbmcgdGhlIHNhbWUgYWxnb3JpdGhtIGFzIGB1c2VgLiBGb3JcbiAgICAvLyBleGFtcGxlLCBmb3IgcHJvbWlzZXMsIFJlYWN0IHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIHRvIHVud2luZCB0aGVcbiAgICAvLyBzdGFjaywgdGhlbiByZXBsYXkgdGhlIGNvbXBvbmVudCBvbmNlIHRoZSBwcm9taXNlIHJlc29sdmVzLlxuICAgIC8vXG4gICAgLy8gQSBkaWZmZXJlbmNlIGZyb20gYHVzZWAgaXMgdGhhdCBSZWFjdCB3aWxsIGtlZXAgdW53cmFwcGluZyB0aGUgdmFsdWVcbiAgICAvLyB1bnRpbCBpdCByZWFjaGVzIGEgbm9uLVVzYWJsZSB0eXBlLlxuICAgIC8vXG4gICAgLy8gZS5nLiBVc2FibGU8VXNhYmxlPFVzYWJsZTxUPj4+IHNob3VsZCByZXNvbHZlIHRvIFRcblxuXG4gICAgdmFyIG1heWJlVXNhYmxlID0gbm9kZTtcblxuICAgIGlmICh0eXBlb2YgbWF5YmVVc2FibGUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRoZW5hYmxlID0gbWF5YmVVc2FibGU7XG4gICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIHVud3JhcFRoZW5hYmxlKHRoZW5hYmxlKSwgY2hpbGRJbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKG1heWJlVXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgbWF5YmVVc2FibGUuJCR0eXBlb2YgPT09IFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gbWF5YmVVc2FibGU7XG4gICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIHJlYWRDb250ZXh0JDEoY29udGV4dCksIGNoaWxkSW5kZXgpO1xuICAgIH0gLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuXG5cbiAgICB2YXIgY2hpbGRTdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobm9kZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZFN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5vZGUpLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZFN0cmluZykgKyBcIikuIFwiICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcblxuICAgIGlmIChzZWdtZW50ID09PSBudWxsKSA7IGVsc2Uge1xuICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9IHB1c2hUZXh0SW5zdGFuY2Uoc2VnbWVudC5jaHVua3MsIG5vZGUsIHJlcXVlc3QucmVuZGVyU3RhdGUsIHNlZ21lbnQubGFzdFB1c2hlZFRleHQpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgX3NlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuXG4gICAgaWYgKF9zZWdtZW50ID09PSBudWxsKSA7IGVsc2Uge1xuICAgICAgX3NlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBwdXNoVGV4dEluc3RhbmNlKF9zZWdtZW50LmNodW5rcywgJycgKyBub2RlLCByZXF1ZXN0LnJlbmRlclN0YXRlLCBfc2VnbWVudC5sYXN0UHVzaGVkVGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LicpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYXlGcmFnbWVudChyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgY2hpbGRJbmRleCkge1xuICAvLyBJZiB3ZSdyZSBzdXBwb3NlZCBmb2xsb3cgdGhpcyBhcnJheSwgd2UnZCBleHBlY3QgdG8gc2VlIGEgUmVwbGF5Tm9kZSBtYXRjaGluZ1xuICAvLyB0aGlzIGZyYWdtZW50LlxuICB2YXIgcmVwbGF5ID0gdGFzay5yZXBsYXk7XG4gIHZhciByZXBsYXlOb2RlcyA9IHJlcGxheS5ub2RlcztcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IHJlcGxheU5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIG5vZGUgPSByZXBsYXlOb2Rlc1tqXTtcblxuICAgIGlmIChub2RlWzFdICE9PSBjaGlsZEluZGV4KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIE1hdGNoZWQgYSByZXBsYXlhYmxlIHBhdGguXG5cblxuICAgIHZhciBjaGlsZE5vZGVzID0gbm9kZVsyXTtcbiAgICB2YXIgY2hpbGRTbG90cyA9IG5vZGVbM107XG4gICAgdGFzay5yZXBsYXkgPSB7XG4gICAgICBub2RlczogY2hpbGROb2RlcyxcbiAgICAgIHNsb3RzOiBjaGlsZFNsb3RzLFxuICAgICAgcGVuZGluZ1Rhc2tzOiAxXG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICByZW5kZXJDaGlsZHJlbkFycmF5KHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSk7XG5cbiAgICAgIGlmICh0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MgPT09IDEgJiYgdGFzay5yZXBsYXkubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGFsbCByZXN1bWFibGUgc2xvdHMgYnkga2V5L2luZGV4IGR1cmluZyByZXBsYXlpbmcuIFwiICsgXCJUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIik7XG4gICAgICB9XG5cbiAgICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCAmJiAoeCA9PT0gU3VzcGVuc2VFeGNlcHRpb24gfHwgdHlwZW9mIHgudGhlbiA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgLy8gU3VzcGVuZFxuICAgICAgICB0aHJvdyB4O1xuICAgICAgfVxuXG4gICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTsgLy8gVW5saWtlIHJlZ3VsYXIgcmVuZGVyLCB3ZSBkb24ndCB0ZXJtaW5hdGUgdGhlIHNpYmxpbmdzIGlmIHdlIGVycm9yXG4gICAgICAvLyBkdXJpbmcgYSByZXBsYXkuIFRoYXQncyBiZWNhdXNlIHRoaXMgY29tcG9uZW50IGRpZG4ndCBhY3R1YWxseSBlcnJvclxuICAgICAgLy8gaW4gdGhlIG9yaWdpbmFsIHByZXJlbmRlci4gV2hhdCdzIHVuYWJsZSB0byBjb21wbGV0ZSBpcyB0aGUgY2hpbGRcbiAgICAgIC8vIHJlcGxheSBub2RlcyB3aGljaCBtaWdodCBiZSBTdXNwZW5zZSBib3VuZGFyaWVzIHdoaWNoIGFyZSBhYmxlIHRvXG4gICAgICAvLyBhYnNvcmIgdGhlIGVycm9yIGFuZCB3ZSBjYW4gc3RpbGwgY29udGludWUgd2l0aCBzaWJsaW5ncy5cbiAgICAgIC8vIFRoaXMgaXMgYW4gZXJyb3IsIHN0YXNoIHRoZSBjb21wb25lbnQgc3RhY2sgaWYgaXQgaXMgbnVsbC5cblxuICAgICAgdmFyIHRocm93bkluZm8gPSBnZXRUaHJvd25JbmZvKHJlcXVlc3QsIHRhc2suY29tcG9uZW50U3RhY2spO1xuICAgICAgZXJyb3JlZFJlcGxheShyZXF1ZXN0LCB0YXNrLmJsb2NrZWRCb3VuZGFyeSwgeCwgdGhyb3duSW5mbywgY2hpbGROb2RlcywgY2hpbGRTbG90cyk7XG4gICAgfVxuXG4gICAgdGFzay5yZXBsYXkgPSByZXBsYXk7IC8vIFdlIGZpbmlzaGVkIHJlbmRlcmluZyB0aGlzIG5vZGUsIHNvIG5vdyB3ZSBjYW4gY29uc3VtZSB0aGlzXG4gICAgLy8gc2xvdC4gVGhpcyBtdXN0IGhhcHBlbiBhZnRlciBpbiBjYXNlIHdlIHJlcmVuZGVyIHRoaXMgdGFzay5cblxuICAgIHJlcGxheU5vZGVzLnNwbGljZShqLCAxKTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDaGlsZHJlbkFycmF5KHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCBjaGlsZEluZGV4KSB7XG4gIHZhciBwcmV2S2V5UGF0aCA9IHRhc2sua2V5UGF0aDtcblxuICBpZiAoY2hpbGRJbmRleCAhPT0gLTEpIHtcbiAgICB0YXNrLmtleVBhdGggPSBbdGFzay5rZXlQYXRoLCAnRnJhZ21lbnQnLCBjaGlsZEluZGV4XTtcblxuICAgIGlmICh0YXNrLnJlcGxheSAhPT0gbnVsbCkge1xuICAgICAgcmVwbGF5RnJhZ21lbnQocmVxdWVzdCwgLy8gJEZsb3dGaXhNZTogUmVmaW5lZC5cbiAgICAgIHRhc2ssIGNoaWxkcmVuLCBjaGlsZEluZGV4KTtcbiAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcmV2VHJlZUNvbnRleHQgPSB0YXNrLnRyZWVDb250ZXh0O1xuICB2YXIgdG90YWxDaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICBpZiAodGFzay5yZXBsYXkgIT09IG51bGwpIHtcbiAgICAvLyBSZXBsYXlcbiAgICAvLyBGaXJzdCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGhhdmUgYW55IHJlc3VtZSBzbG90cyBhdCB0aGlzIGxldmVsLlxuICAgIHZhciByZXN1bWVTbG90cyA9IHRhc2sucmVwbGF5LnNsb3RzO1xuXG4gICAgaWYgKHJlc3VtZVNsb3RzICE9PSBudWxsICYmIHR5cGVvZiByZXN1bWVTbG90cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxDaGlsZHJlbjsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gY2hpbGRyZW5baV07XG4gICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQocHJldlRyZWVDb250ZXh0LCB0b3RhbENoaWxkcmVuLCBpKTsgLy8gV2UgbmVlZCB0byB1c2UgdGhlIG5vbi1kZXN0cnVjdGl2ZSBmb3JtIHNvIHRoYXQgd2UgY2FuIHNhZmVseSBwb3AgYmFja1xuICAgICAgICAvLyB1cCBhbmQgcmVuZGVyIHRoZSBzaWJsaW5nIGlmIHNvbWV0aGluZyBzdXNwZW5kcy5cblxuICAgICAgICB2YXIgcmVzdW1lU2VnbWVudElEID0gcmVzdW1lU2xvdHNbaV07IC8vIFRPRE86IElmIHRoaXMgZXJyb3JzIHdlIHNob3VsZCBzdGlsbCBjb250aW51ZSB3aXRoIHRoZSBuZXh0IHNpYmxpbmcuXG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bWVTZWdtZW50SUQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmVzdW1lTm9kZShyZXF1ZXN0LCB0YXNrLCByZXN1bWVTZWdtZW50SUQsIG5vZGUsIGkpOyAvLyBXZSBmaW5pc2hlZCByZW5kZXJpbmcgdGhpcyBub2RlLCBzbyBub3cgd2UgY2FuIGNvbnN1bWUgdGhpc1xuICAgICAgICAgIC8vIHNsb3QuIFRoaXMgbXVzdCBoYXBwZW4gYWZ0ZXIgaW4gY2FzZSB3ZSByZXJlbmRlciB0aGlzIHRhc2suXG5cbiAgICAgICAgICBkZWxldGUgcmVzdW1lU2xvdHNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldlRyZWVDb250ZXh0O1xuICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRvdGFsQ2hpbGRyZW47IF9pKyspIHtcbiAgICB2YXIgX25vZGUgPSBjaGlsZHJlbltfaV07XG4gICAgdGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChwcmV2VHJlZUNvbnRleHQsIHRvdGFsQ2hpbGRyZW4sIF9pKTsgLy8gV2UgbmVlZCB0byB1c2UgdGhlIG5vbi1kZXN0cnVjdGl2ZSBmb3JtIHNvIHRoYXQgd2UgY2FuIHNhZmVseSBwb3AgYmFja1xuICAgIC8vIHVwIGFuZCByZW5kZXIgdGhlIHNpYmxpbmcgaWYgc29tZXRoaW5nIHN1c3BlbmRzLlxuXG4gICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBfbm9kZSwgX2kpO1xuICB9IC8vIEJlY2F1c2UgdGhpcyBjb250ZXh0IGlzIGFsd2F5cyBzZXQgcmlnaHQgYmVmb3JlIHJlbmRlcmluZyBldmVyeSBjaGlsZCwgd2VcbiAgLy8gb25seSBuZWVkIHRvIHJlc2V0IGl0IHRvIHRoZSBwcmV2aW91cyB2YWx1ZSBhdCB0aGUgdmVyeSBlbmQuXG5cblxuICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldlRyZWVDb250ZXh0O1xuICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbn1cbi8vIHJlc3VtZSBpdC5cblxuXG5mdW5jdGlvbiB1bnRyYWNrQm91bmRhcnkocmVxdWVzdCwgYm91bmRhcnkpIHtcbiAgdmFyIHRyYWNrZWRQb3N0cG9uZXMgPSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXM7XG5cbiAgaWYgKHRyYWNrZWRQb3N0cG9uZXMgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYm91bmRhcnlLZXlQYXRoID0gYm91bmRhcnkudHJhY2tlZENvbnRlbnRLZXlQYXRoO1xuXG4gIGlmIChib3VuZGFyeUtleVBhdGggPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYm91bmRhcnlOb2RlID0gdHJhY2tlZFBvc3Rwb25lcy53b3JraW5nTWFwLmdldChib3VuZGFyeUtleVBhdGgpO1xuXG4gIGlmIChib3VuZGFyeU5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBEb3duZ3JhZGUgdG8gcGxhaW4gUmVwbGF5Tm9kZSBzaW5jZSB3ZSB3b24ndCByZXBsYXkgdGhyb3VnaCBpdC5cbiAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdOiBXZSBpbnRlbnRpb25hbGx5IGRvd25ncmFkZSB0aGlzIHRvIHRoZSBvdGhlciB0dXBsZS5cblxuXG4gIGJvdW5kYXJ5Tm9kZS5sZW5ndGggPSA0OyAvLyBSZW1vdmUgYW55IHJlc3VtYWJsZSBzbG90cy5cblxuICBib3VuZGFyeU5vZGVbMl0gPSBbXTtcbiAgYm91bmRhcnlOb2RlWzNdID0gbnVsbDsgLy8gVE9ETzogV2Ugc2hvdWxkIHJlYWxseSBqdXN0IHJlbW92ZSB0aGUgYm91bmRhcnkgZnJvbSBhbGwgcGFyZW50IHBhdGhzIHRvbyBzb1xuICAvLyB3ZSBkb24ndCByZXBsYXkgdGhlIHBhdGggdG8gaXQuXG59XG5cbmZ1bmN0aW9uIHNwYXduTmV3U3VzcGVuZGVkUmVwbGF5VGFzayhyZXF1ZXN0LCB0YXNrLCB0aGVuYWJsZVN0YXRlLCB4KSB7XG4gIHZhciBuZXdUYXNrID0gY3JlYXRlUmVwbGF5VGFzayhyZXF1ZXN0LCB0aGVuYWJsZVN0YXRlLCB0YXNrLnJlcGxheSwgdGFzay5ub2RlLCB0YXNrLmNoaWxkSW5kZXgsIHRhc2suYmxvY2tlZEJvdW5kYXJ5LCB0YXNrLmFib3J0U2V0LCB0YXNrLmtleVBhdGgsIHRhc2suZm9ybWF0Q29udGV4dCwgdGFzay5sZWdhY3lDb250ZXh0LCB0YXNrLmNvbnRleHQsIHRhc2sudHJlZUNvbnRleHQsIC8vIFdlIHBvcCBvbmUgdGFzayBvZmYgdGhlIHN0YWNrIGJlY2F1c2UgdGhlIG5vZGUgdGhhdCBzdXNwZW5kZWQgd2lsbCBiZSB0cmllZCBhZ2FpbixcbiAgLy8gd2hpY2ggd2lsbCBhZGQgaXQgYmFjayBvbnRvIHRoZSBzdGFjay5cbiAgdGFzay5jb21wb25lbnRTdGFjayAhPT0gbnVsbCA/IHRhc2suY29tcG9uZW50U3RhY2sucGFyZW50IDogbnVsbCk7XG4gIHZhciBwaW5nID0gbmV3VGFzay5waW5nO1xuICB4LnRoZW4ocGluZywgcGluZyk7XG59XG5cbmZ1bmN0aW9uIHNwYXduTmV3U3VzcGVuZGVkUmVuZGVyVGFzayhyZXF1ZXN0LCB0YXNrLCB0aGVuYWJsZVN0YXRlLCB4KSB7XG4gIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQsIHdlJ2xsIG5lZWQgdG8gY3JlYXRlIGEgbmV3IHNlZ21lbnQgYW5kIHJlc29sdmUgaXQgbGF0ZXIuXG4gIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgdmFyIGluc2VydGlvbkluZGV4ID0gc2VnbWVudC5jaHVua3MubGVuZ3RoO1xuICB2YXIgbmV3U2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KHJlcXVlc3QsIGluc2VydGlvbkluZGV4LCBudWxsLCB0YXNrLmZvcm1hdENvbnRleHQsIC8vIEFkb3B0IHRoZSBwYXJlbnQgc2VnbWVudCdzIGxlYWRpbmcgdGV4dCBlbWJlZFxuICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0LCAvLyBBc3N1bWUgd2UgYXJlIHRleHQgZW1iZWRkZWQgYXQgdGhlIHRyYWlsaW5nIGVkZ2VcbiAgdHJ1ZSk7XG4gIHNlZ21lbnQuY2hpbGRyZW4ucHVzaChuZXdTZWdtZW50KTsgLy8gUmVzZXQgbGFzdFB1c2hlZFRleHQgZm9yIGN1cnJlbnQgU2VnbWVudCBzaW5jZSB0aGUgbmV3IFNlZ21lbnQgXCJjb25zdW1lZFwiIGl0XG5cbiAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9IGZhbHNlO1xuICB2YXIgbmV3VGFzayA9IGNyZWF0ZVJlbmRlclRhc2socmVxdWVzdCwgdGhlbmFibGVTdGF0ZSwgdGFzay5ub2RlLCB0YXNrLmNoaWxkSW5kZXgsIHRhc2suYmxvY2tlZEJvdW5kYXJ5LCBuZXdTZWdtZW50LCB0YXNrLmFib3J0U2V0LCB0YXNrLmtleVBhdGgsIHRhc2suZm9ybWF0Q29udGV4dCwgdGFzay5sZWdhY3lDb250ZXh0LCB0YXNrLmNvbnRleHQsIHRhc2sudHJlZUNvbnRleHQsIC8vIFdlIHBvcCBvbmUgdGFzayBvZmYgdGhlIHN0YWNrIGJlY2F1c2UgdGhlIG5vZGUgdGhhdCBzdXNwZW5kZWQgd2lsbCBiZSB0cmllZCBhZ2FpbixcbiAgLy8gd2hpY2ggd2lsbCBhZGQgaXQgYmFjayBvbnRvIHRoZSBzdGFjay5cbiAgdGFzay5jb21wb25lbnRTdGFjayAhPT0gbnVsbCA/IHRhc2suY29tcG9uZW50U3RhY2sucGFyZW50IDogbnVsbCk7XG4gIHZhciBwaW5nID0gbmV3VGFzay5waW5nO1xuICB4LnRoZW4ocGluZywgcGluZyk7XG59IC8vIFRoaXMgaXMgYSBub24tZGVzdHJ1Y3RpdmUgZm9ybSBvZiByZW5kZXJpbmcgYSBub2RlLiBJZiBpdCBzdXNwZW5kcyBpdCBzcGF3bnNcbi8vIGEgbmV3IHRhc2sgYW5kIHJlc3RvcmVzIHRoZSBjb250ZXh0IG9mIHRoaXMgdGFzayB0byB3aGF0IGl0IHdhcyBiZWZvcmUuXG5cblxuZnVuY3Rpb24gcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KSB7XG4gIC8vIFNuYXBzaG90IHRoZSBjdXJyZW50IGNvbnRleHQgaW4gY2FzZSBzb21ldGhpbmcgdGhyb3dzIHRvIGludGVycnVwdCB0aGVcbiAgLy8gcHJvY2Vzcy5cbiAgdmFyIHByZXZpb3VzRm9ybWF0Q29udGV4dCA9IHRhc2suZm9ybWF0Q29udGV4dDtcbiAgdmFyIHByZXZpb3VzTGVnYWN5Q29udGV4dCA9IHRhc2subGVnYWN5Q29udGV4dDtcbiAgdmFyIHByZXZpb3VzQ29udGV4dCA9IHRhc2suY29udGV4dDtcbiAgdmFyIHByZXZpb3VzS2V5UGF0aCA9IHRhc2sua2V5UGF0aDtcbiAgdmFyIHByZXZpb3VzVHJlZUNvbnRleHQgPSB0YXNrLnRyZWVDb250ZXh0O1xuICB2YXIgcHJldmlvdXNDb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2s7XG4gIHZhciB4OyAvLyBTdG9yZSBob3cgbXVjaCB3ZSd2ZSBwdXNoZWQgYXQgdGhpcyBwb2ludCBzbyB3ZSBjYW4gcmVzZXQgaXQgaW4gY2FzZSBzb21ldGhpbmdcbiAgLy8gc3VzcGVuZGVkIHBhcnRpYWxseSB0aHJvdWdoIHdyaXRpbmcgc29tZXRoaW5nLlxuXG4gIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcblxuICBpZiAoc2VnbWVudCA9PT0gbnVsbCkge1xuICAgIC8vIFJlcGxheVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICByZXNldEhvb2tzU3RhdGUoKTtcbiAgICAgIHggPSB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24gPyAvLyBUaGlzIGlzIGEgc3BlY2lhbCB0eXBlIG9mIGV4Y2VwdGlvbiB1c2VkIGZvciBTdXNwZW5zZS4gRm9yIGhpc3RvcmljYWxcbiAgICAgIC8vIHJlYXNvbnMsIHRoZSByZXN0IG9mIHRoZSBTdXNwZW5zZSBpbXBsZW1lbnRhdGlvbiBleHBlY3RzIHRoZSB0aHJvd25cbiAgICAgIC8vIHZhbHVlIHRvIGJlIGEgdGhlbmFibGUsIGJlY2F1c2UgYmVmb3JlIGB1c2VgIGV4aXN0ZWQgdGhhdCB3YXMgdGhlXG4gICAgICAvLyAodW5zdGFibGUpIEFQSSBmb3Igc3VzcGVuZGluZy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgY2FuIGNoYW5nZVxuICAgICAgLy8gbGF0ZXIsIG9uY2Ugd2UgZGVwcmVjYXRlIHRoZSBvbGQgQVBJIGluIGZhdm9yIG9mIGB1c2VgLlxuICAgICAgZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSA6IHRocm93blZhbHVlO1xuXG4gICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgICAgICBpZiAodHlwZW9mIHgudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB3YWtlYWJsZSA9IHg7XG4gICAgICAgICAgdmFyIHRoZW5hYmxlU3RhdGUgPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgICAgc3Bhd25OZXdTdXNwZW5kZWRSZXBsYXlUYXNrKHJlcXVlc3QsIC8vICRGbG93Rml4TWU6IFJlZmluZWQuXG4gICAgICAgICAgdGFzaywgdGhlbmFibGVTdGF0ZSwgd2FrZWFibGUpOyAvLyBSZXN0b3JlIHRoZSBjb250ZXh0LiBXZSBhc3N1bWUgdGhhdCB0aGlzIHdpbGwgYmUgcmVzdG9yZWQgYnkgdGhlIGlubmVyXG4gICAgICAgICAgLy8gZnVuY3Rpb25zIGluIGNhc2Ugbm90aGluZyB0aHJvd3Mgc28gd2UgZG9uJ3QgdXNlIFwiZmluYWxseVwiIGhlcmUuXG5cbiAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICAgICAgdGFzay5sZWdhY3lDb250ZXh0ID0gcHJldmlvdXNMZWdhY3lDb250ZXh0O1xuICAgICAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2aW91c0tleVBhdGg7XG4gICAgICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZpb3VzVHJlZUNvbnRleHQ7XG4gICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7IC8vIFJlc3RvcmUgYWxsIGFjdGl2ZSBSZWFjdENvbnRleHRzIHRvIHdoYXQgdGhleSB3ZXJlIGJlZm9yZS5cblxuICAgICAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVE9ETzogQWJvcnQgYW55IHVuZGlzY292ZXJlZCBTdXNwZW5zZSBib3VuZGFyaWVzIGluIHRoZSBSZXBsYXlOb2RlLlxuXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJlbmRlclxuICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHZhciBjaHVua0xlbmd0aCA9IHNlZ21lbnQuY2h1bmtzLmxlbmd0aDtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICByZXNldEhvb2tzU3RhdGUoKTsgLy8gUmVzZXQgdGhlIHdyaXRlIHBvaW50ZXJzIHRvIHdoZXJlIHdlIHN0YXJ0ZWQuXG5cbiAgICAgIHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoID0gY2hpbGRyZW5MZW5ndGg7XG4gICAgICBzZWdtZW50LmNodW5rcy5sZW5ndGggPSBjaHVua0xlbmd0aDtcbiAgICAgIHggPSB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24gPyAvLyBUaGlzIGlzIGEgc3BlY2lhbCB0eXBlIG9mIGV4Y2VwdGlvbiB1c2VkIGZvciBTdXNwZW5zZS4gRm9yIGhpc3RvcmljYWxcbiAgICAgIC8vIHJlYXNvbnMsIHRoZSByZXN0IG9mIHRoZSBTdXNwZW5zZSBpbXBsZW1lbnRhdGlvbiBleHBlY3RzIHRoZSB0aHJvd25cbiAgICAgIC8vIHZhbHVlIHRvIGJlIGEgdGhlbmFibGUsIGJlY2F1c2UgYmVmb3JlIGB1c2VgIGV4aXN0ZWQgdGhhdCB3YXMgdGhlXG4gICAgICAvLyAodW5zdGFibGUpIEFQSSBmb3Igc3VzcGVuZGluZy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgY2FuIGNoYW5nZVxuICAgICAgLy8gbGF0ZXIsIG9uY2Ugd2UgZGVwcmVjYXRlIHRoZSBvbGQgQVBJIGluIGZhdm9yIG9mIGB1c2VgLlxuICAgICAgZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSA6IHRocm93blZhbHVlO1xuXG4gICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgICAgICBpZiAodHlwZW9mIHgudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBfd2FrZWFibGUgPSB4O1xuXG4gICAgICAgICAgdmFyIF90aGVuYWJsZVN0YXRlID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuXG4gICAgICAgICAgc3Bhd25OZXdTdXNwZW5kZWRSZW5kZXJUYXNrKHJlcXVlc3QsIC8vICRGbG93Rml4TWU6IFJlZmluZWQuXG4gICAgICAgICAgdGFzaywgX3RoZW5hYmxlU3RhdGUsIF93YWtlYWJsZSk7IC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuIFdlIGFzc3VtZSB0aGF0IHRoaXMgd2lsbCBiZSByZXN0b3JlZCBieSB0aGUgaW5uZXJcbiAgICAgICAgICAvLyBmdW5jdGlvbnMgaW4gY2FzZSBub3RoaW5nIHRocm93cyBzbyB3ZSBkb24ndCB1c2UgXCJmaW5hbGx5XCIgaGVyZS5cblxuICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgICAgICB0YXNrLmxlZ2FjeUNvbnRleHQgPSBwcmV2aW91c0xlZ2FjeUNvbnRleHQ7XG4gICAgICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZpb3VzS2V5UGF0aDtcbiAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDtcbiAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjazsgLy8gUmVzdG9yZSBhbGwgYWN0aXZlIFJlYWN0Q29udGV4dHMgdG8gd2hhdCB0aGV5IHdlcmUgYmVmb3JlLlxuXG4gICAgICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZXN0b3JlIHRoZSBjb250ZXh0LiBXZSBhc3N1bWUgdGhhdCB0aGlzIHdpbGwgYmUgcmVzdG9yZWQgYnkgdGhlIGlubmVyXG4gIC8vIGZ1bmN0aW9ucyBpbiBjYXNlIG5vdGhpbmcgdGhyb3dzIHNvIHdlIGRvbid0IHVzZSBcImZpbmFsbHlcIiBoZXJlLlxuXG5cbiAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICB0YXNrLmxlZ2FjeUNvbnRleHQgPSBwcmV2aW91c0xlZ2FjeUNvbnRleHQ7XG4gIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDsgLy8gV2UgaW50ZW50aW9uYWxseSBkbyBub3QgcmVzdG9yZSB0aGUgY29tcG9uZW50IHN0YWNrIG9uIHRoZSBlcnJvciBwYXRod2F5XG4gIC8vIFdoYXRldmVyIGhhbmRsZXMgdGhlIGVycm9yIG5lZWRzIHRvIHVzZSB0aGlzIHN0YWNrIHdoaWNoIGlzIHRoZSBsb2NhdGlvbiBvZiB0aGVcbiAgLy8gZXJyb3IuIFdlIG11c3QgcmVzdG9yZSB0aGUgc3RhY2sgd2hlcmV2ZXIgd2UgaGFuZGxlIHRoaXNcbiAgLy8gUmVzdG9yZSBhbGwgYWN0aXZlIFJlYWN0Q29udGV4dHMgdG8gd2hhdCB0aGV5IHdlcmUgYmVmb3JlLlxuXG4gIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgdGhyb3cgeDtcbn1cblxuZnVuY3Rpb24gZXJyb3JlZFJlcGxheShyZXF1ZXN0LCBib3VuZGFyeSwgZXJyb3IsIGVycm9ySW5mbywgcmVwbGF5Tm9kZXMsIHJlc3VtZVNsb3RzKSB7XG4gIC8vIEVycm9yaW5nIGR1cmluZyBhIHJlcGxheSBkb2Vzbid0IGFjdHVhbGx5IGNhdXNlIGFuIGVycm9yIGJ5IGl0c2VsZiBiZWNhdXNlXG4gIC8vIHRoYXQgY29tcG9uZW50IGhhcyBhbHJlYWR5IHJlbmRlcmVkLiBXaGF0IGNhdXNlcyB0aGUgZXJyb3IgaXMgdGhlIHJlc3VtYWJsZVxuICAvLyBwb2ludHMgdGhhdCB3ZSBkaWQgbm90IHlldCBmaW5pc2ggd2hpY2ggd2lsbCBiZSBiZWxvdyB0aGUgcG9pbnQgb2YgdGhlIHJlc2V0LlxuICAvLyBGb3IgZXhhbXBsZSwgaWYgd2UncmUgcmVwbGF5aW5nIGEgcGF0aCB0byBhIFN1c3BlbnNlIGJvdW5kYXJ5IHRoYXQgaXMgbm90IGRvbmVcbiAgLy8gdGhhdCBkb2Vzbid0IGVycm9yIHRoZSBwYXJlbnQgU3VzcGVuc2UgYm91bmRhcnkuXG4gIC8vIFRoaXMgbWlnaHQgYmUgYSBiaXQgc3RyYW5nZSB0aGF0IHRoZSBlcnJvciBpbiBhIHBhcmVudCBnZXRzIHRocm93biBhdCBhIGNoaWxkLlxuICAvLyBXZSBsb2cgaXQgb25seSBvbmNlIGFuZCByZXVzZSB0aGUgZGlnZXN0LlxuICB2YXIgZXJyb3JEaWdlc3Q7XG5cbiAge1xuICAgIGVycm9yRGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgZXJyb3JJbmZvKTtcbiAgfVxuXG4gIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMocmVxdWVzdCwgYm91bmRhcnksIHJlcGxheU5vZGVzLCByZXN1bWVTbG90cywgZXJyb3IsIGVycm9yRGlnZXN0LCBlcnJvckluZm8pO1xufVxuXG5mdW5jdGlvbiBlcnJvcmVkVGFzayhyZXF1ZXN0LCBib3VuZGFyeSwgZXJyb3IsIGVycm9ySW5mbykge1xuICAvLyBSZXBvcnQgdGhlIGVycm9yIHRvIGEgZ2xvYmFsIGhhbmRsZXIuXG4gIHZhciBlcnJvckRpZ2VzdDtcblxuICB7XG4gICAgZXJyb3JEaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBlcnJvckluZm8pO1xuICB9XG5cbiAgaWYgKGJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS07XG5cbiAgICBpZiAoYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQpIHtcbiAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDtcbiAgICAgIGVuY29kZUVycm9yRm9yQm91bmRhcnkoYm91bmRhcnksIGVycm9yRGlnZXN0LCBlcnJvciwgZXJyb3JJbmZvKTtcbiAgICAgIHVudHJhY2tCb3VuZGFyeShyZXF1ZXN0LCBib3VuZGFyeSk7IC8vIFJlZ2FyZGxlc3Mgb2Ygd2hhdCBoYXBwZW5zIG5leHQsIHRoaXMgYm91bmRhcnkgd29uJ3QgYmUgZGlzcGxheWVkLFxuICAgICAgLy8gc28gd2UgY2FuIGZsdXNoIGl0LCBpZiB0aGUgcGFyZW50IGFscmVhZHkgZmx1c2hlZC5cblxuICAgICAgaWYgKGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBhIHByZWZlcmVuY2Ugd2hlcmUgaW4gdGhlIHF1ZXVlIHRoaXMgZ29lcyBzaW5jZSBpdCdzIGxpa2VseVxuICAgICAgICAvLyB0byBlcnJvciBvbiB0aGUgY2xpZW50IGFueXdheS4gSG93ZXZlciwgaW50ZW50aW9uYWxseSBjbGllbnQtcmVuZGVyZWRcbiAgICAgICAgLy8gYm91bmRhcmllcyBzaG91bGQgYmUgZmx1c2hlZCBlYXJsaWVyIHNvIHRoYXQgdGhleSBjYW4gc3RhcnQgb24gdGhlIGNsaWVudC5cbiAgICAgICAgLy8gV2UgcmV1c2UgdGhlIHNhbWUgcXVldWUgZm9yIGVycm9ycy5cbiAgICAgICAgcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcblxuICBpZiAocmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICBjb21wbGV0ZUFsbChyZXF1ZXN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhYm9ydFRhc2tTb2Z0KHRhc2spIHtcbiAgLy8gVGhpcyBhYm9ydHMgdGFzayB3aXRob3V0IGFib3J0aW5nIHRoZSBwYXJlbnQgYm91bmRhcnkgdGhhdCBpdCBibG9ja3MuXG4gIC8vIEl0J3MgdXNlZCBmb3Igd2hlbiB3ZSBkaWRuJ3QgbmVlZCB0aGlzIHRhc2sgdG8gY29tcGxldGUgdGhlIHRyZWUuXG4gIC8vIElmIHRhc2sgd2FzIG5lZWRlZCwgdGhlbiBpdCBzaG91bGQgdXNlIGFib3J0VGFzayBpbnN0ZWFkLlxuICB2YXIgcmVxdWVzdCA9IHRoaXM7XG4gIHZhciBib3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG5cbiAgaWYgKHNlZ21lbnQgIT09IG51bGwpIHtcbiAgICBzZWdtZW50LnN0YXR1cyA9IEFCT1JURUQ7XG4gICAgZmluaXNoZWRUYXNrKHJlcXVlc3QsIGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhYm9ydFJlbWFpbmluZ1N1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgcm9vdFNlZ21lbnRJRCwgZXJyb3IsIGVycm9yRGlnZXN0LCBlcnJvckluZm8pIHtcbiAgdmFyIHJlc3VtZWRCb3VuZGFyeSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgbmV3IFNldCgpKTtcbiAgcmVzdW1lZEJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgPSB0cnVlOyAvLyBXZSByZXN0b3JlIHRoZSBzYW1lIGlkIG9mIHRoaXMgYm91bmRhcnkgYXMgd2FzIHVzZWQgZHVyaW5nIHByZXJlbmRlci5cblxuICByZXN1bWVkQm91bmRhcnkucm9vdFNlZ21lbnRJRCA9IHJvb3RTZWdtZW50SUQ7XG4gIHJlc3VtZWRCb3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQ7XG4gIHZhciBlcnJvck1lc3NhZ2UgPSBlcnJvcjtcblxuICB7XG4gICAgdmFyIGVycm9yUHJlZml4ID0gJ1RoZSBzZXJ2ZXIgZGlkIG5vdCBmaW5pc2ggdGhpcyBTdXNwZW5zZSBib3VuZGFyeTogJztcblxuICAgIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yUHJlZml4ICsgZXJyb3IubWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvclByZWZpeCArIFN0cmluZyhlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShyZXN1bWVkQm91bmRhcnksIGVycm9yRGlnZXN0LCBlcnJvck1lc3NhZ2UsIGVycm9ySW5mbyk7XG5cbiAgaWYgKHJlc3VtZWRCb3VuZGFyeS5wYXJlbnRGbHVzaGVkKSB7XG4gICAgcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucHVzaChyZXN1bWVkQm91bmRhcnkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMocmVxdWVzdCwgYm91bmRhcnksIG5vZGVzLCBzbG90cywgZXJyb3IsIGVycm9yRGlnZXN0LCBlcnJvckluZm8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAobm9kZS5sZW5ndGggPT09IDQpIHtcbiAgICAgIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMocmVxdWVzdCwgYm91bmRhcnksIG5vZGVbMl0sIG5vZGVbM10sIGVycm9yLCBlcnJvckRpZ2VzdCwgZXJyb3JJbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJvdW5kYXJ5Tm9kZSA9IG5vZGU7XG4gICAgICB2YXIgcm9vdFNlZ21lbnRJRCA9IGJvdW5kYXJ5Tm9kZVs1XTtcbiAgICAgIGFib3J0UmVtYWluaW5nU3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCByb290U2VnbWVudElELCBlcnJvciwgZXJyb3JEaWdlc3QsIGVycm9ySW5mbyk7XG4gICAgfVxuICB9IC8vIEVtcHR5IHRoZSBzZXQsIHNpbmNlIHdlJ3ZlIGNsZWFyZWQgaXQgbm93LlxuXG5cbiAgbm9kZXMubGVuZ3RoID0gMDtcblxuICBpZiAoc2xvdHMgIT09IG51bGwpIHtcbiAgICAvLyBXZSBoYWQgc29tZXRoaW5nIHN0aWxsIHRvIHJlc3VtZSBpbiB0aGUgcGFyZW50IGJvdW5kYXJ5LiBXZSBtdXN0IHRyaWdnZXJcbiAgICAvLyB0aGUgZXJyb3Igb24gdGhlIHBhcmVudCBib3VuZGFyeSBzaW5jZSBpdCdzIG5vdCBhYmxlIHRvIGNvbXBsZXRlLlxuICAgIGlmIChib3VuZGFyeSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZSBzaG91bGQgbm90IGhhdmUgYW55IHJlc3VtYWJsZSBub2RlcyBpbiB0aGUgc2hlbGwuICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9IGVsc2UgaWYgKGJvdW5kYXJ5LnN0YXR1cyAhPT0gQ0xJRU5UX1JFTkRFUkVEKSB7XG4gICAgICBib3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQ7XG4gICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KGJvdW5kYXJ5LCBlcnJvckRpZ2VzdCwgZXJyb3IsIGVycm9ySW5mbyk7XG5cbiAgICAgIGlmIChib3VuZGFyeS5wYXJlbnRGbHVzaGVkKSB7XG4gICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpO1xuICAgICAgfVxuICAgIH0gLy8gRW1wdHkgdGhlIHNldFxuXG5cbiAgICBpZiAodHlwZW9mIHNsb3RzID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIgaW5kZXggaW4gc2xvdHMpIHtcbiAgICAgICAgZGVsZXRlIHNsb3RzW2luZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWJvcnRUYXNrKHRhc2ssIHJlcXVlc3QsIGVycm9yKSB7XG4gIC8vIFRoaXMgYWJvcnRzIHRoZSB0YXNrIGFuZCBhYm9ydHMgdGhlIHBhcmVudCB0aGF0IGl0IGJsb2NrcywgcHV0dGluZyBpdCBpbnRvXG4gIC8vIGNsaWVudCByZW5kZXJlZCBtb2RlLlxuICB2YXIgYm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuXG4gIGlmIChzZWdtZW50ICE9PSBudWxsKSB7XG4gICAgc2VnbWVudC5zdGF0dXMgPSBBQk9SVEVEO1xuICB9XG5cbiAgaWYgKGJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgdmFyIGVycm9ySW5mbyA9IHt9O1xuXG4gICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSBDTE9TSU5HICYmIHJlcXVlc3Quc3RhdHVzICE9PSBDTE9TRUQpIHtcbiAgICAgIHZhciByZXBsYXkgPSB0YXNrLnJlcGxheTtcblxuICAgICAgaWYgKHJlcGxheSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBkaWRuJ3QgY29tcGxldGUgdGhlIHJvb3Qgc28gd2UgaGF2ZSBub3RoaW5nIHRvIHNob3cuIFdlIGNhbiBjbG9zZVxuICAgICAgICAvLyB0aGUgcmVxdWVzdDtcbiAgICAgICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgZXJyb3JJbmZvKTtcbiAgICAgICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSBzaGVsbCBhYm9ydHMgZHVyaW5nIGEgcmVwbGF5LCB0aGF0J3Mgbm90IGEgZmF0YWwgZXJyb3IuIEluc3RlYWRcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVjb3ZlciBieSBjbGllbnQgcmVuZGVyaW5nIGFsbCB0aGUgcm9vdCBib3VuZGFyaWVzIGluXG4gICAgICAgIC8vIHRoZSBSZXBsYXlTZXQuXG4gICAgICAgIHJlcGxheS5wZW5kaW5nVGFza3MtLTtcblxuICAgICAgICBpZiAocmVwbGF5LnBlbmRpbmdUYXNrcyA9PT0gMCAmJiByZXBsYXkubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBlcnJvckRpZ2VzdCA9IGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIGVycm9ySW5mbyk7XG4gICAgICAgICAgYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyhyZXF1ZXN0LCBudWxsLCByZXBsYXkubm9kZXMsIHJlcGxheS5zbG90cywgZXJyb3IsIGVycm9yRGlnZXN0LCBlcnJvckluZm8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzLS07XG5cbiAgICAgICAgaWYgKHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyA9PT0gMCkge1xuICAgICAgICAgIGNvbXBsZXRlU2hlbGwocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS07XG5cbiAgICBpZiAoYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQpIHtcbiAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDsgLy8gV2UgY29uc3RydWN0IGFuIGVycm9ySW5mbyBmcm9tIHRoZSBib3VuZGFyeSdzIGNvbXBvbmVudFN0YWNrIHNvIHRoZSBlcnJvciBpbiBkZXYgd2lsbCBpbmRpY2F0ZSB3aGljaFxuICAgICAgLy8gYm91bmRhcnkgdGhlIG1lc3NhZ2UgaXMgcmVmZXJyaW5nIHRvXG5cbiAgICAgIHZhciBfZXJyb3JJbmZvID0gZ2V0VGhyb3duSW5mbyhyZXF1ZXN0LCB0YXNrLmNvbXBvbmVudFN0YWNrKTtcblxuICAgICAgdmFyIF9lcnJvckRpZ2VzdCA9IGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIF9lcnJvckluZm8pO1xuXG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZXJyb3I7XG5cbiAgICAgIHtcbiAgICAgICAgdmFyIGVycm9yUHJlZml4ID0gJ1RoZSBzZXJ2ZXIgZGlkIG5vdCBmaW5pc2ggdGhpcyBTdXNwZW5zZSBib3VuZGFyeTogJztcblxuICAgICAgICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JQcmVmaXggKyBlcnJvci5tZXNzYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yUHJlZml4ICsgU3RyaW5nKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KGJvdW5kYXJ5LCBfZXJyb3JEaWdlc3QsIGVycm9yTWVzc2FnZSwgX2Vycm9ySW5mbyk7XG4gICAgICB1bnRyYWNrQm91bmRhcnkocmVxdWVzdCwgYm91bmRhcnkpO1xuXG4gICAgICBpZiAoYm91bmRhcnkucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KTtcbiAgICAgIH1cbiAgICB9IC8vIElmIHRoaXMgYm91bmRhcnkgd2FzIHN0aWxsIHBlbmRpbmcgdGhlbiB3ZSBoYXZlbid0IGFscmVhZHkgY2FuY2VsbGVkIGl0cyBmYWxsYmFja3MuXG4gICAgLy8gV2UnbGwgbmVlZCB0byBhYm9ydCB0aGUgZmFsbGJhY2tzLCB3aGljaCB3aWxsIGFsc28gZXJyb3IgdGhhdCBwYXJlbnQgYm91bmRhcnkuXG5cblxuICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAoZmFsbGJhY2tUYXNrKSB7XG4gICAgICByZXR1cm4gYWJvcnRUYXNrKGZhbGxiYWNrVGFzaywgcmVxdWVzdCwgZXJyb3IpO1xuICAgIH0pO1xuICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuY2xlYXIoKTtcbiAgfVxuXG4gIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzLS07XG5cbiAgaWYgKHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzID09PSAwKSB7XG4gICAgY29tcGxldGVBbGwocmVxdWVzdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgc2hlbGxDb21wbGV0ZSkge1xuICB0cnkge1xuICAgIGVtaXRFYXJseVByZWxvYWRzKHJlcXVlc3QucmVuZGVyU3RhdGUsIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsIHNoZWxsQ29tcGxldGUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFdlIGFzc3VtZSBwcmVsb2FkcyBhcmUgb3B0aW1pc3RpYyBhbmQgdGh1cyBub24tZmF0YWwgaWYgZXJyb3JlZC5cbiAgICB2YXIgZXJyb3JJbmZvID0ge307XG4gICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgZXJyb3JJbmZvKTtcbiAgfVxufSAvLyBJIGV4dHJhY3RlZCB0aGlzIGZ1bmN0aW9uIG91dCBiZWNhdXNlIHdlIHdhbnQgdG8gZW5zdXJlIHdlIGNvbnNpc3RlbnRseSBlbWl0IHByZWxvYWRzIGJlZm9yZVxuLy8gdHJhbnNpdGlvbmluZyB0byB0aGUgbmV4dCByZXF1ZXN0IHN0YWdlIGFuZCB0aGlzIHRyYW5zaXRpb24gY2FuIGhhcHBlbiBpbiBtdWx0aXBsZSBwbGFjZXMgaW4gdGhpc1xuLy8gaW1wbGVtZW50YXRpb24uXG5cblxuZnVuY3Rpb24gY29tcGxldGVTaGVsbChyZXF1ZXN0KSB7XG4gIGlmIChyZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgPT09IG51bGwpIHtcbiAgICAvLyBXZSBvbmx5IGVtaXQgZWFybHkgcHJlbG9hZHMgb24gc2hlbGwgY29tcGxldGlvbiBmb3IgcmVuZGVycy4gRm9yIHByZXJlbmRlcnNcbiAgICAvLyB3ZSB3YWl0IGZvciB0aGUgZW50aXJlIFJlcXVlc3QgdG8gZmluaXNoIGJlY2F1c2Ugd2UgYXJlIG5vdCByZXNwb25kaW5nIHRvIGFcbiAgICAvLyBsaXZlIHJlcXVlc3QgYW5kIGNhbiB3YWl0IGZvciBhcyBtdWNoIGRhdGEgYXMgcG9zc2libGUuXG4gICAgLy8gd2Ugc2hvdWxkIG9ubHkgYmUgY2FsbGluZyBjb21wbGV0ZVNoZWxsIHdoZW4gdGhlIHNoZWxsIGlzIGNvbXBsZXRlIHNvIHdlXG4gICAgLy8ganVzdCB1c2UgYSBsaXRlcmFsIGhlcmVcbiAgICB2YXIgc2hlbGxDb21wbGV0ZSA9IHRydWU7XG4gICAgc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgc2hlbGxDb21wbGV0ZSk7XG4gIH0gLy8gV2UgaGF2ZSBjb21wbGV0ZWQgdGhlIHNoZWxsIHNvIHRoZSBzaGVsbCBjYW4ndCBlcnJvciBhbnltb3JlLlxuXG5cbiAgcmVxdWVzdC5vblNoZWxsRXJyb3IgPSBub29wO1xuICB2YXIgb25TaGVsbFJlYWR5ID0gcmVxdWVzdC5vblNoZWxsUmVhZHk7XG4gIG9uU2hlbGxSZWFkeSgpO1xufSAvLyBJIGV4dHJhY3RlZCB0aGlzIGZ1bmN0aW9uIG91dCBiZWNhdXNlIHdlIHdhbnQgdG8gZW5zdXJlIHdlIGNvbnNpc3RlbnRseSBlbWl0IHByZWxvYWRzIGJlZm9yZVxuLy8gdHJhbnNpdGlvbmluZyB0byB0aGUgbmV4dCByZXF1ZXN0IHN0YWdlIGFuZCB0aGlzIHRyYW5zaXRpb24gY2FuIGhhcHBlbiBpbiBtdWx0aXBsZSBwbGFjZXMgaW4gdGhpc1xuLy8gaW1wbGVtZW50YXRpb24uXG5cblxuZnVuY3Rpb24gY29tcGxldGVBbGwocmVxdWVzdCkge1xuICAvLyBEdXJpbmcgYSByZW5kZXIgdGhlIHNoZWxsIG11c3QgYmUgY29tcGxldGUgaWYgdGhlIGVudGlyZSByZXF1ZXN0IGlzIGZpbmlzaGVkXG4gIC8vIGhvd2V2ZXIgZHVyaW5nIGEgUHJlcmVuZGVyIGl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIHNoZWxsIGlzIGluY29tcGxldGUgYmVjYXVzZVxuICAvLyBpdCBwb3N0cG9uZWQuIFdlIGNhbm5vdCB1c2Ugcm9vdFBlbmRpbmdUYXNrcyBpbiB0aGUgcHJlcmVuZGVyIGNhc2UgYmVjYXVzZVxuICAvLyB0aG9zZSBoaXQgemVybyBldmVuIHdoZW4gdGhlIHNoZWxsIHBvc3Rwb25lcy4gSW5zdGVhZCB3ZSBsb29rIGF0IHRoZSBjb21wbGV0ZWRSb290U2VnbWVudFxuICB2YXIgc2hlbGxDb21wbGV0ZSA9IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyA9PT0gbnVsbCA/IC8vIFJlbmRlciwgd2UgYXNzdW1lIGl0IGlzIGNvbXBsZXRlZFxuICB0cnVlIDogLy8gUHJlcmVuZGVyIFJlcXVlc3QsIHdlIHVzZSB0aGUgc3RhdGUgb2YgdGhlIHJvb3Qgc2VnbWVudFxuICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ID09PSBudWxsIHx8IHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQuc3RhdHVzICE9PSBQT1NUUE9ORUQ7XG4gIHNhZmVseUVtaXRFYXJseVByZWxvYWRzKHJlcXVlc3QsIHNoZWxsQ29tcGxldGUpO1xuICB2YXIgb25BbGxSZWFkeSA9IHJlcXVlc3Qub25BbGxSZWFkeTtcbiAgb25BbGxSZWFkeSgpO1xufVxuXG5mdW5jdGlvbiBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYm91bmRhcnksIHNlZ21lbnQpIHtcbiAgaWYgKHNlZ21lbnQuY2h1bmtzLmxlbmd0aCA9PT0gMCAmJiBzZWdtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBzZWdtZW50LmNoaWxkcmVuWzBdLmJvdW5kYXJ5ID09PSBudWxsICYmIHNlZ21lbnQuY2hpbGRyZW5bMF0uaWQgPT09IC0xKSB7XG4gICAgLy8gVGhpcyBpcyBhbiBlbXB0eSBzZWdtZW50LiBUaGVyZSdzIG5vdGhpbmcgdG8gd3JpdGUsIHNvIHdlIGNhbiBpbnN0ZWFkIHRyYW5zZmVyIHRoZSBJRFxuICAgIC8vIHRvIHRoZSBjaGlsZC4gVGhhdCB3YXkgYW55IGV4aXN0aW5nIHJlZmVyZW5jZXMgcG9pbnQgdG8gdGhlIGNoaWxkLlxuICAgIHZhciBjaGlsZFNlZ21lbnQgPSBzZWdtZW50LmNoaWxkcmVuWzBdO1xuICAgIGNoaWxkU2VnbWVudC5pZCA9IHNlZ21lbnQuaWQ7XG4gICAgY2hpbGRTZWdtZW50LnBhcmVudEZsdXNoZWQgPSB0cnVlO1xuXG4gICAgaWYgKGNoaWxkU2VnbWVudC5zdGF0dXMgPT09IENPTVBMRVRFRCkge1xuICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBjaGlsZFNlZ21lbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcbiAgICBjb21wbGV0ZWRTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaGVkVGFzayhyZXF1ZXN0LCBib3VuZGFyeSwgc2VnbWVudCkge1xuICBpZiAoYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICBpZiAoc2VnbWVudCAhPT0gbnVsbCAmJiBzZWdtZW50LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgIGlmIChyZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgY2FuIG9ubHkgYmUgb25lIHJvb3Qgc2VnbWVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzLS07XG5cbiAgICBpZiAocmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzID09PSAwKSB7XG4gICAgICBjb21wbGV0ZVNoZWxsKHJlcXVlc3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBib3VuZGFyeS5wZW5kaW5nVGFza3MtLTtcblxuICAgIGlmIChib3VuZGFyeS5zdGF0dXMgPT09IENMSUVOVF9SRU5ERVJFRCkgOyBlbHNlIGlmIChib3VuZGFyeS5wZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICAgIGlmIChib3VuZGFyeS5zdGF0dXMgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgYm91bmRhcnkuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgICAgfSAvLyBUaGlzIG11c3QgaGF2ZSBiZWVuIHRoZSBsYXN0IHNlZ21lbnQgd2Ugd2VyZSB3YWl0aW5nIG9uLiBUaGlzIGJvdW5kYXJ5IGlzIG5vdyBjb21wbGV0ZS5cblxuXG4gICAgICBpZiAoc2VnbWVudCAhPT0gbnVsbCAmJiBzZWdtZW50LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgLy8gT3VyIHBhcmVudCBzZWdtZW50IGFscmVhZHkgZmx1c2hlZCwgc28gd2UgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHNlZ21lbnQgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBzZWdtZW50IHRoYXQgd2FzIGFib3J0ZWQsIHdlJ2xsIHdyaXRlIG90aGVyIGNvbnRlbnQgaW5zdGVhZCBzbyB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vIHRvIGVtaXQgaXQuXG4gICAgICAgIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEKSB7XG4gICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRhcnkucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAvLyBUaGUgc2VnbWVudCBtaWdodCBiZSBwYXJ0IG9mIGEgc2VnbWVudCB0aGF0IGRpZG4ndCBmbHVzaCB5ZXQsIGJ1dCBpZiB0aGUgYm91bmRhcnknc1xuICAgICAgICAvLyBwYXJlbnQgZmx1c2hlZCwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgYm91bmRhcnkgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpO1xuICAgICAgfSAvLyBXZSBjYW4gbm93IGNhbmNlbCBhbnkgcGVuZGluZyB0YXNrIG9uIHRoZSBmYWxsYmFjayBzaW5jZSB3ZSB3b24ndCBuZWVkIHRvIHNob3cgaXQgYW55bW9yZS5cbiAgICAgIC8vIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHdlIHJlYWQgdGhlIHBhcmVudEZsdXNoZWQgZmxhZ3MgYmVjYXVzZSBhYm9ydGluZyBjYW4gZmluaXNoXG4gICAgICAvLyB3b3JrIHdoaWNoIGNhbiB0cmlnZ2VyIHVzZXIgY29kZSwgd2hpY2ggY2FuIHN0YXJ0IGZsdXNoaW5nLCB3aGljaCBjYW4gY2hhbmdlIHRob3NlIGZsYWdzLlxuICAgICAgLy8gSWYgdGhlIGJvdW5kYXJ5IHdhcyBQT1NUUE9ORUQsIHdlIHN0aWxsIG5lZWQgdG8gZmluaXNoIHRoZSBmYWxsYmFjayBmaXJzdC5cblxuXG4gICAgICBpZiAoYm91bmRhcnkuc3RhdHVzID09PSBDT01QTEVURUQpIHtcbiAgICAgICAgYm91bmRhcnkuZmFsbGJhY2tBYm9ydGFibGVUYXNrcy5mb3JFYWNoKGFib3J0VGFza1NvZnQsIHJlcXVlc3QpO1xuICAgICAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzZWdtZW50ICE9PSBudWxsICYmIHNlZ21lbnQucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAvLyBPdXIgcGFyZW50IGFscmVhZHkgZmx1c2hlZCwgc28gd2UgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHNlZ21lbnQgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBzZWdtZW50IHRoYXQgd2FzIGFib3J0ZWQsIHdlJ2xsIHdyaXRlIG90aGVyIGNvbnRlbnQgaW5zdGVhZCBzbyB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vIHRvIGVtaXQgaXQuXG4gICAgICAgIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEKSB7XG4gICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgICAgICAgICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcblxuICAgICAgICAgIGlmIChjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgc2luY2Ugd2UgbGFzdCBmbHVzaGVkIHRoYXQgd2UgY29tcGxldGVkIGFueXRoaW5nLlxuICAgICAgICAgICAgLy8gV2UgY2FuIHNjaGVkdWxlIHRoaXMgYm91bmRhcnkgdG8gZW1pdCBpdHMgcGFydGlhbGx5IGNvbXBsZXRlZCBzZWdtZW50cyBlYXJseVxuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gZmx1c2hlZC5cbiAgICAgICAgICAgIGlmIChib3VuZGFyeS5wYXJlbnRGbHVzaGVkKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcblxuICBpZiAocmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICBjb21wbGV0ZUFsbChyZXF1ZXN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyeVRhc2socmVxdWVzdCwgdGFzaykge1xuICB7XG4gICAgdmFyIGJsb2NrZWRCb3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICAgIHNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0KHJlcXVlc3QucmVuZGVyU3RhdGUsIGJsb2NrZWRCb3VuZGFyeSA/IGJsb2NrZWRCb3VuZGFyeS5yZXNvdXJjZXMgOiBudWxsKTtcbiAgfVxuXG4gIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcblxuICBpZiAoc2VnbWVudCA9PT0gbnVsbCkge1xuICAgIHJldHJ5UmVwbGF5VGFzayhyZXF1ZXN0LCAvLyAkRmxvd0ZpeE1lOiBSZWZpbmVkLlxuICAgIHRhc2spO1xuICB9IGVsc2Uge1xuICAgIHJldHJ5UmVuZGVyVGFzayhyZXF1ZXN0LCAvLyAkRmxvd0ZpeE1lOiBSZWZpbmVkLlxuICAgIHRhc2ssIHNlZ21lbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJldHJ5UmVuZGVyVGFzayhyZXF1ZXN0LCB0YXNrLCBzZWdtZW50KSB7XG4gIGlmIChzZWdtZW50LnN0YXR1cyAhPT0gUEVORElORykge1xuICAgIC8vIFdlIGNvbXBsZXRlZCB0aGlzIGJ5IG90aGVyIG1lYW5zIGJlZm9yZSB3ZSBoYWQgYSBjaGFuY2UgdG8gcmV0cnkgaXQuXG4gICAgcmV0dXJuO1xuICB9IC8vIFdlIHJlc3RvcmUgdGhlIGNvbnRleHQgdG8gd2hhdCBpdCB3YXMgd2hlbiB3ZSBzdXNwZW5kZWQuXG4gIC8vIFdlIGRvbid0IHJlc3RvcmUgaXQgYWZ0ZXIgd2UgbGVhdmUgYmVjYXVzZSBpdCdzIGxpa2VseSB0aGF0IHdlJ2xsIGVuZCB1cFxuICAvLyBuZWVkaW5nIGEgdmVyeSBzaW1pbGFyIGNvbnRleHQgc29vbiBhZ2Fpbi5cblxuXG4gIHN3aXRjaENvbnRleHQodGFzay5jb250ZXh0KTtcbiAgdmFyIHByZXZUYXNrSW5ERVYgPSBudWxsO1xuXG4gIHtcbiAgICBwcmV2VGFza0luREVWID0gY3VycmVudFRhc2tJbkRFVjtcbiAgICBjdXJyZW50VGFza0luREVWID0gdGFzaztcbiAgfVxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICB2YXIgY2h1bmtMZW5ndGggPSBzZWdtZW50LmNodW5rcy5sZW5ndGg7XG5cbiAgdHJ5IHtcbiAgICAvLyBXZSBjYWxsIHRoZSBkZXN0cnVjdGl2ZSBmb3JtIHRoYXQgbXV0YXRlcyB0aGlzIHRhc2suIFRoYXQgd2F5IGlmIHNvbWV0aGluZ1xuICAgIC8vIHN1c3BlbmRzIGFnYWluLCB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdGFzayBpbnN0ZWFkIG9mIHNwYXduaW5nIGEgbmV3IG9uZS5cbiAgICAvLyBSZXNldCB0aGUgdGFzaydzIHRoZW5hYmxlIHN0YXRlIGJlZm9yZSBjb250aW51aW5nLCBzbyB0aGF0IGlmIGEgbGF0ZXJcbiAgICAvLyBjb21wb25lbnQgc3VzcGVuZHMgd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRhc2sgb2JqZWN0LiBJZiB0aGUgc2FtZVxuICAgIC8vIGNvbXBvbmVudCBzdXNwZW5kcyBhZ2FpbiwgdGhlIHRoZW5hYmxlIHN0YXRlIHdpbGwgYmUgcmVzdG9yZWQuXG4gICAgdmFyIHByZXZUaGVuYWJsZVN0YXRlID0gdGFzay50aGVuYWJsZVN0YXRlO1xuICAgIHRhc2sudGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCB0YXNrLm5vZGUsIHRhc2suY2hpbGRJbmRleCk7XG4gICAgcHVzaFNlZ21lbnRGaW5hbGUoc2VnbWVudC5jaHVua3MsIHJlcXVlc3QucmVuZGVyU3RhdGUsIHNlZ21lbnQubGFzdFB1c2hlZFRleHQsIHNlZ21lbnQudGV4dEVtYmVkZGVkKTtcbiAgICB0YXNrLmFib3J0U2V0LmRlbGV0ZSh0YXNrKTtcbiAgICBzZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRDtcbiAgICBmaW5pc2hlZFRhc2socmVxdWVzdCwgdGFzay5ibG9ja2VkQm91bmRhcnksIHNlZ21lbnQpO1xuICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgIHJlc2V0SG9va3NTdGF0ZSgpOyAvLyBSZXNldCB0aGUgd3JpdGUgcG9pbnRlcnMgdG8gd2hlcmUgd2Ugc3RhcnRlZC5cblxuICAgIHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoID0gY2hpbGRyZW5MZW5ndGg7XG4gICAgc2VnbWVudC5jaHVua3MubGVuZ3RoID0gY2h1bmtMZW5ndGg7XG4gICAgdmFyIHggPSB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24gPyAvLyBUaGlzIGlzIGEgc3BlY2lhbCB0eXBlIG9mIGV4Y2VwdGlvbiB1c2VkIGZvciBTdXNwZW5zZS4gRm9yIGhpc3RvcmljYWxcbiAgICAvLyByZWFzb25zLCB0aGUgcmVzdCBvZiB0aGUgU3VzcGVuc2UgaW1wbGVtZW50YXRpb24gZXhwZWN0cyB0aGUgdGhyb3duXG4gICAgLy8gdmFsdWUgdG8gYmUgYSB0aGVuYWJsZSwgYmVjYXVzZSBiZWZvcmUgYHVzZWAgZXhpc3RlZCB0aGF0IHdhcyB0aGVcbiAgICAvLyAodW5zdGFibGUpIEFQSSBmb3Igc3VzcGVuZGluZy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgY2FuIGNoYW5nZVxuICAgIC8vIGxhdGVyLCBvbmNlIHdlIGRlcHJlY2F0ZSB0aGUgb2xkIEFQSSBpbiBmYXZvciBvZiBgdXNlYC5cbiAgICBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpIDogdGhyb3duVmFsdWU7XG5cbiAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICAgIGlmICh0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQgYWdhaW4sIGxldCdzIHBpY2sgaXQgYmFjayB1cCBsYXRlci5cbiAgICAgICAgdmFyIHBpbmcgPSB0YXNrLnBpbmc7XG4gICAgICAgIHgudGhlbihwaW5nLCBwaW5nKTtcbiAgICAgICAgdGFzay50aGVuYWJsZVN0YXRlID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVycm9ySW5mbyA9IGdldFRocm93bkluZm8ocmVxdWVzdCwgdGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgdGFzay5hYm9ydFNldC5kZWxldGUodGFzayk7XG4gICAgc2VnbWVudC5zdGF0dXMgPSBFUlJPUkVEO1xuICAgIGVycm9yZWRUYXNrKHJlcXVlc3QsIHRhc2suYmxvY2tlZEJvdW5kYXJ5LCB4LCBlcnJvckluZm8pO1xuICAgIHJldHVybjtcbiAgfSBmaW5hbGx5IHtcbiAgICB7XG4gICAgICBzZXRDdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeVJlc291cmNlc1RhcmdldChyZXF1ZXN0LnJlbmRlclN0YXRlLCBudWxsKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBjdXJyZW50VGFza0luREVWID0gcHJldlRhc2tJbkRFVjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cnlSZXBsYXlUYXNrKHJlcXVlc3QsIHRhc2spIHtcbiAgaWYgKHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcyA9PT0gMCkge1xuICAgIC8vIFRoZXJlIGFyZSBubyBwZW5kaW5nIHRhc2tzIHdvcmtpbmcgb24gdGhpcyBzZXQsIHNvIHdlIG11c3QgaGF2ZSBhYm9ydGVkLlxuICAgIHJldHVybjtcbiAgfSAvLyBXZSByZXN0b3JlIHRoZSBjb250ZXh0IHRvIHdoYXQgaXQgd2FzIHdoZW4gd2Ugc3VzcGVuZGVkLlxuICAvLyBXZSBkb24ndCByZXN0b3JlIGl0IGFmdGVyIHdlIGxlYXZlIGJlY2F1c2UgaXQncyBsaWtlbHkgdGhhdCB3ZSdsbCBlbmQgdXBcbiAgLy8gbmVlZGluZyBhIHZlcnkgc2ltaWxhciBjb250ZXh0IHNvb24gYWdhaW4uXG5cblxuICBzd2l0Y2hDb250ZXh0KHRhc2suY29udGV4dCk7XG4gIHZhciBwcmV2VGFza0luREVWID0gbnVsbDtcblxuICB7XG4gICAgcHJldlRhc2tJbkRFViA9IGN1cnJlbnRUYXNrSW5ERVY7XG4gICAgY3VycmVudFRhc2tJbkRFViA9IHRhc2s7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFdlIGNhbGwgdGhlIGRlc3RydWN0aXZlIGZvcm0gdGhhdCBtdXRhdGVzIHRoaXMgdGFzay4gVGhhdCB3YXkgaWYgc29tZXRoaW5nXG4gICAgLy8gc3VzcGVuZHMgYWdhaW4sIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0YXNrIGluc3RlYWQgb2Ygc3Bhd25pbmcgYSBuZXcgb25lLlxuICAgIC8vIFJlc2V0IHRoZSB0YXNrJ3MgdGhlbmFibGUgc3RhdGUgYmVmb3JlIGNvbnRpbnVpbmcsIHNvIHRoYXQgaWYgYSBsYXRlclxuICAgIC8vIGNvbXBvbmVudCBzdXNwZW5kcyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdGFzayBvYmplY3QuIElmIHRoZSBzYW1lXG4gICAgLy8gY29tcG9uZW50IHN1c3BlbmRzIGFnYWluLCB0aGUgdGhlbmFibGUgc3RhdGUgd2lsbCBiZSByZXN0b3JlZC5cbiAgICB2YXIgcHJldlRoZW5hYmxlU3RhdGUgPSB0YXNrLnRoZW5hYmxlU3RhdGU7XG4gICAgdGFzay50aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgcHJldlRoZW5hYmxlU3RhdGUsIHRhc2subm9kZSwgdGFzay5jaGlsZEluZGV4KTtcblxuICAgIGlmICh0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MgPT09IDEgJiYgdGFzay5yZXBsYXkubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBcIiArIFwiVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCIpO1xuICAgIH1cblxuICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgIHRhc2suYWJvcnRTZXQuZGVsZXRlKHRhc2spO1xuICAgIGZpbmlzaGVkVGFzayhyZXF1ZXN0LCB0YXNrLmJsb2NrZWRCb3VuZGFyeSwgbnVsbCk7XG4gIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgcmVzZXRIb29rc1N0YXRlKCk7XG4gICAgdmFyIHggPSB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24gPyAvLyBUaGlzIGlzIGEgc3BlY2lhbCB0eXBlIG9mIGV4Y2VwdGlvbiB1c2VkIGZvciBTdXNwZW5zZS4gRm9yIGhpc3RvcmljYWxcbiAgICAvLyByZWFzb25zLCB0aGUgcmVzdCBvZiB0aGUgU3VzcGVuc2UgaW1wbGVtZW50YXRpb24gZXhwZWN0cyB0aGUgdGhyb3duXG4gICAgLy8gdmFsdWUgdG8gYmUgYSB0aGVuYWJsZSwgYmVjYXVzZSBiZWZvcmUgYHVzZWAgZXhpc3RlZCB0aGF0IHdhcyB0aGVcbiAgICAvLyAodW5zdGFibGUpIEFQSSBmb3Igc3VzcGVuZGluZy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgY2FuIGNoYW5nZVxuICAgIC8vIGxhdGVyLCBvbmNlIHdlIGRlcHJlY2F0ZSB0aGUgb2xkIEFQSSBpbiBmYXZvciBvZiBgdXNlYC5cbiAgICBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpIDogdGhyb3duVmFsdWU7XG5cbiAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICAgIGlmICh0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQgYWdhaW4sIGxldCdzIHBpY2sgaXQgYmFjayB1cCBsYXRlci5cbiAgICAgICAgdmFyIHBpbmcgPSB0YXNrLnBpbmc7XG4gICAgICAgIHgudGhlbihwaW5nLCBwaW5nKTtcbiAgICAgICAgdGFzay50aGVuYWJsZVN0YXRlID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgdGFzay5hYm9ydFNldC5kZWxldGUodGFzayk7XG4gICAgdmFyIGVycm9ySW5mbyA9IGdldFRocm93bkluZm8ocmVxdWVzdCwgdGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgZXJyb3JlZFJlcGxheShyZXF1ZXN0LCB0YXNrLmJsb2NrZWRCb3VuZGFyeSwgeCwgZXJyb3JJbmZvLCB0YXNrLnJlcGxheS5ub2RlcywgdGFzay5yZXBsYXkuc2xvdHMpO1xuICAgIHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcy0tO1xuXG4gICAgaWYgKHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyA9PT0gMCkge1xuICAgICAgY29tcGxldGVTaGVsbChyZXF1ZXN0KTtcbiAgICB9XG5cbiAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcy0tO1xuXG4gICAgaWYgKHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzID09PSAwKSB7XG4gICAgICBjb21wbGV0ZUFsbChyZXF1ZXN0KTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0gZmluYWxseSB7XG4gICAge1xuICAgICAgc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVxdWVzdC5yZW5kZXJTdGF0ZSwgbnVsbCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgY3VycmVudFRhc2tJbkRFViA9IHByZXZUYXNrSW5ERVY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Xb3JrKHJlcXVlc3QpIHtcbiAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSBDTE9TRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcHJldkNvbnRleHQgPSBnZXRBY3RpdmVDb250ZXh0KCk7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gSG9va3NEaXNwYXRjaGVyO1xuICB2YXIgcHJldkNhY2hlRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldkNhY2hlRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudENhY2hlLmN1cnJlbnQ7XG4gICAgUmVhY3RDdXJyZW50Q2FjaGUuY3VycmVudCA9IERlZmF1bHRDYWNoZURpc3BhdGNoZXI7XG4gIH1cblxuICB2YXIgcHJldlJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdDtcbiAgY3VycmVudFJlcXVlc3QgPSByZXF1ZXN0O1xuICB2YXIgcHJldkdldEN1cnJlbnRTdGFja0ltcGw7XG5cbiAge1xuICAgIHByZXZHZXRDdXJyZW50U3RhY2tJbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50U3RhY2tJbkRFVjtcbiAgfVxuXG4gIHZhciBwcmV2UmVzdW1hYmxlU3RhdGUgPSBjdXJyZW50UmVzdW1hYmxlU3RhdGU7XG4gIHNldEN1cnJlbnRSZXN1bWFibGVTdGF0ZShyZXF1ZXN0LnJlc3VtYWJsZVN0YXRlKTtcblxuICB0cnkge1xuICAgIHZhciBwaW5nZWRUYXNrcyA9IHJlcXVlc3QucGluZ2VkVGFza3M7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcGluZ2VkVGFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0YXNrID0gcGluZ2VkVGFza3NbaV07XG4gICAgICByZXRyeVRhc2socmVxdWVzdCwgdGFzayk7XG4gICAgfVxuXG4gICAgcGluZ2VkVGFza3Muc3BsaWNlKDAsIGkpO1xuXG4gICAgaWYgKHJlcXVlc3QuZGVzdGluYXRpb24gIT09IG51bGwpIHtcbiAgICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIHJlcXVlc3QuZGVzdGluYXRpb24pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB2YXIgZXJyb3JJbmZvID0ge307XG4gICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgZXJyb3JJbmZvKTtcbiAgICBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50UmVzdW1hYmxlU3RhdGUocHJldlJlc3VtYWJsZVN0YXRlKTtcbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudENhY2hlLmN1cnJlbnQgPSBwcmV2Q2FjaGVEaXNwYXRjaGVyO1xuICAgIH1cblxuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFja0ltcGw7XG4gICAgfVxuXG4gICAgaWYgKHByZXZEaXNwYXRjaGVyID09PSBIb29rc0Rpc3BhdGNoZXIpIHtcbiAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB3ZSB3ZXJlIGluIGEgcmVlbnRyYW50IHdvcmsgbG9vcC4gVGhpcyBjb3VsZCBoYXBwZW5cbiAgICAgIC8vIGluIGEgcmVuZGVyZXIgdGhhdCBzdXBwb3J0cyBzeW5jaHJvbm91cyB3b3JrIGxpa2UgcmVuZGVyVG9TdHJpbmcsXG4gICAgICAvLyB3aGVuIGl0J3MgY2FsbGVkIGZyb20gd2l0aGluIGFub3RoZXIgcmVuZGVyZXIuXG4gICAgICAvLyBOb3JtYWxseSB3ZSBkb24ndCBib3RoZXIgc3dpdGNoaW5nIHRoZSBjb250ZXh0cyB0byB0aGVpciByb290L2RlZmF1bHRcbiAgICAgIC8vIHZhbHVlcyB3aGVuIGxlYXZpbmcgYmVjYXVzZSB3ZSdsbCBsaWtlbHkgbmVlZCB0aGUgc2FtZSBvciBzaW1pbGFyXG4gICAgICAvLyBjb250ZXh0IGFnYWluLiBIb3dldmVyLCB3aGVuIHdlJ3JlIGluc2lkZSBhIHN5bmNocm9ub3VzIGxvb3AgbGlrZSB0aGlzXG4gICAgICAvLyB3ZSdsbCB0byByZXN0b3JlIHRoZSBjb250ZXh0IHRvIHdoYXQgaXQgd2FzIGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICBzd2l0Y2hDb250ZXh0KHByZXZDb250ZXh0KTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVxdWVzdCA9IHByZXZSZXF1ZXN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCkge1xuICBzZWdtZW50LnBhcmVudEZsdXNoZWQgPSB0cnVlO1xuXG4gIHN3aXRjaCAoc2VnbWVudC5zdGF0dXMpIHtcbiAgICBjYXNlIFBFTkRJTkc6XG4gICAgICB7XG4gICAgICAgIC8vIFdlJ3JlIGVtaXR0aW5nIGEgcGxhY2Vob2xkZXIgZm9yIHRoaXMgc2VnbWVudCB0byBiZSBmaWxsZWQgaW4gbGF0ZXIuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSdsbCBuZWVkIHRvIGFzc2lnbiBpdCBhbiBJRCAtIHRvIHJlZmVyIHRvIGl0IGJ5LlxuICAgICAgICBzZWdtZW50LmlkID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKys7IC8vIEZhbGx0aHJvdWdoXG4gICAgICB9XG5cbiAgICBjYXNlIFBPU1RQT05FRDpcbiAgICAgIHtcbiAgICAgICAgdmFyIHNlZ21lbnRJRCA9IHNlZ21lbnQuaWQ7IC8vIFdoZW4gdGhpcyBzZWdtZW50IGZpbmFsbHkgY29tcGxldGVzIGl0IHdvbid0IGJlIGVtYmVkZGVkIGluIHRleHQgc2luY2UgaXQgd2lsbCBmbHVzaCBzZXBhcmF0ZWx5XG5cbiAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9IGZhbHNlO1xuICAgICAgICBzZWdtZW50LnRleHRFbWJlZGRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gd3JpdGVQbGFjZWhvbGRlcihkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgc2VnbWVudElEKTtcbiAgICAgIH1cblxuICAgIGNhc2UgQ09NUExFVEVEOlxuICAgICAge1xuICAgICAgICBzZWdtZW50LnN0YXR1cyA9IEZMVVNIRUQ7XG4gICAgICAgIHZhciByID0gdHJ1ZTtcbiAgICAgICAgdmFyIGNodW5rcyA9IHNlZ21lbnQuY2h1bmtzO1xuICAgICAgICB2YXIgY2h1bmtJZHggPSAwO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBzZWdtZW50LmNoaWxkcmVuO1xuXG4gICAgICAgIGZvciAodmFyIGNoaWxkSWR4ID0gMDsgY2hpbGRJZHggPCBjaGlsZHJlbi5sZW5ndGg7IGNoaWxkSWR4KyspIHtcbiAgICAgICAgICB2YXIgbmV4dENoaWxkID0gY2hpbGRyZW5bY2hpbGRJZHhdOyAvLyBXcml0ZSBhbGwgdGhlIGNodW5rcyB1cCB1bnRpbCB0aGUgbmV4dCBjaGlsZC5cblxuICAgICAgICAgIGZvciAoOyBjaHVua0lkeCA8IG5leHRDaGlsZC5pbmRleDsgY2h1bmtJZHgrKykge1xuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmtzW2NodW5rSWR4XSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgciA9IGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgbmV4dENoaWxkKTtcbiAgICAgICAgfSAvLyBGaW5hbGx5IGp1c3Qgd3JpdGUgYWxsIHRoZSByZW1haW5pbmcgY2h1bmtzXG5cblxuICAgICAgICBmb3IgKDsgY2h1bmtJZHggPCBjaHVua3MubGVuZ3RoIC0gMTsgY2h1bmtJZHgrKykge1xuICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNodW5rc1tjaHVua0lkeF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNodW5rSWR4IDwgY2h1bmtzLmxlbmd0aCkge1xuICAgICAgICAgIHIgPSB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjaHVua3NbY2h1bmtJZHhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGVkLCBlcnJvcmVkIG9yIGFscmVhZHkgZmx1c2hlZCBib3VuZGFyaWVzIHNob3VsZCBub3QgYmUgZmx1c2hlZCBhZ2Fpbi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpIHtcbiAgdmFyIGJvdW5kYXJ5ID0gc2VnbWVudC5ib3VuZGFyeTtcblxuICBpZiAoYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICAvLyBOb3QgYSBzdXNwZW5zZSBib3VuZGFyeS5cbiAgICByZXR1cm4gZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgfVxuXG4gIGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgPSB0cnVlOyAvLyBUaGlzIHNlZ21lbnQgaXMgYSBTdXNwZW5zZSBib3VuZGFyeS4gV2UgbmVlZCB0byBkZWNpZGUgd2hldGhlciB0b1xuICAvLyBlbWl0IHRoZSBjb250ZW50IG9yIHRoZSBmYWxsYmFjayBub3cuXG5cbiAgaWYgKGJvdW5kYXJ5LnN0YXR1cyA9PT0gQ0xJRU5UX1JFTkRFUkVEKSB7XG4gICAgLy8gRW1pdCBhIGNsaWVudCByZW5kZXJlZCBzdXNwZW5zZSBib3VuZGFyeSB3cmFwcGVyLlxuICAgIC8vIFdlIG5ldmVyIHF1ZXVlIHRoZSBpbm5lciBib3VuZGFyeSBzbyB3ZSdsbCBuZXZlciBlbWl0IGl0cyBjb250ZW50IG9yIHBhcnRpYWwgc2VnbWVudHMuXG4gICAgd3JpdGVTdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgYm91bmRhcnkuZXJyb3JEaWdlc3QsIGJvdW5kYXJ5LmVycm9yTWVzc2FnZSwgYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjayk7IC8vIEZsdXNoIHRoZSBmYWxsYmFjay5cblxuICAgIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlRW5kQ2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlbmRlclN0YXRlKTtcbiAgfSBlbHNlIGlmIChib3VuZGFyeS5zdGF0dXMgIT09IENPTVBMRVRFRCkge1xuICAgIGlmIChib3VuZGFyeS5zdGF0dXMgPT09IFBFTkRJTkcpIHtcbiAgICAgIC8vIEZvciBwZW5kaW5nIGJvdW5kYXJpZXMgd2UgbGF6aWx5IGFzc2lnbiBhbiBJRCB0byB0aGUgYm91bmRhcnlcbiAgICAgIC8vIGFuZCByb290IHNlZ21lbnQuXG4gICAgICBib3VuZGFyeS5yb290U2VnbWVudElEID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKys7XG4gICAgfVxuXG4gICAgaWYgKGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYXQgbGVhc3QgcGFydGlhbGx5IGNvbXBsZXRlLCB3ZSBjYW4gcXVldWUgaXQgdG8gYmUgcGFydGlhbGx5IGVtaXR0ZWQgZWFybHkuXG4gICAgICByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpO1xuICAgIH0gLy8gVGhpcyBib3VuZGFyeSBpcyBzdGlsbCBsb2FkaW5nLiBFbWl0IGEgcGVuZGluZyBzdXNwZW5zZSBib3VuZGFyeSB3cmFwcGVyLlxuXG5cbiAgICB2YXIgaWQgPSBib3VuZGFyeS5yb290U2VnbWVudElEO1xuICAgIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgaWQpOyAvLyBGbHVzaCB0aGUgZmFsbGJhY2suXG5cbiAgICBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpO1xuICAgIHJldHVybiB3cml0ZUVuZFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uKTtcbiAgfSBlbHNlIGlmIChib3VuZGFyeS5ieXRlU2l6ZSA+IHJlcXVlc3QucHJvZ3Jlc3NpdmVDaHVua1NpemUpIHtcbiAgICAvLyBUaGlzIGJvdW5kYXJ5IGlzIGxhcmdlIGFuZCB3aWxsIGJlIGVtaXR0ZWQgc2VwYXJhdGVseSBzbyB0aGF0IHdlIGNhbiBwcm9ncmVzc2l2ZWx5IHNob3dcbiAgICAvLyBvdGhlciBjb250ZW50LiBXZSBhZGQgaXQgdG8gdGhlIHF1ZXVlIGR1cmluZyB0aGUgZmx1c2ggYmVjYXVzZSB3ZSBoYXZlIHRvIGVuc3VyZSB0aGF0XG4gICAgLy8gdGhlIHBhcmVudCBmbHVzaGVzIGZpcnN0IHNvIHRoYXQgdGhlcmUncyBzb21ldGhpbmcgdG8gaW5qZWN0IGl0IGludG8uXG4gICAgLy8gV2UgYWxzbyBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3MgZW1pdHRlZCBpbnRvIHRoZSBxdWV1ZSBpbiBhIGRldGVybWluaXN0aWMgc2xvdC5cbiAgICAvLyBJLmUuIHdlIGNhbid0IGluc2VydCBpdCBoZXJlIHdoZW4gaXQgY29tcGxldGVzLlxuICAgIC8vIEFzc2lnbiBhbiBJRCB0byByZWZlciB0byB0aGUgZnV0dXJlIGNvbnRlbnQgYnkuXG4gICAgYm91bmRhcnkucm9vdFNlZ21lbnRJRCA9IHJlcXVlc3QubmV4dFNlZ21lbnRJZCsrO1xuICAgIHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KTsgLy8gRW1pdCBhIHBlbmRpbmcgcmVuZGVyZWQgc3VzcGVuc2UgYm91bmRhcnkgd3JhcHBlci5cblxuICAgIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgYm91bmRhcnkucm9vdFNlZ21lbnRJRCk7IC8vIEZsdXNoIHRoZSBmYWxsYmFjay5cblxuICAgIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlRW5kUGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24pO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGhvaXN0UmVzb3VyY2VzKHJlcXVlc3QucmVuZGVyU3RhdGUsIGJvdW5kYXJ5LnJlc291cmNlcyk7XG4gICAgfSAvLyBXZSBjYW4gaW5saW5lIHRoaXMgYm91bmRhcnkncyBjb250ZW50IGFzIGEgY29tcGxldGUgYm91bmRhcnkuXG5cblxuICAgIHdyaXRlU3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlbmRlclN0YXRlKTtcbiAgICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcblxuICAgIGlmIChjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSBwcmV2aW91c2x5IHVudmlzaXRlZCBib3VuZGFyeSBtdXN0IGhhdmUgZXhhY3RseSBvbmUgcm9vdCBzZWdtZW50LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cblxuICAgIHZhciBjb250ZW50U2VnbWVudCA9IGNvbXBsZXRlZFNlZ21lbnRzWzBdO1xuICAgIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgY29udGVudFNlZ21lbnQpO1xuICAgIHJldHVybiB3cml0ZUVuZENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlcXVlc3QucmVuZGVyU3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoQ2xpZW50UmVuZGVyZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnkpIHtcbiAgcmV0dXJuIHdyaXRlQ2xpZW50UmVuZGVyQm91bmRhcnlJbnN0cnVjdGlvbihkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgYm91bmRhcnkucm9vdFNlZ21lbnRJRCwgYm91bmRhcnkuZXJyb3JEaWdlc3QsIGJvdW5kYXJ5LmVycm9yTWVzc2FnZSwgYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjayk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoU2VnbWVudENvbnRhaW5lcihyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCkge1xuICB3cml0ZVN0YXJ0U2VnbWVudChkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgc2VnbWVudC5wYXJlbnRGb3JtYXRDb250ZXh0LCBzZWdtZW50LmlkKTtcbiAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgcmV0dXJuIHdyaXRlRW5kU2VnbWVudChkZXN0aW5hdGlvbiwgc2VnbWVudC5wYXJlbnRGb3JtYXRDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnkpIHtcbiAge1xuICAgIHNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0KHJlcXVlc3QucmVuZGVyU3RhdGUsIGJvdW5kYXJ5LnJlc291cmNlcyk7XG4gIH1cblxuICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgY29tcGxldGVkU2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IGNvbXBsZXRlZFNlZ21lbnRzW2ldO1xuICAgIGZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnksIHNlZ21lbnQpO1xuICB9XG5cbiAgY29tcGxldGVkU2VnbWVudHMubGVuZ3RoID0gMDtcblxuICB7XG4gICAgd3JpdGVSZXNvdXJjZXNGb3JCb3VuZGFyeShkZXN0aW5hdGlvbiwgYm91bmRhcnkucmVzb3VyY2VzLCByZXF1ZXN0LnJlbmRlclN0YXRlKTtcbiAgfVxuXG4gIHJldHVybiB3cml0ZUNvbXBsZXRlZEJvdW5kYXJ5SW5zdHJ1Y3Rpb24oZGVzdGluYXRpb24sIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsIHJlcXVlc3QucmVuZGVyU3RhdGUsIGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQsIGJvdW5kYXJ5LnJlc291cmNlcyk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFydGlhbEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSkge1xuICB7XG4gICAgc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVxdWVzdC5yZW5kZXJTdGF0ZSwgYm91bmRhcnkucmVzb3VyY2VzKTtcbiAgfVxuXG4gIHZhciBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzO1xuICB2YXIgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gY29tcGxldGVkU2VnbWVudHNbaV07XG5cbiAgICBpZiAoIWZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnksIHNlZ21lbnQpKSB7XG4gICAgICBpKys7XG4gICAgICBjb21wbGV0ZWRTZWdtZW50cy5zcGxpY2UoMCwgaSk7IC8vIE9ubHkgd3JpdGUgYXMgbXVjaCBhcyB0aGUgYnVmZmVyIHdhbnRzLiBTb21ldGhpbmcgaGlnaGVyIHByaW9yaXR5XG4gICAgICAvLyBtaWdodCB3YW50IHRvIHdyaXRlIGxhdGVyLlxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgY29tcGxldGVkU2VnbWVudHMuc3BsaWNlKDAsIGkpO1xuXG4gIHtcbiAgICAvLyBUaGUgd2F5IHRoaXMgaXMgc3RydWN0dXJlZCB3ZSBvbmx5IHdyaXRlIHJlc291cmNlcyBmb3IgcGFydGlhbCBib3VuZGFyaWVzXG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gYmFja3ByZXNzdXJlLiBMYXRlciBiZWZvcmUgd2UgY29tcGxldGUgdGhlIGJvdW5kYXJ5IHdlXG4gICAgLy8gd2lsbCB3cml0ZSByZXNvdXJjZXMgcmVnYXJkbGVzcyBvZiBiYWNrcHJlc3N1cmUgYmVmb3JlIHdlIGVtaXQgdGhlXG4gICAgLy8gY29tcGxldGlvbiBpbnN0cnVjdGlvblxuICAgIHJldHVybiB3cml0ZVJlc291cmNlc0ZvckJvdW5kYXJ5KGRlc3RpbmF0aW9uLCBib3VuZGFyeS5yZXNvdXJjZXMsIHJlcXVlc3QucmVuZGVyU3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnksIHNlZ21lbnQpIHtcbiAgaWYgKHNlZ21lbnQuc3RhdHVzID09PSBGTFVTSEVEKSB7XG4gICAgLy8gV2UndmUgYWxyZWFkeSBmbHVzaGVkIHRoaXMgaW5saW5lLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHNlZ21lbnRJRCA9IHNlZ21lbnQuaWQ7XG5cbiAgaWYgKHNlZ21lbnRJRCA9PT0gLTEpIHtcbiAgICAvLyBUaGlzIHNlZ21lbnQgd2Fzbid0IHByZXZpb3VzbHkgcmVmZXJyZWQgdG8uIFRoaXMgaGFwcGVucyBhdCB0aGUgcm9vdCBvZlxuICAgIC8vIGEgYm91bmRhcnkuIFdlIG1ha2Uga2luZCBvZiBhIGxlYXAgaGVyZSBhbmQgYXNzdW1lIHRoaXMgaXMgdGhlIHJvb3QuXG4gICAgdmFyIHJvb3RTZWdtZW50SUQgPSBzZWdtZW50LmlkID0gYm91bmRhcnkucm9vdFNlZ21lbnRJRDtcblxuICAgIGlmIChyb290U2VnbWVudElEID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHJvb3Qgc2VnbWVudCBJRCBtdXN0IGhhdmUgYmVlbiBhc3NpZ25lZCBieSBub3cuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZsdXNoU2VnbWVudENvbnRhaW5lcihyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gIH0gZWxzZSBpZiAoc2VnbWVudElEID09PSBib3VuZGFyeS5yb290U2VnbWVudElEKSB7XG4gICAgLy8gV2hlbiB3ZSBlbWl0IHBvc3Rwb25lZCBib3VuZGFyaWVzLCB3ZSBtaWdodCBoYXZlIGFzc2lnbmVkIHRoZSBJRCBhbHJlYWR5XG4gICAgLy8gYnV0IGl0J3Mgc3RpbGwgdGhlIHJvb3Qgc2VnbWVudCBzbyB3ZSBjYW4ndCBpbmplY3QgaXQgaW50byB0aGUgcGFyZW50IHlldC5cbiAgICByZXR1cm4gZmx1c2hTZWdtZW50Q29udGFpbmVyKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBmbHVzaFNlZ21lbnRDb250YWluZXIocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpO1xuICAgIHJldHVybiB3cml0ZUNvbXBsZXRlZFNlZ21lbnRJbnN0cnVjdGlvbihkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgc2VnbWVudElEKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbikge1xuXG4gIHRyeSB7XG4gICAgLy8gVGhlIHN0cnVjdHVyZSBvZiB0aGlzIGlzIHRvIGdvIHRocm91Z2ggZWFjaCBxdWV1ZSBvbmUgYnkgb25lIGFuZCB3cml0ZVxuICAgIC8vIHVudGlsIHRoZSBzaW5rIHRlbGxzIHVzIHRvIHN0b3AuIFdoZW4gd2Ugc2hvdWxkIHN0b3AsIHdlIHN0aWxsIGZpbmlzaCB3cml0aW5nXG4gICAgLy8gdGhhdCBpdGVtIGZ1bGx5IGFuZCB0aGVuIHlpZWxkLiBBdCB0aGF0IHBvaW50IHdlIHJlbW92ZSB0aGUgYWxyZWFkeSBjb21wbGV0ZWRcbiAgICAvLyBpdGVtcyB1cCB1bnRpbCB0aGUgcG9pbnQgd2UgY29tcGxldGVkIHRoZW0uXG4gICAgdmFyIGk7XG4gICAgdmFyIGNvbXBsZXRlZFJvb3RTZWdtZW50ID0gcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudDtcblxuICAgIGlmIChjb21wbGV0ZWRSb290U2VnbWVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNvbXBsZXRlZFJvb3RTZWdtZW50LnN0YXR1cyA9PT0gUE9TVFBPTkVEKSB7XG4gICAgICAgIC8vIFdlIHBvc3Rwb25lZCB0aGUgcm9vdCwgc28gd2Ugd3JpdGUgbm90aGluZy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgPT09IDApIHtcbiAgICAgICAgaWYgKGVuYWJsZUZsb2F0KSB7XG4gICAgICAgICAgd3JpdGVQcmVhbWJsZShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDAgJiYgcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzID09PSBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgY29tcGxldGVkUm9vdFNlZ21lbnQpO1xuICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ID0gbnVsbDtcbiAgICAgICAgd3JpdGVDb21wbGV0ZWRSb290KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlbmRlclN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIGhhdmVuJ3QgZmx1c2hlZCB0aGUgcm9vdCB5ZXQgc28gd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBhbnkgb3RoZXIgYnJhbmNoZXMgZnVydGhlciBkb3duXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW5hYmxlRmxvYXQpIHtcbiAgICAgIHdyaXRlSG9pc3RhYmxlcyhkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSwgcmVxdWVzdC5yZW5kZXJTdGF0ZSk7XG4gICAgfSAvLyBXZSBlbWl0IGNsaWVudCByZW5kZXJpbmcgaW5zdHJ1Y3Rpb25zIGZvciBhbHJlYWR5IGVtaXR0ZWQgYm91bmRhcmllcyBmaXJzdC5cbiAgICAvLyBUaGlzIGlzIHNvIHRoYXQgd2UgY2FuIHNpZ25hbCB0byB0aGUgY2xpZW50IHRvIHN0YXJ0IGNsaWVudCByZW5kZXJpbmcgdGhlbSBhc1xuICAgIC8vIHNvb24gYXMgcG9zc2libGUuXG5cblxuICAgIHZhciBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMgPSByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBib3VuZGFyeSA9IGNsaWVudFJlbmRlcmVkQm91bmRhcmllc1tpXTtcblxuICAgICAgaWYgKCFmbHVzaENsaWVudFJlbmRlcmVkQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5KSkge1xuICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgaSsrO1xuICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTsgLy8gTmV4dCB3ZSBlbWl0IGFueSBjb21wbGV0ZSBib3VuZGFyaWVzLiBJdCdzIGJldHRlciB0byBmYXZvciBib3VuZGFyaWVzXG4gICAgLy8gdGhhdCBhcmUgY29tcGxldGVseSBkb25lIHNpbmNlIHdlIGNhbiBhY3R1YWxseSBzaG93IHRoZW0sIHRoYW4gaXQgaXMgdG8gZW1pdFxuICAgIC8vIGFueSBpbmRpdmlkdWFsIHNlZ21lbnRzIGZyb20gYSBwYXJ0aWFsbHkgY29tcGxldGUgYm91bmRhcnkuXG5cbiAgICB2YXIgY29tcGxldGVkQm91bmRhcmllcyA9IHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb21wbGV0ZWRCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2JvdW5kYXJ5ID0gY29tcGxldGVkQm91bmRhcmllc1tpXTtcblxuICAgICAgaWYgKCFmbHVzaENvbXBsZXRlZEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBfYm91bmRhcnkpKSB7XG4gICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbXBsZXRlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcGxldGVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7IC8vIEFsbG93IGFueXRoaW5nIHdyaXR0ZW4gc28gZmFyIHRvIGZsdXNoIHRvIHRoZSB1bmRlcmx5aW5nIHNpbmsgYmVmb3JlXG4gICAgLy8gd2UgY29udGludWUgd2l0aCBsb3dlciBwcmlvcml0aWVzLlxuXG4gICAgY29tcGxldGVXcml0aW5nKGRlc3RpbmF0aW9uKTtcbiAgICBiZWdpbldyaXRpbmcoZGVzdGluYXRpb24pOyAvLyBUT0RPOiBIZXJlIHdlJ2xsIGVtaXQgZGF0YSB1c2VkIGJ5IGh5ZHJhdGlvbi5cbiAgICAvLyBOZXh0IHdlIGVtaXQgYW55IHNlZ21lbnRzIG9mIGFueSBib3VuZGFyaWVzIHRoYXQgYXJlIHBhcnRpYWxseSBjb21wbGV0ZVxuICAgIC8vIGJ1dCBub3QgZGVlcGx5IGNvbXBsZXRlLlxuXG4gICAgdmFyIHBhcnRpYWxCb3VuZGFyaWVzID0gcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0aWFsQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9ib3VuZGFyeTIgPSBwYXJ0aWFsQm91bmRhcmllc1tpXTtcblxuICAgICAgaWYgKCFmbHVzaFBhcnRpYWxCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgX2JvdW5kYXJ5MikpIHtcbiAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgIGkrKztcbiAgICAgICAgcGFydGlhbEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFydGlhbEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpOyAvLyBOZXh0IHdlIGNoZWNrIHRoZSBjb21wbGV0ZWQgYm91bmRhcmllcyBhZ2Fpbi4gVGhpcyBtYXkgaGF2ZSBoYWRcbiAgICAvLyBib3VuZGFyaWVzIGFkZGVkIHRvIGl0IGluIGNhc2UgdGhleSB3ZXJlIHRvbyBsYXJnZWQgdG8gYmUgaW5saW5lZC5cbiAgICAvLyBOZXcgb25lcyBtaWdodCBiZSBhZGRlZCBpbiB0aGlzIGxvb3AuXG5cbiAgICB2YXIgbGFyZ2VCb3VuZGFyaWVzID0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxhcmdlQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9ib3VuZGFyeTMgPSBsYXJnZUJvdW5kYXJpZXNbaV07XG5cbiAgICAgIGlmICghZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgX2JvdW5kYXJ5MykpIHtcbiAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgIGkrKztcbiAgICAgICAgbGFyZ2VCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhcmdlQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzID09PSAwICYmIHJlcXVlc3QucGluZ2VkVGFza3MubGVuZ3RoID09PSAwICYmIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLmxlbmd0aCA9PT0gMCAmJiByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXMubGVuZ3RoID09PSAwIC8vIFdlIGRvbid0IG5lZWQgdG8gY2hlY2sgYW55IHBhcnRpYWxseSBjb21wbGV0ZWQgc2VnbWVudHMgYmVjYXVzZVxuICAgIC8vIGVpdGhlciB0aGV5IGhhdmUgcGVuZGluZyB0YXNrIG9yIHRoZXkncmUgY29tcGxldGUuXG4gICAgKSB7XG4gICAgICAgIHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2Ugd3JpdGUgdGhlIHRyYWlsaW5nIHRhZ3MgYnV0IG9ubHkgaWYgZG9uJ3QgaGF2ZSBhbnkgZGF0YSB0byByZXN1bWUuXG4gICAgICAgICAgLy8gSWYgd2UgbmVlZCB0byByZXN1bWUgd2UnbGwgd3JpdGUgdGhlIHBvc3RhbWJsZSBpbiB0aGUgcmVzdW1lIGluc3RlYWQuXG4gICAgICAgICAge1xuICAgICAgICAgICAgd3JpdGVQb3N0YW1ibGUoZGVzdGluYXRpb24sIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAocmVxdWVzdC5hYm9ydGFibGVUYXNrcy5zaXplICE9PSAwKSB7XG4gICAgICAgICAgICBlcnJvcignVGhlcmUgd2FzIHN0aWxsIGFib3J0YWJsZSB0YXNrIGF0IHRoZSByb290IHdoZW4gd2UgY2xvc2VkLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBXZSdyZSBkb25lLlxuXG5cbiAgICAgICAgY2xvc2UoZGVzdGluYXRpb24pOyAvLyBXZSBuZWVkIHRvIHN0b3AgZmxvd2luZyBub3cgYmVjYXVzZSB3ZSBkbyBub3Qgd2FudCBhbnkgYXN5bmMgY29udGV4dHMgd2hpY2ggbWlnaHQgY2FsbFxuICAgICAgICAvLyBmbG9hdCBtZXRob2RzIHRvIGluaXRpYXRlIGFueSBmbHVzaGVzIGFmdGVyIHRoaXMgcG9pbnRcblxuICAgICAgICBzdG9wRmxvd2luZyhyZXF1ZXN0KTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFdvcmsocmVxdWVzdCkge1xuICByZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gcmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbDtcblxuICB7XG4gICAgc2NoZWR1bGVXb3JrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtV29yayhyZXF1ZXN0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgPT09IG51bGwpIHtcbiAgICAvLyB0aGlzIGlzIGVpdGhlciBhIHJlZ3VsYXIgcmVuZGVyIG9yIGEgcmVzdW1lLiBGb3IgcmVndWxhciByZW5kZXIgd2Ugd2FudFxuICAgIC8vIHRvIGNhbGwgZW1pdEVhcmx5UHJlbG9hZHMgYWZ0ZXIgdGhlIGZpcnN0IHBlcmZvcm1Xb3JrIGJlY2F1c2Ugd2Ugd2FudFxuICAgIC8vIGFyZSByZXNwb25kaW5nIHRvIGEgbGl2ZSByZXF1ZXN0IGFuZCBuZWVkIHRvIGJhbGFuY2Ugc2VuZGluZyBzb21ldGhpbmcgZWFybHlcbiAgICAvLyAoaS5lLiBkb24ndCB3YW50IGZvciB0aGUgc2hlbGwgdG8gZmluaXNoKSBidXQgd2UgbmVlZCBzb21ldGhpbmcgdG8gc2VuZC5cbiAgICAvLyBUaGUgb25seSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGlzIGZvciBET00gYXQgdGhlIG1vbWVudCBhbmQgZHVyaW5nIHJlc3VtZXMgbm90aGluZ1xuICAgIC8vIGFjdHVhbGx5IGVtaXRzIGJ1dCB0aGUgY29kZSBwYXRocyBoZXJlIGFyZSB0aGUgc2FtZS5cbiAgICAvLyBEdXJpbmcgYSBwcmVyZW5kZXIgd2UgZG9uJ3Qgd2FudCB0byBiZSB0b28gYWdncmVzc2l2ZSBpbiBlbWl0dGluZyBlYXJseSBwcmVsb2Fkc1xuICAgIC8vIGJlY2F1c2Ugd2UgYXJlbid0IHJlc3BvbmRpbmcgdG8gYSBsaXZlIHJlcXVlc3QgYW5kIHdlIGNhbiB3YWl0IGZvciB0aGUgcHJlcmVuZGVyIHRvXG4gICAgLy8gcG9zdHBvbmUgYmVmb3JlIHdlIGVtaXQgYW55dGhpbmcuXG4gICAge1xuICAgICAgc2NoZWR1bGVXb3JrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVucXVldWVFYXJseVByZWxvYWRzQWZ0ZXJJbml0aWFsV29yayhyZXF1ZXN0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlbnF1ZXVlRWFybHlQcmVsb2Fkc0FmdGVySW5pdGlhbFdvcmsocmVxdWVzdCkge1xuICB2YXIgc2hlbGxDb21wbGV0ZSA9IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyA9PT0gMDtcbiAgc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgc2hlbGxDb21wbGV0ZSk7XG59XG5cbmZ1bmN0aW9uIGVucXVldWVGbHVzaChyZXF1ZXN0KSB7XG4gIGlmIChyZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID09PSBmYWxzZSAmJiAvLyBJZiB0aGVyZSBhcmUgcGluZ2VkIHRhc2tzIHdlIGFyZSBnb2luZyB0byBmbHVzaCBhbnl3YXkgYWZ0ZXIgd29yayBjb21wbGV0ZXNcbiAgcmVxdWVzdC5waW5nZWRUYXNrcy5sZW5ndGggPT09IDAgJiYgLy8gSWYgdGhlcmUgaXMgbm8gZGVzdGluYXRpb24gdGhlcmUgaXMgbm90aGluZyB3ZSBjYW4gZmx1c2ggdG8uIEEgZmx1c2ggd2lsbFxuICAvLyBoYXBwZW4gd2hlbiB3ZSBzdGFydCBmbG93aW5nIGFnYWluXG4gIHJlcXVlc3QuZGVzdGluYXRpb24gIT09IG51bGwpIHtcbiAgICByZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBzY2hlZHVsZVdvcmsoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBleGlzdGVuY2UgY2hlY2sgZGVzdGluYXRpb24gYWdhaW4gaGVyZSBiZWNhdXNlIGl0IG1pZ2h0IGdvIGF3YXlcbiAgICAgIC8vIGluIGJldHdlZW4gdGhlIGVucXVldWVGbHVzaCBjYWxsIGFuZCB0aGUgd29yayBleGVjdXRpb25cbiAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHJlcXVlc3QuZGVzdGluYXRpb247XG5cbiAgICAgIGlmIChkZXN0aW5hdGlvbikge1xuICAgICAgICBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBpbnRlbnRlZCB0byBvbmx5IGJlIGNhbGxlZCBkdXJpbmcgdGhlIHBpcGUgZnVuY3Rpb24gZm9yIHRoZSBOb2RlIGJ1aWxkcy5cbmZ1bmN0aW9uIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBkZXN0aW5hdGlvbikge1xuICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IENMT1NJTkcpIHtcbiAgICByZXF1ZXN0LnN0YXR1cyA9IENMT1NFRDtcbiAgICBjbG9zZVdpdGhFcnJvcihkZXN0aW5hdGlvbiwgcmVxdWVzdC5mYXRhbEVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IENMT1NFRCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsKSB7XG4gICAgLy8gV2UncmUgYWxyZWFkeSBmbG93aW5nLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlcXVlc3QuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcblxuICB0cnkge1xuICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB2YXIgZXJyb3JJbmZvID0ge307XG4gICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgZXJyb3JJbmZvKTtcbiAgICBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gc3RvcEZsb3dpbmcocmVxdWVzdCkge1xuICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbn0gLy8gVGhpcyBpcyBjYWxsZWQgdG8gZWFybHkgdGVybWluYXRlIGEgcmVxdWVzdC4gSXQgcHV0cyBhbGwgcGVuZGluZyBib3VuZGFyaWVzIGluIGNsaWVudCByZW5kZXJlZCBzdGF0ZS5cblxuZnVuY3Rpb24gYWJvcnQocmVxdWVzdCwgcmVhc29uKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFib3J0YWJsZVRhc2tzID0gcmVxdWVzdC5hYm9ydGFibGVUYXNrcztcblxuICAgIGlmIChhYm9ydGFibGVUYXNrcy5zaXplID4gMCkge1xuICAgICAgdmFyIGVycm9yID0gcmVhc29uID09PSB1bmRlZmluZWQgPyBuZXcgRXJyb3IoJ1RoZSByZW5kZXIgd2FzIGFib3J0ZWQgYnkgdGhlIHNlcnZlciB3aXRob3V0IGEgcmVhc29uLicpIDogcmVhc29uO1xuICAgICAgYWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAodGFzaykge1xuICAgICAgICByZXR1cm4gYWJvcnRUYXNrKHRhc2ssIHJlcXVlc3QsIGVycm9yKTtcbiAgICAgIH0pO1xuICAgICAgYWJvcnRhYmxlVGFza3MuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbCkge1xuICAgICAgZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgcmVxdWVzdC5kZXN0aW5hdGlvbik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHZhciBlcnJvckluZm8gPSB7fTtcbiAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBlcnJvckluZm8pO1xuICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaFJlc291cmNlcyhyZXF1ZXN0KSB7XG4gIGVucXVldWVGbHVzaChyZXF1ZXN0KTtcbn1cbmZ1bmN0aW9uIGdldEZvcm1TdGF0ZShyZXF1ZXN0KSB7XG4gIHJldHVybiByZXF1ZXN0LmZvcm1TdGF0ZTtcbn1cbmZ1bmN0aW9uIGdldFJlc3VtYWJsZVN0YXRlKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHJlcXVlc3QucmVzdW1hYmxlU3RhdGU7XG59XG5mdW5jdGlvbiBnZXRSZW5kZXJTdGF0ZShyZXF1ZXN0KSB7XG4gIHJldHVybiByZXF1ZXN0LnJlbmRlclN0YXRlO1xufVxuXG5mdW5jdGlvbiBvbkVycm9yKCkgey8vIE5vbi1mYXRhbCBlcnJvcnMgYXJlIGlnbm9yZWQuXG59XG5cbmZ1bmN0aW9uIHJlbmRlclRvU3RyaW5nSW1wbChjaGlsZHJlbiwgb3B0aW9ucywgZ2VuZXJhdGVTdGF0aWNNYXJrdXAsIGFib3J0UmVhc29uKSB7XG4gIHZhciBkaWRGYXRhbCA9IGZhbHNlO1xuICB2YXIgZmF0YWxFcnJvciA9IG51bGw7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIGRlc3RpbmF0aW9uID0ge1xuICAgIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbiAgICBwdXNoOiBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIGlmIChjaHVuayAhPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQgKz0gY2h1bms7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgZmF0YWxFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgdmFyIHJlYWR5VG9TdHJlYW0gPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblNoZWxsUmVhZHkoKSB7XG4gICAgcmVhZHlUb1N0cmVhbSA9IHRydWU7XG4gIH1cblxuICB2YXIgcmVzdW1hYmxlU3RhdGUgPSBjcmVhdGVSZXN1bWFibGVTdGF0ZShvcHRpb25zID8gb3B0aW9ucy5pZGVudGlmaWVyUHJlZml4IDogdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICB2YXIgcmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3QoY2hpbGRyZW4sIHJlc3VtYWJsZVN0YXRlLCBjcmVhdGVSZW5kZXJTdGF0ZShyZXN1bWFibGVTdGF0ZSwgZ2VuZXJhdGVTdGF0aWNNYXJrdXApLCBjcmVhdGVSb290Rm9ybWF0Q29udGV4dCgpLCBJbmZpbml0eSwgb25FcnJvciwgdW5kZWZpbmVkLCBvblNoZWxsUmVhZHksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICBzdGFydFdvcmsocmVxdWVzdCk7IC8vIElmIGFueXRoaW5nIHN1c3BlbmRlZCBhbmQgaXMgc3RpbGwgcGVuZGluZywgd2UnbGwgYWJvcnQgaXQgYmVmb3JlIHdyaXRpbmcuXG4gIC8vIFRoYXQgd2F5IHdlIHdyaXRlIG9ubHkgY2xpZW50LXJlbmRlcmVkIGJvdW5kYXJpZXMgZnJvbSB0aGUgc3RhcnQuXG5cbiAgYWJvcnQocmVxdWVzdCwgYWJvcnRSZWFzb24pO1xuICBzdGFydEZsb3dpbmcocmVxdWVzdCwgZGVzdGluYXRpb24pO1xuXG4gIGlmIChkaWRGYXRhbCAmJiBmYXRhbEVycm9yICE9PSBhYm9ydFJlYXNvbikge1xuICAgIHRocm93IGZhdGFsRXJyb3I7XG4gIH1cblxuICBpZiAoIXJlYWR5VG9TdHJlYW0pIHtcbiAgICAvLyBOb3RlOiBUaGlzIGVycm9yIG1lc3NhZ2UgaXMgdGhlIG9uZSB3ZSB1c2Ugb24gdGhlIGNsaWVudC4gSXQgZG9lc24ndFxuICAgIC8vIHJlYWxseSBtYWtlIHNlbnNlIGhlcmUuIEJ1dCB0aGlzIGlzIHRoZSBsZWdhY3kgc2VydmVyIHJlbmRlcmVyLCBhbnl3YXkuXG4gICAgLy8gV2UncmUgZ29pbmcgdG8gZGVsZXRlIGl0IHNvb24uXG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIGNvbXBvbmVudCBzdXNwZW5kZWQgd2hpbGUgcmVzcG9uZGluZyB0byBzeW5jaHJvbm91cyBpbnB1dC4gVGhpcyAnICsgJ3dpbGwgY2F1c2UgdGhlIFVJIHRvIGJlIHJlcGxhY2VkIHdpdGggYSBsb2FkaW5nIGluZGljYXRvci4gVG8gZml4LCAnICsgJ3VwZGF0ZXMgdGhhdCBzdXNwZW5kIHNob3VsZCBiZSB3cmFwcGVkIHdpdGggc3RhcnRUcmFuc2l0aW9uLicpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVG9TdHJpbmcoY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHJlbmRlclRvU3RyaW5nSW1wbChjaGlsZHJlbiwgb3B0aW9ucywgZmFsc2UsICdUaGUgc2VydmVyIHVzZWQgXCJyZW5kZXJUb1N0cmluZ1wiIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgU3VzcGVuc2UuIElmIHlvdSBpbnRlbmRlZCBmb3IgdGhpcyBTdXNwZW5zZSBib3VuZGFyeSB0byByZW5kZXIgdGhlIGZhbGxiYWNrIGNvbnRlbnQgb24gdGhlIHNlcnZlciBjb25zaWRlciB0aHJvd2luZyBhbiBFcnJvciBzb21ld2hlcmUgd2l0aGluIHRoZSBTdXNwZW5zZSBib3VuZGFyeS4gSWYgeW91IGludGVuZGVkIHRvIGhhdmUgdGhlIHNlcnZlciB3YWl0IGZvciB0aGUgc3VzcGVuZGVkIGNvbXBvbmVudCBwbGVhc2Ugc3dpdGNoIHRvIFwicmVuZGVyVG9SZWFkYWJsZVN0cmVhbVwiIHdoaWNoIHN1cHBvcnRzIFN1c3BlbnNlIG9uIHRoZSBzZXJ2ZXInKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVG9TdGF0aWNNYXJrdXAoY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHJlbmRlclRvU3RyaW5nSW1wbChjaGlsZHJlbiwgb3B0aW9ucywgdHJ1ZSwgJ1RoZSBzZXJ2ZXIgdXNlZCBcInJlbmRlclRvU3RhdGljTWFya3VwXCIgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBTdXNwZW5zZS4gSWYgeW91IGludGVuZGVkIHRvIGhhdmUgdGhlIHNlcnZlciB3YWl0IGZvciB0aGUgc3VzcGVuZGVkIGNvbXBvbmVudCBwbGVhc2Ugc3dpdGNoIHRvIFwicmVuZGVyVG9SZWFkYWJsZVN0cmVhbVwiIHdoaWNoIHN1cHBvcnRzIFN1c3BlbnNlIG9uIHRoZSBzZXJ2ZXInKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVG9Ob2RlU3RyZWFtKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0RE9NU2VydmVyLnJlbmRlclRvTm9kZVN0cmVhbSgpOiBUaGUgc3RyZWFtaW5nIEFQSSBpcyBub3QgYXZhaWxhYmxlICcgKyAnaW4gdGhlIGJyb3dzZXIuIFVzZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGluc3RlYWQuJyk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclRvU3RhdGljTm9kZVN0cmVhbSgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0YXRpY05vZGVTdHJlYW0oKTogVGhlIHN0cmVhbWluZyBBUEkgaXMgbm90IGF2YWlsYWJsZSAnICsgJ2luIHRoZSBicm93c2VyLiBVc2UgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdGF0aWNNYXJrdXAoKSBpbnN0ZWFkLicpO1xufVxuXG5leHBvcnRzLnJlbmRlclRvTm9kZVN0cmVhbSA9IHJlbmRlclRvTm9kZVN0cmVhbTtcbmV4cG9ydHMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSByZW5kZXJUb1N0YXRpY01hcmt1cDtcbmV4cG9ydHMucmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtID0gcmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtO1xuZXhwb3J0cy5yZW5kZXJUb1N0cmluZyA9IHJlbmRlclRvU3RyaW5nO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSZWFjdERPTSIsIlJlYWN0VmVyc2lvbiIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJ3YXJuIiwiZm9ybWF0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJwcmludFdhcm5pbmciLCJlcnJvciIsIl9sZW4yIiwiX2tleTIiLCJsZXZlbCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJzdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJTdHJpbmciLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwiY3JlYXRlRmFzdEhhc2hKUyIsImtleSIsIm11cm11cmhhc2gzXzMyX2djIiwic2VlZCIsInJlbWFpbmRlciIsImJ5dGVzIiwiaDEiLCJoMWIiLCJjMSIsImMyIiwiazEiLCJpIiwiY2hhckNvZGVBdCIsInNjaGVkdWxlV29yayIsImNhbGxiYWNrIiwiYmVnaW5Xcml0aW5nIiwiZGVzdGluYXRpb24iLCJ3cml0ZUNodW5rIiwiY2h1bmsiLCJ3cml0ZUNodW5rQW5kUmV0dXJuIiwicHVzaCIsImNvbXBsZXRlV3JpdGluZyIsImNsb3NlIiwic3RyaW5nVG9DaHVuayIsImNvbnRlbnQiLCJzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsiLCJjbG9uZVByZWNvbXB1dGVkQ2h1bmsiLCJjbG9zZVdpdGhFcnJvciIsImRlc3Ryb3kiLCJhc3NpZ24iLCJPYmplY3QiLCJ0eXBlTmFtZSIsInZhbHVlIiwiaGFzVG9TdHJpbmdUYWciLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInR5cGUiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uIiwiYXR0cmlidXRlTmFtZSIsImNoZWNrT3B0aW9uU3RyaW5nQ29lcmNpb24iLCJwcm9wTmFtZSIsImNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbiIsImNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uIiwiZW5hYmxlRmxvYXQiLCJoYXNPd25Qcm9wZXJ0eSIsIkFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIiLCJBVFRSSUJVVEVfTkFNRV9DSEFSIiwiVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgiLCJSZWdFeHAiLCJpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlIiwidmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlIiwiaXNBdHRyaWJ1dGVOYW1lU2FmZSIsInRlc3QiLCJ1bml0bGVzc051bWJlcnMiLCJTZXQiLCJpc1VuaXRsZXNzTnVtYmVyIiwiaGFzIiwiYWxpYXNlcyIsIk1hcCIsImdldEF0dHJpYnV0ZUFsaWFzIiwiZ2V0IiwiaGFzUmVhZE9ubHlWYWx1ZSIsImJ1dHRvbiIsImNoZWNrYm94IiwiaW1hZ2UiLCJoaWRkZW4iLCJyYWRpbyIsInJlc2V0Iiwic3VibWl0IiwiY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyIsInRhZ05hbWUiLCJwcm9wcyIsIm9uQ2hhbmdlIiwib25JbnB1dCIsInJlYWRPbmx5IiwiZGlzYWJsZWQiLCJjaGVja2VkIiwiYXJpYVByb3BlcnRpZXMiLCJ3YXJuZWRQcm9wZXJ0aWVzJDEiLCJyQVJJQSQxIiwickFSSUFDYW1lbCQxIiwidmFsaWRhdGVQcm9wZXJ0eSQxIiwiYXJpYU5hbWUiLCJzbGljZSIsInRvTG93ZXJDYXNlIiwiY29ycmVjdE5hbWUiLCJsb3dlckNhc2VkTmFtZSIsInN0YW5kYXJkTmFtZSIsInZhbGlkYXRlUHJvcGVydGllcyQyIiwiaW52YWxpZFByb3BzIiwiaXNWYWxpZCIsInVua25vd25Qcm9wU3RyaW5nIiwicHJvcCIsImpvaW4iLCJkaWRXYXJuVmFsdWVOdWxsIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDEiLCJtdWx0aXBsZSIsImlzQ3VzdG9tRWxlbWVudCIsImluZGV4T2YiLCJwb3NzaWJsZVN0YW5kYXJkTmFtZXMiLCJhY2NlcHQiLCJhY2NlcHRjaGFyc2V0IiwiYWNjZXNza2V5IiwiYWN0aW9uIiwiYWxsb3dmdWxsc2NyZWVuIiwiYWx0IiwiYXMiLCJhc3luYyIsImF1dG9jYXBpdGFsaXplIiwiYXV0b2NvbXBsZXRlIiwiYXV0b2NvcnJlY3QiLCJhdXRvZm9jdXMiLCJhdXRvcGxheSIsImF1dG9zYXZlIiwiY2FwdHVyZSIsImNlbGxwYWRkaW5nIiwiY2VsbHNwYWNpbmciLCJjaGFsbGVuZ2UiLCJjaGFyc2V0IiwiY2hpbGRyZW4iLCJjaXRlIiwiY2xhc3MiLCJjbGFzc2lkIiwiY2xhc3NuYW1lIiwiY29scyIsImNvbHNwYW4iLCJjb250ZW50ZWRpdGFibGUiLCJjb250ZXh0bWVudSIsImNvbnRyb2xzIiwiY29udHJvbHNsaXN0IiwiY29vcmRzIiwiY3Jvc3NvcmlnaW4iLCJkYW5nZXJvdXNseXNldGlubmVyaHRtbCIsImRhdGEiLCJkYXRldGltZSIsImRlZmF1bHQiLCJkZWZhdWx0Y2hlY2tlZCIsImRlZmF1bHR2YWx1ZSIsImRlZmVyIiwiZGlyIiwiZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmUiLCJkaXNhYmxlcmVtb3RlcGxheWJhY2siLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImVuY3R5cGUiLCJlbnRlcmtleWhpbnQiLCJmZXRjaHByaW9yaXR5IiwiZm9yIiwiZm9ybSIsImZvcm1tZXRob2QiLCJmb3JtYWN0aW9uIiwiZm9ybWVuY3R5cGUiLCJmb3Jtbm92YWxpZGF0ZSIsImZvcm10YXJnZXQiLCJmcmFtZWJvcmRlciIsImhlYWRlcnMiLCJoZWlnaHQiLCJoaWdoIiwiaHJlZiIsImhyZWZsYW5nIiwiaHRtbGZvciIsImh0dHBlcXVpdiIsImljb24iLCJpZCIsImltYWdlc2l6ZXMiLCJpbWFnZXNyY3NldCIsImlubmVyaHRtbCIsImlucHV0bW9kZSIsImludGVncml0eSIsImlzIiwiaXRlbWlkIiwiaXRlbXByb3AiLCJpdGVtcmVmIiwiaXRlbXNjb3BlIiwiaXRlbXR5cGUiLCJrZXlwYXJhbXMiLCJrZXl0eXBlIiwia2luZCIsImxhYmVsIiwibGFuZyIsImxpc3QiLCJsb29wIiwibG93IiwibWFuaWZlc3QiLCJtYXJnaW53aWR0aCIsIm1hcmdpbmhlaWdodCIsIm1heCIsIm1heGxlbmd0aCIsIm1lZGlhIiwibWVkaWFncm91cCIsIm1ldGhvZCIsIm1pbiIsIm1pbmxlbmd0aCIsIm11dGVkIiwibm9tb2R1bGUiLCJub25jZSIsIm5vdmFsaWRhdGUiLCJvcGVuIiwib3B0aW11bSIsInBhdHRlcm4iLCJwbGFjZWhvbGRlciIsInBsYXlzaW5saW5lIiwicG9zdGVyIiwicHJlbG9hZCIsInByb2ZpbGUiLCJyYWRpb2dyb3VwIiwicmVhZG9ubHkiLCJyZWZlcnJlcnBvbGljeSIsInJlbCIsInJlcXVpcmVkIiwicmV2ZXJzZWQiLCJyb2xlIiwicm93cyIsInJvd3NwYW4iLCJzYW5kYm94Iiwic2NvcGUiLCJzY29wZWQiLCJzY3JvbGxpbmciLCJzZWFtbGVzcyIsInNlbGVjdGVkIiwic2hhcGUiLCJzaXplIiwic2l6ZXMiLCJzcGFuIiwic3BlbGxjaGVjayIsInNyYyIsInNyY2RvYyIsInNyY2xhbmciLCJzcmNzZXQiLCJzdGFydCIsInN0ZXAiLCJzdHlsZSIsInN1bW1hcnkiLCJ0YWJpbmRleCIsInRhcmdldCIsInRpdGxlIiwidXNlbWFwIiwid2lkdGgiLCJ3bW9kZSIsIndyYXAiLCJhYm91dCIsImFjY2VudGhlaWdodCIsImFjY3VtdWxhdGUiLCJhZGRpdGl2ZSIsImFsaWdubWVudGJhc2VsaW5lIiwiYWxsb3dyZW9yZGVyIiwiYWxwaGFiZXRpYyIsImFtcGxpdHVkZSIsImFyYWJpY2Zvcm0iLCJhc2NlbnQiLCJhdHRyaWJ1dGVuYW1lIiwiYXR0cmlidXRldHlwZSIsImF1dG9yZXZlcnNlIiwiYXppbXV0aCIsImJhc2VmcmVxdWVuY3kiLCJiYXNlbGluZXNoaWZ0IiwiYmFzZXByb2ZpbGUiLCJiYm94IiwiYmVnaW4iLCJiaWFzIiwiYnkiLCJjYWxjbW9kZSIsImNhcGhlaWdodCIsImNsaXAiLCJjbGlwcGF0aCIsImNsaXBwYXRodW5pdHMiLCJjbGlwcnVsZSIsImNvbG9yIiwiY29sb3JpbnRlcnBvbGF0aW9uIiwiY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVycyIsImNvbG9ycHJvZmlsZSIsImNvbG9ycmVuZGVyaW5nIiwiY29udGVudHNjcmlwdHR5cGUiLCJjb250ZW50c3R5bGV0eXBlIiwiY3Vyc29yIiwiY3giLCJjeSIsImQiLCJkYXRhdHlwZSIsImRlY2VsZXJhdGUiLCJkZXNjZW50IiwiZGlmZnVzZWNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGlzcGxheSIsImRpdmlzb3IiLCJkb21pbmFudGJhc2VsaW5lIiwiZHVyIiwiZHgiLCJkeSIsImVkZ2Vtb2RlIiwiZWxldmF0aW9uIiwiZW5hYmxlYmFja2dyb3VuZCIsImVuZCIsImV4cG9uZW50IiwiZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZCIsImZpbGwiLCJmaWxsb3BhY2l0eSIsImZpbGxydWxlIiwiZmlsdGVyIiwiZmlsdGVycmVzIiwiZmlsdGVydW5pdHMiLCJmbG9vZG9wYWNpdHkiLCJmbG9vZGNvbG9yIiwiZm9jdXNhYmxlIiwiZm9udGZhbWlseSIsImZvbnRzaXplIiwiZm9udHNpemVhZGp1c3QiLCJmb250c3RyZXRjaCIsImZvbnRzdHlsZSIsImZvbnR2YXJpYW50IiwiZm9udHdlaWdodCIsImZyb20iLCJmeCIsImZ5IiwiZzEiLCJnMiIsImdseXBobmFtZSIsImdseXBob3JpZW50YXRpb25ob3Jpem9udGFsIiwiZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsIiwiZ2x5cGhyZWYiLCJncmFkaWVudHRyYW5zZm9ybSIsImdyYWRpZW50dW5pdHMiLCJoYW5naW5nIiwiaG9yaXphZHZ4IiwiaG9yaXpvcmlnaW54IiwiaWRlb2dyYXBoaWMiLCJpbWFnZXJlbmRlcmluZyIsImluMiIsImluIiwiaW5saXN0IiwiaW50ZXJjZXB0IiwiazIiLCJrMyIsIms0IiwiayIsImtlcm5lbG1hdHJpeCIsImtlcm5lbHVuaXRsZW5ndGgiLCJrZXJuaW5nIiwia2V5cG9pbnRzIiwia2V5c3BsaW5lcyIsImtleXRpbWVzIiwibGVuZ3RoYWRqdXN0IiwibGV0dGVyc3BhY2luZyIsImxpZ2h0aW5nY29sb3IiLCJsaW1pdGluZ2NvbmVhbmdsZSIsImxvY2FsIiwibWFya2VyZW5kIiwibWFya2VyaGVpZ2h0IiwibWFya2VybWlkIiwibWFya2Vyc3RhcnQiLCJtYXJrZXJ1bml0cyIsIm1hcmtlcndpZHRoIiwibWFzayIsIm1hc2tjb250ZW50dW5pdHMiLCJtYXNrdW5pdHMiLCJtYXRoZW1hdGljYWwiLCJtb2RlIiwibnVtb2N0YXZlcyIsIm9mZnNldCIsIm9wYWNpdHkiLCJvcGVyYXRvciIsIm9yZGVyIiwib3JpZW50Iiwib3JpZW50YXRpb24iLCJvcmlnaW4iLCJvdmVyZmxvdyIsIm92ZXJsaW5lcG9zaXRpb24iLCJvdmVybGluZXRoaWNrbmVzcyIsInBhaW50b3JkZXIiLCJwYW5vc2UxIiwicGF0aGxlbmd0aCIsInBhdHRlcm5jb250ZW50dW5pdHMiLCJwYXR0ZXJudHJhbnNmb3JtIiwicGF0dGVybnVuaXRzIiwicG9pbnRlcmV2ZW50cyIsInBvaW50cyIsInBvaW50c2F0eCIsInBvaW50c2F0eSIsInBvaW50c2F0eiIsInByZWZpeCIsInByZXNlcnZlYWxwaGEiLCJwcmVzZXJ2ZWFzcGVjdHJhdGlvIiwicHJpbWl0aXZldW5pdHMiLCJwcm9wZXJ0eSIsInIiLCJyYWRpdXMiLCJyZWZ4IiwicmVmeSIsInJlbmRlcmluZ2ludGVudCIsInJlcGVhdGNvdW50IiwicmVwZWF0ZHVyIiwicmVxdWlyZWRleHRlbnNpb25zIiwicmVxdWlyZWRmZWF0dXJlcyIsInJlc291cmNlIiwicmVzdGFydCIsInJlc3VsdCIsInJlc3VsdHMiLCJyb3RhdGUiLCJyeCIsInJ5Iiwic2NhbGUiLCJzZWN1cml0eSIsInNoYXBlcmVuZGVyaW5nIiwic2xvcGUiLCJzcGFjaW5nIiwic3BlY3VsYXJjb25zdGFudCIsInNwZWN1bGFyZXhwb25lbnQiLCJzcGVlZCIsInNwcmVhZG1ldGhvZCIsInN0YXJ0b2Zmc2V0Iiwic3RkZGV2aWF0aW9uIiwic3RlbWgiLCJzdGVtdiIsInN0aXRjaHRpbGVzIiwic3RvcGNvbG9yIiwic3RvcG9wYWNpdHkiLCJzdHJpa2V0aHJvdWdocG9zaXRpb24iLCJzdHJpa2V0aHJvdWdodGhpY2tuZXNzIiwic3RyaW5nIiwic3Ryb2tlIiwic3Ryb2tlZGFzaGFycmF5Iiwic3Ryb2tlZGFzaG9mZnNldCIsInN0cm9rZWxpbmVjYXAiLCJzdHJva2VsaW5lam9pbiIsInN0cm9rZW1pdGVybGltaXQiLCJzdHJva2V3aWR0aCIsInN0cm9rZW9wYWNpdHkiLCJzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmciLCJzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmciLCJzdXJmYWNlc2NhbGUiLCJzeXN0ZW1sYW5ndWFnZSIsInRhYmxldmFsdWVzIiwidGFyZ2V0eCIsInRhcmdldHkiLCJ0ZXh0YW5jaG9yIiwidGV4dGRlY29yYXRpb24iLCJ0ZXh0bGVuZ3RoIiwidGV4dHJlbmRlcmluZyIsInRvIiwidHJhbnNmb3JtIiwidHJhbnNmb3Jtb3JpZ2luIiwidHlwZW9mIiwidTEiLCJ1MiIsInVuZGVybGluZXBvc2l0aW9uIiwidW5kZXJsaW5ldGhpY2tuZXNzIiwidW5pY29kZSIsInVuaWNvZGViaWRpIiwidW5pY29kZXJhbmdlIiwidW5pdHNwZXJlbSIsInVuc2VsZWN0YWJsZSIsInZhbHBoYWJldGljIiwidmFsdWVzIiwidmVjdG9yZWZmZWN0IiwidmVyc2lvbiIsInZlcnRhZHZ5IiwidmVydG9yaWdpbngiLCJ2ZXJ0b3JpZ2lueSIsInZoYW5naW5nIiwidmlkZW9ncmFwaGljIiwidmlld2JveCIsInZpZXd0YXJnZXQiLCJ2aXNpYmlsaXR5Iiwidm1hdGhlbWF0aWNhbCIsInZvY2FiIiwid2lkdGhzIiwid29yZHNwYWNpbmciLCJ3cml0aW5nbW9kZSIsIngxIiwieDIiLCJ4IiwieGNoYW5uZWxzZWxlY3RvciIsInhoZWlnaHQiLCJ4bGlua2FjdHVhdGUiLCJ4bGlua2FyY3JvbGUiLCJ4bGlua2hyZWYiLCJ4bGlua3JvbGUiLCJ4bGlua3Nob3ciLCJ4bGlua3RpdGxlIiwieGxpbmt0eXBlIiwieG1sYmFzZSIsInhtbGxhbmciLCJ4bWxucyIsInhtbG5zeGxpbmsiLCJ4bWxzcGFjZSIsInkxIiwieTIiLCJ5IiwieWNoYW5uZWxzZWxlY3RvciIsInoiLCJ6b29tYW5kcGFuIiwid2FybmVkUHJvcGVydGllcyIsIkVWRU5UX05BTUVfUkVHRVgiLCJJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgiLCJyQVJJQSIsInJBUklBQ2FtZWwiLCJ2YWxpZGF0ZVByb3BlcnR5IiwiZXZlbnRSZWdpc3RyeSIsInJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMiLCJwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIiwicmVnaXN0cmF0aW9uTmFtZSIsInVuZGVmaW5lZCIsImlzTmFOIiwid2FyblVua25vd25Qcm9wZXJ0aWVzIiwidW5rbm93blByb3BzIiwidmFsaWRhdGVQcm9wZXJ0aWVzIiwiYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuIiwibXNQYXR0ZXJuJDEiLCJoeXBoZW5QYXR0ZXJuIiwiYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuIiwid2FybmVkU3R5bGVOYW1lcyIsIndhcm5lZFN0eWxlVmFsdWVzIiwid2FybmVkRm9yTmFOVmFsdWUiLCJ3YXJuZWRGb3JJbmZpbml0eVZhbHVlIiwiY2FtZWxpemUiLCJyZXBsYWNlIiwiXyIsImNoYXJhY3RlciIsInRvVXBwZXJDYXNlIiwid2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUiLCJ3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUiLCJjaGFyQXQiLCJ3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24iLCJ3YXJuU3R5bGVWYWx1ZUlzTmFOIiwid2FyblN0eWxlVmFsdWVJc0luZmluaXR5Iiwid2FyblZhbGlkU3R5bGUiLCJpc0Zpbml0ZSIsImdldENyb3NzT3JpZ2luU3RyaW5nIiwiaW5wdXQiLCJtYXRjaEh0bWxSZWdFeHAiLCJlc2NhcGVIdG1sIiwic3RyIiwibWF0Y2giLCJleGVjIiwiZXNjYXBlIiwiaHRtbCIsImluZGV4IiwibGFzdEluZGV4IiwiZXNjYXBlVGV4dEZvckJyb3dzZXIiLCJ0ZXh0IiwidXBwZXJjYXNlUGF0dGVybiIsIm1zUGF0dGVybiIsImh5cGhlbmF0ZVN0eWxlTmFtZSIsImlzSmF2YVNjcmlwdFByb3RvY29sIiwiZGlkV2FybiIsInNhbml0aXplVVJMIiwidXJsIiwic3RyaW5naWZpZWRVUkwiLCJKU09OIiwic3RyaW5naWZ5IiwiaXNBcnJheUltcGwiLCJpc0FycmF5IiwiYSIsImNsaWVudFJlbmRlckJvdW5kYXJ5IiwiY29tcGxldGVCb3VuZGFyeSIsImNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzIiwiY29tcGxldGVTZWdtZW50IiwiZm9ybVJlcGxheWluZyIsImdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmciLCJ0aGluZyIsInNoYXJlZE5vdFBlbmRpbmdPYmplY3QiLCJwZW5kaW5nIiwiTm90UGVuZGluZyIsImZyZWV6ZSIsIlJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzIiwiUmVhY3RET01DdXJyZW50RGlzcGF0Y2hlciIsIkRpc3BhdGNoZXIiLCJSZWFjdERPTVNlcnZlckRpc3BhdGNoZXIiLCJwcmVmZXRjaEROUyIsInByZWNvbm5lY3QiLCJwcmVsb2FkTW9kdWxlIiwicHJlaW5pdFN0eWxlIiwicHJlaW5pdFNjcmlwdCIsInByZWluaXRNb2R1bGVTY3JpcHQiLCJwcmVwYXJlSG9zdERpc3BhdGNoZXIiLCJjdXJyZW50IiwiU2NyaXB0U3RyZWFtaW5nRm9ybWF0IiwiRGF0YVN0cmVhbWluZ0Zvcm1hdCIsIk5vdGhpbmdTZW50IiwiU2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uIiwiU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbiIsIlNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbiIsIlNlbnRTdHlsZUluc2VydGlvbkZ1bmN0aW9uIiwiU2VudEZvcm1SZXBsYXlpbmdSdW50aW1lIiwiRVhJU1RTIiwiUFJFTE9BRF9OT19DUkVEUyIsImRhdGFFbGVtZW50UXVvdGVkRW5kIiwic3RhcnRJbmxpbmVTY3JpcHQiLCJlbmRJbmxpbmVTY3JpcHQiLCJzdGFydFNjcmlwdFNyYyIsInN0YXJ0TW9kdWxlU3JjIiwic2NyaXB0Tm9uY2UiLCJzY3JpcHRJbnRlZ2lydHkiLCJzY3JpcHRDcm9zc09yaWdpbiIsImVuZEFzeW5jU2NyaXB0IiwiZXNjYXBlQm9vdHN0cmFwQW5kSW1wb3J0TWFwU2NyaXB0Q29udGVudCIsInNjcmlwdFRleHQiLCJzY3JpcHRSZWdleCIsInNjcmlwdFJlcGxhY2VyIiwicyIsInN1ZmZpeCIsImltcG9ydE1hcFNjcmlwdFN0YXJ0IiwiaW1wb3J0TWFwU2NyaXB0RW5kIiwiREVGQVVMVF9IRUFERVJTX0NBUEFDSVRZX0lOX1VURjE2X0NPREVfVU5JVFMiLCJjcmVhdGVSZW5kZXJTdGF0ZSQxIiwicmVzdW1hYmxlU3RhdGUiLCJleHRlcm5hbFJ1bnRpbWVDb25maWciLCJpbXBvcnRNYXAiLCJvbkhlYWRlcnMiLCJtYXhIZWFkZXJzTGVuZ3RoIiwiaW5saW5lU2NyaXB0V2l0aE5vbmNlIiwiaWRQcmVmaXgiLCJib290c3RyYXBDaHVua3MiLCJleHRlcm5hbFJ1bnRpbWVTY3JpcHQiLCJib290c3RyYXBTY3JpcHRDb250ZW50IiwiYm9vdHN0cmFwU2NyaXB0cyIsImJvb3RzdHJhcE1vZHVsZXMiLCJjaHVua3MiLCJwdXNoU2NyaXB0SW1wbCIsImltcG9ydE1hcENodW5rcyIsInByZWNvbm5lY3RzIiwiZm9udFByZWxvYWRzIiwiaGlnaEltYWdlUHJlbG9hZHMiLCJyZW1haW5pbmdDYXBhY2l0eSIsInJlbmRlclN0YXRlIiwicGxhY2Vob2xkZXJQcmVmaXgiLCJzZWdtZW50UHJlZml4IiwiYm91bmRhcnlQcmVmaXgiLCJodG1sQ2h1bmtzIiwiaGVhZENodW5rcyIsInJlc2V0cyIsImZvbnQiLCJkbnMiLCJjb25uZWN0IiwiYW5vbnltb3VzIiwiY3JlZGVudGlhbHMiLCJjaGFyc2V0Q2h1bmtzIiwicHJlY29ubmVjdENodW5rcyIsInByZWxvYWRDaHVua3MiLCJob2lzdGFibGVDaHVua3MiLCJzdHlsZXMiLCJzY3JpcHRzIiwiYnVsa1ByZWxvYWRzIiwicHJlbG9hZHMiLCJpbWFnZXMiLCJzdHlsZXNoZWV0cyIsIm1vZHVsZVNjcmlwdHMiLCJib3VuZGFyeVJlc291cmNlcyIsInN0eWxlc1RvSG9pc3QiLCJzY3JpcHRDb25maWciLCJjcm9zc09yaWdpbiIsImZldGNoUHJpb3JpdHkiLCJwcmVsb2FkQm9vdHN0cmFwU2NyaXB0T3JNb2R1bGUiLCJfaSIsIl9zY3JpcHRDb25maWciLCJfc3JjIiwiX2Nyb3NzT3JpZ2luIiwiX2ludGVncml0eSIsIl9wcm9wcyIsImNyZWF0ZVJlc3VtYWJsZVN0YXRlIiwiaWRlbnRpZmllclByZWZpeCIsInN0cmVhbWluZ0Zvcm1hdCIsIm5leHRGb3JtSUQiLCJpbnN0cnVjdGlvbnMiLCJoYXNCb2R5IiwiaGFzSHRtbCIsInVua25vd25SZXNvdXJjZXMiLCJkbnNSZXNvdXJjZXMiLCJjb25uZWN0UmVzb3VyY2VzIiwiaW1hZ2VSZXNvdXJjZXMiLCJzdHlsZVJlc291cmNlcyIsInNjcmlwdFJlc291cmNlcyIsIm1vZHVsZVVua25vd25SZXNvdXJjZXMiLCJtb2R1bGVTY3JpcHRSZXNvdXJjZXMiLCJST09UX0hUTUxfTU9ERSIsIkhUTUxfSFRNTF9NT0RFIiwiSFRNTF9NT0RFIiwiU1ZHX01PREUiLCJNQVRITUxfTU9ERSIsIkhUTUxfVEFCTEVfTU9ERSIsIkhUTUxfVEFCTEVfQk9EWV9NT0RFIiwiSFRNTF9UQUJMRV9ST1dfTU9ERSIsIkhUTUxfQ09MR1JPVVBfTU9ERSIsIk5PX1NDT1BFIiwiTk9TQ1JJUFRfU0NPUEUiLCJQSUNUVVJFX1NDT1BFIiwiY3JlYXRlRm9ybWF0Q29udGV4dCIsImluc2VydGlvbk1vZGUiLCJzZWxlY3RlZFZhbHVlIiwidGFnU2NvcGUiLCJjcmVhdGVSb290Rm9ybWF0Q29udGV4dCIsIm5hbWVzcGFjZVVSSSIsImdldENoaWxkRm9ybWF0Q29udGV4dCIsInBhcmVudENvbnRleHQiLCJkZWZhdWx0VmFsdWUiLCJtYWtlSWQiLCJ0cmVlSWQiLCJsb2NhbElkIiwidG9TdHJpbmciLCJlbmNvZGVIVE1MVGV4dE5vZGUiLCJ0ZXh0U2VwYXJhdG9yIiwicHVzaFRleHRJbnN0YW5jZSQxIiwidGV4dEVtYmVkZGVkIiwicHVzaFNlZ21lbnRGaW5hbGUkMSIsImxhc3RQdXNoZWRUZXh0Iiwic3R5bGVOYW1lQ2FjaGUiLCJwcm9jZXNzU3R5bGVOYW1lIiwic3R5bGVOYW1lIiwic2V0Iiwic3R5bGVBdHRyaWJ1dGVTdGFydCIsInN0eWxlQXNzaWduIiwic3R5bGVTZXBhcmF0b3IiLCJwdXNoU3R5bGVBdHRyaWJ1dGUiLCJFcnJvciIsImlzRmlyc3QiLCJzdHlsZVZhbHVlIiwibmFtZUNodW5rIiwidmFsdWVDaHVuayIsImlzQ3VzdG9tUHJvcGVydHkiLCJ0cmltIiwiYXR0cmlidXRlRW5kIiwiYXR0cmlidXRlU2VwYXJhdG9yIiwiYXR0cmlidXRlQXNzaWduIiwiYXR0cmlidXRlRW1wdHlTdHJpbmciLCJwdXNoQm9vbGVhbkF0dHJpYnV0ZSIsInB1c2hTdHJpbmdBdHRyaWJ1dGUiLCJtYWtlRm9ybUZpZWxkUHJlZml4IiwiYWN0aW9uSmF2YVNjcmlwdFVSTCIsInN0YXJ0SGlkZGVuSW5wdXRDaHVuayIsInB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkIiwiZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nIiwicHVzaEFkZGl0aW9uYWxGb3JtRmllbGRzIiwiZm9ybURhdGEiLCJmb3JFYWNoIiwicHVzaEZvcm1BY3Rpb25BdHRyaWJ1dGUiLCJmb3JtQWN0aW9uIiwiZm9ybUVuY1R5cGUiLCJmb3JtTWV0aG9kIiwiZm9ybVRhcmdldCIsImRpZFdhcm5Gb3JtQWN0aW9uTmFtZSIsImRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kIiwiZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQiLCJjdXN0b21BY3Rpb24iLCIkJEZPUk1fQUNUSU9OIiwiY3VzdG9tRmllbGRzIiwiZW5jVHlwZSIsImluamVjdEZvcm1SZXBsYXlpbmdSdW50aW1lIiwicHVzaEF0dHJpYnV0ZSIsInNhbml0aXplZFZhbHVlIiwiX3Nhbml0aXplZFZhbHVlIiwiZW5kT2ZTdGFydFRhZyIsInB1c2hJbm5lckhUTUwiLCJpbm5lckhUTUwiLCJfX2h0bWwiLCJkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUiLCJkaWRXYXJuRGVmYXVsdENoZWNrZWQiLCJkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlIiwiZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlIiwiZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiIsImRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MIiwiZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24iLCJkaWRXYXJuRm9ybUFjdGlvblR5cGUiLCJjaGVja1NlbGVjdFByb3AiLCJhcnJheSIsInB1c2hTdGFydFNlbGVjdCIsInN0YXJ0Q2h1bmtGb3JUYWciLCJwcm9wS2V5IiwicHJvcFZhbHVlIiwiZmxhdHRlbk9wdGlvbkNoaWxkcmVuIiwiQ2hpbGRyZW4iLCJjaGlsZCIsInNlbGVjdGVkTWFya2VyQXR0cmlidXRlIiwicHVzaFN0YXJ0T3B0aW9uIiwiZm9ybWF0Q29udGV4dCIsInN0cmluZ1ZhbHVlIiwidiIsImZvcm1SZXBsYXlpbmdSdW50aW1lU2NyaXB0IiwiZm9ybVN0YXRlTWFya2VySXNNYXRjaGluZyIsImZvcm1TdGF0ZU1hcmtlcklzTm90TWF0Y2hpbmciLCJwdXNoRm9ybVN0YXRlTWFya2VySXNNYXRjaGluZyIsInB1c2hGb3JtU3RhdGVNYXJrZXJJc05vdE1hdGNoaW5nIiwicHVzaFN0YXJ0Rm9ybSIsImZvcm1BY3Rpb25OYW1lIiwicHVzaElucHV0IiwiZGVmYXVsdENoZWNrZWQiLCJwdXNoU3RhcnRCdXR0b24iLCJwdXNoU3RhcnRUZXh0QXJlYSIsImxlYWRpbmdOZXdsaW5lIiwicHVzaE1ldGEiLCJub3NjcmlwdFRhZ0luU2NvcGUiLCJpdGVtUHJvcCIsInB1c2hTZWxmQ2xvc2luZyIsImNoYXJTZXQiLCJwdXNoTGluayIsInByZWNlZGVuY2UiLCJwdXNoTGlua0ltcGwiLCJnZXRSZXNvdXJjZUtleSIsIm9uTG9hZCIsIm9uRXJyb3IiLCJwcm9wRGVzY3JpcHRpb24iLCJzdHlsZVF1ZXVlIiwiaGFzS2V5IiwicmVzb3VyY2VTdGF0ZSIsInJ1bGVzIiwiaHJlZnMiLCJzaGVldHMiLCJzdGF0ZSIsIlBFTkRJTkckMSIsInN0eWxlc2hlZXRQcm9wc0Zyb21SYXdQcm9wcyIsInByZWxvYWRTdGF0ZSIsImFkb3B0UHJlbG9hZENyZWRlbnRpYWxzIiwicHJlbG9hZFJlc291cmNlIiwiUFJFTE9BREVEIiwiYWRkIiwiX3Jlc291cmNlIiwicHVzaFN0eWxlIiwiY2hpbGRUeXBlIiwicHVzaFN0eWxlSW1wbCIsImluY2x1ZGVzIiwicHVzaFN0eWxlQ29udGVudHMiLCJlbmRDaHVua0ZvclRhZyIsInB1c2hJbWciLCJwaWN0dXJlVGFnSW5TY29wZSIsInNyY1NldCIsImxvYWRpbmciLCJnZXRJbWFnZVJlc291cmNlS2V5IiwicHJvbW90YWJsZVByZWxvYWRzIiwiZGVsZXRlIiwiaGVhZGVyIiwiZ2V0UHJlbG9hZEFzSGVhZGVyIiwiaW1hZ2VTcmNTZXQiLCJpbWFnZVNpemVzIiwicmVmZXJyZXJQb2xpY3kiLCJyZWZlcmVyUG9saWN5IiwidGFnIiwicHVzaFN0YXJ0TWVudUl0ZW0iLCJwdXNoVGl0bGUiLCIkJHR5cGVvZiIsInB1c2hUaXRsZUltcGwiLCJwdXNoU3RhcnRIZWFkIiwicHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQiLCJwdXNoU3RhcnRIdG1sIiwiZG9jdHlwZUNodW5rIiwicHVzaFNjcmlwdCIsImFzeW5jUHJvcCIsInJlc291cmNlcyIsInNjcmlwdFByb3BzIiwiZGVzY3JpcHRpdmVTdGF0ZW1lbnQiLCJwdXNoU3RhcnRDdXN0b21FbGVtZW50IiwicHVzaFN0YXJ0UHJlZm9ybWF0dGVkRWxlbWVudCIsIlZBTElEX1RBR19SRUdFWCIsInZhbGlkYXRlZFRhZ0NhY2hlIiwidGFnU3RhcnRDaHVuayIsInB1c2hTdGFydEluc3RhbmNlIiwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiwiY29udGVudEVkaXRhYmxlIiwiZW5kVGFnQ2FjaGUiLCJwdXNoRW5kSW5zdGFuY2UiLCJ3cml0ZUJvb3RzdHJhcCIsImxhc3RDaHVuayIsIndyaXRlQ29tcGxldGVkUm9vdCIsInBsYWNlaG9sZGVyMSIsInBsYWNlaG9sZGVyMiIsIndyaXRlUGxhY2Vob2xkZXIiLCJmb3JtYXR0ZWRJRCIsInN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSIsInN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkxIiwic3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTIiLCJzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSIsImVuZFN1c3BlbnNlQm91bmRhcnkiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBIiwiY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQiIsImNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUMiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjIiLCJ3cml0ZVN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSQxIiwid3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5Iiwid3JpdGVTdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSQxIiwiZXJyb3JEaWdlc3QiLCJlcnJvck1lc3NzYWdlIiwiZXJyb3JDb21wb25lbnRTdGFjayIsIndyaXRlRW5kQ29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSQxIiwid3JpdGVFbmRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeSIsIndyaXRlRW5kQ2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5JDEiLCJzdGFydFNlZ21lbnRIVE1MIiwic3RhcnRTZWdtZW50SFRNTDIiLCJlbmRTZWdtZW50SFRNTCIsInN0YXJ0U2VnbWVudFNWRyIsInN0YXJ0U2VnbWVudFNWRzIiLCJlbmRTZWdtZW50U1ZHIiwic3RhcnRTZWdtZW50TWF0aE1MIiwic3RhcnRTZWdtZW50TWF0aE1MMiIsImVuZFNlZ21lbnRNYXRoTUwiLCJzdGFydFNlZ21lbnRUYWJsZSIsInN0YXJ0U2VnbWVudFRhYmxlMiIsImVuZFNlZ21lbnRUYWJsZSIsInN0YXJ0U2VnbWVudFRhYmxlQm9keSIsInN0YXJ0U2VnbWVudFRhYmxlQm9keTIiLCJlbmRTZWdtZW50VGFibGVCb2R5Iiwic3RhcnRTZWdtZW50VGFibGVSb3ciLCJzdGFydFNlZ21lbnRUYWJsZVJvdzIiLCJlbmRTZWdtZW50VGFibGVSb3ciLCJzdGFydFNlZ21lbnRDb2xHcm91cCIsInN0YXJ0U2VnbWVudENvbEdyb3VwMiIsImVuZFNlZ21lbnRDb2xHcm91cCIsIndyaXRlU3RhcnRTZWdtZW50Iiwid3JpdGVFbmRTZWdtZW50IiwiY29tcGxldGVTZWdtZW50U2NyaXB0MUZ1bGwiLCJjb21wbGV0ZVNlZ21lbnRTY3JpcHQxUGFydGlhbCIsImNvbXBsZXRlU2VnbWVudFNjcmlwdDIiLCJjb21wbGV0ZVNlZ21lbnRTY3JpcHRFbmQiLCJjb21wbGV0ZVNlZ21lbnREYXRhMSIsImNvbXBsZXRlU2VnbWVudERhdGEyIiwiY29tcGxldGVTZWdtZW50RGF0YUVuZCIsIndyaXRlQ29tcGxldGVkU2VnbWVudEluc3RydWN0aW9uIiwiY29udGVudFNlZ21lbnRJRCIsInNjcmlwdEZvcm1hdCIsImNvbXBsZXRlQm91bmRhcnlTY3JpcHQxRnVsbCIsImNvbXBsZXRlQm91bmRhcnlTY3JpcHQxUGFydGlhbCIsImNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxCb3RoIiwiY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxRnVsbFBhcnRpYWwiLCJjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFQYXJ0aWFsIiwiY29tcGxldGVCb3VuZGFyeVNjcmlwdDIiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2EiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2IiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0RW5kIiwiY29tcGxldGVCb3VuZGFyeURhdGExIiwiY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNEYXRhMSIsImNvbXBsZXRlQm91bmRhcnlEYXRhMiIsImNvbXBsZXRlQm91bmRhcnlEYXRhM2EiLCJjb21wbGV0ZUJvdW5kYXJ5RGF0YUVuZCIsIndyaXRlQ29tcGxldGVkQm91bmRhcnlJbnN0cnVjdGlvbiIsInJlcXVpcmVzU3R5bGVJbnNlcnRpb24iLCJpZENodW5rIiwid3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5KUyIsIndyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY2llc0luQXR0ciIsIndyaXRlTW9yZSIsImNsaWVudFJlbmRlclNjcmlwdDFGdWxsIiwiY2xpZW50UmVuZGVyU2NyaXB0MVBhcnRpYWwiLCJjbGllbnRSZW5kZXJTY3JpcHQxQSIsImNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsIiwiY2xpZW50UmVuZGVyU2NyaXB0RW5kIiwiY2xpZW50UmVuZGVyRGF0YTEiLCJjbGllbnRSZW5kZXJEYXRhMiIsImNsaWVudFJlbmRlckRhdGEzIiwiY2xpZW50UmVuZGVyRGF0YTQiLCJjbGllbnRSZW5kZXJEYXRhRW5kIiwid3JpdGVDbGllbnRSZW5kZXJCb3VuZGFyeUluc3RydWN0aW9uIiwiZXJyb3JNZXNzYWdlIiwiZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzIiwicmVnZXhGb3JKU1N0cmluZ3NJbkluc3RydWN0aW9uU2NyaXB0cyIsImVzY2FwZWQiLCJyZWdleEZvckpTU3RyaW5nc0luU2NyaXB0cyIsImVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzIiwibGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMSIsImxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjIiLCJsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4zIiwibGF0ZVN0eWxlVGFnVGVtcGxhdGVDbG9zZSIsImN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCIsImRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkiLCJmbHVzaFN0eWxlVGFnc0xhdGVGb3JCb3VuZGFyeSIsInNwYWNlU2VwYXJhdG9yIiwiaGFzU3R5bGVzVG9Ib2lzdCIsInN0eWxlc2hlZXQiLCJQUkVBTUJMRSIsIndyaXRlUmVzb3VyY2VzRm9yQm91bmRhcnkiLCJmbHVzaFJlc291cmNlIiwic3R5bGVzaGVldEZsdXNoaW5nUXVldWUiLCJmbHVzaFN0eWxlSW5QcmVhbWJsZSIsInN0eWxlVGFnUmVzb3VyY2VPcGVuMSIsInN0eWxlVGFnUmVzb3VyY2VPcGVuMiIsInN0eWxlVGFnUmVzb3VyY2VPcGVuMyIsInN0eWxlVGFnUmVzb3VyY2VDbG9zZSIsImZsdXNoU3R5bGVzSW5QcmVhbWJsZSIsImhhc1N0eWxlc2hlZXRzIiwiY2xlYXIiLCJwcmVsb2FkTGF0ZVN0eWxlIiwicHJlbG9hZFByb3BzIiwicHJlbG9hZEFzU3R5bGVQcm9wc0Zyb21Qcm9wcyIsInByZWxvYWRMYXRlU3R5bGVzIiwid3JpdGVQcmVhbWJsZSIsIndpbGxGbHVzaEFsbFNlZ21lbnRzIiwiX3JlbmRlclN0YXRlJGV4dGVybmFsIiwiaW50ZXJuYWxQcmVpbml0U2NyaXB0Iiwid3JpdGVIb2lzdGFibGVzIiwid3JpdGVQb3N0YW1ibGUiLCJhcnJheUZpcnN0T3BlbkJyYWNrZXQiLCJhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldCIsImFycmF5SW50ZXJzdGl0aWFsIiwiYXJyYXlDbG9zZUJyYWNrZXQiLCJuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayIsIkxBVEUiLCJ3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SHJlZk9ubHlJbkpTIiwid3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUluSlMiLCJjb2VyY2VkSHJlZiIsImNvZXJjZWRQcmVjZWRlbmNlIiwid3JpdGVTdHlsZVJlc291cmNlQXR0cmlidXRlSW5KUyIsImF0dHJpYnV0ZVZhbHVlIiwid3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUhyZWZPbmx5SW5BdHRyIiwid3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUluQXR0ciIsIndyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluQXR0ciIsImNyZWF0ZUJvdW5kYXJ5UmVzb3VyY2VzIiwic2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQiLCJyZXF1ZXN0IiwicmVzb2x2ZVJlcXVlc3QiLCJnZXRSZXN1bWFibGVTdGF0ZSIsImdldFJlbmRlclN0YXRlIiwiZ2V0UHJlZmV0Y2hETlNBc0hlYWRlciIsImZsdXNoUmVzb3VyY2VzIiwiYnVja2V0IiwiZ2V0UHJlY29ubmVjdEFzSGVhZGVyIiwib3B0aW9ucyIsIl9yZXNvdXJjZTIiLCJfcmVzb3VyY2UzIiwiX2tleTMiLCJoYXNBc1R5cGUiLCJfaGVhZGVycyIsIl9oZWFkZXIiLCJfcmVzb3VyY2U0IiwiaHJlZkxhbmciLCJyYXdQcm9wcyIsImVzY2FwZWRIcmVmIiwiZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0IiwiZXNjYXBlZENyb3NzT3JpZ2luIiwiZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0IiwicGFyYW1zIiwiZXNjYXBlZEFzIiwicGFyYW1OYW1lIiwicGFyYW1WYWx1ZSIsImdldFN0eWxlc2hlZXRQcmVsb2FkQXNIZWFkZXIiLCJwcmVsb2FkT3B0aW9ucyIsInJlZ2V4Rm9ySHJlZkluTGlua0hlYWRlclVSTENvbnRleHQiLCJocmVmSW5wdXQiLCJlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHRSZXBsYWNlciIsInJlZ2V4Rm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0IiwiY29lcmNlZCIsImVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dFJlcGxhY2VyIiwiaG9pc3RTdHlsZVF1ZXVlRGVwZW5kZW5jeSIsImhvaXN0U3R5bGVzaGVldERlcGVuZGVuY3kiLCJob2lzdFJlc291cmNlcyIsInNvdXJjZSIsImN1cnJlbnRCb3VuZGFyeVJlc291cmNlcyIsImVtaXRFYXJseVByZWxvYWRzIiwic2hlbGxDb21wbGV0ZSIsImxpbmtIZWFkZXIiLCJxdWV1ZUl0ZXIiLCJvdXRlciIsInF1ZXVlU3RlcCIsIm5leHQiLCJkb25lIiwic2hlZXRJdGVyIiwic2hlZXRTdGVwIiwic2hlZXQiLCJMaW5rIiwiY3JlYXRlUmVuZGVyU3RhdGUiLCJnZW5lcmF0ZVN0YXRpY01hcmt1cCIsInB1c2hUZXh0SW5zdGFuY2UiLCJwdXNoU2VnbWVudEZpbmFsZSIsIndyaXRlU3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5Iiwid3JpdGVTdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSIsIndyaXRlRW5kQ29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSIsIndyaXRlRW5kQ2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5IiwiTm90UGVuZGluZ1RyYW5zaXRpb24iLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9TQ09QRV9UWVBFIiwiUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUiLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsIlJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSIsIlJFQUNUX0NBQ0hFX1RZUEUiLCJSRUFDVF9TRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERUQiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiZ2V0V3JhcHBlZE5hbWUiLCJvdXRlclR5cGUiLCJpbm5lclR5cGUiLCJ3cmFwcGVyTmFtZSIsImRpc3BsYXlOYW1lIiwiZnVuY3Rpb25OYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwiZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlIiwiY29udGV4dCIsInByb3ZpZGVyIiwiX2NvbnRleHQiLCJyZW5kZXIiLCJvdXRlck5hbWUiLCJsYXp5Q29tcG9uZW50IiwicGF5bG9hZCIsIl9wYXlsb2FkIiwiaW5pdCIsIl9pbml0IiwiZGlzYWJsZWREZXB0aCIsInByZXZMb2ciLCJwcmV2SW5mbyIsInByZXZXYXJuIiwicHJldkVycm9yIiwicHJldkdyb3VwIiwicHJldkdyb3VwQ29sbGFwc2VkIiwicHJldkdyb3VwRW5kIiwiZGlzYWJsZWRMb2ciLCJfX3JlYWN0RGlzYWJsZWRMb2ciLCJkaXNhYmxlTG9ncyIsImxvZyIsImluZm8iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVlbmFibGVMb2dzIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwib3duZXJGbiIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiUnVuSW5Sb290RnJhbWUiLCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QiLCJjb250cm9sIiwiRmFrZSIsImRlZmluZVByb3BlcnR5IiwiUmVmbGVjdCIsIm1heWJlUHJvbWlzZSIsImNhdGNoIiwic2FtcGxlIiwibmFtZVByb3BEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX1J1bkluUm9vdEZyYW1lJERldGVyIiwic2FtcGxlU3RhY2siLCJjb250cm9sU3RhY2siLCJzYW1wbGVMaW5lcyIsInNwbGl0IiwiY29udHJvbExpbmVzIiwiYyIsIl9mcmFtZSIsInN5bnRoZXRpY0ZyYW1lIiwiZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lIiwiY3RvciIsImRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSIsInNob3VsZENvbnN0cnVjdCQxIiwiQ29tcG9uZW50IiwiaXNSZWFjdENvbXBvbmVudCIsImRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFViIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50IiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJ3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQiLCJlbXB0eUNvbnRleHRPYmplY3QiLCJnZXRNYXNrZWRDb250ZXh0IiwidW5tYXNrZWRDb250ZXh0IiwiY29udGV4dFR5cGVzIiwicHJvY2Vzc0NoaWxkQ29udGV4dCIsImluc3RhbmNlIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJnZXRDaGlsZENvbnRleHQiLCJjaGlsZENvbnRleHQiLCJjb250ZXh0S2V5IiwicmVuZGVyZXJTaWdpbCIsInJvb3RDb250ZXh0U25hcHNob3QiLCJjdXJyZW50QWN0aXZlU25hcHNob3QiLCJwb3BOb2RlIiwicHJldiIsIl9jdXJyZW50VmFsdWUyIiwicGFyZW50VmFsdWUiLCJwdXNoTm9kZSIsInBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yIiwicGFyZW50UHJldiIsInBhcmVudCIsInBhcmVudE5leHQiLCJwb3BBbGxQcmV2aW91cyIsInB1c2hBbGxOZXh0IiwicG9wUHJldmlvdXNUb0NvbW1vbkxldmVsIiwiZGVwdGgiLCJwb3BOZXh0VG9Db21tb25MZXZlbCIsInN3aXRjaENvbnRleHQiLCJuZXdTbmFwc2hvdCIsInB1c2hQcm92aWRlciIsIm5leHRWYWx1ZSIsInByZXZWYWx1ZSIsIl9jdXJyZW50UmVuZGVyZXIyIiwicHJldk5vZGUiLCJuZXdOb2RlIiwicG9wUHJvdmlkZXIiLCJwcmV2U25hcHNob3QiLCJfdmFsdWUiLCJfZGVmYXVsdFZhbHVlIiwiZ2V0QWN0aXZlQ29udGV4dCIsInJlYWRDb250ZXh0JDEiLCJfcmVhY3RJbnRlcm5hbHMiLCJkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50IiwiZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudCIsImRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSIsImRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSIsImRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUiLCJkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzIiwiZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlIiwiZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrIiwid2Fybk9uSW52YWxpZENhbGxiYWNrIiwiY2FsbGVyTmFtZSIsIndhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZSIsInBhcnRpYWxTdGF0ZSIsIndhcm5Ob29wIiwicHVibGljSW5zdGFuY2UiLCJfY29uc3RydWN0b3IiLCJ3YXJuaW5nS2V5IiwiY2xhc3NDb21wb25lbnRVcGRhdGVyIiwiaXNNb3VudGVkIiwiaW5zdCIsImVucXVldWVTZXRTdGF0ZSIsImludGVybmFscyIsInF1ZXVlIiwiZW5xdWV1ZVJlcGxhY2VTdGF0ZSIsImVucXVldWVGb3JjZVVwZGF0ZSIsImFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwicHJldlN0YXRlIiwibmV4dFByb3BzIiwibmV3U3RhdGUiLCJjb25zdHJ1Y3RDbGFzc0luc3RhbmNlIiwibWFza2VkTGVnYWN5Q29udGV4dCIsImNvbnRleHRUeXBlIiwiYWRkZW5kdW0iLCJrZXlzIiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJmb3VuZFdpbGxNb3VudE5hbWUiLCJmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIiwiZm91bmRXaWxsVXBkYXRlTmFtZSIsImNvbXBvbmVudFdpbGxNb3VudCIsIl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmciLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIiwiX2NvbXBvbmVudE5hbWUiLCJuZXdBcGlOYW1lIiwiY2hlY2tDbGFzc0luc3RhbmNlIiwibmV3UHJvcHMiLCJyZW5kZXJQcmVzZW50IiwiZ2V0SW5pdGlhbFN0YXRlIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJnZXREZWZhdWx0UHJvcHMiLCJwcm9wVHlwZXMiLCJjb21wb25lbnRTaG91bGRVcGRhdGUiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsImNvbXBvbmVudERpZFVubW91bnQiLCJjb21wb25lbnREaWRSZWNlaXZlUHJvcHMiLCJjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJoYXNNdXRhdGVkUHJvcHMiLCJkZWZhdWx0UHJvcHMiLCJjb21wb25lbnREaWRVcGRhdGUiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJjYWxsQ29tcG9uZW50V2lsbE1vdW50Iiwib2xkU3RhdGUiLCJwcm9jZXNzVXBkYXRlUXVldWUiLCJpbnRlcm5hbEluc3RhbmNlIiwib2xkUXVldWUiLCJvbGRSZXBsYWNlIiwibmV4dFN0YXRlIiwiZG9udE11dGF0ZSIsInBhcnRpYWwiLCJtb3VudENsYXNzSW5zdGFuY2UiLCJpbml0aWFsU3RhdGUiLCJ1cGRhdGVyIiwiZW1wdHlUcmVlQ29udGV4dCIsImdldFRyZWVJZCIsImlkV2l0aExlYWRpbmdCaXQiLCJnZXRMZWFkaW5nQml0IiwicHVzaFRyZWVDb250ZXh0IiwiYmFzZUNvbnRleHQiLCJ0b3RhbENoaWxkcmVuIiwiYmFzZUlkV2l0aExlYWRpbmdCaXQiLCJiYXNlT3ZlcmZsb3ciLCJiYXNlTGVuZ3RoIiwiZ2V0Qml0TGVuZ3RoIiwiYmFzZUlkIiwic2xvdCIsIm51bWJlck9mT3ZlcmZsb3dCaXRzIiwibmV3T3ZlcmZsb3dCaXRzIiwibmV3T3ZlcmZsb3ciLCJyZXN0T2ZCYXNlSWQiLCJyZXN0T2ZCYXNlTGVuZ3RoIiwicmVzdE9mTGVuZ3RoIiwicmVzdE9mTmV3Qml0cyIsIm5ld0JpdHMiLCJfaWQiLCJfb3ZlcmZsb3ciLCJudW1iZXIiLCJjbHozMiIsIk1hdGgiLCJjbHozMkZhbGxiYWNrIiwiTE4yIiwiYXNVaW50IiwiU3VzcGVuc2VFeGNlcHRpb24iLCJjcmVhdGVUaGVuYWJsZVN0YXRlIiwibm9vcCQyIiwidHJhY2tVc2VkVGhlbmFibGUiLCJ0aGVuYWJsZVN0YXRlIiwidGhlbmFibGUiLCJwcmV2aW91cyIsInRoZW4iLCJzdGF0dXMiLCJmdWxmaWxsZWRWYWx1ZSIsInJlamVjdGVkRXJyb3IiLCJyZWFzb24iLCJwZW5kaW5nVGhlbmFibGUiLCJmdWxmaWxsZWRUaGVuYWJsZSIsInJlamVjdGVkVGhlbmFibGUiLCJzdXNwZW5kZWRUaGVuYWJsZSIsImdldFN1c3BlbmRlZFRoZW5hYmxlIiwib2JqZWN0SXMiLCJjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQiLCJjdXJyZW50bHlSZW5kZXJpbmdUYXNrIiwiY3VycmVudGx5UmVuZGVyaW5nUmVxdWVzdCIsImN1cnJlbnRseVJlbmRlcmluZ0tleVBhdGgiLCJmaXJzdFdvcmtJblByb2dyZXNzSG9vayIsIndvcmtJblByb2dyZXNzSG9vayIsImlzUmVSZW5kZXIiLCJkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlIiwibG9jYWxJZENvdW50ZXIiLCJmb3JtU3RhdGVDb3VudGVyIiwiZm9ybVN0YXRlTWF0Y2hpbmdJbmRleCIsInRoZW5hYmxlSW5kZXhDb3VudGVyIiwicmVuZGVyUGhhc2VVcGRhdGVzIiwibnVtYmVyT2ZSZVJlbmRlcnMiLCJSRV9SRU5ERVJfTElNSVQiLCJpc0luSG9va1VzZXJDb2RlSW5EZXYiLCJjdXJyZW50SG9va05hbWVJbkRldiIsInJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQiLCJhcmVIb29rSW5wdXRzRXF1YWwiLCJuZXh0RGVwcyIsInByZXZEZXBzIiwiY3JlYXRlSG9vayIsIm1lbW9pemVkU3RhdGUiLCJjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2siLCJwcmVwYXJlVG9Vc2VIb29rcyIsInRhc2siLCJrZXlQYXRoIiwiY29tcG9uZW50SWRlbnRpdHkiLCJwcmV2VGhlbmFibGVTdGF0ZSIsImZpbmlzaEhvb2tzIiwicmVmT3JDb250ZXh0IiwicmVzZXRIb29rc1N0YXRlIiwiZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZyIsImNoZWNrRGlkUmVuZGVySWRIb29rIiwiZGlkUmVuZGVySWRIb29rIiwiZ2V0Rm9ybVN0YXRlQ291bnQiLCJnZXRGb3JtU3RhdGVNYXRjaGluZ0luZGV4IiwicmVhZENvbnRleHQiLCJ1c2VDb250ZXh0IiwiYmFzaWNTdGF0ZVJlZHVjZXIiLCJ1c2VTdGF0ZSIsInVzZVJlZHVjZXIiLCJyZWR1Y2VyIiwiaW5pdGlhbEFyZyIsImRpc3BhdGNoIiwiZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSIsInVwZGF0ZSIsIl9xdWV1ZSIsImxhc3QiLCJfZGlzcGF0Y2giLCJkaXNwYXRjaEFjdGlvbiIsInVzZU1lbW8iLCJuZXh0Q3JlYXRlIiwiZGVwcyIsInVzZVJlZiIsImluaXRpYWxWYWx1ZSIsInByZXZpb3VzUmVmIiwicmVmIiwic2VhbCIsImxhc3RSZW5kZXJQaGFzZVVwZGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJzdWJzY3JpYmUiLCJnZXRTbmFwc2hvdCIsImdldFNlcnZlclNuYXBzaG90IiwidXNlRGVmZXJyZWRWYWx1ZSIsInVuc3VwcG9ydGVkU3RhcnRUcmFuc2l0aW9uIiwidXNlVHJhbnNpdGlvbiIsInVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzIiwidW5zdXBwb3J0ZWRTZXRPcHRpbWlzdGljU3RhdGUiLCJ1c2VPcHRpbWlzdGljIiwicGFzc3Rocm91Z2giLCJjcmVhdGVQb3N0YmFja0Zvcm1TdGF0ZUtleSIsInBlcm1hbGluayIsImNvbXBvbmVudEtleVBhdGgiLCJob29rSW5kZXgiLCJrZXlQYXRoSGFzaCIsInVzZUZvcm1TdGF0ZSIsImZvcm1TdGF0ZUhvb2tJbmRleCIsIm5leHRQb3N0YmFja1N0YXRlS2V5IiwicG9zdGJhY2tGb3JtU3RhdGUiLCJnZXRGb3JtU3RhdGUiLCJpc1NpZ25hdHVyZUVxdWFsIiwiJCRJU19TSUdOQVRVUkVfRVFVQUwiLCJwb3N0YmFja0tleSIsInBvc3RiYWNrUmVmZXJlbmNlSWQiLCJwb3N0YmFja0JvdW5kQXJpdHkiLCJib3VuZEFjdGlvbiIsIm1ldGFkYXRhIiwiYXBwZW5kIiwiX2JvdW5kQWN0aW9uIiwiX2Rpc3BhdGNoMiIsInVzZUlkIiwidHJlZUNvbnRleHQiLCJjdXJyZW50UmVzdW1hYmxlU3RhdGUiLCJ1c2UiLCJ1c2FibGUiLCJ1bndyYXBUaGVuYWJsZSIsInVuc3VwcG9ydGVkUmVmcmVzaCIsInVzZUNhY2hlUmVmcmVzaCIsIm5vb3AkMSIsIkhvb2tzRGlzcGF0Y2hlciIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VFZmZlY3QiLCJ1c2VEZWJ1Z1ZhbHVlIiwic2V0Q3VycmVudFJlc3VtYWJsZVN0YXRlIiwiZ2V0Q2FjaGVTaWduYWwiLCJnZXRDYWNoZUZvclR5cGUiLCJyZXNvdXJjZVR5cGUiLCJEZWZhdWx0Q2FjaGVEaXNwYXRjaGVyIiwiZ2V0U3RhY2tCeUNvbXBvbmVudFN0YWNrTm9kZSIsImNvbXBvbmVudFN0YWNrIiwibm9kZSIsIlJlYWN0Q3VycmVudENhY2hlIiwiQ0xJRU5UX1JFTkRFUkVEIiwiUEVORElORyIsIkNPTVBMRVRFRCIsIkZMVVNIRUQiLCJBQk9SVEVEIiwiRVJST1JFRCIsIlBPU1RQT05FRCIsIk9QRU4iLCJDTE9TSU5HIiwiQ0xPU0VEIiwiREVGQVVMVF9QUk9HUkVTU0lWRV9DSFVOS19TSVpFIiwiZGVmYXVsdEVycm9ySGFuZGxlciIsIm5vb3AiLCJjcmVhdGVSZXF1ZXN0Iiwicm9vdEZvcm1hdENvbnRleHQiLCJwcm9ncmVzc2l2ZUNodW5rU2l6ZSIsIm9uQWxsUmVhZHkiLCJvblNoZWxsUmVhZHkiLCJvblNoZWxsRXJyb3IiLCJvbkZhdGFsRXJyb3IiLCJvblBvc3Rwb25lIiwiZm9ybVN0YXRlIiwicGluZ2VkVGFza3MiLCJhYm9ydFNldCIsImZsdXNoU2NoZWR1bGVkIiwiZmF0YWxFcnJvciIsIm5leHRTZWdtZW50SWQiLCJhbGxQZW5kaW5nVGFza3MiLCJwZW5kaW5nUm9vdFRhc2tzIiwiY29tcGxldGVkUm9vdFNlZ21lbnQiLCJhYm9ydGFibGVUYXNrcyIsImNsaWVudFJlbmRlcmVkQm91bmRhcmllcyIsImNvbXBsZXRlZEJvdW5kYXJpZXMiLCJwYXJ0aWFsQm91bmRhcmllcyIsInRyYWNrZWRQb3N0cG9uZXMiLCJyb290U2VnbWVudCIsImNyZWF0ZVBlbmRpbmdTZWdtZW50IiwicGFyZW50Rmx1c2hlZCIsInJvb3RUYXNrIiwiY3JlYXRlUmVuZGVyVGFzayIsImN1cnJlbnRSZXF1ZXN0IiwicGluZ1Rhc2siLCJwZXJmb3JtV29yayIsImNyZWF0ZVN1c3BlbnNlQm91bmRhcnkiLCJmYWxsYmFja0Fib3J0YWJsZVRhc2tzIiwicm9vdFNlZ21lbnRJRCIsInBlbmRpbmdUYXNrcyIsImNvbXBsZXRlZFNlZ21lbnRzIiwiYnl0ZVNpemUiLCJ0cmFja2VkQ29udGVudEtleVBhdGgiLCJ0cmFja2VkRmFsbGJhY2tOb2RlIiwiY2hpbGRJbmRleCIsImJsb2NrZWRCb3VuZGFyeSIsImJsb2NrZWRTZWdtZW50IiwibGVnYWN5Q29udGV4dCIsInJlcGxheSIsInBpbmciLCJjcmVhdGVSZXBsYXlUYXNrIiwiYm91bmRhcnkiLCJwYXJlbnRGb3JtYXRDb250ZXh0IiwiY3VycmVudFRhc2tJbkRFViIsImdldEN1cnJlbnRTdGFja0luREVWIiwiZ2V0U3RhY2tGcm9tTm9kZSIsInN0YWNrTm9kZSIsImNyZWF0ZUJ1aWx0SW5Db21wb25lbnRTdGFjayIsImNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50U3RhY2siLCJjcmVhdGVDbGFzc0NvbXBvbmVudFN0YWNrIiwiZ2V0VGhyb3duSW5mbyIsImVuY29kZUVycm9yRm9yQm91bmRhcnkiLCJkaWdlc3QiLCJ0aHJvd25JbmZvIiwibG9nUmVjb3ZlcmFibGVFcnJvciIsImVycm9ySW5mbyIsInJlbmRlclN1c3BlbnNlQm91bmRhcnkiLCJzb21lVGFzayIsIl9wcmV2S2V5UGF0aCIsIl9jb250ZW50IiwicmVuZGVyTm9kZSIsInByZXZpb3VzQ29tcG9uZW50U3RhY2siLCJzdXNwZW5zZUNvbXBvbmVudFN0YWNrIiwicHJldktleVBhdGgiLCJwYXJlbnRCb3VuZGFyeSIsInBhcmVudFNlZ21lbnQiLCJmYWxsYmFjayIsImZhbGxiYWNrQWJvcnRTZXQiLCJuZXdCb3VuZGFyeSIsImluc2VydGlvbkluZGV4IiwiYm91bmRhcnlTZWdtZW50IiwiY29udGVudFJvb3RTZWdtZW50IiwicXVldWVDb21wbGV0ZWRTZWdtZW50IiwidW50cmFja0JvdW5kYXJ5IiwiZmFsbGJhY2tLZXlQYXRoIiwiZmFsbGJhY2tSZXBsYXlOb2RlIiwid29ya2luZ01hcCIsImJvdW5kYXJ5UmVwbGF5Tm9kZSIsInN1c3BlbmRlZEZhbGxiYWNrVGFzayIsInJlcGxheVN1c3BlbnNlQm91bmRhcnkiLCJjaGlsZE5vZGVzIiwiY2hpbGRTbG90cyIsImZhbGxiYWNrTm9kZXMiLCJmYWxsYmFja1Nsb3RzIiwicHJldmlvdXNSZXBsYXlTZXQiLCJyZXN1bWVkQm91bmRhcnkiLCJub2RlcyIsInNsb3RzIiwiZmFsbGJhY2tSZXBsYXkiLCJyZW5kZXJIb3N0RWxlbWVudCIsInNlZ21lbnQiLCJwcmV2Q29udGV4dCIsIl9jaGlsZHJlbiIsIl9wcmV2Q29udGV4dCIsIl9wcmV2S2V5UGF0aDIiLCJzaG91bGRDb25zdHJ1Y3QiLCJyZW5kZXJXaXRoSG9va3MiLCJzZWNvbmRBcmciLCJmaW5pc2hDbGFzc0NvbXBvbmVudCIsIm5leHRDaGlsZHJlbiIsImRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMiLCJwcmV2aW91c0NvbnRleHQiLCJtZXJnZWRDb250ZXh0IiwicmVuZGVyTm9kZURlc3RydWN0aXZlIiwicmVuZGVyQ2xhc3NDb21wb25lbnQiLCJtYXNrZWRDb250ZXh0IiwiZGlkV2FybkFib3V0QmFkQ2xhc3MiLCJkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50IiwiZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dERlZmF1bHRQcm9wc09uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRHZW5lcmF0b3JzIiwiZGlkV2FybkFib3V0TWFwcyIsImhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciIsInJlbmRlckluZGV0ZXJtaW5hdGVDb21wb25lbnQiLCJoYXNJZCIsImZvcm1TdGF0ZUNvdW50IiwiX2NvbXBvbmVudE5hbWUyIiwidmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2IiwiZmluaXNoRnVuY3Rpb25Db21wb25lbnQiLCJkaWRFbWl0Rm9ybVN0YXRlTWFya2VycyIsInByZXZUcmVlQ29udGV4dCIsIl9jb21wb25lbnROYW1lMyIsIl9jb21wb25lbnROYW1lNCIsInJlc29sdmVEZWZhdWx0UHJvcHMiLCJiYXNlUHJvcHMiLCJyZW5kZXJGb3J3YXJkUmVmIiwicmVuZGVyTWVtbyIsInJlc29sdmVkUHJvcHMiLCJyZW5kZXJFbGVtZW50IiwicmVuZGVyQ29udGV4dENvbnN1bWVyIiwiQ29uc3VtZXIiLCJuZXdWYWx1ZSIsIm5ld0NoaWxkcmVuIiwicmVuZGVyQ29udGV4dFByb3ZpZGVyIiwicmVuZGVyTGF6eUNvbXBvbmVudCIsInJlbmRlck9mZnNjcmVlbiIsInByZWlvdXNDb21wb25lbnRTdGFjayIsIl9wcmV2S2V5UGF0aDMiLCJyZXN1bWVOb2RlIiwic2VnbWVudElkIiwicHJldlJlcGxheSIsInJlc3VtZWRTZWdtZW50IiwicmVuZGVyVGFzayIsInJlcGxheUVsZW1lbnQiLCJrZXlPckluZGV4IiwicmVwbGF5Tm9kZXMiLCJjdXJyZW50Tm9kZSIsImVycm9yZWRSZXBsYXkiLCJleHBlY3RlZFR5cGUiLCJzcGxpY2UiLCJ2YWxpZGF0ZUl0ZXJhYmxlIiwiaXRlcmFibGUiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInJlc3VtZVNlZ21lbnRJRCIsImxhenlOb2RlIiwicmVzb2x2ZWROb2RlIiwicmVuZGVyQ2hpbGRyZW5BcnJheSIsIm1heWJlVXNhYmxlIiwiY2hpbGRTdHJpbmciLCJfc2VnbWVudCIsInJlcGxheUZyYWdtZW50IiwiaiIsInJlc3VtZVNsb3RzIiwiX25vZGUiLCJib3VuZGFyeUtleVBhdGgiLCJib3VuZGFyeU5vZGUiLCJzcGF3bk5ld1N1c3BlbmRlZFJlcGxheVRhc2siLCJuZXdUYXNrIiwic3Bhd25OZXdTdXNwZW5kZWRSZW5kZXJUYXNrIiwibmV3U2VnbWVudCIsInByZXZpb3VzRm9ybWF0Q29udGV4dCIsInByZXZpb3VzTGVnYWN5Q29udGV4dCIsInByZXZpb3VzS2V5UGF0aCIsInByZXZpb3VzVHJlZUNvbnRleHQiLCJ0aHJvd25WYWx1ZSIsIndha2VhYmxlIiwiY2hpbGRyZW5MZW5ndGgiLCJjaHVua0xlbmd0aCIsIl93YWtlYWJsZSIsIl90aGVuYWJsZVN0YXRlIiwiYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyIsImVycm9yZWRUYXNrIiwiY29tcGxldGVBbGwiLCJhYm9ydFRhc2tTb2Z0IiwiZmluaXNoZWRUYXNrIiwiYWJvcnRSZW1haW5pbmdTdXNwZW5zZUJvdW5kYXJ5IiwiZXJyb3JQcmVmaXgiLCJhYm9ydFRhc2siLCJjb21wbGV0ZVNoZWxsIiwiX2Vycm9ySW5mbyIsIl9lcnJvckRpZ2VzdCIsImZhbGxiYWNrVGFzayIsInNhZmVseUVtaXRFYXJseVByZWxvYWRzIiwiY2hpbGRTZWdtZW50IiwicmV0cnlUYXNrIiwicmV0cnlSZXBsYXlUYXNrIiwicmV0cnlSZW5kZXJUYXNrIiwicHJldlRhc2tJbkRFViIsInByZXZEaXNwYXRjaGVyIiwicHJldkNhY2hlRGlzcGF0Y2hlciIsInByZXZSZXF1ZXN0IiwicHJldkdldEN1cnJlbnRTdGFja0ltcGwiLCJnZXRDdXJyZW50U3RhY2siLCJwcmV2UmVzdW1hYmxlU3RhdGUiLCJmbHVzaENvbXBsZXRlZFF1ZXVlcyIsImZsdXNoU3VidHJlZSIsInNlZ21lbnRJRCIsImNodW5rSWR4IiwiY2hpbGRJZHgiLCJuZXh0Q2hpbGQiLCJmbHVzaFNlZ21lbnQiLCJjb250ZW50U2VnbWVudCIsImZsdXNoQ2xpZW50UmVuZGVyZWRCb3VuZGFyeSIsImZsdXNoU2VnbWVudENvbnRhaW5lciIsImZsdXNoQ29tcGxldGVkQm91bmRhcnkiLCJmbHVzaFBhcnRpYWxseUNvbXBsZXRlZFNlZ21lbnQiLCJmbHVzaFBhcnRpYWxCb3VuZGFyeSIsIl9ib3VuZGFyeSIsIl9ib3VuZGFyeTIiLCJsYXJnZUJvdW5kYXJpZXMiLCJfYm91bmRhcnkzIiwic3RvcEZsb3dpbmciLCJzdGFydFdvcmsiLCJlbnF1ZXVlRWFybHlQcmVsb2Fkc0FmdGVySW5pdGlhbFdvcmsiLCJlbnF1ZXVlRmx1c2giLCJzdGFydEZsb3dpbmciLCJhYm9ydCIsInJlbmRlclRvU3RyaW5nSW1wbCIsImFib3J0UmVhc29uIiwiZGlkRmF0YWwiLCJyZWFkeVRvU3RyZWFtIiwiSW5maW5pdHkiLCJyZW5kZXJUb1N0cmluZyIsInJlbmRlclRvU3RhdGljTWFya3VwIiwicmVuZGVyVG9Ob2RlU3RyZWFtIiwicmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.browser.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.browser.development.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.browser.development.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * @license React\n * react-dom-server.browser.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        var _s = $RefreshSig$(), _s1 = $RefreshSig$();\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        var ReactDOM = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n        var ReactVersion = \"18.3.0-canary-60a927d04-20240113\";\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        // by calls to these methods by a Babel plugin.\n        //\n        // In PROD (or in packages without access to React internals),\n        // they are left as they are instead.\n        function warn(format) {\n            {\n                {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    printWarning(\"warn\", format, args);\n                }\n            }\n        }\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // A pure JS implementation of a string hashing function. We do not use it for\n        // security or obfuscation purposes, only to create compact hashes. So we\n        // prioritize speed over collision avoidance. For example, we use this to hash\n        // the component key path used by useFormState for MPA-style submissions.\n        //\n        // In environments where built-in hashing functions are available, we prefer\n        // those instead. Like Node's crypto module, or Bun.hash. Unfortunately this\n        // does not include the web standard crypto API because those methods are all\n        // async. For our purposes, we need it to be sync because the cost of context\n        // switching is too high to be worth it.\n        //\n        // The most popular hashing algorithm that meets these requirements in the JS\n        // ecosystem is MurmurHash3, and almost all implementations I could find used\n        // some version of the implementation by Gary Court inlined below.\n        function createFastHashJS(key) {\n            return murmurhash3_32_gc(key, 0);\n        }\n        /* eslint-disable prefer-const, no-fallthrough */ /**\n * @license\n *\n * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\n *\n * Copyright (c) 2011 Gary Court\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */ function murmurhash3_32_gc(key, seed) {\n            var remainder, bytes, h1, h1b, c1, c2, k1, i;\n            remainder = key.length & 3; // key.length % 4\n            bytes = key.length - remainder;\n            h1 = seed;\n            c1 = 0xcc9e2d51;\n            c2 = 0x1b873593;\n            i = 0;\n            while(i < bytes){\n                k1 = key.charCodeAt(i) & 0xff | (key.charCodeAt(++i) & 0xff) << 8 | (key.charCodeAt(++i) & 0xff) << 16 | (key.charCodeAt(++i) & 0xff) << 24;\n                ++i;\n                k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;\n                h1 ^= k1;\n                h1 = h1 << 13 | h1 >>> 19;\n                h1b = (h1 & 0xffff) * 5 + (((h1 >>> 16) * 5 & 0xffff) << 16) & 0xffffffff;\n                h1 = (h1b & 0xffff) + 0x6b64 + (((h1b >>> 16) + 0xe654 & 0xffff) << 16);\n            }\n            k1 = 0;\n            switch(remainder){\n                case 3:\n                    k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;\n                case 2:\n                    k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;\n                case 1:\n                    k1 ^= key.charCodeAt(i) & 0xff;\n                    k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;\n                    k1 = k1 << 15 | k1 >>> 17;\n                    k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;\n                    h1 ^= k1;\n            }\n            h1 ^= key.length;\n            h1 ^= h1 >>> 16;\n            h1 = (h1 & 0xffff) * 0x85ebca6b + (((h1 >>> 16) * 0x85ebca6b & 0xffff) << 16) & 0xffffffff;\n            h1 ^= h1 >>> 13;\n            h1 = (h1 & 0xffff) * 0xc2b2ae35 + (((h1 >>> 16) * 0xc2b2ae35 & 0xffff) << 16) & 0xffffffff;\n            h1 ^= h1 >>> 16;\n            return h1 >>> 0;\n        }\n        function scheduleWork(callback) {\n            callback();\n        }\n        var VIEW_SIZE = 512;\n        var currentView = null;\n        var writtenBytes = 0;\n        function beginWriting(destination) {\n            currentView = new Uint8Array(VIEW_SIZE);\n            writtenBytes = 0;\n        }\n        function writeChunk(destination, chunk) {\n            if (chunk.byteLength === 0) {\n                return;\n            }\n            if (chunk.byteLength > VIEW_SIZE) {\n                {\n                    if (precomputedChunkSet.has(chunk)) {\n                        error(\"A large precomputed chunk was passed to writeChunk without being copied.\" + \" Large chunks get enqueued directly and are not copied. This is incompatible with precomputed chunks because you cannot enqueue the same precomputed chunk twice.\" + ' Use \"cloneChunk\" to make a copy of this large precomputed chunk before writing it. This is a bug in React.');\n                    }\n                }\n                // one that is cached by the streaming renderer. We will enqueu\n                // it directly and expect it is not re-used\n                if (writtenBytes > 0) {\n                    destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));\n                    currentView = new Uint8Array(VIEW_SIZE);\n                    writtenBytes = 0;\n                }\n                destination.enqueue(chunk);\n                return;\n            }\n            var bytesToWrite = chunk;\n            var allowableBytes = currentView.length - writtenBytes;\n            if (allowableBytes < bytesToWrite.byteLength) {\n                // this chunk would overflow the current view. We enqueue a full view\n                // and start a new view with the remaining chunk\n                if (allowableBytes === 0) {\n                    // the current view is already full, send it\n                    destination.enqueue(currentView);\n                } else {\n                    // fill up the current view and apply the remaining chunk bytes\n                    // to a new view.\n                    currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes); // writtenBytes += allowableBytes; // this can be skipped because we are going to immediately reset the view\n                    destination.enqueue(currentView);\n                    bytesToWrite = bytesToWrite.subarray(allowableBytes);\n                }\n                currentView = new Uint8Array(VIEW_SIZE);\n                writtenBytes = 0;\n            }\n            currentView.set(bytesToWrite, writtenBytes);\n            writtenBytes += bytesToWrite.byteLength;\n        }\n        function writeChunkAndReturn(destination, chunk) {\n            writeChunk(destination, chunk); // in web streams there is no backpressure so we can alwas write more\n            return true;\n        }\n        function completeWriting(destination) {\n            if (currentView && writtenBytes > 0) {\n                destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));\n                currentView = null;\n                writtenBytes = 0;\n            }\n        }\n        function close(destination) {\n            destination.close();\n        }\n        var textEncoder = new TextEncoder();\n        function stringToChunk(content) {\n            return textEncoder.encode(content);\n        }\n        var precomputedChunkSet = new Set();\n        function stringToPrecomputedChunk(content) {\n            var precomputedChunk = textEncoder.encode(content);\n            {\n                precomputedChunkSet.add(precomputedChunk);\n            }\n            return precomputedChunk;\n        }\n        function clonePrecomputedChunk(precomputedChunk) {\n            return precomputedChunk.byteLength > VIEW_SIZE ? precomputedChunk.slice() : precomputedChunk;\n        }\n        function closeWithError(destination, error) {\n            // $FlowFixMe[method-unbinding]\n            if (typeof destination.error === \"function\") {\n                // $FlowFixMe[incompatible-call]: This is an Error object or the destination accepts other types.\n                destination.error(error);\n            } else {\n                // Earlier implementations doesn't support this method. In that environment you're\n                // supposed to throw from a promise returned but we don't return a promise in our\n                // approach. We could fork this implementation but this is environment is an edge\n                // case to begin with. It's even less common to run this in an older environment.\n                // Even then, this is not where errors are supposed to happen and they get reported\n                // to a global callback in addition to this anyway. So it's fine just to close this.\n                destination.close();\n            }\n        }\n        var assign = Object.assign;\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkAttributeStringCoercion(value, attributeName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` attribute is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", attributeName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkOptionStringCoercion(value, propName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` option is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", propName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkCSSPropertyStringCoercion(value, propName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` CSS property is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", propName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkHtmlStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided HTML markup uses a value of unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableFloat = true; // Enables unstable_useMemoCache hook, intended as a compilation target for\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        /* eslint-disable max-len */ var ATTRIBUTE_NAME_START_CHAR = \":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n        /* eslint-enable max-len */ var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + \"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp(\"^[\" + ATTRIBUTE_NAME_START_CHAR + \"][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var illegalAttributeNameCache = {};\n        var validatedAttributeNameCache = {};\n        function isAttributeNameSafe(attributeName) {\n            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {\n                return true;\n            }\n            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {\n                return false;\n            }\n            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n                validatedAttributeNameCache[attributeName] = true;\n                return true;\n            }\n            illegalAttributeNameCache[attributeName] = true;\n            {\n                error(\"Invalid attribute name: `%s`\", attributeName);\n            }\n            return false;\n        }\n        /**\n * CSS properties which accept numbers but are not in units of \"px\".\n */ var unitlessNumbers = new Set([\n            \"animationIterationCount\",\n            \"aspectRatio\",\n            \"borderImageOutset\",\n            \"borderImageSlice\",\n            \"borderImageWidth\",\n            \"boxFlex\",\n            \"boxFlexGroup\",\n            \"boxOrdinalGroup\",\n            \"columnCount\",\n            \"columns\",\n            \"flex\",\n            \"flexGrow\",\n            \"flexPositive\",\n            \"flexShrink\",\n            \"flexNegative\",\n            \"flexOrder\",\n            \"gridArea\",\n            \"gridRow\",\n            \"gridRowEnd\",\n            \"gridRowSpan\",\n            \"gridRowStart\",\n            \"gridColumn\",\n            \"gridColumnEnd\",\n            \"gridColumnSpan\",\n            \"gridColumnStart\",\n            \"fontWeight\",\n            \"lineClamp\",\n            \"lineHeight\",\n            \"opacity\",\n            \"order\",\n            \"orphans\",\n            \"scale\",\n            \"tabSize\",\n            \"widows\",\n            \"zIndex\",\n            \"zoom\",\n            \"fillOpacity\",\n            \"floodOpacity\",\n            \"stopOpacity\",\n            \"strokeDasharray\",\n            \"strokeDashoffset\",\n            \"strokeMiterlimit\",\n            \"strokeOpacity\",\n            \"strokeWidth\",\n            \"MozAnimationIterationCount\",\n            \"MozBoxFlex\",\n            \"MozBoxFlexGroup\",\n            \"MozLineClamp\",\n            \"msAnimationIterationCount\",\n            \"msFlex\",\n            \"msZoom\",\n            \"msFlexGrow\",\n            \"msFlexNegative\",\n            \"msFlexOrder\",\n            \"msFlexPositive\",\n            \"msFlexShrink\",\n            \"msGridColumn\",\n            \"msGridColumnSpan\",\n            \"msGridRow\",\n            \"msGridRowSpan\",\n            \"WebkitAnimationIterationCount\",\n            \"WebkitBoxFlex\",\n            \"WebKitBoxFlexGroup\",\n            \"WebkitBoxOrdinalGroup\",\n            \"WebkitColumnCount\",\n            \"WebkitColumns\",\n            \"WebkitFlex\",\n            \"WebkitFlexGrow\",\n            \"WebkitFlexPositive\",\n            \"WebkitFlexShrink\",\n            \"WebkitLineClamp\"\n        ]);\n        function isUnitlessNumber(name) {\n            return unitlessNumbers.has(name);\n        }\n        var aliases = new Map([\n            [\n                \"acceptCharset\",\n                \"accept-charset\"\n            ],\n            [\n                \"htmlFor\",\n                \"for\"\n            ],\n            [\n                \"httpEquiv\",\n                \"http-equiv\"\n            ],\n            [\n                \"crossOrigin\",\n                \"crossorigin\"\n            ],\n            // Regular attributes that just accept strings.],\n            [\n                \"accentHeight\",\n                \"accent-height\"\n            ],\n            [\n                \"alignmentBaseline\",\n                \"alignment-baseline\"\n            ],\n            [\n                \"arabicForm\",\n                \"arabic-form\"\n            ],\n            [\n                \"baselineShift\",\n                \"baseline-shift\"\n            ],\n            [\n                \"capHeight\",\n                \"cap-height\"\n            ],\n            [\n                \"clipPath\",\n                \"clip-path\"\n            ],\n            [\n                \"clipRule\",\n                \"clip-rule\"\n            ],\n            [\n                \"colorInterpolation\",\n                \"color-interpolation\"\n            ],\n            [\n                \"colorInterpolationFilters\",\n                \"color-interpolation-filters\"\n            ],\n            [\n                \"colorProfile\",\n                \"color-profile\"\n            ],\n            [\n                \"colorRendering\",\n                \"color-rendering\"\n            ],\n            [\n                \"dominantBaseline\",\n                \"dominant-baseline\"\n            ],\n            [\n                \"enableBackground\",\n                \"enable-background\"\n            ],\n            [\n                \"fillOpacity\",\n                \"fill-opacity\"\n            ],\n            [\n                \"fillRule\",\n                \"fill-rule\"\n            ],\n            [\n                \"floodColor\",\n                \"flood-color\"\n            ],\n            [\n                \"floodOpacity\",\n                \"flood-opacity\"\n            ],\n            [\n                \"fontFamily\",\n                \"font-family\"\n            ],\n            [\n                \"fontSize\",\n                \"font-size\"\n            ],\n            [\n                \"fontSizeAdjust\",\n                \"font-size-adjust\"\n            ],\n            [\n                \"fontStretch\",\n                \"font-stretch\"\n            ],\n            [\n                \"fontStyle\",\n                \"font-style\"\n            ],\n            [\n                \"fontVariant\",\n                \"font-variant\"\n            ],\n            [\n                \"fontWeight\",\n                \"font-weight\"\n            ],\n            [\n                \"glyphName\",\n                \"glyph-name\"\n            ],\n            [\n                \"glyphOrientationHorizontal\",\n                \"glyph-orientation-horizontal\"\n            ],\n            [\n                \"glyphOrientationVertical\",\n                \"glyph-orientation-vertical\"\n            ],\n            [\n                \"horizAdvX\",\n                \"horiz-adv-x\"\n            ],\n            [\n                \"horizOriginX\",\n                \"horiz-origin-x\"\n            ],\n            [\n                \"imageRendering\",\n                \"image-rendering\"\n            ],\n            [\n                \"letterSpacing\",\n                \"letter-spacing\"\n            ],\n            [\n                \"lightingColor\",\n                \"lighting-color\"\n            ],\n            [\n                \"markerEnd\",\n                \"marker-end\"\n            ],\n            [\n                \"markerMid\",\n                \"marker-mid\"\n            ],\n            [\n                \"markerStart\",\n                \"marker-start\"\n            ],\n            [\n                \"overlinePosition\",\n                \"overline-position\"\n            ],\n            [\n                \"overlineThickness\",\n                \"overline-thickness\"\n            ],\n            [\n                \"paintOrder\",\n                \"paint-order\"\n            ],\n            [\n                \"panose-1\",\n                \"panose-1\"\n            ],\n            [\n                \"pointerEvents\",\n                \"pointer-events\"\n            ],\n            [\n                \"renderingIntent\",\n                \"rendering-intent\"\n            ],\n            [\n                \"shapeRendering\",\n                \"shape-rendering\"\n            ],\n            [\n                \"stopColor\",\n                \"stop-color\"\n            ],\n            [\n                \"stopOpacity\",\n                \"stop-opacity\"\n            ],\n            [\n                \"strikethroughPosition\",\n                \"strikethrough-position\"\n            ],\n            [\n                \"strikethroughThickness\",\n                \"strikethrough-thickness\"\n            ],\n            [\n                \"strokeDasharray\",\n                \"stroke-dasharray\"\n            ],\n            [\n                \"strokeDashoffset\",\n                \"stroke-dashoffset\"\n            ],\n            [\n                \"strokeLinecap\",\n                \"stroke-linecap\"\n            ],\n            [\n                \"strokeLinejoin\",\n                \"stroke-linejoin\"\n            ],\n            [\n                \"strokeMiterlimit\",\n                \"stroke-miterlimit\"\n            ],\n            [\n                \"strokeOpacity\",\n                \"stroke-opacity\"\n            ],\n            [\n                \"strokeWidth\",\n                \"stroke-width\"\n            ],\n            [\n                \"textAnchor\",\n                \"text-anchor\"\n            ],\n            [\n                \"textDecoration\",\n                \"text-decoration\"\n            ],\n            [\n                \"textRendering\",\n                \"text-rendering\"\n            ],\n            [\n                \"transformOrigin\",\n                \"transform-origin\"\n            ],\n            [\n                \"underlinePosition\",\n                \"underline-position\"\n            ],\n            [\n                \"underlineThickness\",\n                \"underline-thickness\"\n            ],\n            [\n                \"unicodeBidi\",\n                \"unicode-bidi\"\n            ],\n            [\n                \"unicodeRange\",\n                \"unicode-range\"\n            ],\n            [\n                \"unitsPerEm\",\n                \"units-per-em\"\n            ],\n            [\n                \"vAlphabetic\",\n                \"v-alphabetic\"\n            ],\n            [\n                \"vHanging\",\n                \"v-hanging\"\n            ],\n            [\n                \"vIdeographic\",\n                \"v-ideographic\"\n            ],\n            [\n                \"vMathematical\",\n                \"v-mathematical\"\n            ],\n            [\n                \"vectorEffect\",\n                \"vector-effect\"\n            ],\n            [\n                \"vertAdvY\",\n                \"vert-adv-y\"\n            ],\n            [\n                \"vertOriginX\",\n                \"vert-origin-x\"\n            ],\n            [\n                \"vertOriginY\",\n                \"vert-origin-y\"\n            ],\n            [\n                \"wordSpacing\",\n                \"word-spacing\"\n            ],\n            [\n                \"writingMode\",\n                \"writing-mode\"\n            ],\n            [\n                \"xmlnsXlink\",\n                \"xmlns:xlink\"\n            ],\n            [\n                \"xHeight\",\n                \"x-height\"\n            ]\n        ]);\n        function getAttributeAlias(name) {\n            return aliases.get(name) || name;\n        }\n        var hasReadOnlyValue = {\n            button: true,\n            checkbox: true,\n            image: true,\n            hidden: true,\n            radio: true,\n            reset: true,\n            submit: true\n        };\n        function checkControlledValueProps(tagName, props) {\n            {\n                if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {\n                    if (tagName === \"select\") {\n                        error(\"You provided a `value` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultValue`. Otherwise, set `onChange`.\");\n                    } else {\n                        error(\"You provided a `value` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.\");\n                    }\n                }\n                if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {\n                    error(\"You provided a `checked` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultChecked`. Otherwise, \" + \"set either `onChange` or `readOnly`.\");\n                }\n            }\n        }\n        var ariaProperties = {\n            \"aria-current\": 0,\n            // state\n            \"aria-description\": 0,\n            \"aria-details\": 0,\n            \"aria-disabled\": 0,\n            // state\n            \"aria-hidden\": 0,\n            // state\n            \"aria-invalid\": 0,\n            // state\n            \"aria-keyshortcuts\": 0,\n            \"aria-label\": 0,\n            \"aria-roledescription\": 0,\n            // Widget Attributes\n            \"aria-autocomplete\": 0,\n            \"aria-checked\": 0,\n            \"aria-expanded\": 0,\n            \"aria-haspopup\": 0,\n            \"aria-level\": 0,\n            \"aria-modal\": 0,\n            \"aria-multiline\": 0,\n            \"aria-multiselectable\": 0,\n            \"aria-orientation\": 0,\n            \"aria-placeholder\": 0,\n            \"aria-pressed\": 0,\n            \"aria-readonly\": 0,\n            \"aria-required\": 0,\n            \"aria-selected\": 0,\n            \"aria-sort\": 0,\n            \"aria-valuemax\": 0,\n            \"aria-valuemin\": 0,\n            \"aria-valuenow\": 0,\n            \"aria-valuetext\": 0,\n            // Live Region Attributes\n            \"aria-atomic\": 0,\n            \"aria-busy\": 0,\n            \"aria-live\": 0,\n            \"aria-relevant\": 0,\n            // Drag-and-Drop Attributes\n            \"aria-dropeffect\": 0,\n            \"aria-grabbed\": 0,\n            // Relationship Attributes\n            \"aria-activedescendant\": 0,\n            \"aria-colcount\": 0,\n            \"aria-colindex\": 0,\n            \"aria-colspan\": 0,\n            \"aria-controls\": 0,\n            \"aria-describedby\": 0,\n            \"aria-errormessage\": 0,\n            \"aria-flowto\": 0,\n            \"aria-labelledby\": 0,\n            \"aria-owns\": 0,\n            \"aria-posinset\": 0,\n            \"aria-rowcount\": 0,\n            \"aria-rowindex\": 0,\n            \"aria-rowspan\": 0,\n            \"aria-setsize\": 0\n        };\n        var warnedProperties$1 = {};\n        var rARIA$1 = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var rARIACamel$1 = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        function validateProperty$1(tagName, name) {\n            {\n                if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n                    return true;\n                }\n                if (rARIACamel$1.test(name)) {\n                    var ariaName = \"aria-\" + name.slice(4).toLowerCase();\n                    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n                    // DOM properties, then it is an invalid aria-* attribute.\n                    if (correctName == null) {\n                        error(\"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\", name);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    } // aria-* attributes should be lowercase; suggest the lowercase version.\n                    if (name !== correctName) {\n                        error(\"Invalid ARIA attribute `%s`. Did you mean `%s`?\", name, correctName);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    }\n                }\n                if (rARIA$1.test(name)) {\n                    var lowerCasedName = name.toLowerCase();\n                    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n                    // DOM properties, then it is an invalid aria-* attribute.\n                    if (standardName == null) {\n                        warnedProperties$1[name] = true;\n                        return false;\n                    } // aria-* attributes should be lowercase; suggest the lowercase version.\n                    if (name !== standardName) {\n                        error(\"Unknown ARIA attribute `%s`. Did you mean `%s`?\", name, standardName);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    }\n                }\n            }\n            return true;\n        }\n        function validateProperties$2(type, props) {\n            {\n                var invalidProps = [];\n                for(var key in props){\n                    var isValid = validateProperty$1(type, key);\n                    if (!isValid) {\n                        invalidProps.push(key);\n                    }\n                }\n                var unknownPropString = invalidProps.map(function(prop) {\n                    return \"`\" + prop + \"`\";\n                }).join(\", \");\n                if (invalidProps.length === 1) {\n                    error(\"Invalid aria prop %s on <%s> tag. \" + \"For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n                } else if (invalidProps.length > 1) {\n                    error(\"Invalid aria props %s on <%s> tag. \" + \"For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n                }\n            }\n        }\n        var didWarnValueNull = false;\n        function validateProperties$1(type, props) {\n            {\n                if (type !== \"input\" && type !== \"textarea\" && type !== \"select\") {\n                    return;\n                }\n                if (props != null && props.value === null && !didWarnValueNull) {\n                    didWarnValueNull = true;\n                    if (type === \"select\" && props.multiple) {\n                        error(\"`value` prop on `%s` should not be null. \" + \"Consider using an empty array when `multiple` is set to `true` \" + \"to clear the component or `undefined` for uncontrolled components.\", type);\n                    } else {\n                        error(\"`value` prop on `%s` should not be null. \" + \"Consider using an empty string to clear the component or `undefined` \" + \"for uncontrolled components.\", type);\n                    }\n                }\n            }\n        }\n        function isCustomElement(tagName, props) {\n            if (tagName.indexOf(\"-\") === -1) {\n                return false;\n            }\n            switch(tagName){\n                // These are reserved SVG and MathML elements.\n                // We don't mind this list too much because we expect it to never grow.\n                // The alternative is to track the namespace in a few places which is convoluted.\n                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n                case \"annotation-xml\":\n                case \"color-profile\":\n                case \"font-face\":\n                case \"font-face-src\":\n                case \"font-face-uri\":\n                case \"font-face-format\":\n                case \"font-face-name\":\n                case \"missing-glyph\":\n                    return false;\n                default:\n                    return true;\n            }\n        }\n        // When adding attributes to the HTML or SVG allowed attribute list, be sure to\n        // also add them to this module to ensure casing and incorrect name\n        // warnings.\n        var possibleStandardNames = {\n            // HTML\n            accept: \"accept\",\n            acceptcharset: \"acceptCharset\",\n            \"accept-charset\": \"acceptCharset\",\n            accesskey: \"accessKey\",\n            action: \"action\",\n            allowfullscreen: \"allowFullScreen\",\n            alt: \"alt\",\n            as: \"as\",\n            async: \"async\",\n            autocapitalize: \"autoCapitalize\",\n            autocomplete: \"autoComplete\",\n            autocorrect: \"autoCorrect\",\n            autofocus: \"autoFocus\",\n            autoplay: \"autoPlay\",\n            autosave: \"autoSave\",\n            capture: \"capture\",\n            cellpadding: \"cellPadding\",\n            cellspacing: \"cellSpacing\",\n            challenge: \"challenge\",\n            charset: \"charSet\",\n            checked: \"checked\",\n            children: \"children\",\n            cite: \"cite\",\n            class: \"className\",\n            classid: \"classID\",\n            classname: \"className\",\n            cols: \"cols\",\n            colspan: \"colSpan\",\n            content: \"content\",\n            contenteditable: \"contentEditable\",\n            contextmenu: \"contextMenu\",\n            controls: \"controls\",\n            controlslist: \"controlsList\",\n            coords: \"coords\",\n            crossorigin: \"crossOrigin\",\n            dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n            data: \"data\",\n            datetime: \"dateTime\",\n            default: \"default\",\n            defaultchecked: \"defaultChecked\",\n            defaultvalue: \"defaultValue\",\n            defer: \"defer\",\n            dir: \"dir\",\n            disabled: \"disabled\",\n            disablepictureinpicture: \"disablePictureInPicture\",\n            disableremoteplayback: \"disableRemotePlayback\",\n            download: \"download\",\n            draggable: \"draggable\",\n            enctype: \"encType\",\n            enterkeyhint: \"enterKeyHint\",\n            fetchpriority: \"fetchPriority\",\n            for: \"htmlFor\",\n            form: \"form\",\n            formmethod: \"formMethod\",\n            formaction: \"formAction\",\n            formenctype: \"formEncType\",\n            formnovalidate: \"formNoValidate\",\n            formtarget: \"formTarget\",\n            frameborder: \"frameBorder\",\n            headers: \"headers\",\n            height: \"height\",\n            hidden: \"hidden\",\n            high: \"high\",\n            href: \"href\",\n            hreflang: \"hrefLang\",\n            htmlfor: \"htmlFor\",\n            httpequiv: \"httpEquiv\",\n            \"http-equiv\": \"httpEquiv\",\n            icon: \"icon\",\n            id: \"id\",\n            imagesizes: \"imageSizes\",\n            imagesrcset: \"imageSrcSet\",\n            innerhtml: \"innerHTML\",\n            inputmode: \"inputMode\",\n            integrity: \"integrity\",\n            is: \"is\",\n            itemid: \"itemID\",\n            itemprop: \"itemProp\",\n            itemref: \"itemRef\",\n            itemscope: \"itemScope\",\n            itemtype: \"itemType\",\n            keyparams: \"keyParams\",\n            keytype: \"keyType\",\n            kind: \"kind\",\n            label: \"label\",\n            lang: \"lang\",\n            list: \"list\",\n            loop: \"loop\",\n            low: \"low\",\n            manifest: \"manifest\",\n            marginwidth: \"marginWidth\",\n            marginheight: \"marginHeight\",\n            max: \"max\",\n            maxlength: \"maxLength\",\n            media: \"media\",\n            mediagroup: \"mediaGroup\",\n            method: \"method\",\n            min: \"min\",\n            minlength: \"minLength\",\n            multiple: \"multiple\",\n            muted: \"muted\",\n            name: \"name\",\n            nomodule: \"noModule\",\n            nonce: \"nonce\",\n            novalidate: \"noValidate\",\n            open: \"open\",\n            optimum: \"optimum\",\n            pattern: \"pattern\",\n            placeholder: \"placeholder\",\n            playsinline: \"playsInline\",\n            poster: \"poster\",\n            preload: \"preload\",\n            profile: \"profile\",\n            radiogroup: \"radioGroup\",\n            readonly: \"readOnly\",\n            referrerpolicy: \"referrerPolicy\",\n            rel: \"rel\",\n            required: \"required\",\n            reversed: \"reversed\",\n            role: \"role\",\n            rows: \"rows\",\n            rowspan: \"rowSpan\",\n            sandbox: \"sandbox\",\n            scope: \"scope\",\n            scoped: \"scoped\",\n            scrolling: \"scrolling\",\n            seamless: \"seamless\",\n            selected: \"selected\",\n            shape: \"shape\",\n            size: \"size\",\n            sizes: \"sizes\",\n            span: \"span\",\n            spellcheck: \"spellCheck\",\n            src: \"src\",\n            srcdoc: \"srcDoc\",\n            srclang: \"srcLang\",\n            srcset: \"srcSet\",\n            start: \"start\",\n            step: \"step\",\n            style: \"style\",\n            summary: \"summary\",\n            tabindex: \"tabIndex\",\n            target: \"target\",\n            title: \"title\",\n            type: \"type\",\n            usemap: \"useMap\",\n            value: \"value\",\n            width: \"width\",\n            wmode: \"wmode\",\n            wrap: \"wrap\",\n            // SVG\n            about: \"about\",\n            accentheight: \"accentHeight\",\n            \"accent-height\": \"accentHeight\",\n            accumulate: \"accumulate\",\n            additive: \"additive\",\n            alignmentbaseline: \"alignmentBaseline\",\n            \"alignment-baseline\": \"alignmentBaseline\",\n            allowreorder: \"allowReorder\",\n            alphabetic: \"alphabetic\",\n            amplitude: \"amplitude\",\n            arabicform: \"arabicForm\",\n            \"arabic-form\": \"arabicForm\",\n            ascent: \"ascent\",\n            attributename: \"attributeName\",\n            attributetype: \"attributeType\",\n            autoreverse: \"autoReverse\",\n            azimuth: \"azimuth\",\n            basefrequency: \"baseFrequency\",\n            baselineshift: \"baselineShift\",\n            \"baseline-shift\": \"baselineShift\",\n            baseprofile: \"baseProfile\",\n            bbox: \"bbox\",\n            begin: \"begin\",\n            bias: \"bias\",\n            by: \"by\",\n            calcmode: \"calcMode\",\n            capheight: \"capHeight\",\n            \"cap-height\": \"capHeight\",\n            clip: \"clip\",\n            clippath: \"clipPath\",\n            \"clip-path\": \"clipPath\",\n            clippathunits: \"clipPathUnits\",\n            cliprule: \"clipRule\",\n            \"clip-rule\": \"clipRule\",\n            color: \"color\",\n            colorinterpolation: \"colorInterpolation\",\n            \"color-interpolation\": \"colorInterpolation\",\n            colorinterpolationfilters: \"colorInterpolationFilters\",\n            \"color-interpolation-filters\": \"colorInterpolationFilters\",\n            colorprofile: \"colorProfile\",\n            \"color-profile\": \"colorProfile\",\n            colorrendering: \"colorRendering\",\n            \"color-rendering\": \"colorRendering\",\n            contentscripttype: \"contentScriptType\",\n            contentstyletype: \"contentStyleType\",\n            cursor: \"cursor\",\n            cx: \"cx\",\n            cy: \"cy\",\n            d: \"d\",\n            datatype: \"datatype\",\n            decelerate: \"decelerate\",\n            descent: \"descent\",\n            diffuseconstant: \"diffuseConstant\",\n            direction: \"direction\",\n            display: \"display\",\n            divisor: \"divisor\",\n            dominantbaseline: \"dominantBaseline\",\n            \"dominant-baseline\": \"dominantBaseline\",\n            dur: \"dur\",\n            dx: \"dx\",\n            dy: \"dy\",\n            edgemode: \"edgeMode\",\n            elevation: \"elevation\",\n            enablebackground: \"enableBackground\",\n            \"enable-background\": \"enableBackground\",\n            end: \"end\",\n            exponent: \"exponent\",\n            externalresourcesrequired: \"externalResourcesRequired\",\n            fill: \"fill\",\n            fillopacity: \"fillOpacity\",\n            \"fill-opacity\": \"fillOpacity\",\n            fillrule: \"fillRule\",\n            \"fill-rule\": \"fillRule\",\n            filter: \"filter\",\n            filterres: \"filterRes\",\n            filterunits: \"filterUnits\",\n            floodopacity: \"floodOpacity\",\n            \"flood-opacity\": \"floodOpacity\",\n            floodcolor: \"floodColor\",\n            \"flood-color\": \"floodColor\",\n            focusable: \"focusable\",\n            fontfamily: \"fontFamily\",\n            \"font-family\": \"fontFamily\",\n            fontsize: \"fontSize\",\n            \"font-size\": \"fontSize\",\n            fontsizeadjust: \"fontSizeAdjust\",\n            \"font-size-adjust\": \"fontSizeAdjust\",\n            fontstretch: \"fontStretch\",\n            \"font-stretch\": \"fontStretch\",\n            fontstyle: \"fontStyle\",\n            \"font-style\": \"fontStyle\",\n            fontvariant: \"fontVariant\",\n            \"font-variant\": \"fontVariant\",\n            fontweight: \"fontWeight\",\n            \"font-weight\": \"fontWeight\",\n            format: \"format\",\n            from: \"from\",\n            fx: \"fx\",\n            fy: \"fy\",\n            g1: \"g1\",\n            g2: \"g2\",\n            glyphname: \"glyphName\",\n            \"glyph-name\": \"glyphName\",\n            glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n            \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n            glyphorientationvertical: \"glyphOrientationVertical\",\n            \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n            glyphref: \"glyphRef\",\n            gradienttransform: \"gradientTransform\",\n            gradientunits: \"gradientUnits\",\n            hanging: \"hanging\",\n            horizadvx: \"horizAdvX\",\n            \"horiz-adv-x\": \"horizAdvX\",\n            horizoriginx: \"horizOriginX\",\n            \"horiz-origin-x\": \"horizOriginX\",\n            ideographic: \"ideographic\",\n            imagerendering: \"imageRendering\",\n            \"image-rendering\": \"imageRendering\",\n            in2: \"in2\",\n            in: \"in\",\n            inlist: \"inlist\",\n            intercept: \"intercept\",\n            k1: \"k1\",\n            k2: \"k2\",\n            k3: \"k3\",\n            k4: \"k4\",\n            k: \"k\",\n            kernelmatrix: \"kernelMatrix\",\n            kernelunitlength: \"kernelUnitLength\",\n            kerning: \"kerning\",\n            keypoints: \"keyPoints\",\n            keysplines: \"keySplines\",\n            keytimes: \"keyTimes\",\n            lengthadjust: \"lengthAdjust\",\n            letterspacing: \"letterSpacing\",\n            \"letter-spacing\": \"letterSpacing\",\n            lightingcolor: \"lightingColor\",\n            \"lighting-color\": \"lightingColor\",\n            limitingconeangle: \"limitingConeAngle\",\n            local: \"local\",\n            markerend: \"markerEnd\",\n            \"marker-end\": \"markerEnd\",\n            markerheight: \"markerHeight\",\n            markermid: \"markerMid\",\n            \"marker-mid\": \"markerMid\",\n            markerstart: \"markerStart\",\n            \"marker-start\": \"markerStart\",\n            markerunits: \"markerUnits\",\n            markerwidth: \"markerWidth\",\n            mask: \"mask\",\n            maskcontentunits: \"maskContentUnits\",\n            maskunits: \"maskUnits\",\n            mathematical: \"mathematical\",\n            mode: \"mode\",\n            numoctaves: \"numOctaves\",\n            offset: \"offset\",\n            opacity: \"opacity\",\n            operator: \"operator\",\n            order: \"order\",\n            orient: \"orient\",\n            orientation: \"orientation\",\n            origin: \"origin\",\n            overflow: \"overflow\",\n            overlineposition: \"overlinePosition\",\n            \"overline-position\": \"overlinePosition\",\n            overlinethickness: \"overlineThickness\",\n            \"overline-thickness\": \"overlineThickness\",\n            paintorder: \"paintOrder\",\n            \"paint-order\": \"paintOrder\",\n            panose1: \"panose1\",\n            \"panose-1\": \"panose1\",\n            pathlength: \"pathLength\",\n            patterncontentunits: \"patternContentUnits\",\n            patterntransform: \"patternTransform\",\n            patternunits: \"patternUnits\",\n            pointerevents: \"pointerEvents\",\n            \"pointer-events\": \"pointerEvents\",\n            points: \"points\",\n            pointsatx: \"pointsAtX\",\n            pointsaty: \"pointsAtY\",\n            pointsatz: \"pointsAtZ\",\n            prefix: \"prefix\",\n            preservealpha: \"preserveAlpha\",\n            preserveaspectratio: \"preserveAspectRatio\",\n            primitiveunits: \"primitiveUnits\",\n            property: \"property\",\n            r: \"r\",\n            radius: \"radius\",\n            refx: \"refX\",\n            refy: \"refY\",\n            renderingintent: \"renderingIntent\",\n            \"rendering-intent\": \"renderingIntent\",\n            repeatcount: \"repeatCount\",\n            repeatdur: \"repeatDur\",\n            requiredextensions: \"requiredExtensions\",\n            requiredfeatures: \"requiredFeatures\",\n            resource: \"resource\",\n            restart: \"restart\",\n            result: \"result\",\n            results: \"results\",\n            rotate: \"rotate\",\n            rx: \"rx\",\n            ry: \"ry\",\n            scale: \"scale\",\n            security: \"security\",\n            seed: \"seed\",\n            shaperendering: \"shapeRendering\",\n            \"shape-rendering\": \"shapeRendering\",\n            slope: \"slope\",\n            spacing: \"spacing\",\n            specularconstant: \"specularConstant\",\n            specularexponent: \"specularExponent\",\n            speed: \"speed\",\n            spreadmethod: \"spreadMethod\",\n            startoffset: \"startOffset\",\n            stddeviation: \"stdDeviation\",\n            stemh: \"stemh\",\n            stemv: \"stemv\",\n            stitchtiles: \"stitchTiles\",\n            stopcolor: \"stopColor\",\n            \"stop-color\": \"stopColor\",\n            stopopacity: \"stopOpacity\",\n            \"stop-opacity\": \"stopOpacity\",\n            strikethroughposition: \"strikethroughPosition\",\n            \"strikethrough-position\": \"strikethroughPosition\",\n            strikethroughthickness: \"strikethroughThickness\",\n            \"strikethrough-thickness\": \"strikethroughThickness\",\n            string: \"string\",\n            stroke: \"stroke\",\n            strokedasharray: \"strokeDasharray\",\n            \"stroke-dasharray\": \"strokeDasharray\",\n            strokedashoffset: \"strokeDashoffset\",\n            \"stroke-dashoffset\": \"strokeDashoffset\",\n            strokelinecap: \"strokeLinecap\",\n            \"stroke-linecap\": \"strokeLinecap\",\n            strokelinejoin: \"strokeLinejoin\",\n            \"stroke-linejoin\": \"strokeLinejoin\",\n            strokemiterlimit: \"strokeMiterlimit\",\n            \"stroke-miterlimit\": \"strokeMiterlimit\",\n            strokewidth: \"strokeWidth\",\n            \"stroke-width\": \"strokeWidth\",\n            strokeopacity: \"strokeOpacity\",\n            \"stroke-opacity\": \"strokeOpacity\",\n            suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n            suppresshydrationwarning: \"suppressHydrationWarning\",\n            surfacescale: \"surfaceScale\",\n            systemlanguage: \"systemLanguage\",\n            tablevalues: \"tableValues\",\n            targetx: \"targetX\",\n            targety: \"targetY\",\n            textanchor: \"textAnchor\",\n            \"text-anchor\": \"textAnchor\",\n            textdecoration: \"textDecoration\",\n            \"text-decoration\": \"textDecoration\",\n            textlength: \"textLength\",\n            textrendering: \"textRendering\",\n            \"text-rendering\": \"textRendering\",\n            to: \"to\",\n            transform: \"transform\",\n            transformorigin: \"transformOrigin\",\n            \"transform-origin\": \"transformOrigin\",\n            typeof: \"typeof\",\n            u1: \"u1\",\n            u2: \"u2\",\n            underlineposition: \"underlinePosition\",\n            \"underline-position\": \"underlinePosition\",\n            underlinethickness: \"underlineThickness\",\n            \"underline-thickness\": \"underlineThickness\",\n            unicode: \"unicode\",\n            unicodebidi: \"unicodeBidi\",\n            \"unicode-bidi\": \"unicodeBidi\",\n            unicoderange: \"unicodeRange\",\n            \"unicode-range\": \"unicodeRange\",\n            unitsperem: \"unitsPerEm\",\n            \"units-per-em\": \"unitsPerEm\",\n            unselectable: \"unselectable\",\n            valphabetic: \"vAlphabetic\",\n            \"v-alphabetic\": \"vAlphabetic\",\n            values: \"values\",\n            vectoreffect: \"vectorEffect\",\n            \"vector-effect\": \"vectorEffect\",\n            version: \"version\",\n            vertadvy: \"vertAdvY\",\n            \"vert-adv-y\": \"vertAdvY\",\n            vertoriginx: \"vertOriginX\",\n            \"vert-origin-x\": \"vertOriginX\",\n            vertoriginy: \"vertOriginY\",\n            \"vert-origin-y\": \"vertOriginY\",\n            vhanging: \"vHanging\",\n            \"v-hanging\": \"vHanging\",\n            videographic: \"vIdeographic\",\n            \"v-ideographic\": \"vIdeographic\",\n            viewbox: \"viewBox\",\n            viewtarget: \"viewTarget\",\n            visibility: \"visibility\",\n            vmathematical: \"vMathematical\",\n            \"v-mathematical\": \"vMathematical\",\n            vocab: \"vocab\",\n            widths: \"widths\",\n            wordspacing: \"wordSpacing\",\n            \"word-spacing\": \"wordSpacing\",\n            writingmode: \"writingMode\",\n            \"writing-mode\": \"writingMode\",\n            x1: \"x1\",\n            x2: \"x2\",\n            x: \"x\",\n            xchannelselector: \"xChannelSelector\",\n            xheight: \"xHeight\",\n            \"x-height\": \"xHeight\",\n            xlinkactuate: \"xlinkActuate\",\n            \"xlink:actuate\": \"xlinkActuate\",\n            xlinkarcrole: \"xlinkArcrole\",\n            \"xlink:arcrole\": \"xlinkArcrole\",\n            xlinkhref: \"xlinkHref\",\n            \"xlink:href\": \"xlinkHref\",\n            xlinkrole: \"xlinkRole\",\n            \"xlink:role\": \"xlinkRole\",\n            xlinkshow: \"xlinkShow\",\n            \"xlink:show\": \"xlinkShow\",\n            xlinktitle: \"xlinkTitle\",\n            \"xlink:title\": \"xlinkTitle\",\n            xlinktype: \"xlinkType\",\n            \"xlink:type\": \"xlinkType\",\n            xmlbase: \"xmlBase\",\n            \"xml:base\": \"xmlBase\",\n            xmllang: \"xmlLang\",\n            \"xml:lang\": \"xmlLang\",\n            xmlns: \"xmlns\",\n            \"xml:space\": \"xmlSpace\",\n            xmlnsxlink: \"xmlnsXlink\",\n            \"xmlns:xlink\": \"xmlnsXlink\",\n            xmlspace: \"xmlSpace\",\n            y1: \"y1\",\n            y2: \"y2\",\n            y: \"y\",\n            ychannelselector: \"yChannelSelector\",\n            z: \"z\",\n            zoomandpan: \"zoomAndPan\"\n        };\n        var warnedProperties = {};\n        var EVENT_NAME_REGEX = /^on./;\n        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\n        var rARIA = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var rARIACamel = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        function validateProperty(tagName, name, value, eventRegistry) {\n            {\n                if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n                    return true;\n                }\n                var lowerCasedName = name.toLowerCase();\n                if (lowerCasedName === \"onfocusin\" || lowerCasedName === \"onfocusout\") {\n                    error(\"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. \" + \"All React events are normalized to bubble, so onFocusIn and onFocusOut \" + \"are not needed/supported by React.\");\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                {\n                    // Actions are special because unlike events they can have other value types.\n                    if (typeof value === \"function\") {\n                        if (tagName === \"form\" && name === \"action\") {\n                            return true;\n                        }\n                        if (tagName === \"input\" && name === \"formAction\") {\n                            return true;\n                        }\n                        if (tagName === \"button\" && name === \"formAction\") {\n                            return true;\n                        }\n                    }\n                }\n                if (eventRegistry != null) {\n                    var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;\n                    if (registrationNameDependencies.hasOwnProperty(name)) {\n                        return true;\n                    }\n                    var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\n                    if (registrationName != null) {\n                        error(\"Invalid event handler property `%s`. Did you mean `%s`?\", name, registrationName);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                    if (EVENT_NAME_REGEX.test(name)) {\n                        error(\"Unknown event handler property `%s`. It will be ignored.\", name);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                } else if (EVENT_NAME_REGEX.test(name)) {\n                    // If no event plugins have been injected, we are in a server environment.\n                    // So we can't tell if the event name is correct for sure, but we can filter\n                    // out known bad ones like `onclick`. We can't suggest a specific replacement though.\n                    if (INVALID_EVENT_NAME_REGEX.test(name)) {\n                        error(\"Invalid event handler property `%s`. \" + \"React events use the camelCase naming convention, for example `onClick`.\", name);\n                    }\n                    warnedProperties[name] = true;\n                    return true;\n                } // Let the ARIA attribute hook validate ARIA attributes\n                if (rARIA.test(name) || rARIACamel.test(name)) {\n                    return true;\n                }\n                if (lowerCasedName === \"innerhtml\") {\n                    error(\"Directly setting property `innerHTML` is not permitted. \" + \"For more information, lookup documentation on `dangerouslySetInnerHTML`.\");\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (lowerCasedName === \"aria\") {\n                    error(\"The `aria` attribute is reserved for future use in React. \" + \"Pass individual `aria-` attributes instead.\");\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (lowerCasedName === \"is\" && value !== null && value !== undefined && typeof value !== \"string\") {\n                    error(\"Received a `%s` for a string attribute `is`. If this is expected, cast \" + \"the value to a string.\", typeof value);\n                    warnedProperties[name] = true;\n                    return true;\n                }\n                if (typeof value === \"number\" && isNaN(value)) {\n                    error(\"Received NaN for the `%s` attribute. If this is expected, cast \" + \"the value to a string.\", name);\n                    warnedProperties[name] = true;\n                    return true;\n                } // Known attributes should match the casing specified in the property config.\n                if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n                    var standardName = possibleStandardNames[lowerCasedName];\n                    if (standardName !== name) {\n                        error(\"Invalid DOM property `%s`. Did you mean `%s`?\", name, standardName);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                } else if (name !== lowerCasedName) {\n                    // Unknown attributes should have lowercase casing since that's how they\n                    // will be cased anyway with server rendering.\n                    error(\"React does not recognize the `%s` prop on a DOM element. If you \" + \"intentionally want it to appear in the DOM as a custom \" + \"attribute, spell it as lowercase `%s` instead. \" + \"If you accidentally passed it from a parent component, remove \" + \"it from the DOM element.\", name, lowerCasedName);\n                    warnedProperties[name] = true;\n                    return true;\n                } // Now that we've validated casing, do not validate\n                // data types for reserved props\n                switch(name){\n                    case \"dangerouslySetInnerHTML\":\n                    case \"children\":\n                    case \"style\":\n                    case \"suppressContentEditableWarning\":\n                    case \"suppressHydrationWarning\":\n                    case \"defaultValue\":\n                    case \"defaultChecked\":\n                    case \"innerHTML\":\n                        {\n                            return true;\n                        }\n                }\n                switch(typeof value){\n                    case \"boolean\":\n                        {\n                            switch(name){\n                                case \"autoFocus\":\n                                case \"checked\":\n                                case \"multiple\":\n                                case \"muted\":\n                                case \"selected\":\n                                case \"contentEditable\":\n                                case \"spellCheck\":\n                                case \"draggable\":\n                                case \"value\":\n                                case \"autoReverse\":\n                                case \"externalResourcesRequired\":\n                                case \"focusable\":\n                                case \"preserveAlpha\":\n                                case \"allowFullScreen\":\n                                case \"async\":\n                                case \"autoPlay\":\n                                case \"controls\":\n                                case \"default\":\n                                case \"defer\":\n                                case \"disabled\":\n                                case \"disablePictureInPicture\":\n                                case \"disableRemotePlayback\":\n                                case \"formNoValidate\":\n                                case \"hidden\":\n                                case \"loop\":\n                                case \"noModule\":\n                                case \"noValidate\":\n                                case \"open\":\n                                case \"playsInline\":\n                                case \"readOnly\":\n                                case \"required\":\n                                case \"reversed\":\n                                case \"scoped\":\n                                case \"seamless\":\n                                case \"itemScope\":\n                                case \"capture\":\n                                case \"download\":\n                                    {\n                                        // Boolean properties can accept boolean values\n                                        return true;\n                                    }\n                                default:\n                                    {\n                                        var prefix = name.toLowerCase().slice(0, 5);\n                                        if (prefix === \"data-\" || prefix === \"aria-\") {\n                                            return true;\n                                        }\n                                        if (value) {\n                                            error(\"Received `%s` for a non-boolean attribute `%s`.\\n\\n\" + \"If you want to write it to the DOM, pass a string instead: \" + '%s=\"%s\" or %s={value.toString()}.', value, name, name, value, name);\n                                        } else {\n                                            error(\"Received `%s` for a non-boolean attribute `%s`.\\n\\n\" + \"If you want to write it to the DOM, pass a string instead: \" + '%s=\"%s\" or %s={value.toString()}.\\n\\n' + \"If you used to conditionally omit it with %s={condition && value}, \" + \"pass %s={condition ? value : undefined} instead.\", value, name, name, value, name, name, name);\n                                        }\n                                        warnedProperties[name] = true;\n                                        return true;\n                                    }\n                            }\n                        }\n                    case \"function\":\n                    case \"symbol\":\n                        // eslint-disable-line\n                        // Warn when a known attribute is a bad type\n                        warnedProperties[name] = true;\n                        return false;\n                    case \"string\":\n                        {\n                            // Warn when passing the strings 'false' or 'true' into a boolean prop\n                            if (value === \"false\" || value === \"true\") {\n                                switch(name){\n                                    case \"checked\":\n                                    case \"selected\":\n                                    case \"multiple\":\n                                    case \"muted\":\n                                    case \"allowFullScreen\":\n                                    case \"async\":\n                                    case \"autoPlay\":\n                                    case \"controls\":\n                                    case \"default\":\n                                    case \"defer\":\n                                    case \"disabled\":\n                                    case \"disablePictureInPicture\":\n                                    case \"disableRemotePlayback\":\n                                    case \"formNoValidate\":\n                                    case \"hidden\":\n                                    case \"loop\":\n                                    case \"noModule\":\n                                    case \"noValidate\":\n                                    case \"open\":\n                                    case \"playsInline\":\n                                    case \"readOnly\":\n                                    case \"required\":\n                                    case \"reversed\":\n                                    case \"scoped\":\n                                    case \"seamless\":\n                                    case \"itemScope\":\n                                        {\n                                            break;\n                                        }\n                                    default:\n                                        {\n                                            return true;\n                                        }\n                                }\n                                error(\"Received the string `%s` for the boolean attribute `%s`. \" + \"%s \" + \"Did you mean %s={%s}?\", value, name, value === \"false\" ? \"The browser will interpret it as a truthy value.\" : 'Although this works, it will not work as expected if you pass the string \"false\".', name, value);\n                                warnedProperties[name] = true;\n                                return true;\n                            }\n                        }\n                }\n                return true;\n            }\n        }\n        function warnUnknownProperties(type, props, eventRegistry) {\n            {\n                var unknownProps = [];\n                for(var key in props){\n                    var isValid = validateProperty(type, key, props[key], eventRegistry);\n                    if (!isValid) {\n                        unknownProps.push(key);\n                    }\n                }\n                var unknownPropString = unknownProps.map(function(prop) {\n                    return \"`\" + prop + \"`\";\n                }).join(\", \");\n                if (unknownProps.length === 1) {\n                    error(\"Invalid value for prop %s on <%s> tag. Either remove it from the element, \" + \"or pass a string or number value to keep it in the DOM. \" + \"For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n                } else if (unknownProps.length > 1) {\n                    error(\"Invalid values for props %s on <%s> tag. Either remove them from the element, \" + \"or pass a string or number value to keep them in the DOM. \" + \"For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n                }\n            }\n        }\n        function validateProperties(type, props, eventRegistry) {\n            if (isCustomElement(type) || typeof props.is === \"string\") {\n                return;\n            }\n            warnUnknownProperties(type, props, eventRegistry);\n        }\n        // 'msTransform' is correct, but the other prefixes should be capitalized\n        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n        var msPattern$1 = /^-ms-/;\n        var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon\n        var badStyleValueWithSemicolonPattern = /;\\s*$/;\n        var warnedStyleNames = {};\n        var warnedStyleValues = {};\n        var warnedForNaNValue = false;\n        var warnedForInfinityValue = false;\n        function camelize(string) {\n            return string.replace(hyphenPattern, function(_, character) {\n                return character.toUpperCase();\n            });\n        }\n        function warnHyphenatedStyleName(name) {\n            {\n                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n                    return;\n                }\n                warnedStyleNames[name] = true;\n                error(\"Unsupported style property %s. Did you mean %s?\", name, // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n                // is converted to lowercase `ms`.\n                camelize(name.replace(msPattern$1, \"ms-\")));\n            }\n        }\n        function warnBadVendoredStyleName(name) {\n            {\n                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n                    return;\n                }\n                warnedStyleNames[name] = true;\n                error(\"Unsupported vendor-prefixed style property %s. Did you mean %s?\", name, name.charAt(0).toUpperCase() + name.slice(1));\n            }\n        }\n        function warnStyleValueWithSemicolon(name, value) {\n            {\n                if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n                    return;\n                }\n                warnedStyleValues[value] = true;\n                error(\"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.', name, value.replace(badStyleValueWithSemicolonPattern, \"\"));\n            }\n        }\n        function warnStyleValueIsNaN(name, value) {\n            {\n                if (warnedForNaNValue) {\n                    return;\n                }\n                warnedForNaNValue = true;\n                error(\"`NaN` is an invalid value for the `%s` css style property.\", name);\n            }\n        }\n        function warnStyleValueIsInfinity(name, value) {\n            {\n                if (warnedForInfinityValue) {\n                    return;\n                }\n                warnedForInfinityValue = true;\n                error(\"`Infinity` is an invalid value for the `%s` css style property.\", name);\n            }\n        }\n        function warnValidStyle(name, value) {\n            {\n                if (name.indexOf(\"-\") > -1) {\n                    warnHyphenatedStyleName(name);\n                } else if (badVendoredStyleNamePattern.test(name)) {\n                    warnBadVendoredStyleName(name);\n                } else if (badStyleValueWithSemicolonPattern.test(value)) {\n                    warnStyleValueWithSemicolon(name, value);\n                }\n                if (typeof value === \"number\") {\n                    if (isNaN(value)) {\n                        warnStyleValueIsNaN(name);\n                    } else if (!isFinite(value)) {\n                        warnStyleValueIsInfinity(name);\n                    }\n                }\n            }\n        }\n        function getCrossOriginString(input) {\n            if (typeof input === \"string\") {\n                return input === \"use-credentials\" ? input : \"\";\n            }\n            return undefined;\n        }\n        // code copied and modified from escape-html\n        var matchHtmlRegExp = /[\"'&<>]/;\n        /**\n * Escapes special characters and HTML entities in a given html string.\n *\n * @param  {string} string HTML string to escape for later insertion\n * @return {string}\n * @public\n */ function escapeHtml(string) {\n            {\n                checkHtmlStringCoercion(string);\n            }\n            var str = \"\" + string;\n            var match = matchHtmlRegExp.exec(str);\n            if (!match) {\n                return str;\n            }\n            var escape;\n            var html = \"\";\n            var index;\n            var lastIndex = 0;\n            for(index = match.index; index < str.length; index++){\n                switch(str.charCodeAt(index)){\n                    case 34:\n                        // \"\n                        escape = \"&quot;\";\n                        break;\n                    case 38:\n                        // &\n                        escape = \"&amp;\";\n                        break;\n                    case 39:\n                        // '\n                        escape = \"&#x27;\"; // modified from escape-html; used to be '&#39'\n                        break;\n                    case 60:\n                        // <\n                        escape = \"&lt;\";\n                        break;\n                    case 62:\n                        // >\n                        escape = \"&gt;\";\n                        break;\n                    default:\n                        continue;\n                }\n                if (lastIndex !== index) {\n                    html += str.slice(lastIndex, index);\n                }\n                lastIndex = index + 1;\n                html += escape;\n            }\n            return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n        } // end code copied and modified from escape-html\n        /**\n * Escapes text to prevent scripting attacks.\n *\n * @param {*} text Text value to escape.\n * @return {string} An escaped string.\n */ function escapeTextForBrowser(text) {\n            if (typeof text === \"boolean\" || typeof text === \"number\") {\n                // this shortcircuit helps perf for types that we know will never have\n                // special characters, especially given that this function is used often\n                // for numeric dom ids.\n                return \"\" + text;\n            }\n            return escapeHtml(text);\n        }\n        var uppercasePattern = /([A-Z])/g;\n        var msPattern = /^ms-/;\n        /**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n */ function hyphenateStyleName(name) {\n            return name.replace(uppercasePattern, \"-$1\").toLowerCase().replace(msPattern, \"-ms-\");\n        }\n        // and any newline or tab are filtered out as if they're not part of the URL.\n        // https://url.spec.whatwg.org/#url-parsing\n        // Tab or newline are defined as \\r\\n\\t:\n        // https://infra.spec.whatwg.org/#ascii-tab-or-newline\n        // A C0 control is a code point in the range \\u0000 NULL to \\u001F\n        // INFORMATION SEPARATOR ONE, inclusive:\n        // https://infra.spec.whatwg.org/#c0-control-or-space\n        /* eslint-disable max-len */ var isJavaScriptProtocol = /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;\n        var didWarn = false;\n        function sanitizeURL(url) {\n            // We should never have symbols here because they get filtered out elsewhere.\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            var stringifiedURL = \"\" + url;\n            {\n                if (!didWarn && isJavaScriptProtocol.test(stringifiedURL)) {\n                    didWarn = true;\n                    error(\"A future version of React will block javascript: URLs as a security precaution. \" + \"Use event handlers instead if you can. If you need to generate unsafe HTML try \" + \"using dangerouslySetInnerHTML instead. React was passed %s.\", JSON.stringify(stringifiedURL));\n                }\n            }\n            return url;\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        // The build script is at scripts/rollup/generate-inline-fizz-runtime.js.\n        // Run `yarn generate-inline-fizz-runtime` to generate.\n        var clientRenderBoundary = '$RX=function(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};';\n        var completeBoundary = '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};';\n        var completeBoundaryWithStyles = '$RM=new Map;\\n$RR=function(r,t,w){for(var u=$RC,n=$RM,p=new Map,q=document,g,b,h=q.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),v=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?v.push(b):(\"LINK\"===b.tagName&&n.set(b.getAttribute(\"href\"),b),p.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var f=w[b++];if(!f){k=!1;b=0;continue}var c=!1,m=0;var d=f[m++];if(a=n.get(d)){var e=a._p;c=!0}else{a=q.createElement(\"link\");a.href=d;a.rel=\"stylesheet\";for(a.dataset.precedence=\\nl=f[m++];e=f[m++];)a.setAttribute(e,f[m++]);e=a._p=new Promise(function(x,y){a.onload=x;a.onerror=y});n.set(d,a)}d=a.getAttribute(\"media\");!e||\"l\"===e.s||d&&!matchMedia(d).matches||h.push(e);if(c)continue}else{a=v[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=p.get(l)||g;c===g&&(g=a);p.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=q.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(u.bind(null,r,t,\"\"),u.bind(null,r,t,\"Resource failed to load\"))};';\n        var completeSegment = \"$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};\";\n        var formReplaying = 'addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error(\\'A React form was unexpectedly submitted.\\')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.getRootNode(),(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,\\nd,b))}});';\n        function getValueDescriptorExpectingObjectForWarning(thing) {\n            return thing === null ? \"`null`\" : thing === undefined ? \"`undefined`\" : thing === \"\" ? \"an empty string\" : 'something with type \"' + typeof thing + '\"';\n        }\n        // same object across all transitions.\n        var sharedNotPendingObject = {\n            pending: false,\n            data: null,\n            method: null,\n            action: null\n        };\n        var NotPending = Object.freeze(sharedNotPendingObject);\n        var ReactDOMSharedInternals = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        var ReactDOMCurrentDispatcher = ReactDOMSharedInternals.Dispatcher;\n        var ReactDOMServerDispatcher = {\n            prefetchDNS: prefetchDNS,\n            preconnect: preconnect,\n            preload: preload,\n            preloadModule: preloadModule,\n            preinitStyle: preinitStyle,\n            preinitScript: preinitScript,\n            preinitModuleScript: preinitModuleScript\n        };\n        function prepareHostDispatcher() {\n            ReactDOMCurrentDispatcher.current = ReactDOMServerDispatcher;\n        } // We make every property of the descriptor optional because it is not a contract that\n        var ScriptStreamingFormat = 0;\n        var DataStreamingFormat = 1;\n        var NothingSent = 0;\n        var SentCompleteSegmentFunction = 1;\n        var SentCompleteBoundaryFunction = 2;\n        var SentClientRenderFunction = 4;\n        var SentStyleInsertionFunction = 8;\n        var SentFormReplayingRuntime = 16; // Per request, global state that is not contextual to the rendering subtree.\n        // This cannot be resumed and therefore should only contain things that are\n        // temporary working state or are never used in the prerender pass.\n        // Credentials here are things that affect whether a browser will make a request\n        // as well as things that affect which connection the browser will use for that request.\n        // We want these to be aligned across preloads and resources because otherwise the preload\n        // will be wasted.\n        // We investigated whether referrerPolicy should be included here but from experimentation\n        // it seems that browsers do not treat this as part of the http cache key and does not affect\n        // which connection is used.\n        var EXISTS = null; // This constant is to mark preloads that have no unique credentials\n        // to convey. It should never be checked by identity and we should not\n        // assume Preload values in ResumableState equal this value because they\n        // will have come from some parsed input.\n        var PRELOAD_NO_CREDS = [];\n        {\n            Object.freeze(PRELOAD_NO_CREDS);\n        }\n        // This is resumable and therefore should be serializable.\n        var dataElementQuotedEnd = stringToPrecomputedChunk('\"></template>');\n        var startInlineScript = stringToPrecomputedChunk(\"<script>\");\n        var endInlineScript = stringToPrecomputedChunk(\"</script>\");\n        var startScriptSrc = stringToPrecomputedChunk('<script src=\"');\n        var startModuleSrc = stringToPrecomputedChunk('<script type=\"module\" src=\"');\n        var scriptNonce = stringToPrecomputedChunk('\" nonce=\"');\n        var scriptIntegirty = stringToPrecomputedChunk('\" integrity=\"');\n        var scriptCrossOrigin = stringToPrecomputedChunk('\" crossorigin=\"');\n        var endAsyncScript = stringToPrecomputedChunk('\" async=\"\"></script>');\n        /**\n * This escaping function is designed to work with bootstrapScriptContent and importMap only.\n * because we know we are escaping the entire script. We can avoid for instance\n * escaping html comment string sequences that are valid javascript as well because\n * if there are no sebsequent <script sequences the html parser will never enter\n * script data double escaped state (see: https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state)\n *\n * While untrusted script content should be made safe before using this api it will\n * ensure that the script cannot be early terminated or never terminated state\n */ function escapeBootstrapAndImportMapScriptContent(scriptText) {\n            {\n                checkHtmlStringCoercion(scriptText);\n            }\n            return (\"\" + scriptText).replace(scriptRegex, scriptReplacer);\n        }\n        var scriptRegex = /(<\\/|<)(s)(cript)/gi;\n        var scriptReplacer = function(match, prefix, s, suffix) {\n            return \"\" + prefix + (s === \"s\" ? \"\\\\u0073\" : \"\\\\u0053\") + suffix;\n        };\n        var importMapScriptStart = stringToPrecomputedChunk('<script type=\"importmap\">');\n        var importMapScriptEnd = stringToPrecomputedChunk(\"</script>\"); // Since we store headers as strings we deal with their length in utf16 code units\n        // rather than visual characters or the utf8 encoding that is used for most binary\n        // serialization. Some common HTTP servers only allow for headers to be 4kB in length.\n        // We choose a default length that is likely to be well under this already limited length however\n        // pathological cases may still cause the utf-8 encoding of the headers to approach this limit.\n        // It should also be noted that this maximum is a soft maximum. we have not reached the limit we will\n        // allow one more header to be captured which means in practice if the limit is approached it will be exceeded\n        var DEFAULT_HEADERS_CAPACITY_IN_UTF16_CODE_UNITS = 2000; // Allows us to keep track of what we've already written so we can refer back to it.\n        // if passed externalRuntimeConfig and the enableFizzExternalRuntime feature flag\n        // is set, the server will send instructions via data attributes (instead of inline scripts)\n        function createRenderState(resumableState, nonce, externalRuntimeConfig, importMap, onHeaders, maxHeadersLength) {\n            var inlineScriptWithNonce = nonce === undefined ? startInlineScript : stringToPrecomputedChunk('<script nonce=\"' + escapeTextForBrowser(nonce) + '\">');\n            var idPrefix = resumableState.idPrefix;\n            var bootstrapChunks = [];\n            var externalRuntimeScript = null;\n            var bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;\n            if (bootstrapScriptContent !== undefined) {\n                bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapAndImportMapScriptContent(bootstrapScriptContent)), endInlineScript);\n            }\n            {\n                if (externalRuntimeConfig !== undefined) {\n                    if (typeof externalRuntimeConfig === \"string\") {\n                        externalRuntimeScript = {\n                            src: externalRuntimeConfig,\n                            chunks: []\n                        };\n                        pushScriptImpl(externalRuntimeScript.chunks, {\n                            src: externalRuntimeConfig,\n                            async: true,\n                            integrity: undefined,\n                            nonce: nonce\n                        });\n                    } else {\n                        externalRuntimeScript = {\n                            src: externalRuntimeConfig.src,\n                            chunks: []\n                        };\n                        pushScriptImpl(externalRuntimeScript.chunks, {\n                            src: externalRuntimeConfig.src,\n                            async: true,\n                            integrity: externalRuntimeConfig.integrity,\n                            nonce: nonce\n                        });\n                    }\n                }\n            }\n            var importMapChunks = [];\n            if (importMap !== undefined) {\n                var map = importMap;\n                importMapChunks.push(importMapScriptStart);\n                importMapChunks.push(stringToChunk(escapeBootstrapAndImportMapScriptContent(JSON.stringify(map))));\n                importMapChunks.push(importMapScriptEnd);\n            }\n            {\n                if (onHeaders && typeof maxHeadersLength === \"number\") {\n                    if (maxHeadersLength <= 0) {\n                        error(\"React expected a positive non-zero `maxHeadersLength` option but found %s instead. When using the `onHeaders` option you may supply an optional `maxHeadersLength` option as well however, when setting this value to zero or less no headers will be captured.\", maxHeadersLength === 0 ? \"zero\" : maxHeadersLength);\n                    }\n                }\n            }\n            var headers = onHeaders ? {\n                preconnects: \"\",\n                fontPreloads: \"\",\n                highImagePreloads: \"\",\n                remainingCapacity: typeof maxHeadersLength === \"number\" ? maxHeadersLength : DEFAULT_HEADERS_CAPACITY_IN_UTF16_CODE_UNITS\n            } : null;\n            var renderState = {\n                placeholderPrefix: stringToPrecomputedChunk(idPrefix + \"P:\"),\n                segmentPrefix: stringToPrecomputedChunk(idPrefix + \"S:\"),\n                boundaryPrefix: stringToPrecomputedChunk(idPrefix + \"B:\"),\n                startInlineScript: inlineScriptWithNonce,\n                htmlChunks: null,\n                headChunks: null,\n                externalRuntimeScript: externalRuntimeScript,\n                bootstrapChunks: bootstrapChunks,\n                onHeaders: onHeaders,\n                headers: headers,\n                resets: {\n                    font: {},\n                    dns: {},\n                    connect: {\n                        default: {},\n                        anonymous: {},\n                        credentials: {}\n                    },\n                    image: {},\n                    style: {}\n                },\n                charsetChunks: [],\n                preconnectChunks: [],\n                importMapChunks: importMapChunks,\n                preloadChunks: [],\n                hoistableChunks: [],\n                // cleared on flush\n                preconnects: new Set(),\n                fontPreloads: new Set(),\n                highImagePreloads: new Set(),\n                // usedImagePreloads: new Set(),\n                styles: new Map(),\n                bootstrapScripts: new Set(),\n                scripts: new Set(),\n                bulkPreloads: new Set(),\n                preloads: {\n                    images: new Map(),\n                    stylesheets: new Map(),\n                    scripts: new Map(),\n                    moduleScripts: new Map()\n                },\n                nonce: nonce,\n                // like a module global for currently rendering boundary\n                boundaryResources: null,\n                stylesToHoist: false\n            };\n            if (bootstrapScripts !== undefined) {\n                for(var i = 0; i < bootstrapScripts.length; i++){\n                    var scriptConfig = bootstrapScripts[i];\n                    var src = void 0, crossOrigin = void 0, integrity = void 0;\n                    var props = {\n                        rel: \"preload\",\n                        as: \"script\",\n                        fetchPriority: \"low\",\n                        nonce: nonce\n                    };\n                    if (typeof scriptConfig === \"string\") {\n                        props.href = src = scriptConfig;\n                    } else {\n                        props.href = src = scriptConfig.src;\n                        props.integrity = integrity = typeof scriptConfig.integrity === \"string\" ? scriptConfig.integrity : undefined;\n                        props.crossOrigin = crossOrigin = typeof scriptConfig === \"string\" || scriptConfig.crossOrigin == null ? undefined : scriptConfig.crossOrigin === \"use-credentials\" ? \"use-credentials\" : \"\";\n                    }\n                    preloadBootstrapScriptOrModule(resumableState, renderState, src, props);\n                    bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(src)));\n                    if (nonce) {\n                        bootstrapChunks.push(scriptNonce, stringToChunk(escapeTextForBrowser(nonce)));\n                    }\n                    if (typeof integrity === \"string\") {\n                        bootstrapChunks.push(scriptIntegirty, stringToChunk(escapeTextForBrowser(integrity)));\n                    }\n                    if (typeof crossOrigin === \"string\") {\n                        bootstrapChunks.push(scriptCrossOrigin, stringToChunk(escapeTextForBrowser(crossOrigin)));\n                    }\n                    bootstrapChunks.push(endAsyncScript);\n                }\n            }\n            if (bootstrapModules !== undefined) {\n                for(var _i = 0; _i < bootstrapModules.length; _i++){\n                    var _scriptConfig = bootstrapModules[_i];\n                    var _src = void 0, _crossOrigin = void 0, _integrity = void 0;\n                    var _props = {\n                        rel: \"modulepreload\",\n                        fetchPriority: \"low\",\n                        nonce: nonce\n                    };\n                    if (typeof _scriptConfig === \"string\") {\n                        _props.href = _src = _scriptConfig;\n                    } else {\n                        _props.href = _src = _scriptConfig.src;\n                        _props.integrity = _integrity = typeof _scriptConfig.integrity === \"string\" ? _scriptConfig.integrity : undefined;\n                        _props.crossOrigin = _crossOrigin = typeof _scriptConfig === \"string\" || _scriptConfig.crossOrigin == null ? undefined : _scriptConfig.crossOrigin === \"use-credentials\" ? \"use-credentials\" : \"\";\n                    }\n                    preloadBootstrapScriptOrModule(resumableState, renderState, _src, _props);\n                    bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(_src)));\n                    if (nonce) {\n                        bootstrapChunks.push(scriptNonce, stringToChunk(escapeTextForBrowser(nonce)));\n                    }\n                    if (typeof _integrity === \"string\") {\n                        bootstrapChunks.push(scriptIntegirty, stringToChunk(escapeTextForBrowser(_integrity)));\n                    }\n                    if (typeof _crossOrigin === \"string\") {\n                        bootstrapChunks.push(scriptCrossOrigin, stringToChunk(escapeTextForBrowser(_crossOrigin)));\n                    }\n                    bootstrapChunks.push(endAsyncScript);\n                }\n            }\n            return renderState;\n        }\n        function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {\n            var idPrefix = identifierPrefix === undefined ? \"\" : identifierPrefix;\n            var streamingFormat = ScriptStreamingFormat;\n            {\n                if (externalRuntimeConfig !== undefined) {\n                    streamingFormat = DataStreamingFormat;\n                }\n            }\n            return {\n                idPrefix: idPrefix,\n                nextFormID: 0,\n                streamingFormat: streamingFormat,\n                bootstrapScriptContent: bootstrapScriptContent,\n                bootstrapScripts: bootstrapScripts,\n                bootstrapModules: bootstrapModules,\n                instructions: NothingSent,\n                hasBody: false,\n                hasHtml: false,\n                // @TODO add bootstrap script to implicit preloads\n                // persistent\n                unknownResources: {},\n                dnsResources: {},\n                connectResources: {\n                    default: {},\n                    anonymous: {},\n                    credentials: {}\n                },\n                imageResources: {},\n                styleResources: {},\n                scriptResources: {},\n                moduleUnknownResources: {},\n                moduleScriptResources: {}\n            };\n        }\n        // modes. We only include the variants as they matter for the sake of our purposes.\n        // We don't actually provide the namespace therefore we use constants instead of the string.\n        var ROOT_HTML_MODE = 0; // Used for the root most element tag.\n        // We have a less than HTML_HTML_MODE check elsewhere. If you add more cases here, make sure it\n        // still makes sense\n        var HTML_HTML_MODE = 1; // Used for the <html> if it is at the top level.\n        var HTML_MODE = 2;\n        var SVG_MODE = 3;\n        var MATHML_MODE = 4;\n        var HTML_TABLE_MODE = 5;\n        var HTML_TABLE_BODY_MODE = 6;\n        var HTML_TABLE_ROW_MODE = 7;\n        var HTML_COLGROUP_MODE = 8; // We have a greater than HTML_TABLE_MODE check elsewhere. If you add more cases here, make sure it\n        // still makes sense\n        var NO_SCOPE = /*         */ 0;\n        var NOSCRIPT_SCOPE = /*   */ 1;\n        var PICTURE_SCOPE = /*    */ 2; // Lets us keep track of contextual state and pick it back up after suspending.\n        function createFormatContext(insertionMode, selectedValue, tagScope) {\n            return {\n                insertionMode: insertionMode,\n                selectedValue: selectedValue,\n                tagScope: tagScope\n            };\n        }\n        function createRootFormatContext(namespaceURI) {\n            var insertionMode = namespaceURI === \"http://www.w3.org/2000/svg\" ? SVG_MODE : namespaceURI === \"http://www.w3.org/1998/Math/MathML\" ? MATHML_MODE : ROOT_HTML_MODE;\n            return createFormatContext(insertionMode, null, NO_SCOPE);\n        }\n        function getChildFormatContext(parentContext, type, props) {\n            switch(type){\n                case \"noscript\":\n                    return createFormatContext(HTML_MODE, null, parentContext.tagScope | NOSCRIPT_SCOPE);\n                case \"select\":\n                    return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue, parentContext.tagScope);\n                case \"svg\":\n                    return createFormatContext(SVG_MODE, null, parentContext.tagScope);\n                case \"picture\":\n                    return createFormatContext(HTML_MODE, null, parentContext.tagScope | PICTURE_SCOPE);\n                case \"math\":\n                    return createFormatContext(MATHML_MODE, null, parentContext.tagScope);\n                case \"foreignObject\":\n                    return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n                // Table parents are special in that their children can only be created at all if they're\n                // wrapped in a table parent. So we need to encode that we're entering this mode.\n                case \"table\":\n                    return createFormatContext(HTML_TABLE_MODE, null, parentContext.tagScope);\n                case \"thead\":\n                case \"tbody\":\n                case \"tfoot\":\n                    return createFormatContext(HTML_TABLE_BODY_MODE, null, parentContext.tagScope);\n                case \"colgroup\":\n                    return createFormatContext(HTML_COLGROUP_MODE, null, parentContext.tagScope);\n                case \"tr\":\n                    return createFormatContext(HTML_TABLE_ROW_MODE, null, parentContext.tagScope);\n            }\n            if (parentContext.insertionMode >= HTML_TABLE_MODE) {\n                // Whatever tag this was, it wasn't a table parent or other special parent, so we must have\n                // entered plain HTML again.\n                return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n            }\n            if (parentContext.insertionMode === ROOT_HTML_MODE) {\n                if (type === \"html\") {\n                    // We've emitted the root and is now in <html> mode.\n                    return createFormatContext(HTML_HTML_MODE, null, parentContext.tagScope);\n                } else {\n                    // We've emitted the root and is now in plain HTML mode.\n                    return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n                }\n            } else if (parentContext.insertionMode === HTML_HTML_MODE) {\n                // We've emitted the document element and is now in plain HTML mode.\n                return createFormatContext(HTML_MODE, null, parentContext.tagScope);\n            }\n            return parentContext;\n        }\n        function makeId(resumableState, treeId, localId) {\n            var idPrefix = resumableState.idPrefix;\n            var id = \":\" + idPrefix + \"R\" + treeId; // Unless this is the first id at this level, append a number at the end\n            // that represents the position of this useId hook among all the useId\n            // hooks for this fiber.\n            if (localId > 0) {\n                id += \"H\" + localId.toString(32);\n            }\n            return id + \":\";\n        }\n        function encodeHTMLTextNode(text) {\n            return escapeTextForBrowser(text);\n        }\n        var textSeparator = stringToPrecomputedChunk(\"<!-- -->\");\n        function pushTextInstance(target, text, renderState, textEmbedded) {\n            if (text === \"\") {\n                // Empty text doesn't have a DOM node representation and the hydration is aware of this.\n                return textEmbedded;\n            }\n            if (textEmbedded) {\n                target.push(textSeparator);\n            }\n            target.push(stringToChunk(encodeHTMLTextNode(text)));\n            return true;\n        } // Called when Fizz is done with a Segment. Currently the only purpose is to conditionally\n        // emit a text separator when we don't know for sure it is safe to omit\n        function pushSegmentFinale(target, renderState, lastPushedText, textEmbedded) {\n            if (lastPushedText && textEmbedded) {\n                target.push(textSeparator);\n            }\n        }\n        var styleNameCache = new Map();\n        function processStyleName(styleName) {\n            var chunk = styleNameCache.get(styleName);\n            if (chunk !== undefined) {\n                return chunk;\n            }\n            var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));\n            styleNameCache.set(styleName, result);\n            return result;\n        }\n        var styleAttributeStart = stringToPrecomputedChunk(' style=\"');\n        var styleAssign = stringToPrecomputedChunk(\":\");\n        var styleSeparator = stringToPrecomputedChunk(\";\");\n        function pushStyleAttribute(target, style) {\n            if (typeof style !== \"object\") {\n                throw new Error(\"The `style` prop expects a mapping from style properties to values, \" + \"not a string. For example, style={{marginRight: spacing + 'em'}} when \" + \"using JSX.\");\n            }\n            var isFirst = true;\n            for(var styleName in style){\n                if (!hasOwnProperty.call(style, styleName)) {\n                    continue;\n                } // If you provide unsafe user data here they can inject arbitrary CSS\n                // which may be problematic (I couldn't repro this):\n                // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n                // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n                // This is not an XSS hole but instead a potential CSS injection issue\n                // which has lead to a greater discussion about how we're going to\n                // trust URLs moving forward. See #2115901\n                var styleValue = style[styleName];\n                if (styleValue == null || typeof styleValue === \"boolean\" || styleValue === \"\") {\n                    continue;\n                }\n                var nameChunk = void 0;\n                var valueChunk = void 0;\n                var isCustomProperty = styleName.indexOf(\"--\") === 0;\n                if (isCustomProperty) {\n                    nameChunk = stringToChunk(escapeTextForBrowser(styleName));\n                    {\n                        checkCSSPropertyStringCoercion(styleValue, styleName);\n                    }\n                    valueChunk = stringToChunk(escapeTextForBrowser((\"\" + styleValue).trim()));\n                } else {\n                    {\n                        warnValidStyle(styleName, styleValue);\n                    }\n                    nameChunk = processStyleName(styleName);\n                    if (typeof styleValue === \"number\") {\n                        if (styleValue !== 0 && !isUnitlessNumber(styleName)) {\n                            valueChunk = stringToChunk(styleValue + \"px\"); // Presumes implicit 'px' suffix for unitless numbers\n                        } else {\n                            valueChunk = stringToChunk(\"\" + styleValue);\n                        }\n                    } else {\n                        {\n                            checkCSSPropertyStringCoercion(styleValue, styleName);\n                        }\n                        valueChunk = stringToChunk(escapeTextForBrowser((\"\" + styleValue).trim()));\n                    }\n                }\n                if (isFirst) {\n                    isFirst = false; // If it's first, we don't need any separators prefixed.\n                    target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);\n                } else {\n                    target.push(styleSeparator, nameChunk, styleAssign, valueChunk);\n                }\n            }\n            if (!isFirst) {\n                target.push(attributeEnd);\n            }\n        }\n        var attributeSeparator = stringToPrecomputedChunk(\" \");\n        var attributeAssign = stringToPrecomputedChunk('=\"');\n        var attributeEnd = stringToPrecomputedChunk('\"');\n        var attributeEmptyString = stringToPrecomputedChunk('=\"\"');\n        function pushBooleanAttribute(target, name, value) {\n            if (value && typeof value !== \"function\" && typeof value !== \"symbol\") {\n                target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n            }\n        }\n        function pushStringAttribute(target, name, value) {\n            if (typeof value !== \"function\" && typeof value !== \"symbol\" && typeof value !== \"boolean\") {\n                target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n            }\n        }\n        function makeFormFieldPrefix(resumableState) {\n            var id = resumableState.nextFormID++;\n            return resumableState.idPrefix + id;\n        } // Since this will likely be repeated a lot in the HTML, we use a more concise message\n        // than on the client and hopefully it's googleable.\n        var actionJavaScriptURL = stringToPrecomputedChunk(escapeTextForBrowser(\"javascript:throw new Error('A React form was unexpectedly submitted.')\"));\n        var startHiddenInputChunk = stringToPrecomputedChunk('<input type=\"hidden\"');\n        function pushAdditionalFormField(value, key) {\n            var target = this;\n            target.push(startHiddenInputChunk);\n            if (typeof value !== \"string\") {\n                throw new Error(\"File/Blob fields are not yet supported in progressive forms. \" + \"It probably means you are closing over binary data or FormData in a Server Action.\");\n            }\n            pushStringAttribute(target, \"name\", key);\n            pushStringAttribute(target, \"value\", value);\n            target.push(endOfStartTagSelfClosing);\n        }\n        function pushAdditionalFormFields(target, formData) {\n            if (formData !== null) {\n                // $FlowFixMe[prop-missing]: FormData has forEach.\n                formData.forEach(pushAdditionalFormField, target);\n            }\n        }\n        function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {\n            var formData = null;\n            if (typeof formAction === \"function\") {\n                // Function form actions cannot control the form properties\n                {\n                    if (name !== null && !didWarnFormActionName) {\n                        didWarnFormActionName = true;\n                        error('Cannot specify a \"name\" prop for a button that specifies a function as a formAction. ' + \"React needs it to encode which action should be invoked. It will get overridden.\");\n                    }\n                    if ((formEncType !== null || formMethod !== null) && !didWarnFormActionMethod) {\n                        didWarnFormActionMethod = true;\n                        error(\"Cannot specify a formEncType or formMethod for a button that specifies a \" + \"function as a formAction. React provides those automatically. They will get overridden.\");\n                    }\n                    if (formTarget !== null && !didWarnFormActionTarget) {\n                        didWarnFormActionTarget = true;\n                        error(\"Cannot specify a formTarget for a button that specifies a function as a formAction. \" + \"The function will always be executed in the same window.\");\n                    }\n                }\n                var customAction = formAction.$$FORM_ACTION;\n                if (typeof customAction === \"function\") {\n                    // This action has a custom progressive enhancement form that can submit the form\n                    // back to the server if it's invoked before hydration. Such as a Server Action.\n                    var prefix = makeFormFieldPrefix(resumableState);\n                    var customFields = formAction.$$FORM_ACTION(prefix);\n                    name = customFields.name;\n                    formAction = customFields.action || \"\";\n                    formEncType = customFields.encType;\n                    formMethod = customFields.method;\n                    formTarget = customFields.target;\n                    formData = customFields.data;\n                } else {\n                    // Set a javascript URL that doesn't do anything. We don't expect this to be invoked\n                    // because we'll preventDefault in the Fizz runtime, but it can happen if a form is\n                    // manually submitted or if someone calls stopPropagation before React gets the event.\n                    // If CSP is used to block javascript: URLs that's fine too. It just won't show this\n                    // error message but the URL will be logged.\n                    target.push(attributeSeparator, stringToChunk(\"formAction\"), attributeAssign, actionJavaScriptURL, attributeEnd);\n                    name = null;\n                    formAction = null;\n                    formEncType = null;\n                    formMethod = null;\n                    formTarget = null;\n                    injectFormReplayingRuntime(resumableState, renderState);\n                }\n            }\n            if (name != null) {\n                pushAttribute(target, \"name\", name);\n            }\n            if (formAction != null) {\n                pushAttribute(target, \"formAction\", formAction);\n            }\n            if (formEncType != null) {\n                pushAttribute(target, \"formEncType\", formEncType);\n            }\n            if (formMethod != null) {\n                pushAttribute(target, \"formMethod\", formMethod);\n            }\n            if (formTarget != null) {\n                pushAttribute(target, \"formTarget\", formTarget);\n            }\n            return formData;\n        }\n        function pushAttribute(target, name, value) {\n            switch(name){\n                // These are very common props and therefore are in the beginning of the switch.\n                // TODO: aria-label is a very common prop but allows booleans so is not like the others\n                // but should ideally go in this list too.\n                case \"className\":\n                    {\n                        pushStringAttribute(target, \"class\", value);\n                        break;\n                    }\n                case \"tabIndex\":\n                    {\n                        pushStringAttribute(target, \"tabindex\", value);\n                        break;\n                    }\n                case \"dir\":\n                case \"role\":\n                case \"viewBox\":\n                case \"width\":\n                case \"height\":\n                    {\n                        pushStringAttribute(target, name, value);\n                        break;\n                    }\n                case \"style\":\n                    {\n                        pushStyleAttribute(target, value);\n                        return;\n                    }\n                case \"src\":\n                case \"href\":\n                // Fall through to the last case which shouldn't remove empty strings.\n                case \"action\":\n                case \"formAction\":\n                    {\n                        // TODO: Consider only special casing these for each tag.\n                        if (value == null || typeof value === \"function\" || typeof value === \"symbol\" || typeof value === \"boolean\") {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, name);\n                        }\n                        var sanitizedValue = sanitizeURL(\"\" + value);\n                        target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(sanitizedValue)), attributeEnd);\n                        return;\n                    }\n                case \"defaultValue\":\n                case \"defaultChecked\":\n                case \"innerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                    // Ignored. These are built-in to React on the client.\n                    return;\n                case \"autoFocus\":\n                case \"multiple\":\n                case \"muted\":\n                    {\n                        pushBooleanAttribute(target, name.toLowerCase(), value);\n                        return;\n                    }\n                case \"xlinkHref\":\n                    {\n                        if (typeof value === \"function\" || typeof value === \"symbol\" || typeof value === \"boolean\") {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, name);\n                        }\n                        var _sanitizedValue = sanitizeURL(\"\" + value);\n                        target.push(attributeSeparator, stringToChunk(\"xlink:href\"), attributeAssign, stringToChunk(escapeTextForBrowser(_sanitizedValue)), attributeEnd);\n                        return;\n                    }\n                case \"contentEditable\":\n                case \"spellCheck\":\n                case \"draggable\":\n                case \"value\":\n                case \"autoReverse\":\n                case \"externalResourcesRequired\":\n                case \"focusable\":\n                case \"preserveAlpha\":\n                    {\n                        // Booleanish String\n                        // These are \"enumerated\" attributes that accept \"true\" and \"false\".\n                        // In React, we let users pass `true` and `false` even though technically\n                        // these aren't boolean attributes (they are coerced to strings).\n                        if (typeof value !== \"function\" && typeof value !== \"symbol\") {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"allowFullScreen\":\n                case \"async\":\n                case \"autoPlay\":\n                case \"controls\":\n                case \"default\":\n                case \"defer\":\n                case \"disabled\":\n                case \"disablePictureInPicture\":\n                case \"disableRemotePlayback\":\n                case \"formNoValidate\":\n                case \"hidden\":\n                case \"loop\":\n                case \"noModule\":\n                case \"noValidate\":\n                case \"open\":\n                case \"playsInline\":\n                case \"readOnly\":\n                case \"required\":\n                case \"reversed\":\n                case \"scoped\":\n                case \"seamless\":\n                case \"itemScope\":\n                    {\n                        // Boolean\n                        if (value && typeof value !== \"function\" && typeof value !== \"symbol\") {\n                            target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n                        }\n                        return;\n                    }\n                case \"capture\":\n                case \"download\":\n                    {\n                        // Overloaded Boolean\n                        if (value === true) {\n                            target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n                        } else if (value === false) ;\n                        else if (typeof value !== \"function\" && typeof value !== \"symbol\") {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"cols\":\n                case \"rows\":\n                case \"size\":\n                case \"span\":\n                    {\n                        // These are HTML attributes that must be positive numbers.\n                        if (typeof value !== \"function\" && typeof value !== \"symbol\" && !isNaN(value) && value >= 1) {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"rowSpan\":\n                case \"start\":\n                    {\n                        // These are HTML attributes that must be numbers.\n                        if (typeof value !== \"function\" && typeof value !== \"symbol\" && !isNaN(value)) {\n                            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    }\n                case \"xlinkActuate\":\n                    pushStringAttribute(target, \"xlink:actuate\", value);\n                    return;\n                case \"xlinkArcrole\":\n                    pushStringAttribute(target, \"xlink:arcrole\", value);\n                    return;\n                case \"xlinkRole\":\n                    pushStringAttribute(target, \"xlink:role\", value);\n                    return;\n                case \"xlinkShow\":\n                    pushStringAttribute(target, \"xlink:show\", value);\n                    return;\n                case \"xlinkTitle\":\n                    pushStringAttribute(target, \"xlink:title\", value);\n                    return;\n                case \"xlinkType\":\n                    pushStringAttribute(target, \"xlink:type\", value);\n                    return;\n                case \"xmlBase\":\n                    pushStringAttribute(target, \"xml:base\", value);\n                    return;\n                case \"xmlLang\":\n                    pushStringAttribute(target, \"xml:lang\", value);\n                    return;\n                case \"xmlSpace\":\n                    pushStringAttribute(target, \"xml:space\", value);\n                    return;\n                default:\n                    if (// We have already filtered out null/undefined and reserved words.\n                    name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                        return;\n                    }\n                    var attributeName = getAttributeAlias(name);\n                    if (isAttributeNameSafe(attributeName)) {\n                        // shouldRemoveAttribute\n                        switch(typeof value){\n                            case \"function\":\n                            case \"symbol\":\n                                // eslint-disable-line\n                                return;\n                            case \"boolean\":\n                                {\n                                    var prefix = attributeName.toLowerCase().slice(0, 5);\n                                    if (prefix !== \"data-\" && prefix !== \"aria-\") {\n                                        return;\n                                    }\n                                }\n                        }\n                        target.push(attributeSeparator, stringToChunk(attributeName), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                    }\n            }\n        }\n        var endOfStartTag = stringToPrecomputedChunk(\">\");\n        var endOfStartTagSelfClosing = stringToPrecomputedChunk(\"/>\");\n        function pushInnerHTML(target, innerHTML, children) {\n            if (innerHTML != null) {\n                if (children != null) {\n                    throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n                }\n                if (typeof innerHTML !== \"object\" || !(\"__html\" in innerHTML)) {\n                    throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. \" + \"Please visit https://reactjs.org/link/dangerously-set-inner-html \" + \"for more information.\");\n                }\n                var html = innerHTML.__html;\n                if (html !== null && html !== undefined) {\n                    {\n                        checkHtmlStringCoercion(html);\n                    }\n                    target.push(stringToChunk(\"\" + html));\n                }\n            }\n        } // TODO: Move these to RenderState so that we warn for every request.\n        // It would help debugging in stateful servers (e.g. service worker).\n        var didWarnDefaultInputValue = false;\n        var didWarnDefaultChecked = false;\n        var didWarnDefaultSelectValue = false;\n        var didWarnDefaultTextareaValue = false;\n        var didWarnInvalidOptionChildren = false;\n        var didWarnInvalidOptionInnerHTML = false;\n        var didWarnSelectedSetOnOption = false;\n        var didWarnFormActionType = false;\n        var didWarnFormActionName = false;\n        var didWarnFormActionTarget = false;\n        var didWarnFormActionMethod = false;\n        function checkSelectProp(props, propName) {\n            {\n                var value = props[propName];\n                if (value != null) {\n                    var array = isArray(value);\n                    if (props.multiple && !array) {\n                        error(\"The `%s` prop supplied to <select> must be an array if \" + \"`multiple` is true.\", propName);\n                    } else if (!props.multiple && array) {\n                        error(\"The `%s` prop supplied to <select> must be a scalar \" + \"value if `multiple` is false.\", propName);\n                    }\n                }\n            }\n        }\n        function pushStartSelect(target, props) {\n            {\n                checkControlledValueProps(\"select\", props);\n                checkSelectProp(props, \"value\");\n                checkSelectProp(props, \"defaultValue\");\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {\n                    error(\"Select elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled select \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\");\n                    didWarnDefaultSelectValue = true;\n                }\n            }\n            target.push(startChunkForTag(\"select\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            // TODO: This doesn't really make sense for select since it can't use the controlled\n                            // value in the innerHTML.\n                            innerHTML = propValue;\n                            break;\n                        case \"defaultValue\":\n                        case \"value\":\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        function flattenOptionChildren(children) {\n            var content = \"\"; // Flatten children and warn if they aren't strings or numbers;\n            // invalid types are ignored.\n            React.Children.forEach(children, function(child) {\n                if (child == null) {\n                    return;\n                }\n                content += child;\n                {\n                    if (!didWarnInvalidOptionChildren && typeof child !== \"string\" && typeof child !== \"number\") {\n                        didWarnInvalidOptionChildren = true;\n                        error(\"Cannot infer the option value of complex children. \" + \"Pass a `value` prop or use a plain string as children to <option>.\");\n                    }\n                }\n            });\n            return content;\n        }\n        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=\"\"');\n        function pushStartOption(target, props, formatContext) {\n            var selectedValue = formatContext.selectedValue;\n            target.push(startChunkForTag(\"option\"));\n            var children = null;\n            var value = null;\n            var selected = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"selected\":\n                            // ignore\n                            selected = propValue;\n                            {\n                                // TODO: Remove support for `selected` in <option>.\n                                if (!didWarnSelectedSetOnOption) {\n                                    error(\"Use the `defaultValue` or `value` props on <select> instead of \" + \"setting `selected` on <option>.\");\n                                    didWarnSelectedSetOnOption = true;\n                                }\n                            }\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                        // We intentionally fallthrough to also set the attribute on the node.\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (selectedValue != null) {\n                var stringValue;\n                if (value !== null) {\n                    {\n                        checkAttributeStringCoercion(value, \"value\");\n                    }\n                    stringValue = \"\" + value;\n                } else {\n                    {\n                        if (innerHTML !== null) {\n                            if (!didWarnInvalidOptionInnerHTML) {\n                                didWarnInvalidOptionInnerHTML = true;\n                                error(\"Pass a `value` prop if you set dangerouslyInnerHTML so React knows \" + \"which value should be selected.\");\n                            }\n                        }\n                    }\n                    stringValue = flattenOptionChildren(children);\n                }\n                if (isArray(selectedValue)) {\n                    // multiple\n                    for(var i = 0; i < selectedValue.length; i++){\n                        {\n                            checkAttributeStringCoercion(selectedValue[i], \"value\");\n                        }\n                        var v = \"\" + selectedValue[i];\n                        if (v === stringValue) {\n                            target.push(selectedMarkerAttribute);\n                            break;\n                        }\n                    }\n                } else {\n                    {\n                        checkAttributeStringCoercion(selectedValue, \"select.value\");\n                    }\n                    if (\"\" + selectedValue === stringValue) {\n                        target.push(selectedMarkerAttribute);\n                    }\n                }\n            } else if (selected) {\n                target.push(selectedMarkerAttribute);\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        var formReplayingRuntimeScript = stringToPrecomputedChunk(formReplaying);\n        function injectFormReplayingRuntime(resumableState, renderState) {\n            // If we haven't sent it yet, inject the runtime that tracks submitted JS actions\n            // for later replaying by Fiber. If we use an external runtime, we don't need\n            // to emit anything. It's always used.\n            if ((resumableState.instructions & SentFormReplayingRuntime) === NothingSent && !renderState.externalRuntimeScript) {\n                resumableState.instructions |= SentFormReplayingRuntime;\n                renderState.bootstrapChunks.unshift(renderState.startInlineScript, formReplayingRuntimeScript, endInlineScript);\n            }\n        }\n        var formStateMarkerIsMatching = stringToPrecomputedChunk(\"<!--F!-->\");\n        var formStateMarkerIsNotMatching = stringToPrecomputedChunk(\"<!--F-->\");\n        function pushFormStateMarkerIsMatching(target) {\n            target.push(formStateMarkerIsMatching);\n        }\n        function pushFormStateMarkerIsNotMatching(target) {\n            target.push(formStateMarkerIsNotMatching);\n        }\n        function pushStartForm(target, props, resumableState, renderState) {\n            target.push(startChunkForTag(\"form\"));\n            var children = null;\n            var innerHTML = null;\n            var formAction = null;\n            var formEncType = null;\n            var formMethod = null;\n            var formTarget = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"action\":\n                            formAction = propValue;\n                            break;\n                        case \"encType\":\n                            formEncType = propValue;\n                            break;\n                        case \"method\":\n                            formMethod = propValue;\n                            break;\n                        case \"target\":\n                            formTarget = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            var formData = null;\n            var formActionName = null;\n            if (typeof formAction === \"function\") {\n                // Function form actions cannot control the form properties\n                {\n                    if ((formEncType !== null || formMethod !== null) && !didWarnFormActionMethod) {\n                        didWarnFormActionMethod = true;\n                        error(\"Cannot specify a encType or method for a form that specifies a \" + \"function as the action. React provides those automatically. \" + \"They will get overridden.\");\n                    }\n                    if (formTarget !== null && !didWarnFormActionTarget) {\n                        didWarnFormActionTarget = true;\n                        error(\"Cannot specify a target for a form that specifies a function as the action. \" + \"The function will always be executed in the same window.\");\n                    }\n                }\n                var customAction = formAction.$$FORM_ACTION;\n                if (typeof customAction === \"function\") {\n                    // This action has a custom progressive enhancement form that can submit the form\n                    // back to the server if it's invoked before hydration. Such as a Server Action.\n                    var prefix = makeFormFieldPrefix(resumableState);\n                    var customFields = formAction.$$FORM_ACTION(prefix);\n                    formAction = customFields.action || \"\";\n                    formEncType = customFields.encType;\n                    formMethod = customFields.method;\n                    formTarget = customFields.target;\n                    formData = customFields.data;\n                    formActionName = customFields.name;\n                } else {\n                    // Set a javascript URL that doesn't do anything. We don't expect this to be invoked\n                    // because we'll preventDefault in the Fizz runtime, but it can happen if a form is\n                    // manually submitted or if someone calls stopPropagation before React gets the event.\n                    // If CSP is used to block javascript: URLs that's fine too. It just won't show this\n                    // error message but the URL will be logged.\n                    target.push(attributeSeparator, stringToChunk(\"action\"), attributeAssign, actionJavaScriptURL, attributeEnd);\n                    formAction = null;\n                    formEncType = null;\n                    formMethod = null;\n                    formTarget = null;\n                    injectFormReplayingRuntime(resumableState, renderState);\n                }\n            }\n            if (formAction != null) {\n                pushAttribute(target, \"action\", formAction);\n            }\n            if (formEncType != null) {\n                pushAttribute(target, \"encType\", formEncType);\n            }\n            if (formMethod != null) {\n                pushAttribute(target, \"method\", formMethod);\n            }\n            if (formTarget != null) {\n                pushAttribute(target, \"target\", formTarget);\n            }\n            target.push(endOfStartTag);\n            if (formActionName !== null) {\n                target.push(startHiddenInputChunk);\n                pushStringAttribute(target, \"name\", formActionName);\n                target.push(endOfStartTagSelfClosing);\n                pushAdditionalFormFields(target, formData);\n            }\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushInput(target, props, resumableState, renderState) {\n            {\n                checkControlledValueProps(\"input\", props);\n            }\n            target.push(startChunkForTag(\"input\"));\n            var name = null;\n            var formAction = null;\n            var formEncType = null;\n            var formMethod = null;\n            var formTarget = null;\n            var value = null;\n            var defaultValue = null;\n            var checked = null;\n            var defaultChecked = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"input\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        case \"name\":\n                            name = propValue;\n                            break;\n                        case \"formAction\":\n                            formAction = propValue;\n                            break;\n                        case \"formEncType\":\n                            formEncType = propValue;\n                            break;\n                        case \"formMethod\":\n                            formMethod = propValue;\n                            break;\n                        case \"formTarget\":\n                            formTarget = propValue;\n                            break;\n                        case \"defaultChecked\":\n                            defaultChecked = propValue;\n                            break;\n                        case \"defaultValue\":\n                            defaultValue = propValue;\n                            break;\n                        case \"checked\":\n                            checked = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            {\n                if (formAction !== null && props.type !== \"image\" && props.type !== \"submit\" && !didWarnFormActionType) {\n                    didWarnFormActionType = true;\n                    error('An input can only specify a formAction along with type=\"submit\" or type=\"image\".');\n                }\n            }\n            var formData = pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name);\n            {\n                if (checked !== null && defaultChecked !== null && !didWarnDefaultChecked) {\n                    error(\"%s contains an input of type %s with both checked and defaultChecked props. \" + \"Input elements must be either controlled or uncontrolled \" + \"(specify either the checked prop, or the defaultChecked prop, but not \" + \"both). Decide between using a controlled or uncontrolled input \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", \"A component\", props.type);\n                    didWarnDefaultChecked = true;\n                }\n                if (value !== null && defaultValue !== null && !didWarnDefaultInputValue) {\n                    error(\"%s contains an input of type %s with both value and defaultValue props. \" + \"Input elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled input \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", \"A component\", props.type);\n                    didWarnDefaultInputValue = true;\n                }\n            }\n            if (checked !== null) {\n                pushBooleanAttribute(target, \"checked\", checked);\n            } else if (defaultChecked !== null) {\n                pushBooleanAttribute(target, \"checked\", defaultChecked);\n            }\n            if (value !== null) {\n                pushAttribute(target, \"value\", value);\n            } else if (defaultValue !== null) {\n                pushAttribute(target, \"value\", defaultValue);\n            }\n            target.push(endOfStartTagSelfClosing); // We place any additional hidden form fields after the input.\n            pushAdditionalFormFields(target, formData);\n            return null;\n        }\n        function pushStartButton(target, props, resumableState, renderState) {\n            target.push(startChunkForTag(\"button\"));\n            var children = null;\n            var innerHTML = null;\n            var name = null;\n            var formAction = null;\n            var formEncType = null;\n            var formMethod = null;\n            var formTarget = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"name\":\n                            name = propValue;\n                            break;\n                        case \"formAction\":\n                            formAction = propValue;\n                            break;\n                        case \"formEncType\":\n                            formEncType = propValue;\n                            break;\n                        case \"formMethod\":\n                            formMethod = propValue;\n                            break;\n                        case \"formTarget\":\n                            formTarget = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            {\n                if (formAction !== null && props.type != null && props.type !== \"submit\" && !didWarnFormActionType) {\n                    didWarnFormActionType = true;\n                    error('A button can only specify a formAction along with type=\"submit\" or no type.');\n                }\n            }\n            var formData = pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name);\n            target.push(endOfStartTag); // We place any additional hidden form fields we need to include inside the button itself.\n            pushAdditionalFormFields(target, formData);\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushStartTextArea(target, props) {\n            {\n                checkControlledValueProps(\"textarea\", props);\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {\n                    error(\"Textarea elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled textarea \" + \"and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\");\n                    didWarnDefaultTextareaValue = true;\n                }\n            }\n            target.push(startChunkForTag(\"textarea\"));\n            var value = null;\n            var defaultValue = null;\n            var children = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                            break;\n                        case \"defaultValue\":\n                            defaultValue = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"`dangerouslySetInnerHTML` does not make sense on <textarea>.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (value === null && defaultValue !== null) {\n                value = defaultValue;\n            }\n            target.push(endOfStartTag); // TODO (yungsters): Remove support for children content in <textarea>.\n            if (children != null) {\n                {\n                    error(\"Use the `defaultValue` or `value` props instead of setting \" + \"children on <textarea>.\");\n                }\n                if (value != null) {\n                    throw new Error(\"If you supply `defaultValue` on a <textarea>, do not pass children.\");\n                }\n                if (isArray(children)) {\n                    if (children.length > 1) {\n                        throw new Error(\"<textarea> can only have at most one child.\");\n                    } // TODO: remove the coercion and the DEV check below because it will\n                    // always be overwritten by the coercion several lines below it. #22309\n                    {\n                        checkHtmlStringCoercion(children[0]);\n                    }\n                    value = \"\" + children[0];\n                }\n                {\n                    checkHtmlStringCoercion(children);\n                }\n                value = \"\" + children;\n            }\n            if (typeof value === \"string\" && value[0] === \"\\n\") {\n                // text/html ignores the first character in these tags if it's a newline\n                // Prefer to break application/xml over text/html (for now) by adding\n                // a newline specifically to get eaten by the parser. (Alternately for\n                // textareas, replacing \"^\\n\" with \"\\r\\n\" doesn't get eaten, and the first\n                // \\r is normalized out by HTMLTextAreaElement#value.)\n                // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>\n                // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>\n                // See: <http://www.w3.org/TR/html5/syntax.html#newlines>\n                // See: Parsing of \"textarea\" \"listing\" and \"pre\" elements\n                //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>\n                target.push(leadingNewline);\n            } // ToString and push directly instead of recurse over children.\n            // We don't really support complex children in the value anyway.\n            // This also currently avoids a trailing comment node which breaks textarea.\n            if (value !== null) {\n                {\n                    checkAttributeStringCoercion(value, \"value\");\n                }\n                target.push(stringToChunk(encodeHTMLTextNode(\"\" + value)));\n            }\n            return null;\n        }\n        function pushMeta(target, props, renderState, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null) {\n                    return pushSelfClosing(target, props, \"meta\");\n                } else {\n                    if (textEmbedded) {\n                        // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                        // to be safe and assume text will follow by inserting a textSeparator\n                        target.push(textSeparator);\n                    }\n                    if (typeof props.charSet === \"string\") {\n                        return pushSelfClosing(renderState.charsetChunks, props, \"meta\");\n                    } else if (props.name === \"viewport\") {\n                        // \"viewport\" isn't related to preconnect but it has the right priority\n                        return pushSelfClosing(renderState.preconnectChunks, props, \"meta\");\n                    } else {\n                        return pushSelfClosing(renderState.hoistableChunks, props, \"meta\");\n                    }\n                }\n            }\n        }\n        function pushLink(target, props, resumableState, renderState, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                var rel = props.rel;\n                var href = props.href;\n                var precedence = props.precedence;\n                if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null || typeof rel !== \"string\" || typeof href !== \"string\" || href === \"\") {\n                    {\n                        if (rel === \"stylesheet\" && typeof props.precedence === \"string\") {\n                            if (typeof href !== \"string\" || !href) {\n                                error('React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.', getValueDescriptorExpectingObjectForWarning(href));\n                            }\n                        }\n                    }\n                    pushLinkImpl(target, props);\n                    return null;\n                }\n                if (props.rel === \"stylesheet\") {\n                    // This <link> may hoistable as a Stylesheet Resource, otherwise it will emit in place\n                    var key = getResourceKey(href);\n                    if (typeof precedence !== \"string\" || props.disabled != null || props.onLoad || props.onError) {\n                        // This stylesheet is either not opted into Resource semantics or has conflicting properties which\n                        // disqualify it for such. We can still create a preload resource to help it load faster on the\n                        // client\n                        {\n                            if (typeof precedence === \"string\") {\n                                if (props.disabled != null) {\n                                    error('React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.');\n                                } else if (props.onLoad || props.onError) {\n                                    var propDescription = props.onLoad && props.onError ? \"`onLoad` and `onError` props\" : props.onLoad ? \"`onLoad` prop\" : \"`onError` prop\";\n                                    error('React encountered a `<link rel=\"stylesheet\" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.', propDescription, propDescription);\n                                }\n                            }\n                        }\n                        return pushLinkImpl(target, props);\n                    } else {\n                        // This stylesheet refers to a Resource and we create a new one if necessary\n                        var styleQueue = renderState.styles.get(precedence);\n                        var hasKey = resumableState.styleResources.hasOwnProperty(key);\n                        var resourceState = hasKey ? resumableState.styleResources[key] : undefined;\n                        if (resourceState !== EXISTS) {\n                            // We are going to create this resource now so it is marked as Exists\n                            resumableState.styleResources[key] = EXISTS; // If this is the first time we've encountered this precedence we need\n                            // to create a StyleQueue\n                            if (!styleQueue) {\n                                styleQueue = {\n                                    precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                                    rules: [],\n                                    hrefs: [],\n                                    sheets: new Map()\n                                };\n                                renderState.styles.set(precedence, styleQueue);\n                            }\n                            var resource = {\n                                state: PENDING$1,\n                                props: stylesheetPropsFromRawProps(props)\n                            };\n                            if (resourceState) {\n                                // When resourceState is truty it is a Preload state. We cast it for clarity\n                                var preloadState = resourceState;\n                                if (preloadState.length === 2) {\n                                    adoptPreloadCredentials(resource.props, preloadState);\n                                }\n                                var preloadResource = renderState.preloads.stylesheets.get(key);\n                                if (preloadResource && preloadResource.length > 0) {\n                                    // The Preload for this resource was created in this render pass and has not flushed yet so\n                                    // we need to clear it to avoid it flushing.\n                                    preloadResource.length = 0;\n                                } else {\n                                    // Either the preload resource from this render already flushed in this render pass\n                                    // or the preload flushed in a prior pass (prerender). In either case we need to mark\n                                    // this resource as already having been preloaded.\n                                    resource.state = PRELOADED;\n                                }\n                            } // We add the newly created resource to our StyleQueue and if necessary\n                            // track the resource with the currently rendering boundary\n                            styleQueue.sheets.set(key, resource);\n                            if (renderState.boundaryResources) {\n                                renderState.boundaryResources.stylesheets.add(resource);\n                            }\n                        } else {\n                            // We need to track whether this boundary should wait on this resource or not.\n                            // Typically this resource should always exist since we either had it or just created\n                            // it. However, it's possible when you resume that the style has already been emitted\n                            // and then it wouldn't be recreated in the RenderState and there's no need to track\n                            // it again since we should've hoisted it to the shell already.\n                            if (styleQueue) {\n                                var _resource = styleQueue.sheets.get(key);\n                                if (_resource) {\n                                    if (renderState.boundaryResources) {\n                                        renderState.boundaryResources.stylesheets.add(_resource);\n                                    }\n                                }\n                            }\n                        }\n                        if (textEmbedded) {\n                            // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                            // to be safe and assume text will follow by inserting a textSeparator\n                            target.push(textSeparator);\n                        }\n                        return null;\n                    }\n                } else if (props.onLoad || props.onError) {\n                    // When using load handlers we cannot hoist and need to emit links in place\n                    return pushLinkImpl(target, props);\n                } else {\n                    // We can hoist this link so we may need to emit a text separator.\n                    // @TODO refactor text separators so we don't have to defensively add\n                    // them when we don't end up emitting a tag as a result of pushStartInstance\n                    if (textEmbedded) {\n                        // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                        // to be safe and assume text will follow by inserting a textSeparator\n                        target.push(textSeparator);\n                    }\n                    switch(props.rel){\n                        case \"preconnect\":\n                        case \"dns-prefetch\":\n                            return pushLinkImpl(renderState.preconnectChunks, props);\n                        case \"preload\":\n                            return pushLinkImpl(renderState.preloadChunks, props);\n                        default:\n                            return pushLinkImpl(renderState.hoistableChunks, props);\n                    }\n                }\n            }\n        }\n        function pushLinkImpl(target, props) {\n            target.push(startChunkForTag(\"link\"));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"link\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTagSelfClosing);\n            return null;\n        }\n        function pushStyle(target, props, resumableState, renderState, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                if (hasOwnProperty.call(props, \"children\")) {\n                    var children = props.children;\n                    var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n                    if (typeof child === \"function\" || typeof child === \"symbol\" || Array.isArray(child)) {\n                        var childType = typeof child === \"function\" ? \"a Function\" : typeof child === \"symbol\" ? \"a Sybmol\" : \"an Array\";\n                        error(\"React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. \" + \"In browsers style Elements can only have `Text` Nodes as children.\", childType);\n                    }\n                }\n            }\n            {\n                var precedence = props.precedence;\n                var href = props.href;\n                if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null || typeof precedence !== \"string\" || typeof href !== \"string\" || href === \"\") {\n                    // This style tag is not able to be turned into a Style Resource\n                    return pushStyleImpl(target, props);\n                }\n                {\n                    if (href.includes(\" \")) {\n                        error('React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is \"%s\".', href);\n                    }\n                }\n                var key = getResourceKey(href);\n                var styleQueue = renderState.styles.get(precedence);\n                var hasKey = resumableState.styleResources.hasOwnProperty(key);\n                var resourceState = hasKey ? resumableState.styleResources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resumableState.styleResources[key] = EXISTS;\n                    {\n                        if (resourceState) {\n                            error('React encountered a hoistable style tag for the same href as a preload: \"%s\". When using a style tag to inline styles you should not also preload it as a stylsheet.', href);\n                        }\n                    }\n                    if (!styleQueue) {\n                        // This is the first time we've encountered this precedence we need\n                        // to create a StyleQueue.\n                        styleQueue = {\n                            precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                            rules: [],\n                            hrefs: [\n                                stringToChunk(escapeTextForBrowser(href))\n                            ],\n                            sheets: new Map()\n                        };\n                        renderState.styles.set(precedence, styleQueue);\n                    } else {\n                        // We have seen this precedence before and need to track this href\n                        styleQueue.hrefs.push(stringToChunk(escapeTextForBrowser(href)));\n                    }\n                    pushStyleContents(styleQueue.rules, props);\n                }\n                if (styleQueue) {\n                    // We need to track whether this boundary should wait on this resource or not.\n                    // Typically this resource should always exist since we either had it or just created\n                    // it. However, it's possible when you resume that the style has already been emitted\n                    // and then it wouldn't be recreated in the RenderState and there's no need to track\n                    // it again since we should've hoisted it to the shell already.\n                    if (renderState.boundaryResources) {\n                        renderState.boundaryResources.styles.add(styleQueue);\n                    }\n                }\n                if (textEmbedded) {\n                    // This link follows text but we aren't writing a tag. while not as efficient as possible we need\n                    // to be safe and assume text will follow by inserting a textSeparator\n                    target.push(textSeparator);\n                }\n            }\n        }\n        function pushStyleImpl(target, props) {\n            target.push(startChunkForTag(\"style\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n            if (typeof child !== \"function\" && typeof child !== \"symbol\" && child !== null && child !== undefined) {\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                target.push(stringToChunk(escapeTextForBrowser(\"\" + child)));\n            }\n            pushInnerHTML(target, innerHTML, children);\n            target.push(endChunkForTag(\"style\"));\n            return null;\n        }\n        function pushStyleContents(target, props) {\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                    }\n                }\n            }\n            var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n            if (typeof child !== \"function\" && typeof child !== \"symbol\" && child !== null && child !== undefined) {\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                target.push(stringToChunk(escapeTextForBrowser(\"\" + child)));\n            }\n            pushInnerHTML(target, innerHTML, children);\n            return;\n        }\n        function pushImg(target, props, resumableState, renderState, pictureTagInScope) {\n            var src = props.src, srcSet = props.srcSet;\n            if (props.loading !== \"lazy\" && (src || srcSet) && (typeof src === \"string\" || src == null) && (typeof srcSet === \"string\" || srcSet == null) && props.fetchPriority !== \"low\" && pictureTagInScope === false && // We exclude data URIs in src and srcSet since these should not be preloaded\n            !(typeof src === \"string\" && src[4] === \":\" && (src[0] === \"d\" || src[0] === \"D\") && (src[1] === \"a\" || src[1] === \"A\") && (src[2] === \"t\" || src[2] === \"T\") && (src[3] === \"a\" || src[3] === \"A\")) && !(typeof srcSet === \"string\" && srcSet[4] === \":\" && (srcSet[0] === \"d\" || srcSet[0] === \"D\") && (srcSet[1] === \"a\" || srcSet[1] === \"A\") && (srcSet[2] === \"t\" || srcSet[2] === \"T\") && (srcSet[3] === \"a\" || srcSet[3] === \"A\"))) {\n                // We have a suspensey image and ought to preload it to optimize the loading of display blocking\n                // resumableState.\n                var sizes = typeof props.sizes === \"string\" ? props.sizes : undefined;\n                var key = getImageResourceKey(src, srcSet, sizes);\n                var promotablePreloads = renderState.preloads.images;\n                var resource = promotablePreloads.get(key);\n                if (resource) {\n                    // We consider whether this preload can be promoted to higher priority flushing queue.\n                    // The only time a resource will exist here is if it was created during this render\n                    // and was not already in the high priority queue.\n                    if (props.fetchPriority === \"high\" || renderState.highImagePreloads.size < 10) {\n                        // Delete the resource from the map since we are promoting it and don't want to\n                        // reenter this branch in a second pass for duplicate img hrefs.\n                        promotablePreloads.delete(key); // $FlowFixMe - Flow should understand that this is a Resource if the condition was true\n                        renderState.highImagePreloads.add(resource);\n                    }\n                } else if (!resumableState.imageResources.hasOwnProperty(key)) {\n                    // We must construct a new preload resource\n                    resumableState.imageResources[key] = PRELOAD_NO_CREDS;\n                    var crossOrigin = getCrossOriginString(props.crossOrigin);\n                    var headers = renderState.headers;\n                    var header;\n                    if (headers && headers.remainingCapacity > 0 && // fetchPriority=\"high\". We use length here which means it will fit fewer images when\n                    // the urls are long and more when short. arguably byte size is a better hueristic because\n                    // it directly translates to how much we send down before content is actually seen.\n                    // We could unify the counts and also make it so the total is tracked regardless of\n                    // flushing output but since the headers are likely to be go earlier than content\n                    // they don't really conflict so for now I've kept them separate\n                    (props.fetchPriority === \"high\" || headers.highImagePreloads.length < 500) && // the params list with arbitrary props and if we copied everything over as it we might get\n                    // coercion errors. We have checks for this in Dev but it seems safer to just only accept values\n                    // that are strings\n                    (header = getPreloadAsHeader(src, \"image\", {\n                        imageSrcSet: props.srcSet,\n                        imageSizes: props.sizes,\n                        crossOrigin: crossOrigin,\n                        integrity: props.integrity,\n                        nonce: props.nonce,\n                        type: props.type,\n                        fetchPriority: props.fetchPriority,\n                        referrerPolicy: props.refererPolicy\n                    }), // we assume all the rest won't as well. This is to avoid getting into a situation\n                    // where we have a very small remaining capacity but no headers will ever fit and we end\n                    // up constantly trying to see if the next resource might make it. In the future we can\n                    // make this behavior different between render and prerender since in the latter case\n                    // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                    // headers.\n                    (headers.remainingCapacity -= header.length) >= 2)) {\n                        // If we postpone in the shell we will still emit this preload so we track\n                        // it to make sure we don't reset it.\n                        renderState.resets.image[key] = PRELOAD_NO_CREDS;\n                        if (headers.highImagePreloads) {\n                            headers.highImagePreloads += \", \";\n                        } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                        headers.highImagePreloads += header;\n                    } else {\n                        resource = [];\n                        pushLinkImpl(resource, {\n                            rel: \"preload\",\n                            as: \"image\",\n                            // There is a bug in Safari where imageSrcSet is not respected on preload links\n                            // so we omit the href here if we have imageSrcSet b/c safari will load the wrong image.\n                            // This harms older browers that do not support imageSrcSet by making their preloads not work\n                            // but this population is shrinking fast and is already small so we accept this tradeoff.\n                            href: srcSet ? undefined : src,\n                            imageSrcSet: srcSet,\n                            imageSizes: sizes,\n                            crossOrigin: crossOrigin,\n                            integrity: props.integrity,\n                            type: props.type,\n                            fetchPriority: props.fetchPriority,\n                            referrerPolicy: props.referrerPolicy\n                        });\n                        if (props.fetchPriority === \"high\" || renderState.highImagePreloads.size < 10) {\n                            renderState.highImagePreloads.add(resource);\n                        } else {\n                            renderState.bulkPreloads.add(resource); // We can bump the priority up if the same img is rendered later\n                            // with fetchPriority=\"high\"\n                            promotablePreloads.set(key, resource);\n                        }\n                    }\n                }\n            }\n            return pushSelfClosing(target, props, \"img\");\n        }\n        function pushSelfClosing(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(tag + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTagSelfClosing);\n            return null;\n        }\n        function pushStartMenuItem(target, props) {\n            target.push(startChunkForTag(\"menuitem\"));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"menuitems cannot have `children` nor `dangerouslySetInnerHTML`.\");\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            return null;\n        }\n        function pushTitle(target, props, renderState, insertionMode, noscriptTagInScope) {\n            {\n                if (hasOwnProperty.call(props, \"children\")) {\n                    var children = props.children;\n                    var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n                    if (Array.isArray(children) && children.length > 1) {\n                        error(\"React expects the `children` prop of <title> tags to be a string, number, or object with a novel `toString` method but found an Array with length %s instead.\" + \" Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value\" + \" which is why Arrays of length greater than 1 are not supported. When using JSX it can be commong to combine text nodes and value nodes.\" + \" For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop\" + \" is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.\", children.length);\n                    } else if (typeof child === \"function\" || typeof child === \"symbol\") {\n                        var childType = typeof child === \"function\" ? \"a Function\" : \"a Sybmol\";\n                        error(\"React expect children of <title> tags to be a string, number, or object with a novel `toString` method but found %s instead.\" + \" Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title>\" + \" tags to a single string value.\", childType);\n                    } else if (child && child.toString === ({}).toString) {\n                        if (child.$$typeof != null) {\n                            error(\"React expects the `children` prop of <title> tags to be a string, number, or object with a novel `toString` method but found an object that appears to be\" + \" a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to\" + \" be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is\" + \" a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.\");\n                        } else {\n                            error(\"React expects the `children` prop of <title> tags to be a string, number, or object with a novel `toString` method but found an object that does not implement\" + \" a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags\" + \" to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title>\" + \" is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>.\");\n                        }\n                    }\n                }\n            }\n            {\n                if (insertionMode !== SVG_MODE && !noscriptTagInScope && props.itemProp == null) {\n                    pushTitleImpl(renderState.hoistableChunks, props);\n                    return null;\n                } else {\n                    return pushTitleImpl(target, props);\n                }\n            }\n        }\n        function pushTitleImpl(target, props) {\n            target.push(startChunkForTag(\"title\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            var child = Array.isArray(children) ? children.length < 2 ? children[0] : null : children;\n            if (typeof child !== \"function\" && typeof child !== \"symbol\" && child !== null && child !== undefined) {\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                target.push(stringToChunk(escapeTextForBrowser(\"\" + child)));\n            }\n            pushInnerHTML(target, innerHTML, children);\n            target.push(endChunkForTag(\"title\"));\n            return null;\n        }\n        function pushStartHead(target, props, renderState, insertionMode) {\n            {\n                if (insertionMode < HTML_MODE && renderState.headChunks === null) {\n                    // This <head> is the Document.head and should be part of the preamble\n                    renderState.headChunks = [];\n                    return pushStartGenericElement(renderState.headChunks, props, \"head\");\n                } else {\n                    // This <head> is deep and is likely just an error. we emit it inline though.\n                    // Validation should warn that this tag is the the wrong spot.\n                    return pushStartGenericElement(target, props, \"head\");\n                }\n            }\n        }\n        function pushStartHtml(target, props, renderState, insertionMode) {\n            {\n                if (insertionMode === ROOT_HTML_MODE && renderState.htmlChunks === null) {\n                    // This <html> is the Document.documentElement and should be part of the preamble\n                    renderState.htmlChunks = [\n                        doctypeChunk\n                    ];\n                    return pushStartGenericElement(renderState.htmlChunks, props, \"html\");\n                } else {\n                    // This <html> is deep and is likely just an error. we emit it inline though.\n                    // Validation should warn that this tag is the the wrong spot.\n                    return pushStartGenericElement(target, props, \"html\");\n                }\n            }\n        }\n        function pushScript(target, props, resumableState, renderState, textEmbedded, insertionMode, noscriptTagInScope) {\n            {\n                var asyncProp = props.async;\n                if (typeof props.src !== \"string\" || !props.src || !(asyncProp && typeof asyncProp !== \"function\" && typeof asyncProp !== \"symbol\") || props.onLoad || props.onError || insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null) {\n                    // This script will not be a resource, we bailout early and emit it in place.\n                    return pushScriptImpl(target, props);\n                }\n                var src = props.src;\n                var key = getResourceKey(src); // We can make this <script> into a ScriptResource\n                var resources, preloads;\n                if (props.type === \"module\") {\n                    resources = resumableState.moduleScriptResources;\n                    preloads = renderState.preloads.moduleScripts;\n                } else {\n                    resources = resumableState.scriptResources;\n                    preloads = renderState.preloads.scripts;\n                }\n                var hasKey = resources.hasOwnProperty(key);\n                var resourceState = hasKey ? resources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resources[key] = EXISTS;\n                    var scriptProps = props;\n                    if (resourceState) {\n                        // When resourceState is truty it is a Preload state. We cast it for clarity\n                        var preloadState = resourceState;\n                        if (preloadState.length === 2) {\n                            scriptProps = assign({}, props);\n                            adoptPreloadCredentials(scriptProps, preloadState);\n                        }\n                        var preloadResource = preloads.get(key);\n                        if (preloadResource) {\n                            // the preload resource exists was created in this render. Now that we have\n                            // a script resource which will emit earlier than a preload would if it\n                            // hasn't already flushed we prevent it from flushing by zeroing the length\n                            preloadResource.length = 0;\n                        }\n                    }\n                    var resource = []; // Add to the script flushing queue\n                    renderState.scripts.add(resource); // encode the tag as Chunks\n                    pushScriptImpl(resource, scriptProps);\n                }\n                if (textEmbedded) {\n                    // This script follows text but we aren't writing a tag. while not as efficient as possible we need\n                    // to be safe and assume text will follow by inserting a textSeparator\n                    target.push(textSeparator);\n                }\n                return null;\n            }\n        }\n        function pushScriptImpl(target, props) {\n            target.push(startChunkForTag(\"script\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            {\n                if (children != null && typeof children !== \"string\") {\n                    var descriptiveStatement = typeof children === \"number\" ? \"a number for children\" : Array.isArray(children) ? \"an array for children\" : \"something unexpected for children\";\n                    error(\"A script element was rendered with %s. If script element has children it must be a single string.\" + \" Consider using dangerouslySetInnerHTML or passing a plain string as children.\", descriptiveStatement);\n                }\n            }\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n            }\n            target.push(endChunkForTag(\"script\"));\n            return null;\n        }\n        function pushStartGenericElement(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushStartCustomElement(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    var attributeName = propKey;\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"style\":\n                            pushStyleAttribute(target, propValue);\n                            break;\n                        case \"suppressContentEditableWarning\":\n                        case \"suppressHydrationWarning\":\n                            break;\n                        case \"className\":\n                        // intentional fallthrough\n                        default:\n                            if (isAttributeNameSafe(propKey) && typeof propValue !== \"function\" && typeof propValue !== \"symbol\") {\n                                target.push(attributeSeparator, stringToChunk(attributeName), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);\n                            }\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        var leadingNewline = stringToPrecomputedChunk(\"\\n\");\n        function pushStartPreformattedElement(target, props, tag) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag); // text/html ignores the first character in these tags if it's a newline\n            // Prefer to break application/xml over text/html (for now) by adding\n            // a newline specifically to get eaten by the parser. (Alternately for\n            // textareas, replacing \"^\\n\" with \"\\r\\n\" doesn't get eaten, and the first\n            // \\r is normalized out by HTMLTextAreaElement#value.)\n            // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>\n            // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>\n            // See: <http://www.w3.org/TR/html5/syntax.html#newlines>\n            // See: Parsing of \"textarea\" \"listing\" and \"pre\" elements\n            //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>\n            // TODO: This doesn't deal with the case where the child is an array\n            // or component that returns a string.\n            if (innerHTML != null) {\n                if (children != null) {\n                    throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n                }\n                if (typeof innerHTML !== \"object\" || !(\"__html\" in innerHTML)) {\n                    throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. \" + \"Please visit https://reactjs.org/link/dangerously-set-inner-html \" + \"for more information.\");\n                }\n                var html = innerHTML.__html;\n                if (html !== null && html !== undefined) {\n                    if (typeof html === \"string\" && html.length > 0 && html[0] === \"\\n\") {\n                        target.push(leadingNewline, stringToChunk(html));\n                    } else {\n                        {\n                            checkHtmlStringCoercion(html);\n                        }\n                        target.push(stringToChunk(\"\" + html));\n                    }\n                }\n            }\n            if (typeof children === \"string\" && children[0] === \"\\n\") {\n                target.push(leadingNewline);\n            }\n            return children;\n        } // We accept any tag to be rendered but since this gets injected into arbitrary\n        // HTML, we want to make sure that it's a safe tag.\n        // http://www.w3.org/TR/REC-xml/#NT-Name\n        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/; // Simplified subset\n        var validatedTagCache = new Map();\n        function startChunkForTag(tag) {\n            var tagStartChunk = validatedTagCache.get(tag);\n            if (tagStartChunk === undefined) {\n                if (!VALID_TAG_REGEX.test(tag)) {\n                    throw new Error(\"Invalid tag: \" + tag);\n                }\n                tagStartChunk = stringToPrecomputedChunk(\"<\" + tag);\n                validatedTagCache.set(tag, tagStartChunk);\n            }\n            return tagStartChunk;\n        }\n        var doctypeChunk = stringToPrecomputedChunk(\"<!DOCTYPE html>\");\n        function pushStartInstance(target, type, props, resumableState, renderState, formatContext, textEmbedded) {\n            {\n                validateProperties$2(type, props);\n                validateProperties$1(type, props);\n                validateProperties(type, props, null);\n                if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {\n                    error(\"A component is `contentEditable` and contains `children` managed by \" + \"React. It is now your responsibility to guarantee that none of \" + \"those nodes are unexpectedly modified or duplicated. This is \" + \"probably not intentional.\");\n                }\n                if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {\n                    if (type.indexOf(\"-\") === -1 && type.toLowerCase() !== type) {\n                        error(\"<%s /> is using incorrect casing. \" + \"Use PascalCase for React components, \" + \"or lowercase for HTML elements.\", type);\n                    }\n                }\n            }\n            switch(type){\n                case \"div\":\n                case \"span\":\n                case \"svg\":\n                case \"path\":\n                case \"a\":\n                case \"g\":\n                case \"p\":\n                case \"li\":\n                    break;\n                // Special tags\n                case \"select\":\n                    return pushStartSelect(target, props);\n                case \"option\":\n                    return pushStartOption(target, props, formatContext);\n                case \"textarea\":\n                    return pushStartTextArea(target, props);\n                case \"input\":\n                    return pushInput(target, props, resumableState, renderState);\n                case \"button\":\n                    return pushStartButton(target, props, resumableState, renderState);\n                case \"form\":\n                    return pushStartForm(target, props, resumableState, renderState);\n                case \"menuitem\":\n                    return pushStartMenuItem(target, props);\n                case \"title\":\n                    return pushTitle(target, props, renderState, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                case \"link\":\n                    return pushLink(target, props, resumableState, renderState, textEmbedded, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                case \"script\":\n                    return pushScript(target, props, resumableState, renderState, textEmbedded, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                case \"style\":\n                    return pushStyle(target, props, resumableState, renderState, textEmbedded, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                case \"meta\":\n                    return pushMeta(target, props, renderState, textEmbedded, formatContext.insertionMode, !!(formatContext.tagScope & NOSCRIPT_SCOPE));\n                // Newline eating tags\n                case \"listing\":\n                case \"pre\":\n                    {\n                        return pushStartPreformattedElement(target, props, type);\n                    }\n                case \"img\":\n                    {\n                        return pushImg(target, props, resumableState, renderState, !!(formatContext.tagScope & PICTURE_SCOPE));\n                    }\n                // Omitted close tags\n                case \"base\":\n                case \"area\":\n                case \"br\":\n                case \"col\":\n                case \"embed\":\n                case \"hr\":\n                case \"keygen\":\n                case \"param\":\n                case \"source\":\n                case \"track\":\n                case \"wbr\":\n                    {\n                        return pushSelfClosing(target, props, type);\n                    }\n                // These are reserved SVG and MathML elements, that are never custom elements.\n                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n                case \"annotation-xml\":\n                case \"color-profile\":\n                case \"font-face\":\n                case \"font-face-src\":\n                case \"font-face-uri\":\n                case \"font-face-format\":\n                case \"font-face-name\":\n                case \"missing-glyph\":\n                    {\n                        break;\n                    }\n                // Preamble start tags\n                case \"head\":\n                    return pushStartHead(target, props, renderState, formatContext.insertionMode);\n                case \"html\":\n                    {\n                        return pushStartHtml(target, props, renderState, formatContext.insertionMode);\n                    }\n                default:\n                    {\n                        if (type.indexOf(\"-\") !== -1) {\n                            // Custom element\n                            return pushStartCustomElement(target, props, type);\n                        }\n                    }\n            } // Generic element\n            return pushStartGenericElement(target, props, type);\n        }\n        var endTagCache = new Map();\n        function endChunkForTag(tag) {\n            var chunk = endTagCache.get(tag);\n            if (chunk === undefined) {\n                chunk = stringToPrecomputedChunk(\"</\" + tag + \">\");\n                endTagCache.set(tag, chunk);\n            }\n            return chunk;\n        }\n        function pushEndInstance(target, type, props, resumableState, formatContext) {\n            switch(type){\n                // When float is on we expect title and script tags to always be pushed in\n                // a unit and never return children. when we end up pushing the end tag we\n                // want to ensure there is no extra closing tag pushed\n                case \"title\":\n                case \"style\":\n                case \"script\":\n                // Omitted close tags\n                // TODO: Instead of repeating this switch we could try to pass a flag from above.\n                // That would require returning a tuple. Which might be ok if it gets inlined.\n                case \"area\":\n                case \"base\":\n                case \"br\":\n                case \"col\":\n                case \"embed\":\n                case \"hr\":\n                case \"img\":\n                case \"input\":\n                case \"keygen\":\n                case \"link\":\n                case \"meta\":\n                case \"param\":\n                case \"source\":\n                case \"track\":\n                case \"wbr\":\n                    {\n                        // No close tag needed.\n                        return;\n                    }\n                // Postamble end tags\n                // When float is enabled we omit the end tags for body and html when\n                // they represent the Document.body and Document.documentElement Nodes.\n                // This is so we can withhold them until the postamble when we know\n                // we won't emit any more tags\n                case \"body\":\n                    {\n                        if (formatContext.insertionMode <= HTML_HTML_MODE) {\n                            resumableState.hasBody = true;\n                            return;\n                        }\n                        break;\n                    }\n                case \"html\":\n                    if (formatContext.insertionMode === ROOT_HTML_MODE) {\n                        resumableState.hasHtml = true;\n                        return;\n                    }\n                    break;\n            }\n            target.push(endChunkForTag(type));\n        }\n        function writeBootstrap(destination, renderState) {\n            var bootstrapChunks = renderState.bootstrapChunks;\n            var i = 0;\n            for(; i < bootstrapChunks.length - 1; i++){\n                writeChunk(destination, bootstrapChunks[i]);\n            }\n            if (i < bootstrapChunks.length) {\n                var lastChunk = bootstrapChunks[i];\n                bootstrapChunks.length = 0;\n                return writeChunkAndReturn(destination, lastChunk);\n            }\n            return true;\n        }\n        function writeCompletedRoot(destination, renderState) {\n            return writeBootstrap(destination, renderState);\n        } // Structural Nodes\n        // A placeholder is a node inside a hidden partial tree that can be filled in later, but before\n        // display. It's never visible to users. We use the template tag because it can be used in every\n        // type of parent. <script> tags also work in every other tag except <colgroup>.\n        var placeholder1 = stringToPrecomputedChunk('<template id=\"');\n        var placeholder2 = stringToPrecomputedChunk('\"></template>');\n        function writePlaceholder(destination, renderState, id) {\n            writeChunk(destination, placeholder1);\n            writeChunk(destination, renderState.placeholderPrefix);\n            var formattedID = stringToChunk(id.toString(16));\n            writeChunk(destination, formattedID);\n            return writeChunkAndReturn(destination, placeholder2);\n        } // Suspense boundaries are encoded as comments.\n        var startCompletedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$-->\");\n        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id=\"');\n        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('\"></template>');\n        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$!-->\");\n        var endSuspenseBoundary = stringToPrecomputedChunk(\"<!--/$-->\");\n        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk(\"<template\");\n        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('\"');\n        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst=\"');\n        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg=\"');\n        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck=\"');\n        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk(\"></template>\");\n        function writeStartCompletedSuspenseBoundary(destination, renderState) {\n            return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);\n        }\n        function writeStartPendingSuspenseBoundary(destination, renderState, id) {\n            writeChunk(destination, startPendingSuspenseBoundary1);\n            if (id === null) {\n                throw new Error(\"An ID must have been assigned before we can complete the boundary.\");\n            }\n            writeChunk(destination, renderState.boundaryPrefix);\n            writeChunk(destination, stringToChunk(id.toString(16)));\n            return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);\n        }\n        function writeStartClientRenderedSuspenseBoundary(destination, renderState, errorDigest, errorMesssage, errorComponentStack) {\n            var result;\n            result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);\n            writeChunk(destination, clientRenderedSuspenseBoundaryError1);\n            if (errorDigest) {\n                writeChunk(destination, clientRenderedSuspenseBoundaryError1A);\n                writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));\n                writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n            }\n            {\n                if (errorMesssage) {\n                    writeChunk(destination, clientRenderedSuspenseBoundaryError1B);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));\n                    writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n                }\n                if (errorComponentStack) {\n                    writeChunk(destination, clientRenderedSuspenseBoundaryError1C);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));\n                    writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n                }\n            }\n            result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);\n            return result;\n        }\n        function writeEndCompletedSuspenseBoundary(destination, renderState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        function writeEndPendingSuspenseBoundary(destination, renderState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        function writeEndClientRenderedSuspenseBoundary(destination, renderState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id=\"');\n        var startSegmentHTML2 = stringToPrecomputedChunk('\">');\n        var endSegmentHTML = stringToPrecomputedChunk(\"</div>\");\n        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden=\"true\" style=\"display:none\" id=\"');\n        var startSegmentSVG2 = stringToPrecomputedChunk('\">');\n        var endSegmentSVG = stringToPrecomputedChunk(\"</svg>\");\n        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden=\"true\" style=\"display:none\" id=\"');\n        var startSegmentMathML2 = stringToPrecomputedChunk('\">');\n        var endSegmentMathML = stringToPrecomputedChunk(\"</math>\");\n        var startSegmentTable = stringToPrecomputedChunk('<table hidden id=\"');\n        var startSegmentTable2 = stringToPrecomputedChunk('\">');\n        var endSegmentTable = stringToPrecomputedChunk(\"</table>\");\n        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id=\"');\n        var startSegmentTableBody2 = stringToPrecomputedChunk('\">');\n        var endSegmentTableBody = stringToPrecomputedChunk(\"</tbody></table>\");\n        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id=\"');\n        var startSegmentTableRow2 = stringToPrecomputedChunk('\">');\n        var endSegmentTableRow = stringToPrecomputedChunk(\"</tr></table>\");\n        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id=\"');\n        var startSegmentColGroup2 = stringToPrecomputedChunk('\">');\n        var endSegmentColGroup = stringToPrecomputedChunk(\"</colgroup></table>\");\n        function writeStartSegment(destination, renderState, formatContext, id) {\n            switch(formatContext.insertionMode){\n                case ROOT_HTML_MODE:\n                case HTML_HTML_MODE:\n                case HTML_MODE:\n                    {\n                        writeChunk(destination, startSegmentHTML);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentHTML2);\n                    }\n                case SVG_MODE:\n                    {\n                        writeChunk(destination, startSegmentSVG);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentSVG2);\n                    }\n                case MATHML_MODE:\n                    {\n                        writeChunk(destination, startSegmentMathML);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentMathML2);\n                    }\n                case HTML_TABLE_MODE:\n                    {\n                        writeChunk(destination, startSegmentTable);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTable2);\n                    }\n                // TODO: For the rest of these, there will be extra wrapper nodes that never\n                // get deleted from the document. We need to delete the table too as part\n                // of the injected scripts. They are invisible though so it's not too terrible\n                // and it's kind of an edge case to suspend in a table. Totally supported though.\n                case HTML_TABLE_BODY_MODE:\n                    {\n                        writeChunk(destination, startSegmentTableBody);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTableBody2);\n                    }\n                case HTML_TABLE_ROW_MODE:\n                    {\n                        writeChunk(destination, startSegmentTableRow);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTableRow2);\n                    }\n                case HTML_COLGROUP_MODE:\n                    {\n                        writeChunk(destination, startSegmentColGroup);\n                        writeChunk(destination, renderState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentColGroup2);\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown insertion mode. This is a bug in React.\");\n                    }\n            }\n        }\n        function writeEndSegment(destination, formatContext) {\n            switch(formatContext.insertionMode){\n                case ROOT_HTML_MODE:\n                case HTML_HTML_MODE:\n                case HTML_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentHTML);\n                    }\n                case SVG_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentSVG);\n                    }\n                case MATHML_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentMathML);\n                    }\n                case HTML_TABLE_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTable);\n                    }\n                case HTML_TABLE_BODY_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTableBody);\n                    }\n                case HTML_TABLE_ROW_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTableRow);\n                    }\n                case HTML_COLGROUP_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentColGroup);\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown insertion mode. This is a bug in React.\");\n                    }\n            }\n        }\n        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegment + '$RS(\"');\n        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS(\"');\n        var completeSegmentScript2 = stringToPrecomputedChunk('\",\"');\n        var completeSegmentScriptEnd = stringToPrecomputedChunk('\")</script>');\n        var completeSegmentData1 = stringToPrecomputedChunk('<template data-rsi=\"\" data-sid=\"');\n        var completeSegmentData2 = stringToPrecomputedChunk('\" data-pid=\"');\n        var completeSegmentDataEnd = dataElementQuotedEnd;\n        function writeCompletedSegmentInstruction(destination, resumableState, renderState, contentSegmentID) {\n            var scriptFormat = resumableState.streamingFormat === ScriptStreamingFormat;\n            if (scriptFormat) {\n                writeChunk(destination, renderState.startInlineScript);\n                if ((resumableState.instructions & SentCompleteSegmentFunction) === NothingSent) {\n                    // The first time we write this, we'll need to include the full implementation.\n                    resumableState.instructions |= SentCompleteSegmentFunction;\n                    writeChunk(destination, completeSegmentScript1Full);\n                } else {\n                    // Future calls can just reuse the same function.\n                    writeChunk(destination, completeSegmentScript1Partial);\n                }\n            } else {\n                writeChunk(destination, completeSegmentData1);\n            } // Write function arguments, which are string literals\n            writeChunk(destination, renderState.segmentPrefix);\n            var formattedID = stringToChunk(contentSegmentID.toString(16));\n            writeChunk(destination, formattedID);\n            if (scriptFormat) {\n                writeChunk(destination, completeSegmentScript2);\n            } else {\n                writeChunk(destination, completeSegmentData2);\n            }\n            writeChunk(destination, renderState.placeholderPrefix);\n            writeChunk(destination, formattedID);\n            if (scriptFormat) {\n                return writeChunkAndReturn(destination, completeSegmentScriptEnd);\n            } else {\n                return writeChunkAndReturn(destination, completeSegmentDataEnd);\n            }\n        }\n        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundary + '$RC(\"');\n        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC(\"');\n        var completeBoundaryWithStylesScript1FullBoth = stringToPrecomputedChunk(completeBoundary + completeBoundaryWithStyles + '$RR(\"');\n        var completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(completeBoundaryWithStyles + '$RR(\"');\n        var completeBoundaryWithStylesScript1Partial = stringToPrecomputedChunk('$RR(\"');\n        var completeBoundaryScript2 = stringToPrecomputedChunk('\",\"');\n        var completeBoundaryScript3a = stringToPrecomputedChunk('\",');\n        var completeBoundaryScript3b = stringToPrecomputedChunk('\"');\n        var completeBoundaryScriptEnd = stringToPrecomputedChunk(\")</script>\");\n        var completeBoundaryData1 = stringToPrecomputedChunk('<template data-rci=\"\" data-bid=\"');\n        var completeBoundaryWithStylesData1 = stringToPrecomputedChunk('<template data-rri=\"\" data-bid=\"');\n        var completeBoundaryData2 = stringToPrecomputedChunk('\" data-sid=\"');\n        var completeBoundaryData3a = stringToPrecomputedChunk('\" data-sty=\"');\n        var completeBoundaryDataEnd = dataElementQuotedEnd;\n        function writeCompletedBoundaryInstruction(destination, resumableState, renderState, id, boundaryResources) {\n            var requiresStyleInsertion;\n            {\n                requiresStyleInsertion = renderState.stylesToHoist; // If necessary stylesheets will be flushed with this instruction.\n                // Any style tags not yet hoisted in the Document will also be hoisted.\n                // We reset this state since after this instruction executes all styles\n                // up to this point will have been hoisted\n                renderState.stylesToHoist = false;\n            }\n            var scriptFormat = resumableState.streamingFormat === ScriptStreamingFormat;\n            if (scriptFormat) {\n                writeChunk(destination, renderState.startInlineScript);\n                if (requiresStyleInsertion) {\n                    if ((resumableState.instructions & SentCompleteBoundaryFunction) === NothingSent) {\n                        resumableState.instructions |= SentStyleInsertionFunction | SentCompleteBoundaryFunction;\n                        writeChunk(destination, clonePrecomputedChunk(completeBoundaryWithStylesScript1FullBoth));\n                    } else if ((resumableState.instructions & SentStyleInsertionFunction) === NothingSent) {\n                        resumableState.instructions |= SentStyleInsertionFunction;\n                        writeChunk(destination, completeBoundaryWithStylesScript1FullPartial);\n                    } else {\n                        writeChunk(destination, completeBoundaryWithStylesScript1Partial);\n                    }\n                } else {\n                    if ((resumableState.instructions & SentCompleteBoundaryFunction) === NothingSent) {\n                        resumableState.instructions |= SentCompleteBoundaryFunction;\n                        writeChunk(destination, completeBoundaryScript1Full);\n                    } else {\n                        writeChunk(destination, completeBoundaryScript1Partial);\n                    }\n                }\n            } else {\n                if (requiresStyleInsertion) {\n                    writeChunk(destination, completeBoundaryWithStylesData1);\n                } else {\n                    writeChunk(destination, completeBoundaryData1);\n                }\n            }\n            var idChunk = stringToChunk(id.toString(16));\n            writeChunk(destination, renderState.boundaryPrefix);\n            writeChunk(destination, idChunk); // Write function arguments, which are string and array literals\n            if (scriptFormat) {\n                writeChunk(destination, completeBoundaryScript2);\n            } else {\n                writeChunk(destination, completeBoundaryData2);\n            }\n            writeChunk(destination, renderState.segmentPrefix);\n            writeChunk(destination, idChunk);\n            if (requiresStyleInsertion) {\n                // Script and data writers must format this differently:\n                //  - script writer emits an array literal, whose string elements are\n                //    escaped for javascript  e.g. [\"A\", \"B\"]\n                //  - data writer emits a string literal, which is escaped as html\n                //    e.g. [&#34;A&#34;, &#34;B&#34;]\n                if (scriptFormat) {\n                    writeChunk(destination, completeBoundaryScript3a); // boundaryResources encodes an array literal\n                    writeStyleResourceDependenciesInJS(destination, boundaryResources);\n                } else {\n                    writeChunk(destination, completeBoundaryData3a);\n                    writeStyleResourceDependenciesInAttr(destination, boundaryResources);\n                }\n            } else {\n                if (scriptFormat) {\n                    writeChunk(destination, completeBoundaryScript3b);\n                }\n            }\n            var writeMore;\n            if (scriptFormat) {\n                writeMore = writeChunkAndReturn(destination, completeBoundaryScriptEnd);\n            } else {\n                writeMore = writeChunkAndReturn(destination, completeBoundaryDataEnd);\n            }\n            return writeBootstrap(destination, renderState) && writeMore;\n        }\n        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderBoundary + ';$RX(\"');\n        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX(\"');\n        var clientRenderScript1A = stringToPrecomputedChunk('\"');\n        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(\",\");\n        var clientRenderScriptEnd = stringToPrecomputedChunk(\")</script>\");\n        var clientRenderData1 = stringToPrecomputedChunk('<template data-rxi=\"\" data-bid=\"');\n        var clientRenderData2 = stringToPrecomputedChunk('\" data-dgst=\"');\n        var clientRenderData3 = stringToPrecomputedChunk('\" data-msg=\"');\n        var clientRenderData4 = stringToPrecomputedChunk('\" data-stck=\"');\n        var clientRenderDataEnd = dataElementQuotedEnd;\n        function writeClientRenderBoundaryInstruction(destination, resumableState, renderState, id, errorDigest, errorMessage, errorComponentStack) {\n            var scriptFormat = resumableState.streamingFormat === ScriptStreamingFormat;\n            if (scriptFormat) {\n                writeChunk(destination, renderState.startInlineScript);\n                if ((resumableState.instructions & SentClientRenderFunction) === NothingSent) {\n                    // The first time we write this, we'll need to include the full implementation.\n                    resumableState.instructions |= SentClientRenderFunction;\n                    writeChunk(destination, clientRenderScript1Full);\n                } else {\n                    // Future calls can just reuse the same function.\n                    writeChunk(destination, clientRenderScript1Partial);\n                }\n            } else {\n                // <template data-rxi=\"\" data-bid=\"\n                writeChunk(destination, clientRenderData1);\n            }\n            writeChunk(destination, renderState.boundaryPrefix);\n            writeChunk(destination, stringToChunk(id.toString(16)));\n            if (scriptFormat) {\n                // \" needs to be inserted for scripts, since ArgInterstitual does not contain\n                // leading or trailing quotes\n                writeChunk(destination, clientRenderScript1A);\n            }\n            if (errorDigest || errorMessage || errorComponentStack) {\n                if (scriptFormat) {\n                    // ,\"JSONString\"\n                    writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                    writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || \"\")));\n                } else {\n                    // \" data-dgst=\"HTMLString\n                    writeChunk(destination, clientRenderData2);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest || \"\")));\n                }\n            }\n            if (errorMessage || errorComponentStack) {\n                if (scriptFormat) {\n                    // ,\"JSONString\"\n                    writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                    writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || \"\")));\n                } else {\n                    // \" data-msg=\"HTMLString\n                    writeChunk(destination, clientRenderData3);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMessage || \"\")));\n                }\n            }\n            if (errorComponentStack) {\n                // ,\"JSONString\"\n                if (scriptFormat) {\n                    writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                    writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));\n                } else {\n                    // \" data-stck=\"HTMLString\n                    writeChunk(destination, clientRenderData4);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));\n                }\n            }\n            if (scriptFormat) {\n                // ></script>\n                return writeChunkAndReturn(destination, clientRenderScriptEnd);\n            } else {\n                // \"></template>\n                return writeChunkAndReturn(destination, clientRenderDataEnd);\n            }\n        }\n        var regexForJSStringsInInstructionScripts = /[<\\u2028\\u2029]/g;\n        function escapeJSStringsForInstructionScripts(input) {\n            var escaped = JSON.stringify(input);\n            return escaped.replace(regexForJSStringsInInstructionScripts, function(match) {\n                switch(match){\n                    // santizing breaking out of strings and script tags\n                    case \"<\":\n                        return \"\\\\u003c\";\n                    case \"\\u2028\":\n                        return \"\\\\u2028\";\n                    case \"\\u2029\":\n                        return \"\\\\u2029\";\n                    default:\n                        {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error(\"escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                        }\n                }\n            });\n        }\n        var regexForJSStringsInScripts = /[&><\\u2028\\u2029]/g;\n        function escapeJSObjectForInstructionScripts(input) {\n            var escaped = JSON.stringify(input);\n            return escaped.replace(regexForJSStringsInScripts, function(match) {\n                switch(match){\n                    // santizing breaking out of strings and script tags\n                    case \"&\":\n                        return \"\\\\u0026\";\n                    case \">\":\n                        return \"\\\\u003e\";\n                    case \"<\":\n                        return \"\\\\u003c\";\n                    case \"\\u2028\":\n                        return \"\\\\u2028\";\n                    case \"\\u2029\":\n                        return \"\\\\u2029\";\n                    default:\n                        {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error(\"escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                        }\n                }\n            });\n        }\n        var lateStyleTagResourceOpen1 = stringToPrecomputedChunk('<style media=\"not all\" data-precedence=\"');\n        var lateStyleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"');\n        var lateStyleTagResourceOpen3 = stringToPrecomputedChunk('\">');\n        var lateStyleTagTemplateClose = stringToPrecomputedChunk(\"</style>\"); // Tracks whether the boundary currently flushing is flushign style tags or has any\n        // stylesheet dependencies not flushed in the Preamble.\n        var currentlyRenderingBoundaryHasStylesToHoist = false; // Acts as a return value for the forEach execution of style tag flushing.\n        var destinationHasCapacity = true;\n        function flushStyleTagsLateForBoundary(styleQueue) {\n            var rules = styleQueue.rules;\n            var hrefs = styleQueue.hrefs;\n            {\n                if (rules.length > 0 && hrefs.length === 0) {\n                    error(\"React expected to have at least one href for an a hoistable style but found none. This is a bug in React.\");\n                }\n            }\n            var i = 0;\n            if (hrefs.length) {\n                writeChunk(this, lateStyleTagResourceOpen1);\n                writeChunk(this, styleQueue.precedence);\n                writeChunk(this, lateStyleTagResourceOpen2);\n                for(; i < hrefs.length - 1; i++){\n                    writeChunk(this, hrefs[i]);\n                    writeChunk(this, spaceSeparator);\n                }\n                writeChunk(this, hrefs[i]);\n                writeChunk(this, lateStyleTagResourceOpen3);\n                for(i = 0; i < rules.length; i++){\n                    writeChunk(this, rules[i]);\n                }\n                destinationHasCapacity = writeChunkAndReturn(this, lateStyleTagTemplateClose); // We wrote style tags for this boundary and we may need to emit a script\n                // to hoist them.\n                currentlyRenderingBoundaryHasStylesToHoist = true; // style resources can flush continuously since more rules may be written into\n                // them with new hrefs. Instead of marking it flushed, we simply reset the chunks\n                // and hrefs\n                rules.length = 0;\n                hrefs.length = 0;\n            }\n        }\n        function hasStylesToHoist(stylesheet) {\n            // We need to reveal boundaries with styles whenever a stylesheet it depends on is either\n            // not flushed or flushed after the preamble (shell).\n            if (stylesheet.state !== PREAMBLE) {\n                currentlyRenderingBoundaryHasStylesToHoist = true;\n                return true;\n            }\n            return false;\n        }\n        function writeResourcesForBoundary(destination, boundaryResources, renderState) {\n            // Reset these on each invocation, they are only safe to read in this function\n            currentlyRenderingBoundaryHasStylesToHoist = false;\n            destinationHasCapacity = true; // Flush style tags for each precedence this boundary depends on\n            boundaryResources.styles.forEach(flushStyleTagsLateForBoundary, destination); // Determine if this boundary has stylesheets that need to be awaited upon completion\n            boundaryResources.stylesheets.forEach(hasStylesToHoist);\n            if (currentlyRenderingBoundaryHasStylesToHoist) {\n                renderState.stylesToHoist = true;\n            }\n            return destinationHasCapacity;\n        }\n        function flushResource(resource) {\n            for(var i = 0; i < resource.length; i++){\n                writeChunk(this, resource[i]);\n            }\n            resource.length = 0;\n        }\n        var stylesheetFlushingQueue = [];\n        function flushStyleInPreamble(stylesheet, key, map) {\n            // We still need to encode stylesheet chunks\n            // because unlike most Hoistables and Resources we do not eagerly encode\n            // them during render. This is because if we flush late we have to send a\n            // different encoding and we don't want to encode multiple times\n            pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);\n            for(var i = 0; i < stylesheetFlushingQueue.length; i++){\n                writeChunk(this, stylesheetFlushingQueue[i]);\n            }\n            stylesheetFlushingQueue.length = 0;\n            stylesheet.state = PREAMBLE;\n        }\n        var styleTagResourceOpen1 = stringToPrecomputedChunk('<style data-precedence=\"');\n        var styleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"');\n        var spaceSeparator = stringToPrecomputedChunk(\" \");\n        var styleTagResourceOpen3 = stringToPrecomputedChunk('\">');\n        var styleTagResourceClose = stringToPrecomputedChunk(\"</style>\");\n        function flushStylesInPreamble(styleQueue, precedence) {\n            var hasStylesheets = styleQueue.sheets.size > 0;\n            styleQueue.sheets.forEach(flushStyleInPreamble, this);\n            styleQueue.sheets.clear();\n            var rules = styleQueue.rules;\n            var hrefs = styleQueue.hrefs; // If we don't emit any stylesheets at this precedence we still need to maintain the precedence\n            // order so even if there are no rules for style tags at this precedence we emit an empty style\n            // tag with the data-precedence attribute\n            if (!hasStylesheets || hrefs.length) {\n                writeChunk(this, styleTagResourceOpen1);\n                writeChunk(this, styleQueue.precedence);\n                var i = 0;\n                if (hrefs.length) {\n                    writeChunk(this, styleTagResourceOpen2);\n                    for(; i < hrefs.length - 1; i++){\n                        writeChunk(this, hrefs[i]);\n                        writeChunk(this, spaceSeparator);\n                    }\n                    writeChunk(this, hrefs[i]);\n                }\n                writeChunk(this, styleTagResourceOpen3);\n                for(i = 0; i < rules.length; i++){\n                    writeChunk(this, rules[i]);\n                }\n                writeChunk(this, styleTagResourceClose); // style resources can flush continuously since more rules may be written into\n                // them with new hrefs. Instead of marking it flushed, we simply reset the chunks\n                // and hrefs\n                rules.length = 0;\n                hrefs.length = 0;\n            }\n        }\n        function preloadLateStyle(stylesheet) {\n            if (stylesheet.state === PENDING$1) {\n                stylesheet.state = PRELOADED;\n                var preloadProps = preloadAsStylePropsFromProps(stylesheet.props.href, stylesheet.props);\n                pushLinkImpl(stylesheetFlushingQueue, preloadProps);\n                for(var i = 0; i < stylesheetFlushingQueue.length; i++){\n                    writeChunk(this, stylesheetFlushingQueue[i]);\n                }\n                stylesheetFlushingQueue.length = 0;\n            }\n        }\n        function preloadLateStyles(styleQueue) {\n            styleQueue.sheets.forEach(preloadLateStyle, this);\n            styleQueue.sheets.clear();\n        } // We don't bother reporting backpressure at the moment because we expect to\n        // flush the entire preamble in a single pass. This probably should be modified\n        // in the future to be backpressure sensitive but that requires a larger refactor\n        // of the flushing code in Fizz.\n        function writePreamble(destination, resumableState, renderState, willFlushAllSegments) {\n            // This function must be called exactly once on every request\n            if (!willFlushAllSegments && renderState.externalRuntimeScript) {\n                // If the root segment is incomplete due to suspended tasks\n                // (e.g. willFlushAllSegments = false) and we are using data\n                // streaming format, ensure the external runtime is sent.\n                // (User code could choose to send this even earlier by calling\n                //  preinit(...), if they know they will suspend).\n                var _renderState$external = renderState.externalRuntimeScript, src = _renderState$external.src, chunks = _renderState$external.chunks;\n                internalPreinitScript(resumableState, renderState, src, chunks);\n            }\n            var htmlChunks = renderState.htmlChunks;\n            var headChunks = renderState.headChunks;\n            var i = 0; // Emit open tags before Hoistables and Resources\n            if (htmlChunks) {\n                // We have an <html> to emit as part of the preamble\n                for(i = 0; i < htmlChunks.length; i++){\n                    writeChunk(destination, htmlChunks[i]);\n                }\n                if (headChunks) {\n                    for(i = 0; i < headChunks.length; i++){\n                        writeChunk(destination, headChunks[i]);\n                    }\n                } else {\n                    // We did not render a head but we emitted an <html> so we emit one now\n                    writeChunk(destination, startChunkForTag(\"head\"));\n                    writeChunk(destination, endOfStartTag);\n                }\n            } else if (headChunks) {\n                // We do not have an <html> but we do have a <head>\n                for(i = 0; i < headChunks.length; i++){\n                    writeChunk(destination, headChunks[i]);\n                }\n            } // Emit high priority Hoistables\n            var charsetChunks = renderState.charsetChunks;\n            for(i = 0; i < charsetChunks.length; i++){\n                writeChunk(destination, charsetChunks[i]);\n            }\n            charsetChunks.length = 0; // emit preconnect resources\n            renderState.preconnects.forEach(flushResource, destination);\n            renderState.preconnects.clear();\n            var preconnectChunks = renderState.preconnectChunks;\n            for(i = 0; i < preconnectChunks.length; i++){\n                writeChunk(destination, preconnectChunks[i]);\n            }\n            preconnectChunks.length = 0;\n            renderState.fontPreloads.forEach(flushResource, destination);\n            renderState.fontPreloads.clear();\n            renderState.highImagePreloads.forEach(flushResource, destination);\n            renderState.highImagePreloads.clear(); // Flush unblocked stylesheets by precedence\n            renderState.styles.forEach(flushStylesInPreamble, destination);\n            var importMapChunks = renderState.importMapChunks;\n            for(i = 0; i < importMapChunks.length; i++){\n                writeChunk(destination, importMapChunks[i]);\n            }\n            importMapChunks.length = 0;\n            renderState.bootstrapScripts.forEach(flushResource, destination);\n            renderState.scripts.forEach(flushResource, destination);\n            renderState.scripts.clear();\n            renderState.bulkPreloads.forEach(flushResource, destination);\n            renderState.bulkPreloads.clear(); // Write embedding preloadChunks\n            var preloadChunks = renderState.preloadChunks;\n            for(i = 0; i < preloadChunks.length; i++){\n                writeChunk(destination, preloadChunks[i]);\n            }\n            preloadChunks.length = 0; // Write embedding hoistableChunks\n            var hoistableChunks = renderState.hoistableChunks;\n            for(i = 0; i < hoistableChunks.length; i++){\n                writeChunk(destination, hoistableChunks[i]);\n            }\n            hoistableChunks.length = 0; // Flush closing head if necessary\n            if (htmlChunks && headChunks === null) {\n                // We have an <html> rendered but no <head> rendered. We however inserted\n                // a <head> up above so we need to emit the </head> now. This is safe because\n                // if the main content contained the </head> it would also have provided a\n                // <head>. This means that all the content inside <html> is either <body> or\n                // invalid HTML\n                writeChunk(destination, endChunkForTag(\"head\"));\n            }\n        } // We don't bother reporting backpressure at the moment because we expect to\n        // flush the entire preamble in a single pass. This probably should be modified\n        // in the future to be backpressure sensitive but that requires a larger refactor\n        // of the flushing code in Fizz.\n        function writeHoistables(destination, resumableState, renderState) {\n            var i = 0; // Emit high priority Hoistables\n            // We omit charsetChunks because we have already sent the shell and if it wasn't\n            // already sent it is too late now.\n            renderState.preconnects.forEach(flushResource, destination);\n            renderState.preconnects.clear();\n            var preconnectChunks = renderState.preconnectChunks;\n            for(i = 0; i < preconnectChunks.length; i++){\n                writeChunk(destination, preconnectChunks[i]);\n            }\n            preconnectChunks.length = 0;\n            renderState.fontPreloads.forEach(flushResource, destination);\n            renderState.fontPreloads.clear();\n            renderState.highImagePreloads.forEach(flushResource, destination);\n            renderState.highImagePreloads.clear(); // Preload any stylesheets. these will emit in a render instruction that follows this\n            // but we want to kick off preloading as soon as possible\n            renderState.styles.forEach(preloadLateStyles, destination); // We only hoist importmaps that are configured through createResponse and that will\n            // always flush in the preamble. Generally we don't expect people to render them as\n            // tags when using React but if you do they are going to be treated like regular inline\n            // scripts and flush after other hoistables which is problematic\n            // bootstrap scripts should flush above script priority but these can only flush in the preamble\n            // so we elide the code here for performance\n            renderState.scripts.forEach(flushResource, destination);\n            renderState.scripts.clear();\n            renderState.bulkPreloads.forEach(flushResource, destination);\n            renderState.bulkPreloads.clear(); // Write embedding preloadChunks\n            var preloadChunks = renderState.preloadChunks;\n            for(i = 0; i < preloadChunks.length; i++){\n                writeChunk(destination, preloadChunks[i]);\n            }\n            preloadChunks.length = 0; // Write embedding hoistableChunks\n            var hoistableChunks = renderState.hoistableChunks;\n            for(i = 0; i < hoistableChunks.length; i++){\n                writeChunk(destination, hoistableChunks[i]);\n            }\n            hoistableChunks.length = 0;\n        }\n        function writePostamble(destination, resumableState) {\n            if (resumableState.hasBody) {\n                writeChunk(destination, endChunkForTag(\"body\"));\n            }\n            if (resumableState.hasHtml) {\n                writeChunk(destination, endChunkForTag(\"html\"));\n            }\n        }\n        var arrayFirstOpenBracket = stringToPrecomputedChunk(\"[\");\n        var arraySubsequentOpenBracket = stringToPrecomputedChunk(\",[\");\n        var arrayInterstitial = stringToPrecomputedChunk(\",\");\n        var arrayCloseBracket = stringToPrecomputedChunk(\"]\"); // This function writes a 2D array of strings to be embedded in javascript.\n        // E.g.\n        //  [[\"JS_escaped_string1\", \"JS_escaped_string2\"]]\n        function writeStyleResourceDependenciesInJS(destination, boundaryResources) {\n            writeChunk(destination, arrayFirstOpenBracket);\n            var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n            boundaryResources.stylesheets.forEach(function(resource) {\n                if (resource.state === PREAMBLE) ;\n                else if (resource.state === LATE) {\n                    // We only need to emit the href because this resource flushed in an earlier\n                    // boundary already which encoded the attributes necessary to construct\n                    // the resource instance on the client.\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyHrefOnlyInJS(destination, resource.props.href);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                } else {\n                    // We need to emit the whole resource for insertion on the client\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyInJS(destination, resource.props.href, resource.props[\"data-precedence\"], resource.props);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                    resource.state = LATE;\n                }\n            });\n            writeChunk(destination, arrayCloseBracket);\n        }\n        /* Helper functions */ function writeStyleResourceDependencyHrefOnlyInJS(destination, href) {\n            // We should actually enforce this earlier when the resource is created but for\n            // now we make sure we are actually dealing with a string here.\n            {\n                checkAttributeStringCoercion(href, \"href\");\n            }\n            var coercedHref = \"\" + href;\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(coercedHref)));\n        }\n        function writeStyleResourceDependencyInJS(destination, href, precedence, props) {\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            var coercedHref = sanitizeURL(\"\" + href);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(coercedHref)));\n            {\n                checkAttributeStringCoercion(precedence, \"precedence\");\n            }\n            var coercedPrecedence = \"\" + precedence;\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(coercedPrecedence)));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"href\":\n                        case \"rel\":\n                        case \"precedence\":\n                        case \"data-precedence\":\n                            {\n                                break;\n                            }\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"link\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            writeStyleResourceAttributeInJS(destination, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            return null;\n        }\n        function writeStyleResourceAttributeInJS(destination, name, value) {\n            var attributeName = name.toLowerCase();\n            var attributeValue;\n            switch(typeof value){\n                case \"function\":\n                case \"symbol\":\n                    return;\n            }\n            switch(name){\n                // Reserved names\n                case \"innerHTML\":\n                case \"dangerouslySetInnerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                case \"style\":\n                    // Ignored\n                    return;\n                // Attribute renames\n                case \"className\":\n                    {\n                        attributeName = \"class\";\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                // Booleans\n                case \"hidden\":\n                    {\n                        if (value === false) {\n                            return;\n                        }\n                        attributeValue = \"\";\n                        break;\n                    }\n                // Santized URLs\n                case \"src\":\n                case \"href\":\n                    {\n                        value = sanitizeURL(value);\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                default:\n                    {\n                        if (// use on* as hueristic for these handler props\n                        name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                            return;\n                        }\n                        if (!isAttributeNameSafe(name)) {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                    }\n            }\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(attributeName)));\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeJSObjectForInstructionScripts(attributeValue)));\n        } // This function writes a 2D array of strings to be embedded in an attribute\n        // value and read with JSON.parse in ReactDOMServerExternalRuntime.js\n        // E.g.\n        //  [[&quot;JSON_escaped_string1&quot;, &quot;JSON_escaped_string2&quot;]]\n        function writeStyleResourceDependenciesInAttr(destination, boundaryResources) {\n            writeChunk(destination, arrayFirstOpenBracket);\n            var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n            boundaryResources.stylesheets.forEach(function(resource) {\n                if (resource.state === PREAMBLE) ;\n                else if (resource.state === LATE) {\n                    // We only need to emit the href because this resource flushed in an earlier\n                    // boundary already which encoded the attributes necessary to construct\n                    // the resource instance on the client.\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyHrefOnlyInAttr(destination, resource.props.href);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                } else {\n                    // We need to emit the whole resource for insertion on the client\n                    writeChunk(destination, nextArrayOpenBrackChunk);\n                    writeStyleResourceDependencyInAttr(destination, resource.props.href, resource.props[\"data-precedence\"], resource.props);\n                    writeChunk(destination, arrayCloseBracket);\n                    nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n                    resource.state = LATE;\n                }\n            });\n            writeChunk(destination, arrayCloseBracket);\n        }\n        /* Helper functions */ function writeStyleResourceDependencyHrefOnlyInAttr(destination, href) {\n            // We should actually enforce this earlier when the resource is created but for\n            // now we make sure we are actually dealing with a string here.\n            {\n                checkAttributeStringCoercion(href, \"href\");\n            }\n            var coercedHref = \"\" + href;\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(coercedHref))));\n        }\n        function writeStyleResourceDependencyInAttr(destination, href, precedence, props) {\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            var coercedHref = sanitizeURL(\"\" + href);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(coercedHref))));\n            {\n                checkAttributeStringCoercion(precedence, \"precedence\");\n            }\n            var coercedPrecedence = \"\" + precedence;\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(coercedPrecedence))));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"href\":\n                        case \"rel\":\n                        case \"precedence\":\n                        case \"data-precedence\":\n                            {\n                                break;\n                            }\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"link\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        default:\n                            writeStyleResourceAttributeInAttr(destination, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            return null;\n        }\n        function writeStyleResourceAttributeInAttr(destination, name, value) {\n            var attributeName = name.toLowerCase();\n            var attributeValue;\n            switch(typeof value){\n                case \"function\":\n                case \"symbol\":\n                    return;\n            }\n            switch(name){\n                // Reserved names\n                case \"innerHTML\":\n                case \"dangerouslySetInnerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                case \"style\":\n                    // Ignored\n                    return;\n                // Attribute renames\n                case \"className\":\n                    {\n                        attributeName = \"class\";\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                // Booleans\n                case \"hidden\":\n                    {\n                        if (value === false) {\n                            return;\n                        }\n                        attributeValue = \"\";\n                        break;\n                    }\n                // Santized URLs\n                case \"src\":\n                case \"href\":\n                    {\n                        value = sanitizeURL(value);\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                        break;\n                    }\n                default:\n                    {\n                        if (// use on* as hueristic for these handler props\n                        name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                            return;\n                        }\n                        if (!isAttributeNameSafe(name)) {\n                            return;\n                        }\n                        {\n                            checkAttributeStringCoercion(value, attributeName);\n                        }\n                        attributeValue = \"\" + value;\n                    }\n            }\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(attributeName))));\n            writeChunk(destination, arrayInterstitial);\n            writeChunk(destination, stringToChunk(escapeTextForBrowser(JSON.stringify(attributeValue))));\n        }\n        /**\n * Resources\n */ var PENDING$1 = 0;\n        var PRELOADED = 1;\n        var PREAMBLE = 2;\n        var LATE = 3;\n        function createBoundaryResources() {\n            return {\n                styles: new Set(),\n                stylesheets: new Set()\n            };\n        }\n        function setCurrentlyRenderingBoundaryResourcesTarget(renderState, boundaryResources) {\n            renderState.boundaryResources = boundaryResources;\n        }\n        function getResourceKey(href) {\n            return href;\n        }\n        function getImageResourceKey(href, imageSrcSet, imageSizes) {\n            if (imageSrcSet) {\n                return imageSrcSet + \"\\n\" + (imageSizes || \"\");\n            }\n            return href;\n        }\n        function prefetchDNS(href) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (typeof href === \"string\" && href) {\n                var key = getResourceKey(href);\n                if (!resumableState.dnsResources.hasOwnProperty(key)) {\n                    resumableState.dnsResources[key] = EXISTS;\n                    var headers = renderState.headers;\n                    var header;\n                    if (headers && headers.remainingCapacity > 0 && (header = getPrefetchDNSAsHeader(href), // we assume all the rest won't as well. This is to avoid getting into a situation\n                    // where we have a very small remaining capacity but no headers will ever fit and we end\n                    // up constantly trying to see if the next resource might make it. In the future we can\n                    // make this behavior different between render and prerender since in the latter case\n                    // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                    // headers.\n                    (headers.remainingCapacity -= header.length) >= 2)) {\n                        // Store this as resettable in case we are prerendering and postpone in the Shell\n                        renderState.resets.dns[key] = EXISTS;\n                        if (headers.preconnects) {\n                            headers.preconnects += \", \";\n                        } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                        headers.preconnects += header;\n                    } else {\n                        // Encode as element\n                        var resource = [];\n                        pushLinkImpl(resource, {\n                            href: href,\n                            rel: \"dns-prefetch\"\n                        });\n                        renderState.preconnects.add(resource);\n                    }\n                }\n                flushResources(request);\n            }\n        }\n        function preconnect(href, crossOrigin) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (typeof href === \"string\" && href) {\n                var bucket = crossOrigin === \"use-credentials\" ? \"credentials\" : typeof crossOrigin === \"string\" ? \"anonymous\" : \"default\";\n                var key = getResourceKey(href);\n                if (!resumableState.connectResources[bucket].hasOwnProperty(key)) {\n                    resumableState.connectResources[bucket][key] = EXISTS;\n                    var headers = renderState.headers;\n                    var header;\n                    if (headers && headers.remainingCapacity > 0 && (header = getPreconnectAsHeader(href, crossOrigin), // we assume all the rest won't as well. This is to avoid getting into a situation\n                    // where we have a very small remaining capacity but no headers will ever fit and we end\n                    // up constantly trying to see if the next resource might make it. In the future we can\n                    // make this behavior different between render and prerender since in the latter case\n                    // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                    // headers.\n                    (headers.remainingCapacity -= header.length) >= 2)) {\n                        // Store this in resettableState in case we are prerending and postpone in the Shell\n                        renderState.resets.connect[bucket][key] = EXISTS;\n                        if (headers.preconnects) {\n                            headers.preconnects += \", \";\n                        } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                        headers.preconnects += header;\n                    } else {\n                        var resource = [];\n                        pushLinkImpl(resource, {\n                            rel: \"preconnect\",\n                            href: href,\n                            crossOrigin: crossOrigin\n                        });\n                        renderState.preconnects.add(resource);\n                    }\n                }\n                flushResources(request);\n            }\n        }\n        function preload(href, as, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (as && href) {\n                switch(as){\n                    case \"image\":\n                        {\n                            var imageSrcSet, imageSizes, fetchPriority;\n                            if (options) {\n                                imageSrcSet = options.imageSrcSet;\n                                imageSizes = options.imageSizes;\n                                fetchPriority = options.fetchPriority;\n                            }\n                            var key = getImageResourceKey(href, imageSrcSet, imageSizes);\n                            if (resumableState.imageResources.hasOwnProperty(key)) {\n                                // we can return if we already have this resource\n                                return;\n                            }\n                            resumableState.imageResources[key] = PRELOAD_NO_CREDS;\n                            var headers = renderState.headers;\n                            var header;\n                            if (headers && headers.remainingCapacity > 0 && fetchPriority === \"high\" && (header = getPreloadAsHeader(href, as, options), // we assume all the rest won't as well. This is to avoid getting into a situation\n                            // where we have a very small remaining capacity but no headers will ever fit and we end\n                            // up constantly trying to see if the next resource might make it. In the future we can\n                            // make this behavior different between render and prerender since in the latter case\n                            // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                            // headers.\n                            (headers.remainingCapacity -= header.length) >= 2)) {\n                                // If we postpone in the shell we will still emit a preload as a header so we\n                                // track this to make sure we don't reset it.\n                                renderState.resets.image[key] = PRELOAD_NO_CREDS;\n                                if (headers.highImagePreloads) {\n                                    headers.highImagePreloads += \", \";\n                                } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                                headers.highImagePreloads += header;\n                            } else {\n                                // If we don't have headers to write to we have to encode as elements to flush in the head\n                                // When we have imageSrcSet the browser probably cannot load the right version from headers\n                                // (this should be verified by testing). For now we assume these need to go in the head\n                                // as elements even if headers are available.\n                                var resource = [];\n                                pushLinkImpl(resource, assign({\n                                    rel: \"preload\",\n                                    // There is a bug in Safari where imageSrcSet is not respected on preload links\n                                    // so we omit the href here if we have imageSrcSet b/c safari will load the wrong image.\n                                    // This harms older browers that do not support imageSrcSet by making their preloads not work\n                                    // but this population is shrinking fast and is already small so we accept this tradeoff.\n                                    href: imageSrcSet ? undefined : href,\n                                    as: as\n                                }, options));\n                                if (fetchPriority === \"high\") {\n                                    renderState.highImagePreloads.add(resource);\n                                } else {\n                                    renderState.bulkPreloads.add(resource); // Stash the resource in case we need to promote it to higher priority\n                                    // when an img tag is rendered\n                                    renderState.preloads.images.set(key, resource);\n                                }\n                            }\n                            break;\n                        }\n                    case \"style\":\n                        {\n                            var _key = getResourceKey(href);\n                            if (resumableState.styleResources.hasOwnProperty(_key)) {\n                                // we can return if we already have this resource\n                                return;\n                            }\n                            var _resource2 = [];\n                            pushLinkImpl(_resource2, assign({\n                                rel: \"preload\",\n                                href: href,\n                                as: as\n                            }, options));\n                            resumableState.styleResources[_key] = options && (typeof options.crossOrigin === \"string\" || typeof options.integrity === \"string\") ? [\n                                options.crossOrigin,\n                                options.integrity\n                            ] : PRELOAD_NO_CREDS;\n                            renderState.preloads.stylesheets.set(_key, _resource2);\n                            renderState.bulkPreloads.add(_resource2);\n                            break;\n                        }\n                    case \"script\":\n                        {\n                            var _key2 = getResourceKey(href);\n                            if (resumableState.scriptResources.hasOwnProperty(_key2)) {\n                                // we can return if we already have this resource\n                                return;\n                            }\n                            var _resource3 = [];\n                            renderState.preloads.scripts.set(_key2, _resource3);\n                            renderState.bulkPreloads.add(_resource3);\n                            pushLinkImpl(_resource3, assign({\n                                rel: \"preload\",\n                                href: href,\n                                as: as\n                            }, options));\n                            resumableState.scriptResources[_key2] = options && (typeof options.crossOrigin === \"string\" || typeof options.integrity === \"string\") ? [\n                                options.crossOrigin,\n                                options.integrity\n                            ] : PRELOAD_NO_CREDS;\n                            break;\n                        }\n                    default:\n                        {\n                            var _key3 = getResourceKey(href);\n                            var hasAsType = resumableState.unknownResources.hasOwnProperty(as);\n                            var resources;\n                            if (hasAsType) {\n                                resources = resumableState.unknownResources[as];\n                                if (resources.hasOwnProperty(_key3)) {\n                                    // we can return if we already have this resource\n                                    return;\n                                }\n                            } else {\n                                resources = {};\n                                resumableState.unknownResources[as] = resources;\n                            }\n                            resources[_key3] = PRELOAD_NO_CREDS;\n                            var _headers = renderState.headers;\n                            var _header;\n                            if (_headers && _headers.remainingCapacity > 0 && as === \"font\" && (_header = getPreloadAsHeader(href, as, options), // we assume all the rest won't as well. This is to avoid getting into a situation\n                            // where we have a very small remaining capacity but no headers will ever fit and we end\n                            // up constantly trying to see if the next resource might make it. In the future we can\n                            // make this behavior different between render and prerender since in the latter case\n                            // we are less sensitive to the current requests runtime per and more sensitive to maximizing\n                            // headers.\n                            (_headers.remainingCapacity -= _header.length) >= 2)) {\n                                // If we postpone in the shell we will still emit this preload so we\n                                // track it here to prevent it from being reset.\n                                renderState.resets.font[_key3] = PRELOAD_NO_CREDS;\n                                if (_headers.fontPreloads) {\n                                    _headers.fontPreloads += \", \";\n                                } // $FlowFixMe[unsafe-addition]: we assign header during the if condition\n                                _headers.fontPreloads += _header;\n                            } else {\n                                // We either don't have headers or we are preloading something that does\n                                // not warrant elevated priority so we encode as an element.\n                                var _resource4 = [];\n                                var props = assign({\n                                    rel: \"preload\",\n                                    href: href,\n                                    as: as\n                                }, options);\n                                pushLinkImpl(_resource4, props);\n                                switch(as){\n                                    case \"font\":\n                                        renderState.fontPreloads.add(_resource4);\n                                        break;\n                                    // intentional fall through\n                                    default:\n                                        renderState.bulkPreloads.add(_resource4);\n                                }\n                            }\n                        }\n                } // If we got this far we created a new resource\n                flushResources(request);\n            }\n        }\n        function preloadModule(href, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (href) {\n                var key = getResourceKey(href);\n                var as = options && typeof options.as === \"string\" ? options.as : \"script\";\n                var resource;\n                switch(as){\n                    case \"script\":\n                        {\n                            if (resumableState.moduleScriptResources.hasOwnProperty(key)) {\n                                // we can return if we already have this resource\n                                return;\n                            }\n                            resource = [];\n                            resumableState.moduleScriptResources[key] = options && (typeof options.crossOrigin === \"string\" || typeof options.integrity === \"string\") ? [\n                                options.crossOrigin,\n                                options.integrity\n                            ] : PRELOAD_NO_CREDS;\n                            renderState.preloads.moduleScripts.set(key, resource);\n                            break;\n                        }\n                    default:\n                        {\n                            var hasAsType = resumableState.moduleUnknownResources.hasOwnProperty(as);\n                            var resources;\n                            if (hasAsType) {\n                                resources = resumableState.unknownResources[as];\n                                if (resources.hasOwnProperty(key)) {\n                                    // we can return if we already have this resource\n                                    return;\n                                }\n                            } else {\n                                resources = {};\n                                resumableState.moduleUnknownResources[as] = resources;\n                            }\n                            resource = [];\n                            resources[key] = PRELOAD_NO_CREDS;\n                        }\n                }\n                pushLinkImpl(resource, assign({\n                    rel: \"modulepreload\",\n                    href: href\n                }, options));\n                renderState.bulkPreloads.add(resource); // If we got this far we created a new resource\n                flushResources(request);\n            }\n        }\n        function preinitStyle(href, precedence, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (href) {\n                precedence = precedence || \"default\";\n                var key = getResourceKey(href);\n                var styleQueue = renderState.styles.get(precedence);\n                var hasKey = resumableState.styleResources.hasOwnProperty(key);\n                var resourceState = hasKey ? resumableState.styleResources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resumableState.styleResources[key] = EXISTS; // If this is the first time we've encountered this precedence we need\n                    // to create a StyleQueue\n                    if (!styleQueue) {\n                        styleQueue = {\n                            precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                            rules: [],\n                            hrefs: [],\n                            sheets: new Map()\n                        };\n                        renderState.styles.set(precedence, styleQueue);\n                    }\n                    var resource = {\n                        state: PENDING$1,\n                        props: assign({\n                            rel: \"stylesheet\",\n                            href: href,\n                            \"data-precedence\": precedence\n                        }, options)\n                    };\n                    if (resourceState) {\n                        // When resourceState is truty it is a Preload state. We cast it for clarity\n                        var preloadState = resourceState;\n                        if (preloadState.length === 2) {\n                            adoptPreloadCredentials(resource.props, preloadState);\n                        }\n                        var preloadResource = renderState.preloads.stylesheets.get(key);\n                        if (preloadResource && preloadResource.length > 0) {\n                            // The Preload for this resource was created in this render pass and has not flushed yet so\n                            // we need to clear it to avoid it flushing.\n                            preloadResource.length = 0;\n                        } else {\n                            // Either the preload resource from this render already flushed in this render pass\n                            // or the preload flushed in a prior pass (prerender). In either case we need to mark\n                            // this resource as already having been preloaded.\n                            resource.state = PRELOADED;\n                        }\n                    } // We add the newly created resource to our StyleQueue and if necessary\n                    // track the resource with the currently rendering boundary\n                    styleQueue.sheets.set(key, resource); // Notify the request that there are resources to flush even if no work is currently happening\n                    flushResources(request);\n                }\n            }\n        }\n        function preinitScript(src, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (src) {\n                var key = getResourceKey(src);\n                var hasKey = resumableState.scriptResources.hasOwnProperty(key);\n                var resourceState = hasKey ? resumableState.scriptResources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resumableState.scriptResources[key] = EXISTS;\n                    var props = assign({\n                        src: src,\n                        async: true\n                    }, options);\n                    if (resourceState) {\n                        // When resourceState is truty it is a Preload state. We cast it for clarity\n                        var preloadState = resourceState;\n                        if (preloadState.length === 2) {\n                            adoptPreloadCredentials(props, preloadState);\n                        }\n                        var preloadResource = renderState.preloads.scripts.get(key);\n                        if (preloadResource) {\n                            // the preload resource exists was created in this render. Now that we have\n                            // a script resource which will emit earlier than a preload would if it\n                            // hasn't already flushed we prevent it from flushing by zeroing the length\n                            preloadResource.length = 0;\n                        }\n                    }\n                    var resource = []; // Add to the script flushing queue\n                    renderState.scripts.add(resource); // encode the tag as Chunks\n                    pushScriptImpl(resource, props); // Notify the request that there are resources to flush even if no work is currently happening\n                    flushResources(request);\n                }\n                return;\n            }\n        }\n        function preinitModuleScript(src, options) {\n            var request = resolveRequest();\n            if (!request) {\n                // In async contexts we can sometimes resolve resources from AsyncLocalStorage. If we can't we can also\n                // possibly get them from the stack if we are not in an async context. Since we were not able to resolve\n                // the resources for this call in either case we opt to do nothing. We can consider making this a warning\n                // but there may be times where calling a function outside of render is intentional (i.e. to warm up data\n                // fetching) and we don't want to warn in those cases.\n                return;\n            }\n            var resumableState = getResumableState(request);\n            var renderState = getRenderState(request);\n            if (src) {\n                var key = getResourceKey(src);\n                var hasKey = resumableState.moduleScriptResources.hasOwnProperty(key);\n                var resourceState = hasKey ? resumableState.moduleScriptResources[key] : undefined;\n                if (resourceState !== EXISTS) {\n                    // We are going to create this resource now so it is marked as Exists\n                    resumableState.moduleScriptResources[key] = EXISTS;\n                    var props = assign({\n                        src: src,\n                        type: \"module\",\n                        async: true\n                    }, options);\n                    if (resourceState) {\n                        // When resourceState is truty it is a Preload state. We cast it for clarity\n                        var preloadState = resourceState;\n                        if (preloadState.length === 2) {\n                            adoptPreloadCredentials(props, preloadState);\n                        }\n                        var preloadResource = renderState.preloads.moduleScripts.get(key);\n                        if (preloadResource) {\n                            // the preload resource exists was created in this render. Now that we have\n                            // a script resource which will emit earlier than a preload would if it\n                            // hasn't already flushed we prevent it from flushing by zeroing the length\n                            preloadResource.length = 0;\n                        }\n                    }\n                    var resource = []; // Add to the script flushing queue\n                    renderState.scripts.add(resource); // encode the tag as Chunks\n                    pushScriptImpl(resource, props); // Notify the request that there are resources to flush even if no work is currently happening\n                    flushResources(request);\n                }\n                return;\n            }\n        } // This function is only safe to call at Request start time since it assumes\n        // that each module has not already been preloaded. If we find a need to preload\n        // scripts at any other point in time we will need to check whether the preload\n        // already exists and not assume it\n        function preloadBootstrapScriptOrModule(resumableState, renderState, href, props) {\n            var key = getResourceKey(href);\n            {\n                if (resumableState.scriptResources.hasOwnProperty(key) || resumableState.moduleScriptResources.hasOwnProperty(key)) {\n                    // This is coded as a React error because it should be impossible for a userspace preload to preempt this call\n                    // If a userspace preload can preempt it then this assumption is broken and we need to reconsider this strategy\n                    // rather than instruct the user to not preload their bootstrap scripts themselves\n                    error('Internal React Error: React expected bootstrap script or module with src \"%s\" to not have been preloaded already. please file an issue', href);\n                }\n            }\n            // used to preinit the resource. If a script can be preinited then it shouldn't\n            // be a bootstrap script/module and if it is a bootstrap script/module then it\n            // must not be safe to emit early. To avoid possibly allowing for preinits of\n            // bootstrap scripts/modules we occlude these keys.\n            resumableState.scriptResources[key] = EXISTS;\n            resumableState.moduleScriptResources[key] = EXISTS;\n            var resource = [];\n            pushLinkImpl(resource, props);\n            renderState.bootstrapScripts.add(resource);\n        }\n        function internalPreinitScript(resumableState, renderState, src, chunks) {\n            var key = getResourceKey(src);\n            if (!resumableState.scriptResources.hasOwnProperty(key)) {\n                var resource = chunks;\n                resumableState.scriptResources[key] = EXISTS;\n                renderState.scripts.add(resource);\n            }\n            return;\n        }\n        function preloadAsStylePropsFromProps(href, props) {\n            return {\n                rel: \"preload\",\n                as: \"style\",\n                href: href,\n                crossOrigin: props.crossOrigin,\n                fetchPriority: props.fetchPriority,\n                integrity: props.integrity,\n                media: props.media,\n                hrefLang: props.hrefLang,\n                referrerPolicy: props.referrerPolicy\n            };\n        }\n        function stylesheetPropsFromRawProps(rawProps) {\n            return assign({}, rawProps, {\n                \"data-precedence\": rawProps.precedence,\n                precedence: null\n            });\n        }\n        function adoptPreloadCredentials(target, preloadState) {\n            if (target.crossOrigin == null) target.crossOrigin = preloadState[0];\n            if (target.integrity == null) target.integrity = preloadState[1];\n        }\n        function getPrefetchDNSAsHeader(href) {\n            var escapedHref = escapeHrefForLinkHeaderURLContext(href);\n            return \"<\" + escapedHref + \">; rel=dns-prefetch\";\n        }\n        function getPreconnectAsHeader(href, crossOrigin) {\n            var escapedHref = escapeHrefForLinkHeaderURLContext(href);\n            var value = \"<\" + escapedHref + \">; rel=preconnect\";\n            if (typeof crossOrigin === \"string\") {\n                var escapedCrossOrigin = escapeStringForLinkHeaderQuotedParamValueContext(crossOrigin, \"crossOrigin\");\n                value += '; crossorigin=\"' + escapedCrossOrigin + '\"';\n            }\n            return value;\n        }\n        function getPreloadAsHeader(href, as, params) {\n            var escapedHref = escapeHrefForLinkHeaderURLContext(href);\n            var escapedAs = escapeStringForLinkHeaderQuotedParamValueContext(as, \"as\");\n            var value = \"<\" + escapedHref + '>; rel=preload; as=\"' + escapedAs + '\"';\n            for(var paramName in params){\n                if (hasOwnProperty.call(params, paramName)) {\n                    var paramValue = params[paramName];\n                    if (typeof paramValue === \"string\") {\n                        value += \"; \" + paramName.toLowerCase() + '=\"' + escapeStringForLinkHeaderQuotedParamValueContext(paramValue, paramName) + '\"';\n                    }\n                }\n            }\n            return value;\n        }\n        function getStylesheetPreloadAsHeader(stylesheet) {\n            var props = stylesheet.props;\n            var preloadOptions = {\n                crossOrigin: props.crossOrigin,\n                integrity: props.integrity,\n                nonce: props.nonce,\n                type: props.type,\n                fetchPriority: props.fetchPriority,\n                referrerPolicy: props.referrerPolicy,\n                media: props.media\n            };\n            return getPreloadAsHeader(props.href, \"style\", preloadOptions);\n        } // This escaping function is only safe to use for href values being written into\n        // a \"Link\" header in between `<` and `>` characters. The primary concern with the href is\n        // to escape the bounding characters as well as new lines. This is unsafe to use in any other\n        // context\n        var regexForHrefInLinkHeaderURLContext = /[<>\\r\\n]/g;\n        function escapeHrefForLinkHeaderURLContext(hrefInput) {\n            {\n                checkAttributeStringCoercion(hrefInput, \"href\");\n            }\n            var coercedHref = \"\" + hrefInput;\n            return coercedHref.replace(regexForHrefInLinkHeaderURLContext, escapeHrefForLinkHeaderURLContextReplacer);\n        }\n        function escapeHrefForLinkHeaderURLContextReplacer(match) {\n            switch(match){\n                case \"<\":\n                    return \"%3C\";\n                case \">\":\n                    return \"%3E\";\n                case \"\\n\":\n                    return \"%0A\";\n                case \"\\r\":\n                    return \"%0D\";\n                default:\n                    {\n                        // eslint-disable-next-line react-internal/prod-error-codes\n                        throw new Error(\"escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                    }\n            }\n        } // This escaping function is only safe to use for quoted param values in an HTTP header.\n        // It is unsafe to use for any value not inside quote marks in parater value position.\n        var regexForLinkHeaderQuotedParamValueContext = /[\"';,\\r\\n]/g;\n        function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {\n            {\n                checkOptionStringCoercion(value, name);\n            }\n            var coerced = \"\" + value;\n            return coerced.replace(regexForLinkHeaderQuotedParamValueContext, escapeStringForLinkHeaderQuotedParamValueContextReplacer);\n        }\n        function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {\n            switch(match){\n                case '\"':\n                    return \"%22\";\n                case \"'\":\n                    return \"%27\";\n                case \";\":\n                    return \"%3B\";\n                case \",\":\n                    return \"%2C\";\n                case \"\\n\":\n                    return \"%0A\";\n                case \"\\r\":\n                    return \"%0D\";\n                default:\n                    {\n                        // eslint-disable-next-line react-internal/prod-error-codes\n                        throw new Error(\"escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                    }\n            }\n        }\n        function hoistStyleQueueDependency(styleQueue) {\n            this.styles.add(styleQueue);\n        }\n        function hoistStylesheetDependency(stylesheet) {\n            this.stylesheets.add(stylesheet);\n        }\n        function hoistResources(renderState, source) {\n            var currentBoundaryResources = renderState.boundaryResources;\n            if (currentBoundaryResources) {\n                source.styles.forEach(hoistStyleQueueDependency, currentBoundaryResources);\n                source.stylesheets.forEach(hoistStylesheetDependency, currentBoundaryResources);\n            }\n        } // This function is called at various times depending on whether we are rendering\n        // or prerendering. In this implementation we only actually emit headers once and\n        // subsequent calls are ignored. We track whether the request has a completed shell\n        // to determine whether we will follow headers with a flush including stylesheets.\n        // In the context of prerrender we don't have a completed shell when the request finishes\n        // with a postpone in the shell. In the context of a render we don't have a completed shell\n        // if this is called before the shell finishes rendering which usually will happen anytime\n        // anything suspends in the shell.\n        function emitEarlyPreloads(renderState, resumableState, shellComplete) {\n            var onHeaders = renderState.onHeaders;\n            if (onHeaders) {\n                var headers = renderState.headers;\n                if (headers) {\n                    // Even if onHeaders throws we don't want to call this again so\n                    // we drop the headers state from this point onwards.\n                    renderState.headers = null;\n                    var linkHeader = headers.preconnects;\n                    if (headers.fontPreloads) {\n                        if (linkHeader) {\n                            linkHeader += \", \";\n                        }\n                        linkHeader += headers.fontPreloads;\n                    }\n                    if (headers.highImagePreloads) {\n                        if (linkHeader) {\n                            linkHeader += \", \";\n                        }\n                        linkHeader += headers.highImagePreloads;\n                    }\n                    if (!shellComplete) {\n                        // We use raw iterators because we want to be able to halt iteration\n                        // We could refactor renderState to store these dually in arrays to\n                        // make this more efficient at the cost of additional memory and\n                        // write overhead. However this code only runs once per request so\n                        // for now I consider this sufficient.\n                        var queueIter = renderState.styles.values();\n                        outer: for(var queueStep = queueIter.next(); headers.remainingCapacity > 0 && !queueStep.done; queueStep = queueIter.next()){\n                            var sheets = queueStep.value.sheets;\n                            var sheetIter = sheets.values();\n                            for(var sheetStep = sheetIter.next(); headers.remainingCapacity > 0 && !sheetStep.done; sheetStep = sheetIter.next()){\n                                var sheet = sheetStep.value;\n                                var props = sheet.props;\n                                var key = getResourceKey(props.href);\n                                var header = getStylesheetPreloadAsHeader(sheet); // We mutate the capacity b/c we don't want to keep checking if later headers will fit.\n                                // This means that a particularly long header might close out the header queue where later\n                                // headers could still fit. We could in the future alter the behavior here based on prerender vs render\n                                // since during prerender we aren't as concerned with pure runtime performance.\n                                if ((headers.remainingCapacity -= header.length) >= 2) {\n                                    renderState.resets.style[key] = PRELOAD_NO_CREDS;\n                                    if (linkHeader) {\n                                        linkHeader += \", \";\n                                    }\n                                    linkHeader += header; // We already track that the resource exists in resumableState however\n                                    // if the resumableState resets because we postponed in the shell\n                                    // which is what is happening in this branch if we are prerendering\n                                    // then we will end up resetting the resumableState. When it resets we\n                                    // want to record the fact that this stylesheet was already preloaded\n                                    renderState.resets.style[key] = typeof props.crossOrigin === \"string\" || typeof props.integrity === \"string\" ? [\n                                        props.crossOrigin,\n                                        props.integrity\n                                    ] : PRELOAD_NO_CREDS;\n                                } else {\n                                    break outer;\n                                }\n                            }\n                        }\n                    }\n                    if (linkHeader) {\n                        onHeaders({\n                            Link: linkHeader\n                        });\n                    } else {\n                        // We still call this with no headers because a user may be using it as a signal that\n                        // it React will not provide any headers\n                        onHeaders({});\n                    }\n                    return;\n                }\n            }\n        }\n        var NotPendingTransition = NotPending;\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_SCOPE_TYPE = Symbol.for(\"react.scope\");\n        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for(\"react.debug_trace_mode\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for(\"react.default_value\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher$1.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher$1.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeClassComponentFrame(ctor, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(ctor, true);\n            }\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct$1(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct$1(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement(null);\n                        }\n                    }\n                }\n            }\n        }\n        var warnedAboutMissingGetChildContext;\n        {\n            warnedAboutMissingGetChildContext = {};\n        }\n        var emptyContextObject = {};\n        {\n            Object.freeze(emptyContextObject);\n        }\n        function getMaskedContext(type, unmaskedContext) {\n            {\n                var contextTypes = type.contextTypes;\n                if (!contextTypes) {\n                    return emptyContextObject;\n                }\n                var context = {};\n                for(var key in contextTypes){\n                    context[key] = unmaskedContext[key];\n                }\n                {\n                    var name = getComponentNameFromType(type) || \"Unknown\";\n                    checkPropTypes(contextTypes, context, \"context\", name);\n                }\n                return context;\n            }\n        }\n        function processChildContext(instance, type, parentContext, childContextTypes) {\n            {\n                // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n                // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n                if (typeof instance.getChildContext !== \"function\") {\n                    {\n                        var componentName = getComponentNameFromType(type) || \"Unknown\";\n                        if (!warnedAboutMissingGetChildContext[componentName]) {\n                            warnedAboutMissingGetChildContext[componentName] = true;\n                            error(\"%s.childContextTypes is specified but there is no getChildContext() method \" + \"on the instance. You can either define getChildContext() on %s or remove \" + \"childContextTypes from it.\", componentName, componentName);\n                        }\n                    }\n                    return parentContext;\n                }\n                var childContext = instance.getChildContext();\n                for(var contextKey in childContext){\n                    if (!(contextKey in childContextTypes)) {\n                        throw new Error((getComponentNameFromType(type) || \"Unknown\") + '.getChildContext(): key \"' + contextKey + '\" is not defined in childContextTypes.');\n                    }\n                }\n                {\n                    var name = getComponentNameFromType(type) || \"Unknown\";\n                    checkPropTypes(childContextTypes, childContext, \"child context\", name);\n                }\n                return assign({}, parentContext, childContext);\n            }\n        }\n        var rendererSigil;\n        {\n            // Use this to detect multiple renderers using the same context\n            rendererSigil = {};\n        }\n        // Forming a reverse tree.\n        // The structure of a context snapshot is an implementation of this file.\n        // Currently, it's implemented as tracking the current active node.\n        var rootContextSnapshot = null; // We assume that this runtime owns the \"current\" field on all ReactContext instances.\n        // This global (actually thread local) state represents what state all those \"current\",\n        // fields are currently in.\n        var currentActiveSnapshot = null;\n        function popNode(prev) {\n            {\n                prev.context._currentValue = prev.parentValue;\n            }\n        }\n        function pushNode(next) {\n            {\n                next.context._currentValue = next.value;\n            }\n        }\n        function popToNearestCommonAncestor(prev, next) {\n            if (prev === next) ;\n            else {\n                popNode(prev);\n                var parentPrev = prev.parent;\n                var parentNext = next.parent;\n                if (parentPrev === null) {\n                    if (parentNext !== null) {\n                        throw new Error(\"The stacks must reach the root at the same time. This is a bug in React.\");\n                    }\n                } else {\n                    if (parentNext === null) {\n                        throw new Error(\"The stacks must reach the root at the same time. This is a bug in React.\");\n                    }\n                    popToNearestCommonAncestor(parentPrev, parentNext);\n                } // On the way back, we push the new ones that weren't common.\n                pushNode(next);\n            }\n        }\n        function popAllPrevious(prev) {\n            popNode(prev);\n            var parentPrev = prev.parent;\n            if (parentPrev !== null) {\n                popAllPrevious(parentPrev);\n            }\n        }\n        function pushAllNext(next) {\n            var parentNext = next.parent;\n            if (parentNext !== null) {\n                pushAllNext(parentNext);\n            }\n            pushNode(next);\n        }\n        function popPreviousToCommonLevel(prev, next) {\n            popNode(prev);\n            var parentPrev = prev.parent;\n            if (parentPrev === null) {\n                throw new Error(\"The depth must equal at least at zero before reaching the root. This is a bug in React.\");\n            }\n            if (parentPrev.depth === next.depth) {\n                // We found the same level. Now we just need to find a shared ancestor.\n                popToNearestCommonAncestor(parentPrev, next);\n            } else {\n                // We must still be deeper.\n                popPreviousToCommonLevel(parentPrev, next);\n            }\n        }\n        function popNextToCommonLevel(prev, next) {\n            var parentNext = next.parent;\n            if (parentNext === null) {\n                throw new Error(\"The depth must equal at least at zero before reaching the root. This is a bug in React.\");\n            }\n            if (prev.depth === parentNext.depth) {\n                // We found the same level. Now we just need to find a shared ancestor.\n                popToNearestCommonAncestor(prev, parentNext);\n            } else {\n                // We must still be deeper.\n                popNextToCommonLevel(prev, parentNext);\n            }\n            pushNode(next);\n        } // Perform context switching to the new snapshot.\n        // To make it cheap to read many contexts, while not suspending, we make the switch eagerly by\n        // updating all the context's current values. That way reads, always just read the current value.\n        // At the cost of updating contexts even if they're never read by this subtree.\n        function switchContext(newSnapshot) {\n            // The basic algorithm we need to do is to pop back any contexts that are no longer on the stack.\n            // We also need to update any new contexts that are now on the stack with the deepest value.\n            // The easiest way to update new contexts is to just reapply them in reverse order from the\n            // perspective of the backpointers. To avoid allocating a lot when switching, we use the stack\n            // for that. Therefore this algorithm is recursive.\n            // 1) First we pop which ever snapshot tree was deepest. Popping old contexts as we go.\n            // 2) Then we find the nearest common ancestor from there. Popping old contexts as we go.\n            // 3) Then we reapply new contexts on the way back up the stack.\n            var prev = currentActiveSnapshot;\n            var next = newSnapshot;\n            if (prev !== next) {\n                if (prev === null) {\n                    // $FlowFixMe[incompatible-call]: This has to be non-null since it's not equal to prev.\n                    pushAllNext(next);\n                } else if (next === null) {\n                    popAllPrevious(prev);\n                } else if (prev.depth === next.depth) {\n                    popToNearestCommonAncestor(prev, next);\n                } else if (prev.depth > next.depth) {\n                    popPreviousToCommonLevel(prev, next);\n                } else {\n                    popNextToCommonLevel(prev, next);\n                }\n                currentActiveSnapshot = next;\n            }\n        }\n        function pushProvider(context, nextValue) {\n            var prevValue;\n            {\n                prevValue = context._currentValue;\n                context._currentValue = nextValue;\n                {\n                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer = rendererSigil;\n                }\n            }\n            var prevNode = currentActiveSnapshot;\n            var newNode = {\n                parent: prevNode,\n                depth: prevNode === null ? 0 : prevNode.depth + 1,\n                context: context,\n                parentValue: prevValue,\n                value: nextValue\n            };\n            currentActiveSnapshot = newNode;\n            return newNode;\n        }\n        function popProvider(context) {\n            var prevSnapshot = currentActiveSnapshot;\n            if (prevSnapshot === null) {\n                throw new Error(\"Tried to pop a Context at the root of the app. This is a bug in React.\");\n            }\n            {\n                if (prevSnapshot.context !== context) {\n                    error(\"The parent context is not the expected context. This is probably a bug in React.\");\n                }\n            }\n            {\n                var value = prevSnapshot.parentValue;\n                if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {\n                    prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;\n                } else {\n                    prevSnapshot.context._currentValue = value;\n                }\n                {\n                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer = rendererSigil;\n                }\n            }\n            return currentActiveSnapshot = prevSnapshot.parent;\n        }\n        function getActiveContext() {\n            return currentActiveSnapshot;\n        }\n        function readContext$1(context) {\n            var value = context._currentValue;\n            return value;\n        }\n        /**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */ function get(key) {\n            return key._reactInternals;\n        }\n        function set(key, value) {\n            key._reactInternals = value;\n        }\n        var didWarnAboutNoopUpdateForComponent = {};\n        var didWarnAboutDeprecatedWillMount = {};\n        var didWarnAboutUninitializedState;\n        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n        var didWarnAboutLegacyLifecyclesAndDerivedState;\n        var didWarnAboutUndefinedDerivedState;\n        var didWarnAboutDirectlyAssigningPropsToState;\n        var didWarnAboutContextTypeAndContextTypes;\n        var didWarnAboutInvalidateContextType;\n        var didWarnOnInvalidCallback;\n        {\n            didWarnAboutUninitializedState = new Set();\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n            didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n            didWarnAboutDirectlyAssigningPropsToState = new Set();\n            didWarnAboutUndefinedDerivedState = new Set();\n            didWarnAboutContextTypeAndContextTypes = new Set();\n            didWarnAboutInvalidateContextType = new Set();\n            didWarnOnInvalidCallback = new Set();\n        }\n        function warnOnInvalidCallback(callback, callerName) {\n            {\n                if (callback === null || typeof callback === \"function\") {\n                    return;\n                }\n                var key = callerName + \"_\" + callback;\n                if (!didWarnOnInvalidCallback.has(key)) {\n                    didWarnOnInvalidCallback.add(key);\n                    error(\"%s(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callerName, callback);\n                }\n            }\n        }\n        function warnOnUndefinedDerivedState(type, partialState) {\n            {\n                if (partialState === undefined) {\n                    var componentName = getComponentNameFromType(type) || \"Component\";\n                    if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n                        didWarnAboutUndefinedDerivedState.add(componentName);\n                        error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \" + \"You have returned undefined.\", componentName);\n                    }\n                }\n            }\n        }\n        function warnNoop(publicInstance, callerName) {\n            {\n                var _constructor = publicInstance.constructor;\n                var componentName = _constructor && getComponentNameFromType(_constructor) || \"ReactClass\";\n                var warningKey = componentName + \".\" + callerName;\n                if (didWarnAboutNoopUpdateForComponent[warningKey]) {\n                    return;\n                }\n                error(\"%s(...): Can only update a mounting component. \" + \"This usually means you called %s() outside componentWillMount() on the server. \" + \"This is a no-op.\\n\\nPlease check the code for the %s component.\", callerName, callerName, componentName);\n                didWarnAboutNoopUpdateForComponent[warningKey] = true;\n            }\n        }\n        var classComponentUpdater = {\n            isMounted: function(inst) {\n                return false;\n            },\n            // $FlowFixMe[missing-local-annot]\n            enqueueSetState: function(inst, payload, callback) {\n                var internals = get(inst);\n                if (internals.queue === null) {\n                    warnNoop(inst, \"setState\");\n                } else {\n                    internals.queue.push(payload);\n                    {\n                        if (callback !== undefined && callback !== null) {\n                            warnOnInvalidCallback(callback, \"setState\");\n                        }\n                    }\n                }\n            },\n            enqueueReplaceState: function(inst, payload, callback) {\n                var internals = get(inst);\n                internals.replace = true;\n                internals.queue = [\n                    payload\n                ];\n                {\n                    if (callback !== undefined && callback !== null) {\n                        warnOnInvalidCallback(callback, \"setState\");\n                    }\n                }\n            },\n            // $FlowFixMe[missing-local-annot]\n            enqueueForceUpdate: function(inst, callback) {\n                var internals = get(inst);\n                if (internals.queue === null) {\n                    warnNoop(inst, \"forceUpdate\");\n                } else {\n                    {\n                        if (callback !== undefined && callback !== null) {\n                            warnOnInvalidCallback(callback, \"setState\");\n                        }\n                    }\n                }\n            }\n        };\n        function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {\n            var partialState = getDerivedStateFromProps(nextProps, prevState);\n            {\n                warnOnUndefinedDerivedState(ctor, partialState);\n            }\n            var newState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n            return newState;\n        }\n        function constructClassInstance(ctor, props, maskedLegacyContext) {\n            var context = emptyContextObject;\n            var contextType = ctor.contextType;\n            {\n                if (\"contextType\" in ctor) {\n                    var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n                    if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n                        didWarnAboutInvalidateContextType.add(ctor);\n                        var addendum = \"\";\n                        if (contextType === undefined) {\n                            addendum = \" However, it is set to undefined. \" + \"This can be caused by a typo or by mixing up named and default imports. \" + \"This can also happen due to a circular dependency, so \" + \"try moving the createContext() call to a separate file.\";\n                        } else if (typeof contextType !== \"object\") {\n                            addendum = \" However, it is set to a \" + typeof contextType + \".\";\n                        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n                            addendum = \" Did you accidentally pass the Context.Provider instead?\";\n                        } else if (contextType._context !== undefined) {\n                            // <Context.Consumer>\n                            addendum = \" Did you accidentally pass the Context.Consumer instead?\";\n                        } else {\n                            addendum = \" However, it is set to an object with keys {\" + Object.keys(contextType).join(\", \") + \"}.\";\n                        }\n                        error(\"%s defines an invalid contextType. \" + \"contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(ctor) || \"Component\", addendum);\n                    }\n                }\n            }\n            if (typeof contextType === \"object\" && contextType !== null) {\n                context = readContext$1(contextType);\n            } else {\n                context = maskedLegacyContext;\n            }\n            var instance = new ctor(props, context);\n            {\n                if (typeof ctor.getDerivedStateFromProps === \"function\" && (instance.state === null || instance.state === undefined)) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutUninitializedState.has(componentName)) {\n                        didWarnAboutUninitializedState.add(componentName);\n                        error(\"`%s` uses `getDerivedStateFromProps` but its initial state is \" + \"%s. This is not recommended. Instead, define the initial state by \" + \"assigning an object to `this.state` in the constructor of `%s`. \" + \"This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", componentName, instance.state === null ? \"null\" : \"undefined\", componentName);\n                    }\n                } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n                // Warn about these lifecycles if they are present.\n                // Don't warn about react-lifecycles-compat polyfilled methods though.\n                if (typeof ctor.getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    var foundWillMountName = null;\n                    var foundWillReceivePropsName = null;\n                    var foundWillUpdateName = null;\n                    if (typeof instance.componentWillMount === \"function\" && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        foundWillMountName = \"componentWillMount\";\n                    } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                        foundWillMountName = \"UNSAFE_componentWillMount\";\n                    }\n                    if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                        foundWillReceivePropsName = \"componentWillReceiveProps\";\n                    } else if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                        foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n                    }\n                    if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                        foundWillUpdateName = \"componentWillUpdate\";\n                    } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                        foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n                    }\n                    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n                        var _componentName = getComponentNameFromType(ctor) || \"Component\";\n                        var newApiName = typeof ctor.getDerivedStateFromProps === \"function\" ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n                            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n                            error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n\" + \"%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n\" + \"The above lifecycles should be removed. Learn more about this warning here:\\n\" + \"https://reactjs.org/link/unsafe-component-lifecycles\", _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : \"\", foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : \"\", foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : \"\");\n                        }\n                    }\n                }\n            }\n            return instance;\n        }\n        function checkClassInstance(instance, ctor, newProps) {\n            {\n                var name = getComponentNameFromType(ctor) || \"Component\";\n                var renderPresent = instance.render;\n                if (!renderPresent) {\n                    if (ctor.prototype && typeof ctor.prototype.render === \"function\") {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: did you accidentally return an object from the constructor?\", name);\n                    } else {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: you may have forgotten to define `render`.\", name);\n                    }\n                }\n                if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n                    error(\"getInitialState was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Did you mean to define a state property instead?\", name);\n                }\n                if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Use a static property to define defaultProps instead.\", name);\n                }\n                if (instance.propTypes) {\n                    error(\"propTypes was defined as an instance property on %s. Use a static \" + \"property to define propTypes instead.\", name);\n                }\n                if (instance.contextType) {\n                    error(\"contextType was defined as an instance property on %s. Use a static \" + \"property to define contextType instead.\", name);\n                }\n                {\n                    if (instance.contextTypes) {\n                        error(\"contextTypes was defined as an instance property on %s. Use a static \" + \"property to define contextTypes instead.\", name);\n                    }\n                    if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n                        didWarnAboutContextTypeAndContextTypes.add(ctor);\n                        error(\"%s declares both contextTypes and contextType static properties. \" + \"The legacy contextTypes property will be ignored.\", name);\n                    }\n                }\n                if (typeof instance.componentShouldUpdate === \"function\") {\n                    error(\"%s has a method called \" + \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" + \"The name is phrased as a question because the function is \" + \"expected to return a value.\", name);\n                }\n                if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== \"undefined\") {\n                    error(\"%s has a method called shouldComponentUpdate(). \" + \"shouldComponentUpdate should not be used when extending React.PureComponent. \" + \"Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(ctor) || \"A pure component\");\n                }\n                if (typeof instance.componentDidUnmount === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidUnmount(). But there is no such lifecycle method. \" + \"Did you mean componentWillUnmount()?\", name);\n                }\n                if (typeof instance.componentDidReceiveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidReceiveProps(). But there is no such lifecycle method. \" + \"If you meant to update the state in response to changing props, \" + \"use componentWillReceiveProps(). If you meant to fetch data or \" + \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", name);\n                }\n                if (typeof instance.componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", name);\n                }\n                if (typeof instance.UNSAFE_componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", name);\n                }\n                var hasMutatedProps = instance.props !== newProps;\n                if (instance.props !== undefined && hasMutatedProps) {\n                    error(\"%s(...): When calling super() in `%s`, make sure to pass \" + \"up the same props that your component's constructor was passed.\", name, name);\n                }\n                if (instance.defaultProps) {\n                    error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" + \" Instead, define defaultProps as a static property on %s.\", name, name);\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\" && typeof instance.componentDidUpdate !== \"function\" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n                    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n                    error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). \" + \"This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(ctor));\n                }\n                if (typeof instance.getDerivedStateFromProps === \"function\") {\n                    error(\"%s: getDerivedStateFromProps() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof instance.getDerivedStateFromError === \"function\") {\n                    error(\"%s: getDerivedStateFromError() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof ctor.getSnapshotBeforeUpdate === \"function\") {\n                    error(\"%s: getSnapshotBeforeUpdate() is defined as a static method \" + \"and will be ignored. Instead, declare it as an instance method.\", name);\n                }\n                var state = instance.state;\n                if (state && (typeof state !== \"object\" || isArray(state))) {\n                    error(\"%s.state: must be set to an object or null\", name);\n                }\n                if (typeof instance.getChildContext === \"function\" && typeof ctor.childContextTypes !== \"object\") {\n                    error(\"%s.getChildContext(): childContextTypes must be defined in order to \" + \"use getChildContext().\", name);\n                }\n            }\n        }\n        function callComponentWillMount(type, instance) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillMount === \"function\") {\n                {\n                    if (instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        var componentName = getComponentNameFromType(type) || \"Unknown\";\n                        if (!didWarnAboutDeprecatedWillMount[componentName]) {\n                            warn(\"componentWillMount has been renamed, and is not recommended for use. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move code from componentWillMount to componentDidMount (preferred in most cases) \" + \"or the constructor.\\n\" + \"\\nPlease update the following components: %s\", componentName);\n                            didWarnAboutDeprecatedWillMount[componentName] = true;\n                        }\n                    }\n                }\n                instance.componentWillMount();\n            }\n            if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                instance.UNSAFE_componentWillMount();\n            }\n            if (oldState !== instance.state) {\n                {\n                    error(\"%s.componentWillMount(): Assigning directly to this.state is \" + \"deprecated (except inside a component's \" + \"constructor). Use setState instead.\", getComponentNameFromType(type) || \"Component\");\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        }\n        function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {\n            if (internalInstance.queue !== null && internalInstance.queue.length > 0) {\n                var oldQueue = internalInstance.queue;\n                var oldReplace = internalInstance.replace;\n                internalInstance.queue = null;\n                internalInstance.replace = false;\n                if (oldReplace && oldQueue.length === 1) {\n                    inst.state = oldQueue[0];\n                } else {\n                    var nextState = oldReplace ? oldQueue[0] : inst.state;\n                    var dontMutate = true;\n                    for(var i = oldReplace ? 1 : 0; i < oldQueue.length; i++){\n                        var partial = oldQueue[i];\n                        var partialState = typeof partial === \"function\" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;\n                        if (partialState != null) {\n                            if (dontMutate) {\n                                dontMutate = false;\n                                nextState = assign({}, nextState, partialState);\n                            } else {\n                                assign(nextState, partialState);\n                            }\n                        }\n                    }\n                    inst.state = nextState;\n                }\n            } else {\n                internalInstance.queue = null;\n            }\n        } // Invokes the mount life-cycles on a previously never rendered instance.\n        function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {\n            {\n                checkClassInstance(instance, ctor, newProps);\n            }\n            var initialState = instance.state !== undefined ? instance.state : null;\n            instance.updater = classComponentUpdater;\n            instance.props = newProps;\n            instance.state = initialState; // We don't bother initializing the refs object on the server, since we're not going to resolve them anyway.\n            // The internal instance will be used to manage updates that happen during this mount.\n            var internalInstance = {\n                queue: [],\n                replace: false\n            };\n            set(instance, internalInstance);\n            var contextType = ctor.contextType;\n            if (typeof contextType === \"object\" && contextType !== null) {\n                instance.context = readContext$1(contextType);\n            } else {\n                instance.context = maskedLegacyContext;\n            }\n            {\n                if (instance.state === newProps) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n                        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n                        error(\"%s: It is not recommended to assign props directly to state \" + \"because updates to props won't be reflected in state. \" + \"In most cases, it is better to use props directly.\", componentName);\n                    }\n                }\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            if (typeof getDerivedStateFromProps === \"function\") {\n                instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);\n            } // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (typeof ctor.getDerivedStateFromProps !== \"function\" && typeof instance.getSnapshotBeforeUpdate !== \"function\" && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n                callComponentWillMount(ctor, instance); // If we had additional state updates during this life-cycle, let's\n                // process them now.\n                processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);\n            }\n        }\n        // Ids are base 32 strings whose binary representation corresponds to the\n        // position of a node in a tree.\n        // Every time the tree forks into multiple children, we add additional bits to\n        // the left of the sequence that represent the position of the child within the\n        // current level of children.\n        //\n        //      00101       00010001011010101\n        //             \n        //   Fork 5 of 20       Parent id\n        //\n        // The leading 0s are important. In the above example, you only need 3 bits to\n        // represent slot 5. However, you need 5 bits to represent all the forks at\n        // the current level, so we must account for the empty bits at the end.\n        //\n        // For this same reason, slots are 1-indexed instead of 0-indexed. Otherwise,\n        // the zeroth id at a level would be indistinguishable from its parent.\n        //\n        // If a node has only one child, and does not materialize an id (i.e. does not\n        // contain a useId hook), then we don't need to allocate any space in the\n        // sequence. It's treated as a transparent indirection. For example, these two\n        // trees produce the same ids:\n        //\n        // <>                          <>\n        //   <Indirection>               <A />\n        //     <A />                     <B />\n        //   </Indirection>            </>\n        //   <B />\n        // </>\n        //\n        // However, we cannot skip any node that materializes an id. Otherwise, a parent\n        // id that does not fork would be indistinguishable from its child id. For\n        // example, this tree does not fork, but the parent and child must have\n        // different ids.\n        //\n        // <Parent>\n        //   <Child />\n        // </Parent>\n        //\n        // To handle this scenario, every time we materialize an id, we allocate a\n        // new level with a single slot. You can think of this as a fork with only one\n        // prong, or an array of children with length 1.\n        //\n        // It's possible for the size of the sequence to exceed 32 bits, the max\n        // size for bitwise operations. When this happens, we make more room by\n        // converting the right part of the id to a string and storing it in an overflow\n        // variable. We use a base 32 string representation, because 32 is the largest\n        // power of 2 that is supported by toString(). We want the base to be large so\n        // that the resulting ids are compact, and we want the base to be a power of 2\n        // because every log2(base) bits corresponds to a single character, i.e. every\n        // log2(32) = 5 bits. That means we can lop bits off the end 5 at a time without\n        // affecting the final result.\n        var emptyTreeContext = {\n            id: 1,\n            overflow: \"\"\n        };\n        function getTreeId(context) {\n            var overflow = context.overflow;\n            var idWithLeadingBit = context.id;\n            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n            return id.toString(32) + overflow;\n        }\n        function pushTreeContext(baseContext, totalChildren, index) {\n            var baseIdWithLeadingBit = baseContext.id;\n            var baseOverflow = baseContext.overflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n            // of the id; we use it to account for leading 0s.\n            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n            var slot = index + 1;\n            var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n            // consideration the leading 1 we use to mark the end of the sequence.\n            if (length > 30) {\n                // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n                // This branch assumes the length of the base id is greater than 5; it won't\n                // work for smaller ids, because you need 5 bits per character.\n                //\n                // We encode the id in multiple steps: first the base id, then the\n                // remaining digits.\n                //\n                // Each 5 bit sequence corresponds to a single base 32 character. So for\n                // example, if the current id is 23 bits long, we can convert 20 of those\n                // bits into a string of 4 characters, with 3 bits left over.\n                //\n                // First calculate how many bits in the base id represent a complete\n                // sequence of characters.\n                var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n                var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n                var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n                var restOfBaseId = baseId >> numberOfOverflowBits;\n                var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n                // we made more room, this time it won't overflow.\n                var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n                var restOfNewBits = slot << restOfBaseLength;\n                var id = restOfNewBits | restOfBaseId;\n                var overflow = newOverflow + baseOverflow;\n                return {\n                    id: 1 << restOfLength | id,\n                    overflow: overflow\n                };\n            } else {\n                // Normal path\n                var newBits = slot << baseLength;\n                var _id = newBits | baseId;\n                var _overflow = baseOverflow;\n                return {\n                    id: 1 << length | _id,\n                    overflow: _overflow\n                };\n            }\n        }\n        function getBitLength(number) {\n            return 32 - clz32(number);\n        }\n        function getLeadingBit(id) {\n            return 1 << getBitLength(id) - 1;\n        } // TODO: Math.clz32 is supported in Node 12+. Maybe we can drop the fallback.\n        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n        // Based on:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n        var log = Math.log;\n        var LN2 = Math.LN2;\n        function clz32Fallback(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0;\n        }\n        // Corresponds to ReactFiberWakeable and ReactFlightWakeable modules. Generally,\n        // changes to one module should be reflected in the others.\n        // TODO: Rename this module and the corresponding Fiber one to \"Thenable\"\n        // instead of \"Wakeable\". Or some other more appropriate name.\n        // An error that is thrown (e.g. by `use`) to trigger Suspense. If we\n        // detect this is caught by userspace, we'll log a warning in development.\n        var SuspenseException = new Error(\"Suspense Exception: This is not a real error! It's an implementation \" + \"detail of `use` to interrupt the current render. You must either \" + \"rethrow it immediately, or move the `use` call outside of the \" + \"`try/catch` block. Capturing without rethrowing will lead to \" + \"unexpected behavior.\\n\\n\" + \"To handle async errors, wrap your component in an error boundary, or \" + \"call the promise's `.catch` method and pass the result to `use`\");\n        function createThenableState() {\n            // The ThenableState is created the first time a component suspends. If it\n            // suspends again, we'll reuse the same state.\n            return [];\n        }\n        function noop$2() {}\n        function trackUsedThenable(thenableState, thenable, index) {\n            var previous = thenableState[index];\n            if (previous === undefined) {\n                thenableState.push(thenable);\n            } else {\n                if (previous !== thenable) {\n                    // Reuse the previous thenable, and drop the new one. We can assume\n                    // they represent the same value, because components are idempotent.\n                    // Avoid an unhandled rejection errors for the Promises that we'll\n                    // intentionally ignore.\n                    thenable.then(noop$2, noop$2);\n                    thenable = previous;\n                }\n            } // We use an expando to track the status and result of a thenable so that we\n            // can synchronously unwrap the value. Think of this as an extension of the\n            // Promise API, or a custom interface that is a superset of Thenable.\n            //\n            // If the thenable doesn't have a status, set it to \"pending\" and attach\n            // a listener that will update its status and result when it resolves.\n            switch(thenable.status){\n                case \"fulfilled\":\n                    {\n                        var fulfilledValue = thenable.value;\n                        return fulfilledValue;\n                    }\n                case \"rejected\":\n                    {\n                        var rejectedError = thenable.reason;\n                        throw rejectedError;\n                    }\n                default:\n                    {\n                        if (typeof thenable.status === \"string\") ;\n                        else {\n                            var pendingThenable = thenable;\n                            pendingThenable.status = \"pending\";\n                            pendingThenable.then(function(fulfilledValue) {\n                                if (thenable.status === \"pending\") {\n                                    var fulfilledThenable = thenable;\n                                    fulfilledThenable.status = \"fulfilled\";\n                                    fulfilledThenable.value = fulfilledValue;\n                                }\n                            }, function(error) {\n                                if (thenable.status === \"pending\") {\n                                    var rejectedThenable = thenable;\n                                    rejectedThenable.status = \"rejected\";\n                                    rejectedThenable.reason = error;\n                                }\n                            }); // Check one more time in case the thenable resolved synchronously\n                            switch(thenable.status){\n                                case \"fulfilled\":\n                                    {\n                                        var fulfilledThenable = thenable;\n                                        return fulfilledThenable.value;\n                                    }\n                                case \"rejected\":\n                                    {\n                                        var rejectedThenable = thenable;\n                                        throw rejectedThenable.reason;\n                                    }\n                            }\n                        } // Suspend.\n                        //\n                        // Throwing here is an implementation detail that allows us to unwind the\n                        // call stack. But we shouldn't allow it to leak into userspace. Throw an\n                        // opaque placeholder value instead of the actual thenable. If it doesn't\n                        // get captured by the work loop, log a warning, because that means\n                        // something in userspace must have caught it.\n                        suspendedThenable = thenable;\n                        throw SuspenseException;\n                    }\n            }\n        } // This is used to track the actual thenable that suspended so it can be\n        // passed to the rest of the Suspense implementation  which, for historical\n        // reasons, expects to receive a thenable.\n        var suspendedThenable = null;\n        function getSuspendedThenable() {\n            // This is called right after `use` suspends by throwing an exception. `use`\n            // throws an opaque value instead of the thenable itself so that it can't be\n            // caught in userspace. Then the work loop accesses the actual thenable using\n            // this function.\n            if (suspendedThenable === null) {\n                throw new Error(\"Expected a suspended thenable. This is a bug in React. Please file \" + \"an issue.\");\n            }\n            var thenable = suspendedThenable;\n            suspendedThenable = null;\n            return thenable;\n        }\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        var currentlyRenderingComponent = null;\n        var currentlyRenderingTask = null;\n        var currentlyRenderingRequest = null;\n        var currentlyRenderingKeyPath = null;\n        var firstWorkInProgressHook = null;\n        var workInProgressHook = null; // Whether the work-in-progress hook is a re-rendered hook\n        var isReRender = false; // Whether an update was scheduled during the currently executing render pass.\n        var didScheduleRenderPhaseUpdate = false; // Counts the number of useId hooks in this component\n        var localIdCounter = 0; // Chunks that should be pushed to the stream once the component\n        // finishes rendering.\n        // Counts the number of useFormState calls in this component\n        var formStateCounter = 0; // The index of the useFormState hook that matches the one passed in at the\n        // root during an MPA navigation, if any.\n        var formStateMatchingIndex = -1; // Counts the number of use(thenable) calls in this component\n        var thenableIndexCounter = 0;\n        var thenableState = null; // Lazily created map of render-phase updates\n        var renderPhaseUpdates = null; // Counter to prevent infinite loops.\n        var numberOfReRenders = 0;\n        var RE_RENDER_LIMIT = 25;\n        var isInHookUserCodeInDev = false; // In DEV, this is the name of the currently executing primitive hook\n        var currentHookNameInDev;\n        function resolveCurrentlyRenderingComponent() {\n            if (currentlyRenderingComponent === null) {\n                throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for\" + \" one of the following reasons:\\n\" + \"1. You might have mismatching versions of React and the renderer (such as React DOM)\\n\" + \"2. You might be breaking the Rules of Hooks\\n\" + \"3. You might have more than one copy of React in the same app\\n\" + \"See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n            }\n            {\n                if (isInHookUserCodeInDev) {\n                    error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. \" + \"You can only call Hooks at the top level of your React function. \" + \"For more information, see \" + \"https://reactjs.org/link/rules-of-hooks\");\n                }\n            }\n            return currentlyRenderingComponent;\n        }\n        function areHookInputsEqual(nextDeps, prevDeps) {\n            if (prevDeps === null) {\n                {\n                    error(\"%s received a final argument during this render, but not during \" + \"the previous render. Even though the final argument is optional, \" + \"its type cannot change between renders.\", currentHookNameInDev);\n                }\n                return false;\n            }\n            {\n                // Don't bother comparing lengths in prod because these arrays should be\n                // passed inline.\n                if (nextDeps.length !== prevDeps.length) {\n                    error(\"The final argument passed to %s changed size between renders. The \" + \"order and size of this array must remain constant.\\n\\n\" + \"Previous: %s\\n\" + \"Incoming: %s\", currentHookNameInDev, \"[\" + nextDeps.join(\", \") + \"]\", \"[\" + prevDeps.join(\", \") + \"]\");\n                }\n            }\n            for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){\n                // $FlowFixMe[incompatible-use] found when upgrading Flow\n                if (objectIs(nextDeps[i], prevDeps[i])) {\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        function createHook() {\n            if (numberOfReRenders > 0) {\n                throw new Error(\"Rendered more hooks than during the previous render\");\n            }\n            return {\n                memoizedState: null,\n                queue: null,\n                next: null\n            };\n        }\n        function createWorkInProgressHook() {\n            if (workInProgressHook === null) {\n                // This is the first hook in the list\n                if (firstWorkInProgressHook === null) {\n                    isReRender = false;\n                    firstWorkInProgressHook = workInProgressHook = createHook();\n                } else {\n                    // There's already a work-in-progress. Reuse it.\n                    isReRender = true;\n                    workInProgressHook = firstWorkInProgressHook;\n                }\n            } else {\n                if (workInProgressHook.next === null) {\n                    isReRender = false; // Append to the end of the list\n                    workInProgressHook = workInProgressHook.next = createHook();\n                } else {\n                    // There's already a work-in-progress. Reuse it.\n                    isReRender = true;\n                    workInProgressHook = workInProgressHook.next;\n                }\n            }\n            return workInProgressHook;\n        }\n        function prepareToUseHooks(request, task, keyPath, componentIdentity, prevThenableState) {\n            currentlyRenderingComponent = componentIdentity;\n            currentlyRenderingTask = task;\n            currentlyRenderingRequest = request;\n            currentlyRenderingKeyPath = keyPath;\n            {\n                isInHookUserCodeInDev = false;\n            }\n            // didScheduleRenderPhaseUpdate = false;\n            // firstWorkInProgressHook = null;\n            // numberOfReRenders = 0;\n            // renderPhaseUpdates = null;\n            // workInProgressHook = null;\n            localIdCounter = 0;\n            formStateCounter = 0;\n            formStateMatchingIndex = -1;\n            thenableIndexCounter = 0;\n            thenableState = prevThenableState;\n        }\n        function finishHooks(Component, props, children, refOrContext) {\n            // This must be called after every function component to prevent hooks from\n            // being used in classes.\n            while(didScheduleRenderPhaseUpdate){\n                // Updates were scheduled during the render phase. They are stored in\n                // the `renderPhaseUpdates` map. Call the component again, reusing the\n                // work-in-progress hooks and applying the additional updates on top. Keep\n                // restarting until no more updates are scheduled.\n                didScheduleRenderPhaseUpdate = false;\n                localIdCounter = 0;\n                formStateCounter = 0;\n                formStateMatchingIndex = -1;\n                thenableIndexCounter = 0;\n                numberOfReRenders += 1; // Start over from the beginning of the list\n                workInProgressHook = null;\n                children = Component(props, refOrContext);\n            }\n            resetHooksState();\n            return children;\n        }\n        function getThenableStateAfterSuspending() {\n            var state = thenableState;\n            thenableState = null;\n            return state;\n        }\n        function checkDidRenderIdHook() {\n            // This should be called immediately after every finishHooks call.\n            // Conceptually, it's part of the return value of finishHooks; it's only a\n            // separate function to avoid using an array tuple.\n            var didRenderIdHook = localIdCounter !== 0;\n            return didRenderIdHook;\n        }\n        function getFormStateCount() {\n            // This should be called immediately after every finishHooks call.\n            // Conceptually, it's part of the return value of finishHooks; it's only a\n            // separate function to avoid using an array tuple.\n            return formStateCounter;\n        }\n        function getFormStateMatchingIndex() {\n            // This should be called immediately after every finishHooks call.\n            // Conceptually, it's part of the return value of finishHooks; it's only a\n            // separate function to avoid using an array tuple.\n            return formStateMatchingIndex;\n        } // Reset the internal hooks state if an error occurs while rendering a component\n        function resetHooksState() {\n            {\n                isInHookUserCodeInDev = false;\n            }\n            currentlyRenderingComponent = null;\n            currentlyRenderingTask = null;\n            currentlyRenderingRequest = null;\n            currentlyRenderingKeyPath = null;\n            didScheduleRenderPhaseUpdate = false;\n            firstWorkInProgressHook = null;\n            numberOfReRenders = 0;\n            renderPhaseUpdates = null;\n            workInProgressHook = null;\n        }\n        function readContext(context) {\n            {\n                if (isInHookUserCodeInDev) {\n                    error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n                }\n            }\n            return readContext$1(context);\n        }\n        function useContext(context) {\n            {\n                currentHookNameInDev = \"useContext\";\n            }\n            resolveCurrentlyRenderingComponent();\n            return readContext$1(context);\n        }\n        function basicStateReducer(state, action) {\n            // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n            return typeof action === \"function\" ? action(state) : action;\n        }\n        function useState(initialState) {\n            _s();\n            {\n                currentHookNameInDev = \"useState\";\n            }\n            return useReducer(basicStateReducer, initialState);\n        }\n        _s(useState, \"skVOqNGrFQuDFh+lpttAJ2AZFeA=\");\n        function useReducer(reducer, initialArg, init) {\n            {\n                if (reducer !== basicStateReducer) {\n                    currentHookNameInDev = \"useReducer\";\n                }\n            }\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            if (isReRender) {\n                // This is a re-render. Apply the new render phase updates to the previous\n                // current hook.\n                var queue = workInProgressHook.queue;\n                var dispatch = queue.dispatch;\n                if (renderPhaseUpdates !== null) {\n                    // Render phase updates are stored in a map of queue -> linked list\n                    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                    if (firstRenderPhaseUpdate !== undefined) {\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        renderPhaseUpdates.delete(queue); // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        var newState = workInProgressHook.memoizedState;\n                        var update = firstRenderPhaseUpdate;\n                        do {\n                            // Process this render phase update. We don't have to check the\n                            // priority because it will always be the same as the current\n                            // render's.\n                            var action = update.action;\n                            {\n                                isInHookUserCodeInDev = true;\n                            }\n                            newState = reducer(newState, action);\n                            {\n                                isInHookUserCodeInDev = false;\n                            }\n                            update = update.next;\n                        }while (update !== null); // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        workInProgressHook.memoizedState = newState;\n                        return [\n                            newState,\n                            dispatch\n                        ];\n                    }\n                } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                return [\n                    workInProgressHook.memoizedState,\n                    dispatch\n                ];\n            } else {\n                {\n                    isInHookUserCodeInDev = true;\n                }\n                var initialState;\n                if (reducer === basicStateReducer) {\n                    // Special case for `useState`.\n                    initialState = typeof initialArg === \"function\" ? initialArg() : initialArg;\n                } else {\n                    initialState = init !== undefined ? init(initialArg) : initialArg;\n                }\n                {\n                    isInHookUserCodeInDev = false;\n                }\n                workInProgressHook.memoizedState = initialState; // $FlowFixMe[incompatible-use] found when upgrading Flow\n                var _queue = workInProgressHook.queue = {\n                    last: null,\n                    dispatch: null\n                };\n                var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue); // $FlowFixMe[incompatible-use] found when upgrading Flow\n                return [\n                    workInProgressHook.memoizedState,\n                    _dispatch\n                ];\n            }\n        }\n        function useMemo(nextCreate, deps) {\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            if (workInProgressHook !== null) {\n                var prevState = workInProgressHook.memoizedState;\n                if (prevState !== null) {\n                    if (nextDeps !== null) {\n                        var prevDeps = prevState[1];\n                        if (areHookInputsEqual(nextDeps, prevDeps)) {\n                            return prevState[0];\n                        }\n                    }\n                }\n            }\n            {\n                isInHookUserCodeInDev = true;\n            }\n            var nextValue = nextCreate();\n            {\n                isInHookUserCodeInDev = false;\n            }\n            workInProgressHook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function useRef(initialValue) {\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            var previousRef = workInProgressHook.memoizedState;\n            if (previousRef === null) {\n                var ref = {\n                    current: initialValue\n                };\n                {\n                    Object.seal(ref);\n                }\n                workInProgressHook.memoizedState = ref;\n                return ref;\n            } else {\n                return previousRef;\n            }\n        }\n        function dispatchAction(componentIdentity, queue, action) {\n            if (numberOfReRenders >= RE_RENDER_LIMIT) {\n                throw new Error(\"Too many re-renders. React limits the number of renders to prevent \" + \"an infinite loop.\");\n            }\n            if (componentIdentity === currentlyRenderingComponent) {\n                // This is a render phase update. Stash it in a lazily-created map of\n                // queue -> linked list of updates. After this render pass, we'll restart\n                // and apply the stashed updates on top of the work-in-progress hook.\n                didScheduleRenderPhaseUpdate = true;\n                var update = {\n                    action: action,\n                    next: null\n                };\n                if (renderPhaseUpdates === null) {\n                    renderPhaseUpdates = new Map();\n                }\n                var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                if (firstRenderPhaseUpdate === undefined) {\n                    // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    renderPhaseUpdates.set(queue, update);\n                } else {\n                    // Append the update to the end of the list.\n                    var lastRenderPhaseUpdate = firstRenderPhaseUpdate;\n                    while(lastRenderPhaseUpdate.next !== null){\n                        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n                    }\n                    lastRenderPhaseUpdate.next = update;\n                }\n            }\n        }\n        function useCallback(callback, deps) {\n            _s1();\n            return useMemo(function() {\n                return callback;\n            }, deps);\n        }\n        _s1(useCallback, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\n        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            if (getServerSnapshot === undefined) {\n                throw new Error(\"Missing getServerSnapshot, which is required for \" + \"server-rendered content. Will revert to client rendering.\");\n            }\n            return getServerSnapshot();\n        }\n        function useDeferredValue(value, initialValue) {\n            resolveCurrentlyRenderingComponent();\n            {\n                return value;\n            }\n        }\n        function unsupportedStartTransition() {\n            throw new Error(\"startTransition cannot be called during server rendering.\");\n        }\n        function useTransition() {\n            resolveCurrentlyRenderingComponent();\n            return [\n                false,\n                unsupportedStartTransition\n            ];\n        }\n        function useHostTransitionStatus() {\n            resolveCurrentlyRenderingComponent();\n            return NotPendingTransition;\n        }\n        function unsupportedSetOptimisticState() {\n            throw new Error(\"Cannot update optimistic state while rendering.\");\n        }\n        function useOptimistic(passthrough, reducer) {\n            resolveCurrentlyRenderingComponent();\n            return [\n                passthrough,\n                unsupportedSetOptimisticState\n            ];\n        }\n        function createPostbackFormStateKey(permalink, componentKeyPath, hookIndex) {\n            if (permalink !== undefined) {\n                // Don't bother to hash a permalink-based key since it's already short.\n                return \"p\" + permalink;\n            } else {\n                // Append a node to the key path that represents the form state hook.\n                var keyPath = [\n                    componentKeyPath,\n                    null,\n                    hookIndex\n                ]; // Key paths are hashed to reduce the size. It does not need to be secure,\n                // and it's more important that it's fast than that it's completely\n                // collision-free.\n                var keyPathHash = createFastHashJS(JSON.stringify(keyPath));\n                return \"k\" + keyPathHash;\n            }\n        }\n        function useFormState(action, initialState, permalink) {\n            resolveCurrentlyRenderingComponent(); // Count the number of useFormState hooks per component. We also use this to\n            // track the position of this useFormState hook relative to the other ones in\n            // this component, so we can generate a unique key for each one.\n            var formStateHookIndex = formStateCounter++;\n            var request = currentlyRenderingRequest; // $FlowIgnore[prop-missing]\n            var formAction = action.$$FORM_ACTION;\n            if (typeof formAction === \"function\") {\n                // This is a server action. These have additional features to enable\n                // MPA-style form submissions with progressive enhancement.\n                // TODO: If the same permalink is passed to multiple useFormStates, and\n                // they all have the same action signature, Fizz will pass the postback\n                // state to all of them. We should probably only pass it to the first one,\n                // and/or warn.\n                // The key is lazily generated and deduped so the that the keypath doesn't\n                // get JSON.stringify-ed unnecessarily, and at most once.\n                var nextPostbackStateKey = null; // Determine the current form state. If we received state during an MPA form\n                // submission, then we will reuse that, if the action identity matches.\n                // Otherwise we'll use the initial state argument. We will emit a comment\n                // marker into the stream that indicates whether the state was reused.\n                var state = initialState;\n                var componentKeyPath = currentlyRenderingKeyPath;\n                var postbackFormState = getFormState(request); // $FlowIgnore[prop-missing]\n                var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;\n                if (postbackFormState !== null && typeof isSignatureEqual === \"function\") {\n                    var postbackKey = postbackFormState[1];\n                    var postbackReferenceId = postbackFormState[2];\n                    var postbackBoundArity = postbackFormState[3];\n                    if (isSignatureEqual.call(action, postbackReferenceId, postbackBoundArity)) {\n                        nextPostbackStateKey = createPostbackFormStateKey(permalink, componentKeyPath, formStateHookIndex);\n                        if (postbackKey === nextPostbackStateKey) {\n                            // This was a match\n                            formStateMatchingIndex = formStateHookIndex; // Reuse the state that was submitted by the form.\n                            state = postbackFormState[0];\n                        }\n                    }\n                } // Bind the state to the first argument of the action.\n                var boundAction = action.bind(null, state); // Wrap the action so the return value is void.\n                var dispatch = function(payload) {\n                    boundAction(payload);\n                }; // $FlowIgnore[prop-missing]\n                if (typeof boundAction.$$FORM_ACTION === \"function\") {\n                    // $FlowIgnore[prop-missing]\n                    dispatch.$$FORM_ACTION = function(prefix) {\n                        var metadata = boundAction.$$FORM_ACTION(prefix); // Override the action URL\n                        if (permalink !== undefined) {\n                            {\n                                checkAttributeStringCoercion(permalink, \"target\");\n                            }\n                            permalink += \"\";\n                            metadata.action = permalink;\n                        }\n                        var formData = metadata.data;\n                        if (formData) {\n                            if (nextPostbackStateKey === null) {\n                                nextPostbackStateKey = createPostbackFormStateKey(permalink, componentKeyPath, formStateHookIndex);\n                            }\n                            formData.append(\"$ACTION_KEY\", nextPostbackStateKey);\n                        }\n                        return metadata;\n                    };\n                }\n                return [\n                    state,\n                    dispatch\n                ];\n            } else {\n                // This is not a server action, so the implementation is much simpler.\n                // Bind the state to the first argument of the action.\n                var _boundAction = action.bind(null, initialState); // Wrap the action so the return value is void.\n                var _dispatch2 = function(payload) {\n                    _boundAction(payload);\n                };\n                return [\n                    initialState,\n                    _dispatch2\n                ];\n            }\n        }\n        function useId() {\n            var task = currentlyRenderingTask;\n            var treeId = getTreeId(task.treeContext);\n            var resumableState = currentResumableState;\n            if (resumableState === null) {\n                throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component.\");\n            }\n            var localId = localIdCounter++;\n            return makeId(resumableState, treeId, localId);\n        }\n        function use(usable) {\n            if (usable !== null && typeof usable === \"object\") {\n                // $FlowFixMe[method-unbinding]\n                if (typeof usable.then === \"function\") {\n                    // This is a thenable.\n                    var thenable = usable;\n                    return unwrapThenable(thenable);\n                } else if (usable.$$typeof === REACT_CONTEXT_TYPE || usable.$$typeof === REACT_SERVER_CONTEXT_TYPE) {\n                    var context = usable;\n                    return readContext(context);\n                }\n            } // eslint-disable-next-line react-internal/safe-string-coercion\n            throw new Error(\"An unsupported type was passed to use(): \" + String(usable));\n        }\n        function unwrapThenable(thenable) {\n            var index = thenableIndexCounter;\n            thenableIndexCounter += 1;\n            if (thenableState === null) {\n                thenableState = createThenableState();\n            }\n            return trackUsedThenable(thenableState, thenable, index);\n        }\n        function unsupportedRefresh() {\n            throw new Error(\"Cache cannot be refreshed during server rendering.\");\n        }\n        function useCacheRefresh() {\n            return unsupportedRefresh;\n        }\n        function noop$1() {}\n        var HooksDispatcher = {\n            readContext: readContext,\n            use: use,\n            useContext: useContext,\n            useMemo: useMemo,\n            useReducer: useReducer,\n            useRef: useRef,\n            useState: useState,\n            useInsertionEffect: noop$1,\n            useLayoutEffect: noop$1,\n            useCallback: useCallback,\n            // useImperativeHandle is not run in the server environment\n            useImperativeHandle: noop$1,\n            // Effects are not run in the server environment.\n            useEffect: noop$1,\n            // Debugging effect\n            useDebugValue: noop$1,\n            useDeferredValue: useDeferredValue,\n            useTransition: useTransition,\n            useId: useId,\n            // Subscriptions are not setup in a server environment.\n            useSyncExternalStore: useSyncExternalStore\n        };\n        {\n            HooksDispatcher.useCacheRefresh = useCacheRefresh;\n        }\n        {\n            HooksDispatcher.useHostTransitionStatus = useHostTransitionStatus;\n        }\n        {\n            HooksDispatcher.useOptimistic = useOptimistic;\n            HooksDispatcher.useFormState = useFormState;\n        }\n        var currentResumableState = null;\n        function setCurrentResumableState(resumableState) {\n            currentResumableState = resumableState;\n        }\n        function getCacheSignal() {\n            throw new Error(\"Not implemented.\");\n        }\n        function getCacheForType(resourceType) {\n            throw new Error(\"Not implemented.\");\n        }\n        var DefaultCacheDispatcher = {\n            getCacheSignal: getCacheSignal,\n            getCacheForType: getCacheForType\n        };\n        function getStackByComponentStackNode(componentStack) {\n            try {\n                var info = \"\";\n                var node = componentStack;\n                do {\n                    switch(node.tag){\n                        case 0:\n                            info += describeBuiltInComponentFrame(node.type, null, null);\n                            break;\n                        case 1:\n                            info += describeFunctionComponentFrame(node.type, null, null);\n                            break;\n                        case 2:\n                            info += describeClassComponentFrame(node.type, null, null);\n                            break;\n                    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                    node = node.parent;\n                }while (node);\n                return info;\n            } catch (x) {\n                return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var ReactCurrentCache = ReactSharedInternals.ReactCurrentCache;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame; // Linked list representing the identity of a component given the component/tag name and key.\n        // The name might be minified but we assume that it's going to be the same generated name. Typically\n        // because it's just the same compiled output in practice.\n        // resume with segmentID at the index\n        var CLIENT_RENDERED = 4; // if it errors or infinitely suspends\n        var PENDING = 0;\n        var COMPLETED = 1;\n        var FLUSHED = 2;\n        var ABORTED = 3;\n        var ERRORED = 4;\n        var POSTPONED = 5;\n        var OPEN = 0;\n        var CLOSING = 1;\n        var CLOSED = 2; // This is a default heuristic for how to split up the HTML content into progressive\n        // loading. Our goal is to be able to display additional new content about every 500ms.\n        // Faster than that is unnecessary and should be throttled on the client. It also\n        // adds unnecessary overhead to do more splits. We don't know if it's a higher or lower\n        // end device but higher end suffer less from the overhead than lower end does from\n        // not getting small enough pieces. We error on the side of low end.\n        // We base this on low end 3G speeds which is about 500kbits per second. We assume\n        // that there can be a reasonable drop off from max bandwidth which leaves you with\n        // as little as 80%. We can receive half of that each 500ms - at best. In practice,\n        // a little bandwidth is lost to processing and contention - e.g. CSS and images that\n        // are downloaded along with the main content. So we estimate about half of that to be\n        // the lower end throughput. In other words, we expect that you can at least show\n        // about 12.5kb of content per 500ms. Not counting starting latency for the first\n        // paint.\n        // 500 * 1024 / 8 * .8 * 0.5 / 2\n        var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;\n        function defaultErrorHandler(error) {\n            console[\"error\"](error); // Don't transform to our wrapper\n            return null;\n        }\n        function noop() {}\n        function createRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {\n            prepareHostDispatcher();\n            var pingedTasks = [];\n            var abortSet = new Set();\n            var request = {\n                destination: null,\n                flushScheduled: false,\n                resumableState: resumableState,\n                renderState: renderState,\n                rootFormatContext: rootFormatContext,\n                progressiveChunkSize: progressiveChunkSize === undefined ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,\n                status: OPEN,\n                fatalError: null,\n                nextSegmentId: 0,\n                allPendingTasks: 0,\n                pendingRootTasks: 0,\n                completedRootSegment: null,\n                abortableTasks: abortSet,\n                pingedTasks: pingedTasks,\n                clientRenderedBoundaries: [],\n                completedBoundaries: [],\n                partialBoundaries: [],\n                trackedPostpones: null,\n                onError: onError === undefined ? defaultErrorHandler : onError,\n                onPostpone: onPostpone === undefined ? noop : onPostpone,\n                onAllReady: onAllReady === undefined ? noop : onAllReady,\n                onShellReady: onShellReady === undefined ? noop : onShellReady,\n                onShellError: onShellError === undefined ? noop : onShellError,\n                onFatalError: onFatalError === undefined ? noop : onFatalError,\n                formState: formState === undefined ? null : formState\n            }; // This segment represents the root fallback.\n            var rootSegment = createPendingSegment(request, 0, null, rootFormatContext, false, false); // There is no parent so conceptually, we're unblocked to flush this segment.\n            rootSegment.parentFlushed = true;\n            var rootTask = createRenderTask(request, null, children, -1, null, rootSegment, abortSet, null, rootFormatContext, emptyContextObject, rootContextSnapshot, emptyTreeContext, null);\n            pingedTasks.push(rootTask);\n            return request;\n        }\n        var currentRequest = null;\n        function resolveRequest() {\n            if (currentRequest) return currentRequest;\n            return null;\n        }\n        function pingTask(request, task) {\n            var pingedTasks = request.pingedTasks;\n            pingedTasks.push(task);\n            if (request.pingedTasks.length === 1) {\n                request.flushScheduled = request.destination !== null;\n                scheduleWork(function() {\n                    return performWork(request);\n                });\n            }\n        }\n        function createSuspenseBoundary(request, fallbackAbortableTasks) {\n            return {\n                status: PENDING,\n                rootSegmentID: -1,\n                parentFlushed: false,\n                pendingTasks: 0,\n                completedSegments: [],\n                byteSize: 0,\n                fallbackAbortableTasks: fallbackAbortableTasks,\n                errorDigest: null,\n                resources: createBoundaryResources(),\n                trackedContentKeyPath: null,\n                trackedFallbackNode: null\n            };\n        }\n        function createRenderTask(request, thenableState, node, childIndex, blockedBoundary, blockedSegment, abortSet, keyPath, formatContext, legacyContext, context, treeContext, componentStack) {\n            request.allPendingTasks++;\n            if (blockedBoundary === null) {\n                request.pendingRootTasks++;\n            } else {\n                blockedBoundary.pendingTasks++;\n            }\n            var task = {\n                replay: null,\n                node: node,\n                childIndex: childIndex,\n                ping: function() {\n                    return pingTask(request, task);\n                },\n                blockedBoundary: blockedBoundary,\n                blockedSegment: blockedSegment,\n                abortSet: abortSet,\n                keyPath: keyPath,\n                formatContext: formatContext,\n                legacyContext: legacyContext,\n                context: context,\n                treeContext: treeContext,\n                componentStack: componentStack,\n                thenableState: thenableState\n            };\n            abortSet.add(task);\n            return task;\n        }\n        function createReplayTask(request, thenableState, replay, node, childIndex, blockedBoundary, abortSet, keyPath, formatContext, legacyContext, context, treeContext, componentStack) {\n            request.allPendingTasks++;\n            if (blockedBoundary === null) {\n                request.pendingRootTasks++;\n            } else {\n                blockedBoundary.pendingTasks++;\n            }\n            replay.pendingTasks++;\n            var task = {\n                replay: replay,\n                node: node,\n                childIndex: childIndex,\n                ping: function() {\n                    return pingTask(request, task);\n                },\n                blockedBoundary: blockedBoundary,\n                blockedSegment: null,\n                abortSet: abortSet,\n                keyPath: keyPath,\n                formatContext: formatContext,\n                legacyContext: legacyContext,\n                context: context,\n                treeContext: treeContext,\n                componentStack: componentStack,\n                thenableState: thenableState\n            };\n            abortSet.add(task);\n            return task;\n        }\n        function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {\n            return {\n                status: PENDING,\n                id: -1,\n                // lazily assigned later\n                index: index,\n                parentFlushed: false,\n                chunks: [],\n                children: [],\n                parentFormatContext: parentFormatContext,\n                boundary: boundary,\n                lastPushedText: lastPushedText,\n                textEmbedded: textEmbedded\n            };\n        } // DEV-only global reference to the currently executing task\n        var currentTaskInDEV = null;\n        function getCurrentStackInDEV() {\n            {\n                if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {\n                    return \"\";\n                }\n                return getStackByComponentStackNode(currentTaskInDEV.componentStack);\n            }\n        }\n        function getStackFromNode(stackNode) {\n            return getStackByComponentStackNode(stackNode);\n        }\n        function createBuiltInComponentStack(task, type) {\n            return {\n                tag: 0,\n                parent: task.componentStack,\n                type: type\n            };\n        }\n        function createFunctionComponentStack(task, type) {\n            return {\n                tag: 1,\n                parent: task.componentStack,\n                type: type\n            };\n        }\n        function createClassComponentStack(task, type) {\n            return {\n                tag: 2,\n                parent: task.componentStack,\n                type: type\n            };\n        } // While we track component stacks in prod all the time we only produce a reified stack in dev and\n        // during prerender in Prod. The reason for this is that the stack is useful for prerender where the timeliness\n        // of the request is less critical than the observability of the execution. For renders and resumes however we\n        // prioritize speed of the request.\n        function getThrownInfo(request, node) {\n            if (node && true) {\n                return {\n                    componentStack: getStackFromNode(node)\n                };\n            } else {\n                return {};\n            }\n        }\n        function encodeErrorForBoundary(boundary, digest, error, thrownInfo) {\n            boundary.errorDigest = digest;\n            {\n                // In dev we additionally encode the error message and component stack on the boundary\n                var errorMessage;\n                if (typeof error === \"string\") {\n                    errorMessage = error;\n                } else if (error && typeof error.message === \"string\") {\n                    errorMessage = error.message;\n                } else {\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    errorMessage = String(error);\n                }\n                boundary.errorMessage = errorMessage;\n                boundary.errorComponentStack = thrownInfo.componentStack;\n            }\n        }\n        function logRecoverableError(request, error$1, errorInfo) {\n            // If this callback errors, we intentionally let that error bubble up to become a fatal error\n            // so that someone fixes the error reporting instead of hiding it.\n            var errorDigest = request.onError(error$1, errorInfo);\n            if (errorDigest != null && typeof errorDigest !== \"string\") {\n                // We used to throw here but since this gets called from a variety of unprotected places it\n                // seems better to just warn and discard the returned value.\n                {\n                    error('onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"%s\" instead', typeof errorDigest);\n                }\n                return;\n            }\n            return errorDigest;\n        }\n        function fatalError(request, error) {\n            // This is called outside error handling code such as if the root errors outside\n            // a suspense boundary or if the root suspense boundary's fallback errors.\n            // It's also called if React itself or its host configs errors.\n            var onShellError = request.onShellError;\n            onShellError(error);\n            var onFatalError = request.onFatalError;\n            onFatalError(error);\n            if (request.destination !== null) {\n                request.status = CLOSED;\n                closeWithError(request.destination, error);\n            } else {\n                request.status = CLOSING;\n                request.fatalError = error;\n            }\n        }\n        function renderSuspenseBoundary(request, someTask, keyPath, props) {\n            if (someTask.replay !== null) {\n                // If we're replaying through this pass, it means we're replaying through\n                // an already completed Suspense boundary. It's too late to do anything about it\n                // so we can just render through it.\n                var _prevKeyPath = someTask.keyPath;\n                someTask.keyPath = keyPath;\n                var _content = props.children;\n                try {\n                    renderNode(request, someTask, _content, -1);\n                } finally{\n                    someTask.keyPath = _prevKeyPath;\n                }\n                return;\n            } // $FlowFixMe: Refined.\n            var task = someTask;\n            var previousComponentStack = task.componentStack; // If we end up creating the fallback task we need it to have the correct stack which is\n            // the stack for the boundary itself. We stash it here so we can use it if needed later\n            var suspenseComponentStack = task.componentStack = createBuiltInComponentStack(task, \"Suspense\");\n            var prevKeyPath = task.keyPath;\n            var parentBoundary = task.blockedBoundary;\n            var parentSegment = task.blockedSegment; // Each time we enter a suspense boundary, we split out into a new segment for\n            // the fallback so that we can later replace that segment with the content.\n            // This also lets us split out the main content even if it doesn't suspend,\n            // in case it ends up generating a large subtree of content.\n            var fallback = props.fallback;\n            var content = props.children;\n            var fallbackAbortSet = new Set();\n            var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);\n            if (request.trackedPostpones !== null) {\n                newBoundary.trackedContentKeyPath = keyPath;\n            }\n            var insertionIndex = parentSegment.chunks.length; // The children of the boundary segment is actually the fallback.\n            var boundarySegment = createPendingSegment(request, insertionIndex, newBoundary, task.formatContext, false, false);\n            parentSegment.children.push(boundarySegment); // The parentSegment has a child Segment at this index so we reset the lastPushedText marker on the parent\n            parentSegment.lastPushedText = false; // This segment is the actual child content. We can start rendering that immediately.\n            var contentRootSegment = createPendingSegment(request, 0, null, task.formatContext, false, false); // We mark the root segment as having its parent flushed. It's not really flushed but there is\n            // no parent segment so there's nothing to wait on.\n            contentRootSegment.parentFlushed = true; // Currently this is running synchronously. We could instead schedule this to pingedTasks.\n            // I suspect that there might be some efficiency benefits from not creating the suspended task\n            // and instead just using the stack if possible.\n            // TODO: Call this directly instead of messing with saving and restoring contexts.\n            // We can reuse the current context and task to render the content immediately without\n            // context switching. We just need to temporarily switch which boundary and which segment\n            // we're writing to. If something suspends, it'll spawn new suspended task with that context.\n            task.blockedBoundary = newBoundary;\n            task.blockedSegment = contentRootSegment;\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, newBoundary.resources);\n            }\n            task.keyPath = keyPath;\n            try {\n                // We use the safe form because we don't handle suspending here. Only error handling.\n                renderNode(request, task, content, -1);\n                pushSegmentFinale(contentRootSegment.chunks, request.renderState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);\n                contentRootSegment.status = COMPLETED;\n                queueCompletedSegment(newBoundary, contentRootSegment);\n                if (newBoundary.pendingTasks === 0 && newBoundary.status === PENDING) {\n                    // This must have been the last segment we were waiting on. This boundary is now complete.\n                    // Therefore we won't need the fallback. We early return so that we don't have to create\n                    // the fallback.\n                    newBoundary.status = COMPLETED; // We are returning early so we need to restore the\n                    task.componentStack = previousComponentStack;\n                    return;\n                }\n            } catch (error) {\n                contentRootSegment.status = ERRORED;\n                newBoundary.status = CLIENT_RENDERED;\n                var thrownInfo = getThrownInfo(request, task.componentStack);\n                var errorDigest;\n                {\n                    errorDigest = logRecoverableError(request, error, thrownInfo);\n                }\n                encodeErrorForBoundary(newBoundary, errorDigest, error, thrownInfo);\n                untrackBoundary(request, newBoundary); // We don't need to decrement any task numbers because we didn't spawn any new task.\n            // We don't need to schedule any task because we know the parent has written yet.\n            // We do need to fallthrough to create the fallback though.\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, parentBoundary ? parentBoundary.resources : null);\n                }\n                task.blockedBoundary = parentBoundary;\n                task.blockedSegment = parentSegment;\n                task.keyPath = prevKeyPath;\n                task.componentStack = previousComponentStack;\n            }\n            var fallbackKeyPath = [\n                keyPath[0],\n                \"Suspense Fallback\",\n                keyPath[2]\n            ];\n            var trackedPostpones = request.trackedPostpones;\n            if (trackedPostpones !== null) {\n                // We create a detached replay node to track any postpones inside the fallback.\n                var fallbackReplayNode = [\n                    fallbackKeyPath[1],\n                    fallbackKeyPath[2],\n                    [],\n                    null\n                ];\n                trackedPostpones.workingMap.set(fallbackKeyPath, fallbackReplayNode);\n                if (newBoundary.status === POSTPONED) {\n                    // This must exist now.\n                    var boundaryReplayNode = trackedPostpones.workingMap.get(keyPath);\n                    boundaryReplayNode[4] = fallbackReplayNode;\n                } else {\n                    // We might not inject it into the postponed tree, unless the content actually\n                    // postpones too. We need to keep track of it until that happpens.\n                    newBoundary.trackedFallbackNode = fallbackReplayNode;\n                }\n            } // We create suspended task for the fallback because we don't want to actually work\n            // on it yet in case we finish the main content, so we queue for later.\n            var suspendedFallbackTask = createRenderTask(request, null, fallback, -1, parentBoundary, boundarySegment, fallbackAbortSet, fallbackKeyPath, task.formatContext, task.legacyContext, task.context, task.treeContext, // of the parent boundary from a component standpoint the fallback is a child of the Suspense boundary itself\n            suspenseComponentStack); // TODO: This should be queued at a separate lower priority queue so that we only work\n            // on preparing fallbacks if we don't have any more main content to task on.\n            request.pingedTasks.push(suspendedFallbackTask);\n        }\n        function replaySuspenseBoundary(request, task, keyPath, props, id, childNodes, childSlots, fallbackNodes, fallbackSlots) {\n            var previousComponentStack = task.componentStack; // If we end up creating the fallback task we need it to have the correct stack which is\n            // the stack for the boundary itself. We stash it here so we can use it if needed later\n            var suspenseComponentStack = task.componentStack = createBuiltInComponentStack(task, \"Suspense\");\n            var prevKeyPath = task.keyPath;\n            var previousReplaySet = task.replay;\n            var parentBoundary = task.blockedBoundary;\n            var content = props.children;\n            var fallback = props.fallback;\n            var fallbackAbortSet = new Set();\n            var resumedBoundary = createSuspenseBoundary(request, fallbackAbortSet);\n            resumedBoundary.parentFlushed = true; // We restore the same id of this boundary as was used during prerender.\n            resumedBoundary.rootSegmentID = id; // We can reuse the current context and task to render the content immediately without\n            // context switching. We just need to temporarily switch which boundary and replay node\n            // we're writing to. If something suspends, it'll spawn new suspended task with that context.\n            task.blockedBoundary = resumedBoundary;\n            task.replay = {\n                nodes: childNodes,\n                slots: childSlots,\n                pendingTasks: 1\n            };\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, resumedBoundary.resources);\n            }\n            try {\n                // We use the safe form because we don't handle suspending here. Only error handling.\n                renderNode(request, task, content, -1);\n                if (task.replay.pendingTasks === 1 && task.replay.nodes.length > 0) {\n                    throw new Error(\"Couldn't find all resumable slots by key/index during replaying. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                }\n                task.replay.pendingTasks--;\n                if (resumedBoundary.pendingTasks === 0 && resumedBoundary.status === PENDING) {\n                    // This must have been the last segment we were waiting on. This boundary is now complete.\n                    // Therefore we won't need the fallback. We early return so that we don't have to create\n                    // the fallback.\n                    resumedBoundary.status = COMPLETED;\n                    request.completedBoundaries.push(resumedBoundary); // We restore the parent componentStack. Semantically this is the same as\n                    // popComponentStack(task) but we do this instead because it should be slightly\n                    // faster\n                    return;\n                }\n            } catch (error) {\n                resumedBoundary.status = CLIENT_RENDERED;\n                var thrownInfo = getThrownInfo(request, task.componentStack);\n                var errorDigest;\n                {\n                    errorDigest = logRecoverableError(request, error, thrownInfo);\n                }\n                encodeErrorForBoundary(resumedBoundary, errorDigest, error, thrownInfo);\n                task.replay.pendingTasks--; // The parent already flushed in the prerender so we need to schedule this to be emitted.\n                request.clientRenderedBoundaries.push(resumedBoundary); // We don't need to decrement any task numbers because we didn't spawn any new task.\n            // We don't need to schedule any task because we know the parent has written yet.\n            // We do need to fallthrough to create the fallback though.\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, parentBoundary ? parentBoundary.resources : null);\n                }\n                task.blockedBoundary = parentBoundary;\n                task.replay = previousReplaySet;\n                task.keyPath = prevKeyPath;\n                task.componentStack = previousComponentStack;\n            }\n            var fallbackKeyPath = [\n                keyPath[0],\n                \"Suspense Fallback\",\n                keyPath[2]\n            ]; // We create suspended task for the fallback because we don't want to actually work\n            // on it yet in case we finish the main content, so we queue for later.\n            var fallbackReplay = {\n                nodes: fallbackNodes,\n                slots: fallbackSlots,\n                pendingTasks: 0\n            };\n            var suspendedFallbackTask = createReplayTask(request, null, fallbackReplay, fallback, -1, parentBoundary, fallbackAbortSet, fallbackKeyPath, task.formatContext, task.legacyContext, task.context, task.treeContext, // of the parent boundary from a component standpoint the fallback is a child of the Suspense boundary itself\n            suspenseComponentStack); // TODO: This should be queued at a separate lower priority queue so that we only work\n            // on preparing fallbacks if we don't have any more main content to task on.\n            request.pingedTasks.push(suspendedFallbackTask);\n        }\n        function renderHostElement(request, task, keyPath, type, props) {\n            var previousComponentStack = task.componentStack;\n            task.componentStack = createBuiltInComponentStack(task, type);\n            var segment = task.blockedSegment;\n            if (segment === null) {\n                // Replay\n                var children = props.children; // TODO: Make this a Config for replaying.\n                var prevContext = task.formatContext;\n                var prevKeyPath = task.keyPath;\n                task.formatContext = getChildFormatContext(prevContext, type, props);\n                task.keyPath = keyPath; // We use the non-destructive form because if something suspends, we still\n                // need to pop back up and finish this subtree of HTML.\n                renderNode(request, task, children, -1); // We expect that errors will fatal the whole task and that we don't need\n                // the correct context. Therefore this is not in a finally.\n                task.formatContext = prevContext;\n                task.keyPath = prevKeyPath;\n            } else {\n                // Render\n                var _children = pushStartInstance(segment.chunks, type, props, request.resumableState, request.renderState, task.formatContext, segment.lastPushedText);\n                segment.lastPushedText = false;\n                var _prevContext = task.formatContext;\n                var _prevKeyPath2 = task.keyPath;\n                task.formatContext = getChildFormatContext(_prevContext, type, props);\n                task.keyPath = keyPath; // We use the non-destructive form because if something suspends, we still\n                // need to pop back up and finish this subtree of HTML.\n                renderNode(request, task, _children, -1); // We expect that errors will fatal the whole task and that we don't need\n                // the correct context. Therefore this is not in a finally.\n                task.formatContext = _prevContext;\n                task.keyPath = _prevKeyPath2;\n                pushEndInstance(segment.chunks, type, props, request.resumableState, _prevContext);\n                segment.lastPushedText = false;\n            }\n            task.componentStack = previousComponentStack;\n        }\n        function shouldConstruct(Component) {\n            return Component.prototype && Component.prototype.isReactComponent;\n        }\n        function renderWithHooks(request, task, keyPath, prevThenableState, Component, props, secondArg) {\n            var componentIdentity = {};\n            prepareToUseHooks(request, task, keyPath, componentIdentity, prevThenableState);\n            var result = Component(props, secondArg);\n            return finishHooks(Component, props, result, secondArg);\n        }\n        function finishClassComponent(request, task, keyPath, instance, Component, props) {\n            var nextChildren = instance.render();\n            {\n                if (instance.props !== props) {\n                    if (!didWarnAboutReassigningProps) {\n                        error(\"It looks like %s is reassigning its own `this.props` while rendering. \" + \"This is not supported and can lead to confusing bugs.\", getComponentNameFromType(Component) || \"a component\");\n                    }\n                    didWarnAboutReassigningProps = true;\n                }\n            }\n            {\n                var childContextTypes = Component.childContextTypes;\n                if (childContextTypes !== null && childContextTypes !== undefined) {\n                    var previousContext = task.legacyContext;\n                    var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);\n                    task.legacyContext = mergedContext;\n                    renderNodeDestructive(request, task, null, nextChildren, -1);\n                    task.legacyContext = previousContext;\n                    return;\n                }\n            }\n            var prevKeyPath = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, null, nextChildren, -1);\n            task.keyPath = prevKeyPath;\n        }\n        function renderClassComponent(request, task, keyPath, Component, props) {\n            var previousComponentStack = task.componentStack;\n            task.componentStack = createClassComponentStack(task, Component);\n            var maskedContext = getMaskedContext(Component, task.legacyContext);\n            var instance = constructClassInstance(Component, props, maskedContext);\n            mountClassInstance(instance, Component, props, maskedContext);\n            finishClassComponent(request, task, keyPath, instance, Component, props);\n            task.componentStack = previousComponentStack;\n        }\n        var didWarnAboutBadClass = {};\n        var didWarnAboutModulePatternComponent = {};\n        var didWarnAboutContextTypeOnFunctionComponent = {};\n        var didWarnAboutGetDerivedStateOnFunctionComponent = {};\n        var didWarnAboutReassigningProps = false;\n        var didWarnAboutDefaultPropsOnFunctionComponent = {};\n        var didWarnAboutGenerators = false;\n        var didWarnAboutMaps = false;\n        var hasWarnedAboutUsingContextAsConsumer = false; // This would typically be a function component but we still support module pattern\n        // components for some reason.\n        function renderIndeterminateComponent(request, task, keyPath, prevThenableState, Component, props) {\n            var legacyContext;\n            {\n                legacyContext = getMaskedContext(Component, task.legacyContext);\n            }\n            var previousComponentStack = task.componentStack;\n            task.componentStack = createFunctionComponentStack(task, Component);\n            {\n                if (Component.prototype && typeof Component.prototype.render === \"function\") {\n                    var componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutBadClass[componentName]) {\n                        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + \"This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName);\n                        didWarnAboutBadClass[componentName] = true;\n                    }\n                }\n            }\n            var value = renderWithHooks(request, task, keyPath, prevThenableState, Component, props, legacyContext);\n            var hasId = checkDidRenderIdHook();\n            var formStateCount = getFormStateCount();\n            var formStateMatchingIndex = getFormStateMatchingIndex();\n            {\n                // Support for module components is deprecated and is removed behind a flag.\n                // Whether or not it would crash later, we want to show a good message in DEV first.\n                if (typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                    var _componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName, _componentName, _componentName);\n                        didWarnAboutModulePatternComponent[_componentName] = true;\n                    }\n                }\n            }\n            if (// Eventually we'll delete this branch altogether.\n            typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                {\n                    var _componentName2 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName2]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName2, _componentName2, _componentName2);\n                        didWarnAboutModulePatternComponent[_componentName2] = true;\n                    }\n                }\n                mountClassInstance(value, Component, props, legacyContext);\n                finishClassComponent(request, task, keyPath, value, Component, props);\n            } else {\n                {\n                    validateFunctionComponentInDev(Component);\n                }\n                finishFunctionComponent(request, task, keyPath, value, hasId, formStateCount, formStateMatchingIndex);\n            }\n            task.componentStack = previousComponentStack;\n        }\n        function finishFunctionComponent(request, task, keyPath, children, hasId, formStateCount, formStateMatchingIndex) {\n            var didEmitFormStateMarkers = false;\n            if (formStateCount !== 0 && request.formState !== null) {\n                // For each useFormState hook, emit a marker that indicates whether we\n                // rendered using the form state passed at the root. We only emit these\n                // markers if form state is passed at the root.\n                var segment = task.blockedSegment;\n                if (segment === null) ;\n                else {\n                    didEmitFormStateMarkers = true;\n                    var target = segment.chunks;\n                    for(var i = 0; i < formStateCount; i++){\n                        if (i === formStateMatchingIndex) {\n                            pushFormStateMarkerIsMatching(target);\n                        } else {\n                            pushFormStateMarkerIsNotMatching(target);\n                        }\n                    }\n                }\n            }\n            var prevKeyPath = task.keyPath;\n            task.keyPath = keyPath;\n            if (hasId) {\n                // This component materialized an id. We treat this as its own level, with\n                // a single \"child\" slot.\n                var prevTreeContext = task.treeContext;\n                var totalChildren = 1;\n                var index = 0; // Modify the id context. Because we'll need to reset this if something\n                // suspends or errors, we'll use the non-destructive render path.\n                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);\n                renderNode(request, task, children, -1); // Like the other contexts, this does not need to be in a finally block\n                // because renderNode takes care of unwinding the stack.\n                task.treeContext = prevTreeContext;\n            } else if (didEmitFormStateMarkers) {\n                // If there were formState hooks, we must use the non-destructive path\n                // because this component is not a pure indirection; we emitted markers\n                // to the stream.\n                renderNode(request, task, children, -1);\n            } else {\n                // We're now successfully past this task, and we haven't modified the\n                // context stack. We don't have to pop back to the previous task every\n                // again, so we can use the destructive recursive form.\n                renderNodeDestructive(request, task, null, children, -1);\n            }\n            task.keyPath = prevKeyPath;\n        }\n        function validateFunctionComponentInDev(Component) {\n            {\n                if (Component) {\n                    if (Component.childContextTypes) {\n                        error(\"%s(...): childContextTypes cannot be defined on a function component.\", Component.displayName || Component.name || \"Component\");\n                    }\n                }\n                if (Component.defaultProps !== undefined) {\n                    var componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n                        error(\"%s: Support for defaultProps will be removed from function components \" + \"in a future major release. Use JavaScript default parameters instead.\", componentName);\n                        didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n                    }\n                }\n                if (typeof Component.getDerivedStateFromProps === \"function\") {\n                    var _componentName3 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\n                        error(\"%s: Function components do not support getDerivedStateFromProps.\", _componentName3);\n                        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\n                    }\n                }\n                if (typeof Component.contextType === \"object\" && Component.contextType !== null) {\n                    var _componentName4 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\n                        error(\"%s: Function components do not support contextType.\", _componentName4);\n                        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\n                    }\n                }\n            }\n        }\n        function resolveDefaultProps(Component, baseProps) {\n            if (Component && Component.defaultProps) {\n                // Resolve default props. Taken from ReactElement\n                var props = assign({}, baseProps);\n                var defaultProps = Component.defaultProps;\n                for(var propName in defaultProps){\n                    if (props[propName] === undefined) {\n                        props[propName] = defaultProps[propName];\n                    }\n                }\n                return props;\n            }\n            return baseProps;\n        }\n        function renderForwardRef(request, task, keyPath, prevThenableState, type, props, ref) {\n            var previousComponentStack = task.componentStack;\n            task.componentStack = createFunctionComponentStack(task, type.render);\n            var children = renderWithHooks(request, task, keyPath, prevThenableState, type.render, props, ref);\n            var hasId = checkDidRenderIdHook();\n            var formStateCount = getFormStateCount();\n            var formStateMatchingIndex = getFormStateMatchingIndex();\n            finishFunctionComponent(request, task, keyPath, children, hasId, formStateCount, formStateMatchingIndex);\n            task.componentStack = previousComponentStack;\n        }\n        function renderMemo(request, task, keyPath, prevThenableState, type, props, ref) {\n            var innerType = type.type;\n            var resolvedProps = resolveDefaultProps(innerType, props);\n            renderElement(request, task, keyPath, prevThenableState, innerType, resolvedProps, ref);\n        }\n        function renderContextConsumer(request, task, keyPath, context, props) {\n            // The logic below for Context differs depending on PROD or DEV mode. In\n            // DEV mode, we create a separate object for Context.Consumer that acts\n            // like a proxy to Context. This proxy object adds unnecessary code in PROD\n            // so we use the old behaviour (Context.Consumer references Context) to\n            // reduce size and overhead. The separate object references context via\n            // a property called \"_context\", which also gives us the ability to check\n            // in DEV mode if this property exists or not and warn if it does not.\n            {\n                if (context._context === undefined) {\n                    // This may be because it's a Context (rather than a Consumer).\n                    // Or it may be because it's older React where they're the same thing.\n                    // We only want to warn if we're sure it's a new React.\n                    if (context !== context.Consumer) {\n                        if (!hasWarnedAboutUsingContextAsConsumer) {\n                            hasWarnedAboutUsingContextAsConsumer = true;\n                            error(\"Rendering <Context> directly is not supported and will be removed in \" + \"a future major release. Did you mean to render <Context.Consumer> instead?\");\n                        }\n                    }\n                } else {\n                    context = context._context;\n                }\n            }\n            var render = props.children;\n            {\n                if (typeof render !== \"function\") {\n                    error(\"A context consumer was rendered with multiple children, or a child \" + \"that isn't a function. A context consumer expects a single child \" + \"that is a function. If you did pass a function, make sure there \" + \"is no trailing or leading whitespace around it.\");\n                }\n            }\n            var newValue = readContext$1(context);\n            var newChildren = render(newValue);\n            var prevKeyPath = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, null, newChildren, -1);\n            task.keyPath = prevKeyPath;\n        }\n        function renderContextProvider(request, task, keyPath, type, props) {\n            var context = type._context;\n            var value = props.value;\n            var children = props.children;\n            var prevSnapshot;\n            {\n                prevSnapshot = task.context;\n            }\n            var prevKeyPath = task.keyPath;\n            task.context = pushProvider(context, value);\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, null, children, -1);\n            task.context = popProvider(context);\n            task.keyPath = prevKeyPath;\n            {\n                if (prevSnapshot !== task.context) {\n                    error(\"Popping the context provider did not return back to the original snapshot. This is a bug in React.\");\n                }\n            }\n        }\n        function renderLazyComponent(request, task, keyPath, prevThenableState, lazyComponent, props, ref) {\n            var previousComponentStack = task.componentStack;\n            task.componentStack = createBuiltInComponentStack(task, \"Lazy\");\n            var payload = lazyComponent._payload;\n            var init = lazyComponent._init;\n            var Component = init(payload);\n            var resolvedProps = resolveDefaultProps(Component, props);\n            renderElement(request, task, keyPath, prevThenableState, Component, resolvedProps, ref);\n            task.componentStack = previousComponentStack;\n        }\n        function renderOffscreen(request, task, keyPath, props) {\n            var mode = props.mode;\n            if (mode === \"hidden\") ;\n            else {\n                // A visible Offscreen boundary is treated exactly like a fragment: a\n                // pure indirection.\n                var prevKeyPath = task.keyPath;\n                task.keyPath = keyPath;\n                renderNodeDestructive(request, task, null, props.children, -1);\n                task.keyPath = prevKeyPath;\n            }\n        }\n        function renderElement(request, task, keyPath, prevThenableState, type, props, ref) {\n            if (typeof type === \"function\") {\n                if (shouldConstruct(type)) {\n                    renderClassComponent(request, task, keyPath, type, props);\n                    return;\n                } else {\n                    renderIndeterminateComponent(request, task, keyPath, prevThenableState, type, props);\n                    return;\n                }\n            }\n            if (typeof type === \"string\") {\n                renderHostElement(request, task, keyPath, type, props);\n                return;\n            }\n            switch(type){\n                // LegacyHidden acts the same as a fragment. This only works because we\n                // currently assume that every instance of LegacyHidden is accompanied by a\n                // host component wrapper. In the hidden mode, the host component is given a\n                // `hidden` attribute, which ensures that the initial HTML is not visible.\n                // To support the use of LegacyHidden as a true fragment, without an extra\n                // DOM node, we would have to hide the initial HTML in some other way.\n                // TODO: Delete in LegacyHidden. It's an unstable API only used in the\n                // www build. As a migration step, we could add a special prop to Offscreen\n                // that simulates the old behavior (no hiding, no change to effects).\n                case REACT_LEGACY_HIDDEN_TYPE:\n                case REACT_DEBUG_TRACING_MODE_TYPE:\n                case REACT_STRICT_MODE_TYPE:\n                case REACT_PROFILER_TYPE:\n                case REACT_FRAGMENT_TYPE:\n                    {\n                        var prevKeyPath = task.keyPath;\n                        task.keyPath = keyPath;\n                        renderNodeDestructive(request, task, null, props.children, -1);\n                        task.keyPath = prevKeyPath;\n                        return;\n                    }\n                case REACT_OFFSCREEN_TYPE:\n                    {\n                        renderOffscreen(request, task, keyPath, props);\n                        return;\n                    }\n                case REACT_SUSPENSE_LIST_TYPE:\n                    {\n                        var preiousComponentStack = task.componentStack;\n                        task.componentStack = createBuiltInComponentStack(task, \"SuspenseList\"); // TODO: SuspenseList should control the boundaries.\n                        var _prevKeyPath3 = task.keyPath;\n                        task.keyPath = keyPath;\n                        renderNodeDestructive(request, task, null, props.children, -1);\n                        task.keyPath = _prevKeyPath3;\n                        task.componentStack = preiousComponentStack;\n                        return;\n                    }\n                case REACT_SCOPE_TYPE:\n                    {\n                        throw new Error(\"ReactDOMServer does not yet support scope components.\");\n                    }\n                case REACT_SUSPENSE_TYPE:\n                    {\n                        {\n                            renderSuspenseBoundary(request, task, keyPath, props);\n                        }\n                        return;\n                    }\n            }\n            if (typeof type === \"object\" && type !== null) {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        {\n                            renderForwardRef(request, task, keyPath, prevThenableState, type, props, ref);\n                            return;\n                        }\n                    case REACT_MEMO_TYPE:\n                        {\n                            renderMemo(request, task, keyPath, prevThenableState, type, props, ref);\n                            return;\n                        }\n                    case REACT_PROVIDER_TYPE:\n                        {\n                            renderContextProvider(request, task, keyPath, type, props);\n                            return;\n                        }\n                    case REACT_CONTEXT_TYPE:\n                        {\n                            renderContextConsumer(request, task, keyPath, type, props);\n                            return;\n                        }\n                    case REACT_LAZY_TYPE:\n                        {\n                            renderLazyComponent(request, task, keyPath, prevThenableState, type, props);\n                            return;\n                        }\n                }\n            }\n            var info = \"\";\n            {\n                if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                    info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and \" + \"named imports.\";\n                }\n            }\n            throw new Error(\"Element type is invalid: expected a string (for built-in \" + \"components) or a class/function (for composite components) \" + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n        }\n        function resumeNode(request, task, segmentId, node, childIndex) {\n            var prevReplay = task.replay;\n            var blockedBoundary = task.blockedBoundary;\n            var resumedSegment = createPendingSegment(request, 0, null, task.formatContext, false, false);\n            resumedSegment.id = segmentId;\n            resumedSegment.parentFlushed = true;\n            try {\n                // Convert the current ReplayTask to a RenderTask.\n                var renderTask = task;\n                renderTask.replay = null;\n                renderTask.blockedSegment = resumedSegment;\n                renderNode(request, task, node, childIndex);\n                resumedSegment.status = COMPLETED;\n                if (blockedBoundary === null) {\n                    request.completedRootSegment = resumedSegment;\n                } else {\n                    queueCompletedSegment(blockedBoundary, resumedSegment);\n                    if (blockedBoundary.parentFlushed) {\n                        request.partialBoundaries.push(blockedBoundary);\n                    }\n                }\n            } finally{\n                // Restore to a ReplayTask.\n                task.replay = prevReplay;\n                task.blockedSegment = null;\n            }\n        }\n        function replayElement(request, task, keyPath, prevThenableState, name, keyOrIndex, childIndex, type, props, ref, replay) {\n            // We're replaying. Find the path to follow.\n            var replayNodes = replay.nodes;\n            for(var i = 0; i < replayNodes.length; i++){\n                // Flow doesn't support refinement on tuples so we do it manually here.\n                var node = replayNodes[i];\n                if (keyOrIndex !== node[1]) {\n                    continue;\n                }\n                if (node.length === 4) {\n                    // Matched a replayable path.\n                    // Let's double check that the component name matches as a precaution.\n                    if (name !== null && name !== node[0]) {\n                        throw new Error(\"Expected the resume to render <\" + node[0] + \"> in this slot but instead it rendered <\" + name + \">. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                    }\n                    var childNodes = node[2];\n                    var childSlots = node[3];\n                    var currentNode = task.node;\n                    task.replay = {\n                        nodes: childNodes,\n                        slots: childSlots,\n                        pendingTasks: 1\n                    };\n                    try {\n                        renderElement(request, task, keyPath, prevThenableState, type, props, ref);\n                        if (task.replay.pendingTasks === 1 && task.replay.nodes.length > 0 // TODO check remaining slots\n                        ) {\n                            throw new Error(\"Couldn't find all resumable slots by key/index during replaying. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                        }\n                        task.replay.pendingTasks--;\n                    } catch (x) {\n                        if (typeof x === \"object\" && x !== null && (x === SuspenseException || typeof x.then === \"function\")) {\n                            // Suspend\n                            if (task.node === currentNode) {\n                                // This same element suspended so we need to pop the replay we just added.\n                                task.replay = replay;\n                            }\n                            throw x;\n                        }\n                        task.replay.pendingTasks--; // Unlike regular render, we don't terminate the siblings if we error\n                        // during a replay. That's because this component didn't actually error\n                        // in the original prerender. What's unable to complete is the child\n                        // replay nodes which might be Suspense boundaries which are able to\n                        // absorb the error and we can still continue with siblings.\n                        var thrownInfo = getThrownInfo(request, task.componentStack);\n                        erroredReplay(request, task.blockedBoundary, x, thrownInfo, childNodes, childSlots);\n                    }\n                    task.replay = replay;\n                } else {\n                    // Let's double check that the component type matches.\n                    if (type !== REACT_SUSPENSE_TYPE) {\n                        var expectedType = \"Suspense\";\n                        throw new Error(\"Expected the resume to render <\" + expectedType + \"> in this slot but instead it rendered <\" + (getComponentNameFromType(type) || \"Unknown\") + \">. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                    } // Matched a replayable path.\n                    replaySuspenseBoundary(request, task, keyPath, props, node[5], node[2], node[3], node[4] === null ? [] : node[4][2], node[4] === null ? null : node[4][3]);\n                } // We finished rendering this node, so now we can consume this\n                // slot. This must happen after in case we rerender this task.\n                replayNodes.splice(i, 1);\n                return;\n            } // We didn't find any matching nodes. We assume that this element was already\n        // rendered in the prelude and skip it.\n        } // $FlowFixMe[missing-local-annot]\n        function validateIterable(iterable, iteratorFn) {\n            {\n                // We don't support rendering Generators because it's a mutation.\n                // See https://github.com/facebook/react/issues/12995\n                if (typeof Symbol === \"function\" && iterable[Symbol.toStringTag] === \"Generator\") {\n                    if (!didWarnAboutGenerators) {\n                        error(\"Using Generators as children is unsupported and will likely yield \" + \"unexpected results because enumerating a generator mutates it. \" + \"You may convert it to an array with `Array.from()` or the \" + \"`[...spread]` operator before rendering. Keep in mind \" + \"you might need to polyfill these features for older browsers.\");\n                    }\n                    didWarnAboutGenerators = true;\n                } // Warn about using Maps as children\n                if (iterable.entries === iteratorFn) {\n                    if (!didWarnAboutMaps) {\n                        error(\"Using Maps as children is not supported. \" + \"Use an array of keyed ReactElements instead.\");\n                    }\n                    didWarnAboutMaps = true;\n                }\n            }\n        } // This function by it self renders a node and consumes the task by mutating it\n        // to update the current execution state.\n        function renderNodeDestructive(request, task, // always null, except when called by retryTask.\n        prevThenableState, node, childIndex) {\n            if (task.replay !== null && typeof task.replay.slots === \"number\") {\n                // TODO: Figure out a cheaper place than this hot path to do this check.\n                var resumeSegmentID = task.replay.slots;\n                resumeNode(request, task, resumeSegmentID, node, childIndex);\n                return;\n            } // Stash the node we're working on. We'll pick up from this task in case\n            // something suspends.\n            task.node = node;\n            task.childIndex = childIndex; // Handle object types\n            if (typeof node === \"object\" && node !== null) {\n                switch(node.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        {\n                            var element = node;\n                            var type = element.type;\n                            var key = element.key;\n                            var props = element.props;\n                            var ref = element.ref;\n                            var name = getComponentNameFromType(type);\n                            var keyOrIndex = key == null ? childIndex === -1 ? 0 : childIndex : key;\n                            var keyPath = [\n                                task.keyPath,\n                                name,\n                                keyOrIndex\n                            ];\n                            if (task.replay !== null) {\n                                replayElement(request, task, keyPath, prevThenableState, name, keyOrIndex, childIndex, type, props, ref, task.replay); // No matches found for this node. We assume it's already emitted in the\n                            // prelude and skip it during the replay.\n                            } else {\n                                // We're doing a plain render.\n                                renderElement(request, task, keyPath, prevThenableState, type, props, ref);\n                            }\n                            return;\n                        }\n                    case REACT_PORTAL_TYPE:\n                        throw new Error(\"Portals are not currently supported by the server renderer. \" + \"Render them conditionally so that they only appear on the client render.\");\n                    case REACT_LAZY_TYPE:\n                        {\n                            var previousComponentStack = task.componentStack;\n                            task.componentStack = createBuiltInComponentStack(task, \"Lazy\");\n                            var lazyNode = node;\n                            var payload = lazyNode._payload;\n                            var init = lazyNode._init;\n                            var resolvedNode = init(payload); // We restore the stack before rendering the resolved node because once the Lazy\n                            // has resolved any future errors\n                            task.componentStack = previousComponentStack; // Now we render the resolved node\n                            renderNodeDestructive(request, task, null, resolvedNode, childIndex);\n                            return;\n                        }\n                }\n                if (isArray(node)) {\n                    renderChildrenArray(request, task, node, childIndex);\n                    return;\n                }\n                var iteratorFn = getIteratorFn(node);\n                if (iteratorFn) {\n                    {\n                        validateIterable(node, iteratorFn);\n                    }\n                    var iterator = iteratorFn.call(node);\n                    if (iterator) {\n                        // We need to know how many total children are in this set, so that we\n                        // can allocate enough id slots to acommodate them. So we must exhaust\n                        // the iterator before we start recursively rendering the children.\n                        // TODO: This is not great but I think it's inherent to the id\n                        // generation algorithm.\n                        var step = iterator.next(); // If there are not entries, we need to push an empty so we start by checking that.\n                        if (!step.done) {\n                            var children = [];\n                            do {\n                                children.push(step.value);\n                                step = iterator.next();\n                            }while (!step.done);\n                            renderChildrenArray(request, task, children, childIndex);\n                            return;\n                        }\n                        return;\n                    }\n                } // Usables are a valid React node type. When React encounters a Usable in\n                // a child position, it unwraps it using the same algorithm as `use`. For\n                // example, for promises, React will throw an exception to unwind the\n                // stack, then replay the component once the promise resolves.\n                //\n                // A difference from `use` is that React will keep unwrapping the value\n                // until it reaches a non-Usable type.\n                //\n                // e.g. Usable<Usable<Usable<T>>> should resolve to T\n                var maybeUsable = node;\n                if (typeof maybeUsable.then === \"function\") {\n                    var thenable = maybeUsable;\n                    return renderNodeDestructive(request, task, null, unwrapThenable(thenable), childIndex);\n                }\n                if (maybeUsable.$$typeof === REACT_CONTEXT_TYPE || maybeUsable.$$typeof === REACT_SERVER_CONTEXT_TYPE) {\n                    var context = maybeUsable;\n                    return renderNodeDestructive(request, task, null, readContext$1(context), childIndex);\n                } // $FlowFixMe[method-unbinding]\n                var childString = Object.prototype.toString.call(node);\n                throw new Error(\"Objects are not valid as a React child (found: \" + (childString === \"[object Object]\" ? \"object with keys {\" + Object.keys(node).join(\", \") + \"}\" : childString) + \"). \" + \"If you meant to render a collection of children, use an array \" + \"instead.\");\n            }\n            if (typeof node === \"string\") {\n                var segment = task.blockedSegment;\n                if (segment === null) ;\n                else {\n                    segment.lastPushedText = pushTextInstance(segment.chunks, node, request.renderState, segment.lastPushedText);\n                }\n                return;\n            }\n            if (typeof node === \"number\") {\n                var _segment = task.blockedSegment;\n                if (_segment === null) ;\n                else {\n                    _segment.lastPushedText = pushTextInstance(_segment.chunks, \"\" + node, request.renderState, _segment.lastPushedText);\n                }\n                return;\n            }\n            {\n                if (typeof node === \"function\") {\n                    error(\"Functions are not valid as a React child. This may happen if \" + \"you return a Component instead of <Component /> from render. \" + \"Or maybe you meant to call this function rather than return it.\");\n                }\n            }\n        }\n        function replayFragment(request, task, children, childIndex) {\n            // If we're supposed follow this array, we'd expect to see a ReplayNode matching\n            // this fragment.\n            var replay = task.replay;\n            var replayNodes = replay.nodes;\n            for(var j = 0; j < replayNodes.length; j++){\n                var node = replayNodes[j];\n                if (node[1] !== childIndex) {\n                    continue;\n                } // Matched a replayable path.\n                var childNodes = node[2];\n                var childSlots = node[3];\n                task.replay = {\n                    nodes: childNodes,\n                    slots: childSlots,\n                    pendingTasks: 1\n                };\n                try {\n                    renderChildrenArray(request, task, children, -1);\n                    if (task.replay.pendingTasks === 1 && task.replay.nodes.length > 0) {\n                        throw new Error(\"Couldn't find all resumable slots by key/index during replaying. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                    }\n                    task.replay.pendingTasks--;\n                } catch (x) {\n                    if (typeof x === \"object\" && x !== null && (x === SuspenseException || typeof x.then === \"function\")) {\n                        // Suspend\n                        throw x;\n                    }\n                    task.replay.pendingTasks--; // Unlike regular render, we don't terminate the siblings if we error\n                    // during a replay. That's because this component didn't actually error\n                    // in the original prerender. What's unable to complete is the child\n                    // replay nodes which might be Suspense boundaries which are able to\n                    // absorb the error and we can still continue with siblings.\n                    // This is an error, stash the component stack if it is null.\n                    var thrownInfo = getThrownInfo(request, task.componentStack);\n                    erroredReplay(request, task.blockedBoundary, x, thrownInfo, childNodes, childSlots);\n                }\n                task.replay = replay; // We finished rendering this node, so now we can consume this\n                // slot. This must happen after in case we rerender this task.\n                replayNodes.splice(j, 1);\n                break;\n            }\n        }\n        function renderChildrenArray(request, task, children, childIndex) {\n            var prevKeyPath = task.keyPath;\n            if (childIndex !== -1) {\n                task.keyPath = [\n                    task.keyPath,\n                    \"Fragment\",\n                    childIndex\n                ];\n                if (task.replay !== null) {\n                    replayFragment(request, task, children, childIndex);\n                    task.keyPath = prevKeyPath;\n                    return;\n                }\n            }\n            var prevTreeContext = task.treeContext;\n            var totalChildren = children.length;\n            if (task.replay !== null) {\n                // Replay\n                // First we need to check if we have any resume slots at this level.\n                var resumeSlots = task.replay.slots;\n                if (resumeSlots !== null && typeof resumeSlots === \"object\") {\n                    for(var i = 0; i < totalChildren; i++){\n                        var node = children[i];\n                        task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i); // We need to use the non-destructive form so that we can safely pop back\n                        // up and render the sibling if something suspends.\n                        var resumeSegmentID = resumeSlots[i]; // TODO: If this errors we should still continue with the next sibling.\n                        if (typeof resumeSegmentID === \"number\") {\n                            resumeNode(request, task, resumeSegmentID, node, i); // We finished rendering this node, so now we can consume this\n                            // slot. This must happen after in case we rerender this task.\n                            delete resumeSlots[i];\n                        } else {\n                            renderNode(request, task, node, i);\n                        }\n                    }\n                    task.treeContext = prevTreeContext;\n                    task.keyPath = prevKeyPath;\n                    return;\n                }\n            }\n            for(var _i = 0; _i < totalChildren; _i++){\n                var _node = children[_i];\n                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, _i); // We need to use the non-destructive form so that we can safely pop back\n                // up and render the sibling if something suspends.\n                renderNode(request, task, _node, _i);\n            } // Because this context is always set right before rendering every child, we\n            // only need to reset it to the previous value at the very end.\n            task.treeContext = prevTreeContext;\n            task.keyPath = prevKeyPath;\n        }\n        // resume it.\n        function untrackBoundary(request, boundary) {\n            var trackedPostpones = request.trackedPostpones;\n            if (trackedPostpones === null) {\n                return;\n            }\n            var boundaryKeyPath = boundary.trackedContentKeyPath;\n            if (boundaryKeyPath === null) {\n                return;\n            }\n            var boundaryNode = trackedPostpones.workingMap.get(boundaryKeyPath);\n            if (boundaryNode === undefined) {\n                return;\n            } // Downgrade to plain ReplayNode since we won't replay through it.\n            // $FlowFixMe[cannot-write]: We intentionally downgrade this to the other tuple.\n            boundaryNode.length = 4; // Remove any resumable slots.\n            boundaryNode[2] = [];\n            boundaryNode[3] = null; // TODO: We should really just remove the boundary from all parent paths too so\n        // we don't replay the path to it.\n        }\n        function spawnNewSuspendedReplayTask(request, task, thenableState, x) {\n            var newTask = createReplayTask(request, thenableState, task.replay, task.node, task.childIndex, task.blockedBoundary, task.abortSet, task.keyPath, task.formatContext, task.legacyContext, task.context, task.treeContext, // which will add it back onto the stack.\n            task.componentStack !== null ? task.componentStack.parent : null);\n            var ping = newTask.ping;\n            x.then(ping, ping);\n        }\n        function spawnNewSuspendedRenderTask(request, task, thenableState, x) {\n            // Something suspended, we'll need to create a new segment and resolve it later.\n            var segment = task.blockedSegment;\n            var insertionIndex = segment.chunks.length;\n            var newSegment = createPendingSegment(request, insertionIndex, null, task.formatContext, segment.lastPushedText, true);\n            segment.children.push(newSegment); // Reset lastPushedText for current Segment since the new Segment \"consumed\" it\n            segment.lastPushedText = false;\n            var newTask = createRenderTask(request, thenableState, task.node, task.childIndex, task.blockedBoundary, newSegment, task.abortSet, task.keyPath, task.formatContext, task.legacyContext, task.context, task.treeContext, // which will add it back onto the stack.\n            task.componentStack !== null ? task.componentStack.parent : null);\n            var ping = newTask.ping;\n            x.then(ping, ping);\n        } // This is a non-destructive form of rendering a node. If it suspends it spawns\n        // a new task and restores the context of this task to what it was before.\n        function renderNode(request, task, node, childIndex) {\n            // Snapshot the current context in case something throws to interrupt the\n            // process.\n            var previousFormatContext = task.formatContext;\n            var previousLegacyContext = task.legacyContext;\n            var previousContext = task.context;\n            var previousKeyPath = task.keyPath;\n            var previousTreeContext = task.treeContext;\n            var previousComponentStack = task.componentStack;\n            var x; // Store how much we've pushed at this point so we can reset it in case something\n            // suspended partially through writing something.\n            var segment = task.blockedSegment;\n            if (segment === null) {\n                // Replay\n                try {\n                    return renderNodeDestructive(request, task, null, node, childIndex);\n                } catch (thrownValue) {\n                    resetHooksState();\n                    x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                    // value to be a thenable, because before `use` existed that was the\n                    // (unstable) API for suspending. This implementation detail can change\n                    // later, once we deprecate the old API in favor of `use`.\n                    getSuspendedThenable() : thrownValue;\n                    if (typeof x === \"object\" && x !== null) {\n                        // $FlowFixMe[method-unbinding]\n                        if (typeof x.then === \"function\") {\n                            var wakeable = x;\n                            var thenableState = getThenableStateAfterSuspending();\n                            spawnNewSuspendedReplayTask(request, task, thenableState, wakeable); // Restore the context. We assume that this will be restored by the inner\n                            // functions in case nothing throws so we don't use \"finally\" here.\n                            task.formatContext = previousFormatContext;\n                            task.legacyContext = previousLegacyContext;\n                            task.context = previousContext;\n                            task.keyPath = previousKeyPath;\n                            task.treeContext = previousTreeContext;\n                            task.componentStack = previousComponentStack; // Restore all active ReactContexts to what they were before.\n                            switchContext(previousContext);\n                            return;\n                        }\n                    } // TODO: Abort any undiscovered Suspense boundaries in the ReplayNode.\n                }\n            } else {\n                // Render\n                var childrenLength = segment.children.length;\n                var chunkLength = segment.chunks.length;\n                try {\n                    return renderNodeDestructive(request, task, null, node, childIndex);\n                } catch (thrownValue) {\n                    resetHooksState(); // Reset the write pointers to where we started.\n                    segment.children.length = childrenLength;\n                    segment.chunks.length = chunkLength;\n                    x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                    // value to be a thenable, because before `use` existed that was the\n                    // (unstable) API for suspending. This implementation detail can change\n                    // later, once we deprecate the old API in favor of `use`.\n                    getSuspendedThenable() : thrownValue;\n                    if (typeof x === \"object\" && x !== null) {\n                        // $FlowFixMe[method-unbinding]\n                        if (typeof x.then === \"function\") {\n                            var _wakeable = x;\n                            var _thenableState = getThenableStateAfterSuspending();\n                            spawnNewSuspendedRenderTask(request, task, _thenableState, _wakeable); // Restore the context. We assume that this will be restored by the inner\n                            // functions in case nothing throws so we don't use \"finally\" here.\n                            task.formatContext = previousFormatContext;\n                            task.legacyContext = previousLegacyContext;\n                            task.context = previousContext;\n                            task.keyPath = previousKeyPath;\n                            task.treeContext = previousTreeContext;\n                            task.componentStack = previousComponentStack; // Restore all active ReactContexts to what they were before.\n                            switchContext(previousContext);\n                            return;\n                        }\n                    }\n                }\n            } // Restore the context. We assume that this will be restored by the inner\n            // functions in case nothing throws so we don't use \"finally\" here.\n            task.formatContext = previousFormatContext;\n            task.legacyContext = previousLegacyContext;\n            task.context = previousContext;\n            task.keyPath = previousKeyPath;\n            task.treeContext = previousTreeContext; // We intentionally do not restore the component stack on the error pathway\n            // Whatever handles the error needs to use this stack which is the location of the\n            // error. We must restore the stack wherever we handle this\n            // Restore all active ReactContexts to what they were before.\n            switchContext(previousContext);\n            throw x;\n        }\n        function erroredReplay(request, boundary, error, errorInfo, replayNodes, resumeSlots) {\n            // Erroring during a replay doesn't actually cause an error by itself because\n            // that component has already rendered. What causes the error is the resumable\n            // points that we did not yet finish which will be below the point of the reset.\n            // For example, if we're replaying a path to a Suspense boundary that is not done\n            // that doesn't error the parent Suspense boundary.\n            // This might be a bit strange that the error in a parent gets thrown at a child.\n            // We log it only once and reuse the digest.\n            var errorDigest;\n            {\n                errorDigest = logRecoverableError(request, error, errorInfo);\n            }\n            abortRemainingReplayNodes(request, boundary, replayNodes, resumeSlots, error, errorDigest, errorInfo);\n        }\n        function erroredTask(request, boundary, error, errorInfo) {\n            // Report the error to a global handler.\n            var errorDigest;\n            {\n                errorDigest = logRecoverableError(request, error, errorInfo);\n            }\n            if (boundary === null) {\n                fatalError(request, error);\n            } else {\n                boundary.pendingTasks--;\n                if (boundary.status !== CLIENT_RENDERED) {\n                    boundary.status = CLIENT_RENDERED;\n                    encodeErrorForBoundary(boundary, errorDigest, error, errorInfo);\n                    untrackBoundary(request, boundary); // Regardless of what happens next, this boundary won't be displayed,\n                    // so we can flush it, if the parent already flushed.\n                    if (boundary.parentFlushed) {\n                        // We don't have a preference where in the queue this goes since it's likely\n                        // to error on the client anyway. However, intentionally client-rendered\n                        // boundaries should be flushed earlier so that they can start on the client.\n                        // We reuse the same queue for errors.\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                }\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                completeAll(request);\n            }\n        }\n        function abortTaskSoft(task) {\n            // This aborts task without aborting the parent boundary that it blocks.\n            // It's used for when we didn't need this task to complete the tree.\n            // If task was needed, then it should use abortTask instead.\n            var request = this;\n            var boundary = task.blockedBoundary;\n            var segment = task.blockedSegment;\n            if (segment !== null) {\n                segment.status = ABORTED;\n                finishedTask(request, boundary, segment);\n            }\n        }\n        function abortRemainingSuspenseBoundary(request, rootSegmentID, error, errorDigest, errorInfo) {\n            var resumedBoundary = createSuspenseBoundary(request, new Set());\n            resumedBoundary.parentFlushed = true; // We restore the same id of this boundary as was used during prerender.\n            resumedBoundary.rootSegmentID = rootSegmentID;\n            resumedBoundary.status = CLIENT_RENDERED;\n            var errorMessage = error;\n            {\n                var errorPrefix = \"The server did not finish this Suspense boundary: \";\n                if (error && typeof error.message === \"string\") {\n                    errorMessage = errorPrefix + error.message;\n                } else {\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    errorMessage = errorPrefix + String(error);\n                }\n            }\n            encodeErrorForBoundary(resumedBoundary, errorDigest, errorMessage, errorInfo);\n            if (resumedBoundary.parentFlushed) {\n                request.clientRenderedBoundaries.push(resumedBoundary);\n            }\n        }\n        function abortRemainingReplayNodes(request, boundary, nodes, slots, error, errorDigest, errorInfo) {\n            for(var i = 0; i < nodes.length; i++){\n                var node = nodes[i];\n                if (node.length === 4) {\n                    abortRemainingReplayNodes(request, boundary, node[2], node[3], error, errorDigest, errorInfo);\n                } else {\n                    var boundaryNode = node;\n                    var rootSegmentID = boundaryNode[5];\n                    abortRemainingSuspenseBoundary(request, rootSegmentID, error, errorDigest, errorInfo);\n                }\n            } // Empty the set, since we've cleared it now.\n            nodes.length = 0;\n            if (slots !== null) {\n                // We had something still to resume in the parent boundary. We must trigger\n                // the error on the parent boundary since it's not able to complete.\n                if (boundary === null) {\n                    throw new Error(\"We should not have any resumable nodes in the shell. \" + \"This is a bug in React.\");\n                } else if (boundary.status !== CLIENT_RENDERED) {\n                    boundary.status = CLIENT_RENDERED;\n                    encodeErrorForBoundary(boundary, errorDigest, error, errorInfo);\n                    if (boundary.parentFlushed) {\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                } // Empty the set\n                if (typeof slots === \"object\") {\n                    for(var index in slots){\n                        delete slots[index];\n                    }\n                }\n            }\n        }\n        function abortTask(task, request, error) {\n            // This aborts the task and aborts the parent that it blocks, putting it into\n            // client rendered mode.\n            var boundary = task.blockedBoundary;\n            var segment = task.blockedSegment;\n            if (segment !== null) {\n                segment.status = ABORTED;\n            }\n            if (boundary === null) {\n                var errorInfo = {};\n                if (request.status !== CLOSING && request.status !== CLOSED) {\n                    var replay = task.replay;\n                    if (replay === null) {\n                        // We didn't complete the root so we have nothing to show. We can close\n                        // the request;\n                        logRecoverableError(request, error, errorInfo);\n                        fatalError(request, error);\n                        return;\n                    } else {\n                        // If the shell aborts during a replay, that's not a fatal error. Instead\n                        // we should be able to recover by client rendering all the root boundaries in\n                        // the ReplaySet.\n                        replay.pendingTasks--;\n                        if (replay.pendingTasks === 0 && replay.nodes.length > 0) {\n                            var errorDigest = logRecoverableError(request, error, errorInfo);\n                            abortRemainingReplayNodes(request, null, replay.nodes, replay.slots, error, errorDigest, errorInfo);\n                        }\n                        request.pendingRootTasks--;\n                        if (request.pendingRootTasks === 0) {\n                            completeShell(request);\n                        }\n                    }\n                }\n            } else {\n                boundary.pendingTasks--;\n                if (boundary.status !== CLIENT_RENDERED) {\n                    boundary.status = CLIENT_RENDERED; // We construct an errorInfo from the boundary's componentStack so the error in dev will indicate which\n                    // boundary the message is referring to\n                    var _errorInfo = getThrownInfo(request, task.componentStack);\n                    var _errorDigest = logRecoverableError(request, error, _errorInfo);\n                    var errorMessage = error;\n                    {\n                        var errorPrefix = \"The server did not finish this Suspense boundary: \";\n                        if (error && typeof error.message === \"string\") {\n                            errorMessage = errorPrefix + error.message;\n                        } else {\n                            // eslint-disable-next-line react-internal/safe-string-coercion\n                            errorMessage = errorPrefix + String(error);\n                        }\n                    }\n                    encodeErrorForBoundary(boundary, _errorDigest, errorMessage, _errorInfo);\n                    untrackBoundary(request, boundary);\n                    if (boundary.parentFlushed) {\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                } // If this boundary was still pending then we haven't already cancelled its fallbacks.\n                // We'll need to abort the fallbacks, which will also error that parent boundary.\n                boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {\n                    return abortTask(fallbackTask, request, error);\n                });\n                boundary.fallbackAbortableTasks.clear();\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                completeAll(request);\n            }\n        }\n        function safelyEmitEarlyPreloads(request, shellComplete) {\n            try {\n                emitEarlyPreloads(request.renderState, request.resumableState, shellComplete);\n            } catch (error) {\n                // We assume preloads are optimistic and thus non-fatal if errored.\n                var errorInfo = {};\n                logRecoverableError(request, error, errorInfo);\n            }\n        } // I extracted this function out because we want to ensure we consistently emit preloads before\n        // transitioning to the next request stage and this transition can happen in multiple places in this\n        // implementation.\n        function completeShell(request) {\n            if (request.trackedPostpones === null) {\n                // We only emit early preloads on shell completion for renders. For prerenders\n                // we wait for the entire Request to finish because we are not responding to a\n                // live request and can wait for as much data as possible.\n                // we should only be calling completeShell when the shell is complete so we\n                // just use a literal here\n                var shellComplete = true;\n                safelyEmitEarlyPreloads(request, shellComplete);\n            } // We have completed the shell so the shell can't error anymore.\n            request.onShellError = noop;\n            var onShellReady = request.onShellReady;\n            onShellReady();\n        } // I extracted this function out because we want to ensure we consistently emit preloads before\n        // transitioning to the next request stage and this transition can happen in multiple places in this\n        // implementation.\n        function completeAll(request) {\n            // During a render the shell must be complete if the entire request is finished\n            // however during a Prerender it is possible that the shell is incomplete because\n            // it postponed. We cannot use rootPendingTasks in the prerender case because\n            // those hit zero even when the shell postpones. Instead we look at the completedRootSegment\n            var shellComplete = request.trackedPostpones === null ? true : request.completedRootSegment === null || request.completedRootSegment.status !== POSTPONED;\n            safelyEmitEarlyPreloads(request, shellComplete);\n            var onAllReady = request.onAllReady;\n            onAllReady();\n        }\n        function queueCompletedSegment(boundary, segment) {\n            if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null && segment.children[0].id === -1) {\n                // This is an empty segment. There's nothing to write, so we can instead transfer the ID\n                // to the child. That way any existing references point to the child.\n                var childSegment = segment.children[0];\n                childSegment.id = segment.id;\n                childSegment.parentFlushed = true;\n                if (childSegment.status === COMPLETED) {\n                    queueCompletedSegment(boundary, childSegment);\n                }\n            } else {\n                var completedSegments = boundary.completedSegments;\n                completedSegments.push(segment);\n            }\n        }\n        function finishedTask(request, boundary, segment) {\n            if (boundary === null) {\n                if (segment !== null && segment.parentFlushed) {\n                    if (request.completedRootSegment !== null) {\n                        throw new Error(\"There can only be one root segment. This is a bug in React.\");\n                    }\n                    request.completedRootSegment = segment;\n                }\n                request.pendingRootTasks--;\n                if (request.pendingRootTasks === 0) {\n                    completeShell(request);\n                }\n            } else {\n                boundary.pendingTasks--;\n                if (boundary.status === CLIENT_RENDERED) ;\n                else if (boundary.pendingTasks === 0) {\n                    if (boundary.status === PENDING) {\n                        boundary.status = COMPLETED;\n                    } // This must have been the last segment we were waiting on. This boundary is now complete.\n                    if (segment !== null && segment.parentFlushed) {\n                        // Our parent segment already flushed, so we need to schedule this segment to be emitted.\n                        // If it is a segment that was aborted, we'll write other content instead so we don't need\n                        // to emit it.\n                        if (segment.status === COMPLETED) {\n                            queueCompletedSegment(boundary, segment);\n                        }\n                    }\n                    if (boundary.parentFlushed) {\n                        // The segment might be part of a segment that didn't flush yet, but if the boundary's\n                        // parent flushed, we need to schedule the boundary to be emitted.\n                        request.completedBoundaries.push(boundary);\n                    } // We can now cancel any pending task on the fallback since we won't need to show it anymore.\n                    // This needs to happen after we read the parentFlushed flags because aborting can finish\n                    // work which can trigger user code, which can start flushing, which can change those flags.\n                    // If the boundary was POSTPONED, we still need to finish the fallback first.\n                    if (boundary.status === COMPLETED) {\n                        boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);\n                        boundary.fallbackAbortableTasks.clear();\n                    }\n                } else {\n                    if (segment !== null && segment.parentFlushed) {\n                        // Our parent already flushed, so we need to schedule this segment to be emitted.\n                        // If it is a segment that was aborted, we'll write other content instead so we don't need\n                        // to emit it.\n                        if (segment.status === COMPLETED) {\n                            queueCompletedSegment(boundary, segment);\n                            var completedSegments = boundary.completedSegments;\n                            if (completedSegments.length === 1) {\n                                // This is the first time since we last flushed that we completed anything.\n                                // We can schedule this boundary to emit its partially completed segments early\n                                // in case the parent has already been flushed.\n                                if (boundary.parentFlushed) {\n                                    request.partialBoundaries.push(boundary);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                completeAll(request);\n            }\n        }\n        function retryTask(request, task) {\n            {\n                var blockedBoundary = task.blockedBoundary;\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, blockedBoundary ? blockedBoundary.resources : null);\n            }\n            var segment = task.blockedSegment;\n            if (segment === null) {\n                retryReplayTask(request, task);\n            } else {\n                retryRenderTask(request, task, segment);\n            }\n        }\n        function retryRenderTask(request, task, segment) {\n            if (segment.status !== PENDING) {\n                // We completed this by other means before we had a chance to retry it.\n                return;\n            } // We restore the context to what it was when we suspended.\n            // We don't restore it after we leave because it's likely that we'll end up\n            // needing a very similar context soon again.\n            switchContext(task.context);\n            var prevTaskInDEV = null;\n            {\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = task;\n            }\n            var childrenLength = segment.children.length;\n            var chunkLength = segment.chunks.length;\n            try {\n                // We call the destructive form that mutates this task. That way if something\n                // suspends again, we can reuse the same task instead of spawning a new one.\n                // Reset the task's thenable state before continuing, so that if a later\n                // component suspends we can reuse the same task object. If the same\n                // component suspends again, the thenable state will be restored.\n                var prevThenableState = task.thenableState;\n                task.thenableState = null;\n                renderNodeDestructive(request, task, prevThenableState, task.node, task.childIndex);\n                pushSegmentFinale(segment.chunks, request.renderState, segment.lastPushedText, segment.textEmbedded);\n                task.abortSet.delete(task);\n                segment.status = COMPLETED;\n                finishedTask(request, task.blockedBoundary, segment);\n            } catch (thrownValue) {\n                resetHooksState(); // Reset the write pointers to where we started.\n                segment.children.length = childrenLength;\n                segment.chunks.length = chunkLength;\n                var x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                // value to be a thenable, because before `use` existed that was the\n                // (unstable) API for suspending. This implementation detail can change\n                // later, once we deprecate the old API in favor of `use`.\n                getSuspendedThenable() : thrownValue;\n                if (typeof x === \"object\" && x !== null) {\n                    // $FlowFixMe[method-unbinding]\n                    if (typeof x.then === \"function\") {\n                        // Something suspended again, let's pick it back up later.\n                        var ping = task.ping;\n                        x.then(ping, ping);\n                        task.thenableState = getThenableStateAfterSuspending();\n                        return;\n                    }\n                }\n                var errorInfo = getThrownInfo(request, task.componentStack);\n                task.abortSet.delete(task);\n                segment.status = ERRORED;\n                erroredTask(request, task.blockedBoundary, x, errorInfo);\n                return;\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, null);\n                }\n                {\n                    currentTaskInDEV = prevTaskInDEV;\n                }\n            }\n        }\n        function retryReplayTask(request, task) {\n            if (task.replay.pendingTasks === 0) {\n                // There are no pending tasks working on this set, so we must have aborted.\n                return;\n            } // We restore the context to what it was when we suspended.\n            // We don't restore it after we leave because it's likely that we'll end up\n            // needing a very similar context soon again.\n            switchContext(task.context);\n            var prevTaskInDEV = null;\n            {\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = task;\n            }\n            try {\n                // We call the destructive form that mutates this task. That way if something\n                // suspends again, we can reuse the same task instead of spawning a new one.\n                // Reset the task's thenable state before continuing, so that if a later\n                // component suspends we can reuse the same task object. If the same\n                // component suspends again, the thenable state will be restored.\n                var prevThenableState = task.thenableState;\n                task.thenableState = null;\n                renderNodeDestructive(request, task, prevThenableState, task.node, task.childIndex);\n                if (task.replay.pendingTasks === 1 && task.replay.nodes.length > 0) {\n                    throw new Error(\"Couldn't find all resumable slots by key/index during replaying. \" + \"The tree doesn't match so React will fallback to client rendering.\");\n                }\n                task.replay.pendingTasks--;\n                task.abortSet.delete(task);\n                finishedTask(request, task.blockedBoundary, null);\n            } catch (thrownValue) {\n                resetHooksState();\n                var x = thrownValue === SuspenseException ? // reasons, the rest of the Suspense implementation expects the thrown\n                // value to be a thenable, because before `use` existed that was the\n                // (unstable) API for suspending. This implementation detail can change\n                // later, once we deprecate the old API in favor of `use`.\n                getSuspendedThenable() : thrownValue;\n                if (typeof x === \"object\" && x !== null) {\n                    // $FlowFixMe[method-unbinding]\n                    if (typeof x.then === \"function\") {\n                        // Something suspended again, let's pick it back up later.\n                        var ping = task.ping;\n                        x.then(ping, ping);\n                        task.thenableState = getThenableStateAfterSuspending();\n                        return;\n                    }\n                }\n                task.replay.pendingTasks--;\n                task.abortSet.delete(task);\n                var errorInfo = getThrownInfo(request, task.componentStack);\n                erroredReplay(request, task.blockedBoundary, x, errorInfo, task.replay.nodes, task.replay.slots);\n                request.pendingRootTasks--;\n                if (request.pendingRootTasks === 0) {\n                    completeShell(request);\n                }\n                request.allPendingTasks--;\n                if (request.allPendingTasks === 0) {\n                    completeAll(request);\n                }\n                return;\n            } finally{\n                {\n                    setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, null);\n                }\n                {\n                    currentTaskInDEV = prevTaskInDEV;\n                }\n            }\n        }\n        function performWork(request) {\n            if (request.status === CLOSED) {\n                return;\n            }\n            var prevContext = getActiveContext();\n            var prevDispatcher = ReactCurrentDispatcher.current;\n            ReactCurrentDispatcher.current = HooksDispatcher;\n            var prevCacheDispatcher;\n            {\n                prevCacheDispatcher = ReactCurrentCache.current;\n                ReactCurrentCache.current = DefaultCacheDispatcher;\n            }\n            var prevRequest = currentRequest;\n            currentRequest = request;\n            var prevGetCurrentStackImpl;\n            {\n                prevGetCurrentStackImpl = ReactDebugCurrentFrame.getCurrentStack;\n                ReactDebugCurrentFrame.getCurrentStack = getCurrentStackInDEV;\n            }\n            var prevResumableState = currentResumableState;\n            setCurrentResumableState(request.resumableState);\n            try {\n                var pingedTasks = request.pingedTasks;\n                var i;\n                for(i = 0; i < pingedTasks.length; i++){\n                    var task = pingedTasks[i];\n                    retryTask(request, task);\n                }\n                pingedTasks.splice(0, i);\n                if (request.destination !== null) {\n                    flushCompletedQueues(request, request.destination);\n                }\n            } catch (error) {\n                var errorInfo = {};\n                logRecoverableError(request, error, errorInfo);\n                fatalError(request, error);\n            } finally{\n                setCurrentResumableState(prevResumableState);\n                ReactCurrentDispatcher.current = prevDispatcher;\n                {\n                    ReactCurrentCache.current = prevCacheDispatcher;\n                }\n                {\n                    ReactDebugCurrentFrame.getCurrentStack = prevGetCurrentStackImpl;\n                }\n                if (prevDispatcher === HooksDispatcher) {\n                    // This means that we were in a reentrant work loop. This could happen\n                    // in a renderer that supports synchronous work like renderToString,\n                    // when it's called from within another renderer.\n                    // Normally we don't bother switching the contexts to their root/default\n                    // values when leaving because we'll likely need the same or similar\n                    // context again. However, when we're inside a synchronous loop like this\n                    // we'll to restore the context to what it was before returning.\n                    switchContext(prevContext);\n                }\n                currentRequest = prevRequest;\n            }\n        }\n        function flushSubtree(request, destination, segment) {\n            segment.parentFlushed = true;\n            switch(segment.status){\n                case PENDING:\n                    {\n                        // We're emitting a placeholder for this segment to be filled in later.\n                        // Therefore we'll need to assign it an ID - to refer to it by.\n                        segment.id = request.nextSegmentId++; // Fallthrough\n                    }\n                case POSTPONED:\n                    {\n                        var segmentID = segment.id; // When this segment finally completes it won't be embedded in text since it will flush separately\n                        segment.lastPushedText = false;\n                        segment.textEmbedded = false;\n                        return writePlaceholder(destination, request.renderState, segmentID);\n                    }\n                case COMPLETED:\n                    {\n                        segment.status = FLUSHED;\n                        var r = true;\n                        var chunks = segment.chunks;\n                        var chunkIdx = 0;\n                        var children = segment.children;\n                        for(var childIdx = 0; childIdx < children.length; childIdx++){\n                            var nextChild = children[childIdx]; // Write all the chunks up until the next child.\n                            for(; chunkIdx < nextChild.index; chunkIdx++){\n                                writeChunk(destination, chunks[chunkIdx]);\n                            }\n                            r = flushSegment(request, destination, nextChild);\n                        } // Finally just write all the remaining chunks\n                        for(; chunkIdx < chunks.length - 1; chunkIdx++){\n                            writeChunk(destination, chunks[chunkIdx]);\n                        }\n                        if (chunkIdx < chunks.length) {\n                            r = writeChunkAndReturn(destination, chunks[chunkIdx]);\n                        }\n                        return r;\n                    }\n                default:\n                    {\n                        throw new Error(\"Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.\");\n                    }\n            }\n        }\n        function flushSegment(request, destination, segment) {\n            var boundary = segment.boundary;\n            if (boundary === null) {\n                // Not a suspense boundary.\n                return flushSubtree(request, destination, segment);\n            }\n            boundary.parentFlushed = true; // This segment is a Suspense boundary. We need to decide whether to\n            // emit the content or the fallback now.\n            if (boundary.status === CLIENT_RENDERED) {\n                // Emit a client rendered suspense boundary wrapper.\n                // We never queue the inner boundary so we'll never emit its content or partial segments.\n                writeStartClientRenderedSuspenseBoundary(destination, request.renderState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndClientRenderedSuspenseBoundary(destination);\n            } else if (boundary.status !== COMPLETED) {\n                if (boundary.status === PENDING) {\n                    // For pending boundaries we lazily assign an ID to the boundary\n                    // and root segment.\n                    boundary.rootSegmentID = request.nextSegmentId++;\n                }\n                if (boundary.completedSegments.length > 0) {\n                    // If this is at least partially complete, we can queue it to be partially emitted early.\n                    request.partialBoundaries.push(boundary);\n                } // This boundary is still loading. Emit a pending suspense boundary wrapper.\n                var id = boundary.rootSegmentID;\n                writeStartPendingSuspenseBoundary(destination, request.renderState, id); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndPendingSuspenseBoundary(destination);\n            } else if (boundary.byteSize > request.progressiveChunkSize) {\n                // This boundary is large and will be emitted separately so that we can progressively show\n                // other content. We add it to the queue during the flush because we have to ensure that\n                // the parent flushes first so that there's something to inject it into.\n                // We also have to make sure that it's emitted into the queue in a deterministic slot.\n                // I.e. we can't insert it here when it completes.\n                // Assign an ID to refer to the future content by.\n                boundary.rootSegmentID = request.nextSegmentId++;\n                request.completedBoundaries.push(boundary); // Emit a pending rendered suspense boundary wrapper.\n                writeStartPendingSuspenseBoundary(destination, request.renderState, boundary.rootSegmentID); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndPendingSuspenseBoundary(destination);\n            } else {\n                {\n                    hoistResources(request.renderState, boundary.resources);\n                }\n                writeStartCompletedSuspenseBoundary(destination);\n                var completedSegments = boundary.completedSegments;\n                if (completedSegments.length !== 1) {\n                    throw new Error(\"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\");\n                }\n                var contentSegment = completedSegments[0];\n                flushSegment(request, destination, contentSegment);\n                return writeEndCompletedSuspenseBoundary(destination);\n            }\n        }\n        function flushClientRenderedBoundary(request, destination, boundary) {\n            return writeClientRenderBoundaryInstruction(destination, request.resumableState, request.renderState, boundary.rootSegmentID, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);\n        }\n        function flushSegmentContainer(request, destination, segment) {\n            writeStartSegment(destination, request.renderState, segment.parentFormatContext, segment.id);\n            flushSegment(request, destination, segment);\n            return writeEndSegment(destination, segment.parentFormatContext);\n        }\n        function flushCompletedBoundary(request, destination, boundary) {\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, boundary.resources);\n            }\n            var completedSegments = boundary.completedSegments;\n            var i = 0;\n            for(; i < completedSegments.length; i++){\n                var segment = completedSegments[i];\n                flushPartiallyCompletedSegment(request, destination, boundary, segment);\n            }\n            completedSegments.length = 0;\n            {\n                writeResourcesForBoundary(destination, boundary.resources, request.renderState);\n            }\n            return writeCompletedBoundaryInstruction(destination, request.resumableState, request.renderState, boundary.rootSegmentID, boundary.resources);\n        }\n        function flushPartialBoundary(request, destination, boundary) {\n            {\n                setCurrentlyRenderingBoundaryResourcesTarget(request.renderState, boundary.resources);\n            }\n            var completedSegments = boundary.completedSegments;\n            var i = 0;\n            for(; i < completedSegments.length; i++){\n                var segment = completedSegments[i];\n                if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {\n                    i++;\n                    completedSegments.splice(0, i); // Only write as much as the buffer wants. Something higher priority\n                    // might want to write later.\n                    return false;\n                }\n            }\n            completedSegments.splice(0, i);\n            {\n                // The way this is structured we only write resources for partial boundaries\n                // if there is no backpressure. Later before we complete the boundary we\n                // will write resources regardless of backpressure before we emit the\n                // completion instruction\n                return writeResourcesForBoundary(destination, boundary.resources, request.renderState);\n            }\n        }\n        function flushPartiallyCompletedSegment(request, destination, boundary, segment) {\n            if (segment.status === FLUSHED) {\n                // We've already flushed this inline.\n                return true;\n            }\n            var segmentID = segment.id;\n            if (segmentID === -1) {\n                // This segment wasn't previously referred to. This happens at the root of\n                // a boundary. We make kind of a leap here and assume this is the root.\n                var rootSegmentID = segment.id = boundary.rootSegmentID;\n                if (rootSegmentID === -1) {\n                    throw new Error(\"A root segment ID must have been assigned by now. This is a bug in React.\");\n                }\n                return flushSegmentContainer(request, destination, segment);\n            } else if (segmentID === boundary.rootSegmentID) {\n                // When we emit postponed boundaries, we might have assigned the ID already\n                // but it's still the root segment so we can't inject it into the parent yet.\n                return flushSegmentContainer(request, destination, segment);\n            } else {\n                flushSegmentContainer(request, destination, segment);\n                return writeCompletedSegmentInstruction(destination, request.resumableState, request.renderState, segmentID);\n            }\n        }\n        function flushCompletedQueues(request, destination) {\n            beginWriting();\n            try {\n                // The structure of this is to go through each queue one by one and write\n                // until the sink tells us to stop. When we should stop, we still finish writing\n                // that item fully and then yield. At that point we remove the already completed\n                // items up until the point we completed them.\n                var i;\n                var completedRootSegment = request.completedRootSegment;\n                if (completedRootSegment !== null) {\n                    if (completedRootSegment.status === POSTPONED) {\n                        // We postponed the root, so we write nothing.\n                        return;\n                    } else if (request.pendingRootTasks === 0) {\n                        if (enableFloat) {\n                            writePreamble(destination, request.resumableState, request.renderState, request.allPendingTasks === 0 && request.trackedPostpones === null);\n                        }\n                        flushSegment(request, destination, completedRootSegment);\n                        request.completedRootSegment = null;\n                        writeCompletedRoot(destination, request.renderState);\n                    } else {\n                        // We haven't flushed the root yet so we don't need to check any other branches further down\n                        return;\n                    }\n                }\n                if (enableFloat) {\n                    writeHoistables(destination, request.resumableState, request.renderState);\n                } // We emit client rendering instructions for already emitted boundaries first.\n                // This is so that we can signal to the client to start client rendering them as\n                // soon as possible.\n                var clientRenderedBoundaries = request.clientRenderedBoundaries;\n                for(i = 0; i < clientRenderedBoundaries.length; i++){\n                    var boundary = clientRenderedBoundaries[i];\n                    if (!flushClientRenderedBoundary(request, destination, boundary)) {\n                        request.destination = null;\n                        i++;\n                        clientRenderedBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                clientRenderedBoundaries.splice(0, i); // Next we emit any complete boundaries. It's better to favor boundaries\n                // that are completely done since we can actually show them, than it is to emit\n                // any individual segments from a partially complete boundary.\n                var completedBoundaries = request.completedBoundaries;\n                for(i = 0; i < completedBoundaries.length; i++){\n                    var _boundary = completedBoundaries[i];\n                    if (!flushCompletedBoundary(request, destination, _boundary)) {\n                        request.destination = null;\n                        i++;\n                        completedBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                completedBoundaries.splice(0, i); // Allow anything written so far to flush to the underlying sink before\n                // we continue with lower priorities.\n                completeWriting(destination);\n                beginWriting(destination); // TODO: Here we'll emit data used by hydration.\n                // Next we emit any segments of any boundaries that are partially complete\n                // but not deeply complete.\n                var partialBoundaries = request.partialBoundaries;\n                for(i = 0; i < partialBoundaries.length; i++){\n                    var _boundary2 = partialBoundaries[i];\n                    if (!flushPartialBoundary(request, destination, _boundary2)) {\n                        request.destination = null;\n                        i++;\n                        partialBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                partialBoundaries.splice(0, i); // Next we check the completed boundaries again. This may have had\n                // boundaries added to it in case they were too larged to be inlined.\n                // New ones might be added in this loop.\n                var largeBoundaries = request.completedBoundaries;\n                for(i = 0; i < largeBoundaries.length; i++){\n                    var _boundary3 = largeBoundaries[i];\n                    if (!flushCompletedBoundary(request, destination, _boundary3)) {\n                        request.destination = null;\n                        i++;\n                        largeBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                largeBoundaries.splice(0, i);\n            } finally{\n                if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 // We don't need to check any partially completed segments because\n                ) {\n                    request.flushScheduled = false;\n                    {\n                        // We write the trailing tags but only if don't have any data to resume.\n                        // If we need to resume we'll write the postamble in the resume instead.\n                        {\n                            writePostamble(destination, request.resumableState);\n                        }\n                    }\n                    completeWriting(destination);\n                    {\n                        if (request.abortableTasks.size !== 0) {\n                            error(\"There was still abortable task at the root when we closed. This is a bug in React.\");\n                        }\n                    }\n                    close(destination); // We need to stop flowing now because we do not want any async contexts which might call\n                    // float methods to initiate any flushes after this point\n                    stopFlowing(request);\n                } else {\n                    completeWriting(destination);\n                }\n            }\n        }\n        function startWork(request) {\n            request.flushScheduled = request.destination !== null;\n            {\n                scheduleWork(function() {\n                    return performWork(request);\n                });\n            }\n            if (request.trackedPostpones === null) {\n                // this is either a regular render or a resume. For regular render we want\n                // to call emitEarlyPreloads after the first performWork because we want\n                // are responding to a live request and need to balance sending something early\n                // (i.e. don't want for the shell to finish) but we need something to send.\n                // The only implementation of this is for DOM at the moment and during resumes nothing\n                // actually emits but the code paths here are the same.\n                // During a prerender we don't want to be too aggressive in emitting early preloads\n                // because we aren't responding to a live request and we can wait for the prerender to\n                // postpone before we emit anything.\n                {\n                    scheduleWork(function() {\n                        return enqueueEarlyPreloadsAfterInitialWork(request);\n                    });\n                }\n            }\n        }\n        function enqueueEarlyPreloadsAfterInitialWork(request) {\n            var shellComplete = request.pendingRootTasks === 0;\n            safelyEmitEarlyPreloads(request, shellComplete);\n        }\n        function enqueueFlush(request) {\n            if (request.flushScheduled === false && // If there are pinged tasks we are going to flush anyway after work completes\n            request.pingedTasks.length === 0 && // If there is no destination there is nothing we can flush to. A flush will\n            // happen when we start flowing again\n            request.destination !== null) {\n                request.flushScheduled = true;\n                scheduleWork(function() {\n                    // We need to existence check destination again here because it might go away\n                    // in between the enqueueFlush call and the work execution\n                    var destination = request.destination;\n                    if (destination) {\n                        flushCompletedQueues(request, destination);\n                    } else {\n                        request.flushScheduled = false;\n                    }\n                });\n            }\n        } // This function is intented to only be called during the pipe function for the Node builds.\n        function startFlowing(request, destination) {\n            if (request.status === CLOSING) {\n                request.status = CLOSED;\n                closeWithError(destination, request.fatalError);\n                return;\n            }\n            if (request.status === CLOSED) {\n                return;\n            }\n            if (request.destination !== null) {\n                // We're already flowing.\n                return;\n            }\n            request.destination = destination;\n            try {\n                flushCompletedQueues(request, destination);\n            } catch (error) {\n                var errorInfo = {};\n                logRecoverableError(request, error, errorInfo);\n                fatalError(request, error);\n            }\n        }\n        function stopFlowing(request) {\n            request.destination = null;\n        } // This is called to early terminate a request. It puts all pending boundaries in client rendered state.\n        function abort(request, reason) {\n            try {\n                var abortableTasks = request.abortableTasks;\n                if (abortableTasks.size > 0) {\n                    var error = reason === undefined ? new Error(\"The render was aborted by the server without a reason.\") : reason;\n                    abortableTasks.forEach(function(task) {\n                        return abortTask(task, request, error);\n                    });\n                    abortableTasks.clear();\n                }\n                if (request.destination !== null) {\n                    flushCompletedQueues(request, request.destination);\n                }\n            } catch (error) {\n                var errorInfo = {};\n                logRecoverableError(request, error, errorInfo);\n                fatalError(request, error);\n            }\n        }\n        function flushResources(request) {\n            enqueueFlush(request);\n        }\n        function getFormState(request) {\n            return request.formState;\n        }\n        function getResumableState(request) {\n            return request.resumableState;\n        }\n        function getRenderState(request) {\n            return request.renderState;\n        }\n        function renderToReadableStream(children, options) {\n            return new Promise(function(resolve, reject) {\n                var onFatalError;\n                var onAllReady;\n                var allReady = new Promise(function(res, rej) {\n                    onAllReady = res;\n                    onFatalError = rej;\n                });\n                function onShellReady() {\n                    var stream = new ReadableStream({\n                        type: \"bytes\",\n                        pull: function(controller) {\n                            startFlowing(request, controller);\n                        },\n                        cancel: function(reason) {\n                            stopFlowing(request);\n                            abort(request, reason);\n                        }\n                    }, {\n                        highWaterMark: 0\n                    }); // TODO: Move to sub-classing ReadableStream.\n                    stream.allReady = allReady;\n                    resolve(stream);\n                }\n                function onShellError(error) {\n                    // If the shell errors the caller of `renderToReadableStream` won't have access to `allReady`.\n                    // However, `allReady` will be rejected by `onFatalError` as well.\n                    // So we need to catch the duplicate, uncatchable fatal error in `allReady` to prevent a `UnhandledPromiseRejection`.\n                    allReady.catch(function() {});\n                    reject(error);\n                }\n                var onHeaders = options ? options.onHeaders : undefined;\n                var onHeadersImpl;\n                if (onHeaders) {\n                    onHeadersImpl = function(headersDescriptor) {\n                        onHeaders(new Headers(headersDescriptor));\n                    };\n                }\n                var resumableState = createResumableState(options ? options.identifierPrefix : undefined, options ? options.unstable_externalRuntimeSrc : undefined, options ? options.bootstrapScriptContent : undefined, options ? options.bootstrapScripts : undefined, options ? options.bootstrapModules : undefined);\n                var request = createRequest(children, resumableState, createRenderState(resumableState, options ? options.nonce : undefined, options ? options.unstable_externalRuntimeSrc : undefined, options ? options.importMap : undefined, onHeadersImpl, options ? options.maxHeadersLength : undefined), createRootFormatContext(options ? options.namespaceURI : undefined), options ? options.progressiveChunkSize : undefined, options ? options.onError : undefined, onAllReady, onShellReady, onShellError, onFatalError, options ? options.onPostpone : undefined, options ? options.formState : undefined);\n                if (options && options.signal) {\n                    var signal = options.signal;\n                    if (signal.aborted) {\n                        abort(request, signal.reason);\n                    } else {\n                        var listener = function() {\n                            abort(request, signal.reason);\n                            signal.removeEventListener(\"abort\", listener);\n                        };\n                        signal.addEventListener(\"abort\", listener);\n                    }\n                }\n                startWork(request);\n            });\n        }\n        exports.renderToReadableStream = renderToReadableStream;\n        exports.version = ReactVersion;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20tc2VydmVyLmJyb3dzZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUMsR0FFRDtBQUVBLElBQUlBLElBQXFDLEVBQUU7SUFDeEM7O1FBQ0g7UUFFQSxJQUFJQyxRQUFRQyxtQkFBT0EsQ0FBQyxzR0FBMEI7UUFDOUMsSUFBSUMsV0FBV0QsbUJBQU9BLENBQUM7UUFFdkIsSUFBSUUsZUFBZTtRQUVuQixJQUFJQyx1QkFBdUJKLE1BQU1LLGtEQUFrRDtRQUVuRiwrQ0FBK0M7UUFDL0MsRUFBRTtRQUNGLDhEQUE4RDtRQUM5RCxxQ0FBcUM7UUFFckMsU0FBU0MsS0FBS0MsTUFBTTtZQUNsQjtnQkFDRTtvQkFDRSxJQUFLLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQVE7d0JBQzFHRixJQUFJLENBQUNFLE9BQU8sRUFBRSxHQUFHSixTQUFTLENBQUNJLEtBQUs7b0JBQ2xDO29CQUVBQyxhQUFhLFFBQVFQLFFBQVFJO2dCQUMvQjtZQUNGO1FBQ0Y7UUFDQSxTQUFTSSxNQUFNUixNQUFNO1lBQ25CO2dCQUNFO29CQUNFLElBQUssSUFBSVMsUUFBUVAsVUFBVUMsTUFBTSxFQUFFQyxPQUFPLElBQUlDLE1BQU1JLFFBQVEsSUFBSUEsUUFBUSxJQUFJLElBQUlDLFFBQVEsR0FBR0EsUUFBUUQsT0FBT0MsUUFBUzt3QkFDakhOLElBQUksQ0FBQ00sUUFBUSxFQUFFLEdBQUdSLFNBQVMsQ0FBQ1EsTUFBTTtvQkFDcEM7b0JBRUFILGFBQWEsU0FBU1AsUUFBUUk7Z0JBQ2hDO1lBQ0Y7UUFDRjtRQUVBLFNBQVNHLGFBQWFJLEtBQUssRUFBRVgsTUFBTSxFQUFFSSxJQUFJO1lB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QjtRQUNqQ3NCLGVBQWUsR0FBR3R2RDtJQUNoQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20tc2VydmVyLmJyb3dzZXIuZGV2ZWxvcG1lbnQuanM/M2QxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1kb20tc2VydmVyLmJyb3dzZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxOC4zLjAtY2FuYXJ5LTYwYTkyN2QwNC0yMDI0MDExMyc7XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyBBIHB1cmUgSlMgaW1wbGVtZW50YXRpb24gb2YgYSBzdHJpbmcgaGFzaGluZyBmdW5jdGlvbi4gV2UgZG8gbm90IHVzZSBpdCBmb3Jcbi8vIHNlY3VyaXR5IG9yIG9iZnVzY2F0aW9uIHB1cnBvc2VzLCBvbmx5IHRvIGNyZWF0ZSBjb21wYWN0IGhhc2hlcy4gU28gd2Vcbi8vIHByaW9yaXRpemUgc3BlZWQgb3ZlciBjb2xsaXNpb24gYXZvaWRhbmNlLiBGb3IgZXhhbXBsZSwgd2UgdXNlIHRoaXMgdG8gaGFzaFxuLy8gdGhlIGNvbXBvbmVudCBrZXkgcGF0aCB1c2VkIGJ5IHVzZUZvcm1TdGF0ZSBmb3IgTVBBLXN0eWxlIHN1Ym1pc3Npb25zLlxuLy9cbi8vIEluIGVudmlyb25tZW50cyB3aGVyZSBidWlsdC1pbiBoYXNoaW5nIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlLCB3ZSBwcmVmZXJcbi8vIHRob3NlIGluc3RlYWQuIExpa2UgTm9kZSdzIGNyeXB0byBtb2R1bGUsIG9yIEJ1bi5oYXNoLiBVbmZvcnR1bmF0ZWx5IHRoaXNcbi8vIGRvZXMgbm90IGluY2x1ZGUgdGhlIHdlYiBzdGFuZGFyZCBjcnlwdG8gQVBJIGJlY2F1c2UgdGhvc2UgbWV0aG9kcyBhcmUgYWxsXG4vLyBhc3luYy4gRm9yIG91ciBwdXJwb3Nlcywgd2UgbmVlZCBpdCB0byBiZSBzeW5jIGJlY2F1c2UgdGhlIGNvc3Qgb2YgY29udGV4dFxuLy8gc3dpdGNoaW5nIGlzIHRvbyBoaWdoIHRvIGJlIHdvcnRoIGl0LlxuLy9cbi8vIFRoZSBtb3N0IHBvcHVsYXIgaGFzaGluZyBhbGdvcml0aG0gdGhhdCBtZWV0cyB0aGVzZSByZXF1aXJlbWVudHMgaW4gdGhlIEpTXG4vLyBlY29zeXN0ZW0gaXMgTXVybXVySGFzaDMsIGFuZCBhbG1vc3QgYWxsIGltcGxlbWVudGF0aW9ucyBJIGNvdWxkIGZpbmQgdXNlZFxuLy8gc29tZSB2ZXJzaW9uIG9mIHRoZSBpbXBsZW1lbnRhdGlvbiBieSBHYXJ5IENvdXJ0IGlubGluZWQgYmVsb3cuXG5mdW5jdGlvbiBjcmVhdGVGYXN0SGFzaEpTKGtleSkge1xuICByZXR1cm4gbXVybXVyaGFzaDNfMzJfZ2Moa2V5LCAwKTtcbn1cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCwgbm8tZmFsbHRocm91Z2ggKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICpcbiAqIEpTIEltcGxlbWVudGF0aW9uIG9mIE11cm11ckhhc2gzIChyMTM2KSAoYXMgb2YgTWF5IDIwLCAyMDExKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMSBHYXJ5IENvdXJ0XG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmZ1bmN0aW9uIG11cm11cmhhc2gzXzMyX2djKGtleSwgc2VlZCkge1xuICB2YXIgcmVtYWluZGVyLCBieXRlcywgaDEsIGgxYiwgYzEsIGMyLCBrMSwgaTtcbiAgcmVtYWluZGVyID0ga2V5Lmxlbmd0aCAmIDM7IC8vIGtleS5sZW5ndGggJSA0XG5cbiAgYnl0ZXMgPSBrZXkubGVuZ3RoIC0gcmVtYWluZGVyO1xuICBoMSA9IHNlZWQ7XG4gIGMxID0gMHhjYzllMmQ1MTtcbiAgYzIgPSAweDFiODczNTkzO1xuICBpID0gMDtcblxuICB3aGlsZSAoaSA8IGJ5dGVzKSB7XG4gICAgazEgPSBrZXkuY2hhckNvZGVBdChpKSAmIDB4ZmYgfCAoa2V5LmNoYXJDb2RlQXQoKytpKSAmIDB4ZmYpIDw8IDggfCAoa2V5LmNoYXJDb2RlQXQoKytpKSAmIDB4ZmYpIDw8IDE2IHwgKGtleS5jaGFyQ29kZUF0KCsraSkgJiAweGZmKSA8PCAyNDtcbiAgICArK2k7XG4gICAgazEgPSAoazEgJiAweGZmZmYpICogYzEgKyAoKChrMSA+Pj4gMTYpICogYzEgJiAweGZmZmYpIDw8IDE2KSAmIDB4ZmZmZmZmZmY7XG4gICAgazEgPSBrMSA8PCAxNSB8IGsxID4+PiAxNztcbiAgICBrMSA9IChrMSAmIDB4ZmZmZikgKiBjMiArICgoKGsxID4+PiAxNikgKiBjMiAmIDB4ZmZmZikgPDwgMTYpICYgMHhmZmZmZmZmZjtcbiAgICBoMSBePSBrMTtcbiAgICBoMSA9IGgxIDw8IDEzIHwgaDEgPj4+IDE5O1xuICAgIGgxYiA9IChoMSAmIDB4ZmZmZikgKiA1ICsgKCgoaDEgPj4+IDE2KSAqIDUgJiAweGZmZmYpIDw8IDE2KSAmIDB4ZmZmZmZmZmY7XG4gICAgaDEgPSAoaDFiICYgMHhmZmZmKSArIDB4NmI2NCArICgoKGgxYiA+Pj4gMTYpICsgMHhlNjU0ICYgMHhmZmZmKSA8PCAxNik7XG4gIH1cblxuICBrMSA9IDA7XG5cbiAgc3dpdGNoIChyZW1haW5kZXIpIHtcbiAgICBjYXNlIDM6XG4gICAgICBrMSBePSAoa2V5LmNoYXJDb2RlQXQoaSArIDIpICYgMHhmZikgPDwgMTY7XG5cbiAgICBjYXNlIDI6XG4gICAgICBrMSBePSAoa2V5LmNoYXJDb2RlQXQoaSArIDEpICYgMHhmZikgPDwgODtcblxuICAgIGNhc2UgMTpcbiAgICAgIGsxIF49IGtleS5jaGFyQ29kZUF0KGkpICYgMHhmZjtcbiAgICAgIGsxID0gKGsxICYgMHhmZmZmKSAqIGMxICsgKCgoazEgPj4+IDE2KSAqIGMxICYgMHhmZmZmKSA8PCAxNikgJiAweGZmZmZmZmZmO1xuICAgICAgazEgPSBrMSA8PCAxNSB8IGsxID4+PiAxNztcbiAgICAgIGsxID0gKGsxICYgMHhmZmZmKSAqIGMyICsgKCgoazEgPj4+IDE2KSAqIGMyICYgMHhmZmZmKSA8PCAxNikgJiAweGZmZmZmZmZmO1xuICAgICAgaDEgXj0gazE7XG4gIH1cblxuICBoMSBePSBrZXkubGVuZ3RoO1xuICBoMSBePSBoMSA+Pj4gMTY7XG4gIGgxID0gKGgxICYgMHhmZmZmKSAqIDB4ODVlYmNhNmIgKyAoKChoMSA+Pj4gMTYpICogMHg4NWViY2E2YiAmIDB4ZmZmZikgPDwgMTYpICYgMHhmZmZmZmZmZjtcbiAgaDEgXj0gaDEgPj4+IDEzO1xuICBoMSA9IChoMSAmIDB4ZmZmZikgKiAweGMyYjJhZTM1ICsgKCgoaDEgPj4+IDE2KSAqIDB4YzJiMmFlMzUgJiAweGZmZmYpIDw8IDE2KSAmIDB4ZmZmZmZmZmY7XG4gIGgxIF49IGgxID4+PiAxNjtcbiAgcmV0dXJuIGgxID4+PiAwO1xufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVdvcmsoY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soKTtcbn1cbnZhciBWSUVXX1NJWkUgPSA1MTI7XG52YXIgY3VycmVudFZpZXcgPSBudWxsO1xudmFyIHdyaXR0ZW5CeXRlcyA9IDA7XG5mdW5jdGlvbiBiZWdpbldyaXRpbmcoZGVzdGluYXRpb24pIHtcbiAgY3VycmVudFZpZXcgPSBuZXcgVWludDhBcnJheShWSUVXX1NJWkUpO1xuICB3cml0dGVuQnl0ZXMgPSAwO1xufVxuZnVuY3Rpb24gd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmspIHtcbiAgaWYgKGNodW5rLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCA+IFZJRVdfU0laRSkge1xuICAgIHtcbiAgICAgIGlmIChwcmVjb21wdXRlZENodW5rU2V0LmhhcyhjaHVuaykpIHtcbiAgICAgICAgZXJyb3IoJ0EgbGFyZ2UgcHJlY29tcHV0ZWQgY2h1bmsgd2FzIHBhc3NlZCB0byB3cml0ZUNodW5rIHdpdGhvdXQgYmVpbmcgY29waWVkLicgKyAnIExhcmdlIGNodW5rcyBnZXQgZW5xdWV1ZWQgZGlyZWN0bHkgYW5kIGFyZSBub3QgY29waWVkLiBUaGlzIGlzIGluY29tcGF0aWJsZSB3aXRoIHByZWNvbXB1dGVkIGNodW5rcyBiZWNhdXNlIHlvdSBjYW5ub3QgZW5xdWV1ZSB0aGUgc2FtZSBwcmVjb21wdXRlZCBjaHVuayB0d2ljZS4nICsgJyBVc2UgXCJjbG9uZUNodW5rXCIgdG8gbWFrZSBhIGNvcHkgb2YgdGhpcyBsYXJnZSBwcmVjb21wdXRlZCBjaHVuayBiZWZvcmUgd3JpdGluZyBpdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgICB9IC8vIHRoaXMgY2h1bmsgbWF5IG92ZXJmbG93IGEgc2luZ2xlIHZpZXcgd2hpY2ggaW1wbGllcyBpdCB3YXMgbm90XG4gICAgLy8gb25lIHRoYXQgaXMgY2FjaGVkIGJ5IHRoZSBzdHJlYW1pbmcgcmVuZGVyZXIuIFdlIHdpbGwgZW5xdWV1XG4gICAgLy8gaXQgZGlyZWN0bHkgYW5kIGV4cGVjdCBpdCBpcyBub3QgcmUtdXNlZFxuXG5cbiAgICBpZiAod3JpdHRlbkJ5dGVzID4gMCkge1xuICAgICAgZGVzdGluYXRpb24uZW5xdWV1ZShuZXcgVWludDhBcnJheShjdXJyZW50Vmlldy5idWZmZXIsIDAsIHdyaXR0ZW5CeXRlcykpO1xuICAgICAgY3VycmVudFZpZXcgPSBuZXcgVWludDhBcnJheShWSUVXX1NJWkUpO1xuICAgICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgICB9XG5cbiAgICBkZXN0aW5hdGlvbi5lbnF1ZXVlKGNodW5rKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYnl0ZXNUb1dyaXRlID0gY2h1bms7XG4gIHZhciBhbGxvd2FibGVCeXRlcyA9IGN1cnJlbnRWaWV3Lmxlbmd0aCAtIHdyaXR0ZW5CeXRlcztcblxuICBpZiAoYWxsb3dhYmxlQnl0ZXMgPCBieXRlc1RvV3JpdGUuYnl0ZUxlbmd0aCkge1xuICAgIC8vIHRoaXMgY2h1bmsgd291bGQgb3ZlcmZsb3cgdGhlIGN1cnJlbnQgdmlldy4gV2UgZW5xdWV1ZSBhIGZ1bGwgdmlld1xuICAgIC8vIGFuZCBzdGFydCBhIG5ldyB2aWV3IHdpdGggdGhlIHJlbWFpbmluZyBjaHVua1xuICAgIGlmIChhbGxvd2FibGVCeXRlcyA9PT0gMCkge1xuICAgICAgLy8gdGhlIGN1cnJlbnQgdmlldyBpcyBhbHJlYWR5IGZ1bGwsIHNlbmQgaXRcbiAgICAgIGRlc3RpbmF0aW9uLmVucXVldWUoY3VycmVudFZpZXcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmaWxsIHVwIHRoZSBjdXJyZW50IHZpZXcgYW5kIGFwcGx5IHRoZSByZW1haW5pbmcgY2h1bmsgYnl0ZXNcbiAgICAgIC8vIHRvIGEgbmV3IHZpZXcuXG4gICAgICBjdXJyZW50Vmlldy5zZXQoYnl0ZXNUb1dyaXRlLnN1YmFycmF5KDAsIGFsbG93YWJsZUJ5dGVzKSwgd3JpdHRlbkJ5dGVzKTsgLy8gd3JpdHRlbkJ5dGVzICs9IGFsbG93YWJsZUJ5dGVzOyAvLyB0aGlzIGNhbiBiZSBza2lwcGVkIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIHRvIGltbWVkaWF0ZWx5IHJlc2V0IHRoZSB2aWV3XG5cbiAgICAgIGRlc3RpbmF0aW9uLmVucXVldWUoY3VycmVudFZpZXcpO1xuICAgICAgYnl0ZXNUb1dyaXRlID0gYnl0ZXNUb1dyaXRlLnN1YmFycmF5KGFsbG93YWJsZUJ5dGVzKTtcbiAgICB9XG5cbiAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KFZJRVdfU0laRSk7XG4gICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgfVxuXG4gIGN1cnJlbnRWaWV3LnNldChieXRlc1RvV3JpdGUsIHdyaXR0ZW5CeXRlcyk7XG4gIHdyaXR0ZW5CeXRlcyArPSBieXRlc1RvV3JpdGUuYnl0ZUxlbmd0aDtcbn1cbmZ1bmN0aW9uIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNodW5rKSB7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNodW5rKTsgLy8gaW4gd2ViIHN0cmVhbXMgdGhlcmUgaXMgbm8gYmFja3ByZXNzdXJlIHNvIHdlIGNhbiBhbHdhcyB3cml0ZSBtb3JlXG5cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb21wbGV0ZVdyaXRpbmcoZGVzdGluYXRpb24pIHtcbiAgaWYgKGN1cnJlbnRWaWV3ICYmIHdyaXR0ZW5CeXRlcyA+IDApIHtcbiAgICBkZXN0aW5hdGlvbi5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KGN1cnJlbnRWaWV3LmJ1ZmZlciwgMCwgd3JpdHRlbkJ5dGVzKSk7XG4gICAgY3VycmVudFZpZXcgPSBudWxsO1xuICAgIHdyaXR0ZW5CeXRlcyA9IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsb3NlKGRlc3RpbmF0aW9uKSB7XG4gIGRlc3RpbmF0aW9uLmNsb3NlKCk7XG59XG52YXIgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIHN0cmluZ1RvQ2h1bmsoY29udGVudCkge1xuICByZXR1cm4gdGV4dEVuY29kZXIuZW5jb2RlKGNvbnRlbnQpO1xufVxudmFyIHByZWNvbXB1dGVkQ2h1bmtTZXQgPSBuZXcgU2V0KCkgO1xuZnVuY3Rpb24gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNvbnRlbnQpIHtcbiAgdmFyIHByZWNvbXB1dGVkQ2h1bmsgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoY29udGVudCk7XG5cbiAge1xuICAgIHByZWNvbXB1dGVkQ2h1bmtTZXQuYWRkKHByZWNvbXB1dGVkQ2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIHByZWNvbXB1dGVkQ2h1bms7XG59XG5mdW5jdGlvbiBjbG9uZVByZWNvbXB1dGVkQ2h1bmsocHJlY29tcHV0ZWRDaHVuaykge1xuICByZXR1cm4gcHJlY29tcHV0ZWRDaHVuay5ieXRlTGVuZ3RoID4gVklFV19TSVpFID8gcHJlY29tcHV0ZWRDaHVuay5zbGljZSgpIDogcHJlY29tcHV0ZWRDaHVuaztcbn1cbmZ1bmN0aW9uIGNsb3NlV2l0aEVycm9yKGRlc3RpbmF0aW9uLCBlcnJvcikge1xuICAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gIGlmICh0eXBlb2YgZGVzdGluYXRpb24uZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogVGhpcyBpcyBhbiBFcnJvciBvYmplY3Qgb3IgdGhlIGRlc3RpbmF0aW9uIGFjY2VwdHMgb3RoZXIgdHlwZXMuXG4gICAgZGVzdGluYXRpb24uZXJyb3IoZXJyb3IpO1xuICB9IGVsc2Uge1xuICAgIC8vIEVhcmxpZXIgaW1wbGVtZW50YXRpb25zIGRvZXNuJ3Qgc3VwcG9ydCB0aGlzIG1ldGhvZC4gSW4gdGhhdCBlbnZpcm9ubWVudCB5b3UncmVcbiAgICAvLyBzdXBwb3NlZCB0byB0aHJvdyBmcm9tIGEgcHJvbWlzZSByZXR1cm5lZCBidXQgd2UgZG9uJ3QgcmV0dXJuIGEgcHJvbWlzZSBpbiBvdXJcbiAgICAvLyBhcHByb2FjaC4gV2UgY291bGQgZm9yayB0aGlzIGltcGxlbWVudGF0aW9uIGJ1dCB0aGlzIGlzIGVudmlyb25tZW50IGlzIGFuIGVkZ2VcbiAgICAvLyBjYXNlIHRvIGJlZ2luIHdpdGguIEl0J3MgZXZlbiBsZXNzIGNvbW1vbiB0byBydW4gdGhpcyBpbiBhbiBvbGRlciBlbnZpcm9ubWVudC5cbiAgICAvLyBFdmVuIHRoZW4sIHRoaXMgaXMgbm90IHdoZXJlIGVycm9ycyBhcmUgc3VwcG9zZWQgdG8gaGFwcGVuIGFuZCB0aGV5IGdldCByZXBvcnRlZFxuICAgIC8vIHRvIGEgZ2xvYmFsIGNhbGxiYWNrIGluIGFkZGl0aW9uIHRvIHRoaXMgYW55d2F5LiBTbyBpdCdzIGZpbmUganVzdCB0byBjbG9zZSB0aGlzLlxuICAgIGRlc3RpbmF0aW9uLmNsb3NlKCk7XG4gIH1cbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGAlc2AgYXR0cmlidXRlIGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgYXR0cmlidXRlTmFtZSwgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja09wdGlvblN0cmluZ0NvZXJjaW9uKHZhbHVlLCBwcm9wTmFtZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBgJXNgIG9wdGlvbiBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHByb3BOYW1lLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbih2YWx1ZSwgcHJvcE5hbWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQgYCVzYCBDU1MgcHJvcGVydHkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCBwcm9wTmFtZSwgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBIVE1MIG1hcmt1cCB1c2VzIGEgdmFsdWUgb2YgdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBlbmFibGVGbG9hdCA9IHRydWU7IC8vIEVuYWJsZXMgdW5zdGFibGVfdXNlTWVtb0NhY2hlIGhvb2ssIGludGVuZGVkIGFzIGEgY29tcGlsYXRpb24gdGFyZ2V0IGZvclxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gXCI6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXCI7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxudmFyIEFUVFJJQlVURV9OQU1FX0NIQVIgPSBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgXCJcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO1xudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuXG4gIHtcbiAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIHVuaXRsZXNzTnVtYmVycyA9IG5ldyBTZXQoWydhbmltYXRpb25JdGVyYXRpb25Db3VudCcsICdhc3BlY3RSYXRpbycsICdib3JkZXJJbWFnZU91dHNldCcsICdib3JkZXJJbWFnZVNsaWNlJywgJ2JvcmRlckltYWdlV2lkdGgnLCAnYm94RmxleCcsICdib3hGbGV4R3JvdXAnLCAnYm94T3JkaW5hbEdyb3VwJywgJ2NvbHVtbkNvdW50JywgJ2NvbHVtbnMnLCAnZmxleCcsICdmbGV4R3JvdycsICdmbGV4UG9zaXRpdmUnLCAnZmxleFNocmluaycsICdmbGV4TmVnYXRpdmUnLCAnZmxleE9yZGVyJywgJ2dyaWRBcmVhJywgJ2dyaWRSb3cnLCAnZ3JpZFJvd0VuZCcsICdncmlkUm93U3BhbicsICdncmlkUm93U3RhcnQnLCAnZ3JpZENvbHVtbicsICdncmlkQ29sdW1uRW5kJywgJ2dyaWRDb2x1bW5TcGFuJywgJ2dyaWRDb2x1bW5TdGFydCcsICdmb250V2VpZ2h0JywgJ2xpbmVDbGFtcCcsICdsaW5lSGVpZ2h0JywgJ29wYWNpdHknLCAnb3JkZXInLCAnb3JwaGFucycsICdzY2FsZScsICd0YWJTaXplJywgJ3dpZG93cycsICd6SW5kZXgnLCAnem9vbScsICdmaWxsT3BhY2l0eScsIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbidmbG9vZE9wYWNpdHknLCAnc3RvcE9wYWNpdHknLCAnc3Ryb2tlRGFzaGFycmF5JywgJ3N0cm9rZURhc2hvZmZzZXQnLCAnc3Ryb2tlTWl0ZXJsaW1pdCcsICdzdHJva2VPcGFjaXR5JywgJ3N0cm9rZVdpZHRoJywgJ01vekFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50JywgLy8gS25vd24gUHJlZml4ZWQgUHJvcGVydGllc1xuJ01vekJveEZsZXgnLCAvLyBUT0RPOiBSZW1vdmUgdGhlc2Ugc2luY2UgdGhleSBzaG91bGRuJ3QgYmUgdXNlZCBpbiBtb2Rlcm4gY29kZVxuJ01vekJveEZsZXhHcm91cCcsICdNb3pMaW5lQ2xhbXAnLCAnbXNBbmltYXRpb25JdGVyYXRpb25Db3VudCcsICdtc0ZsZXgnLCAnbXNab29tJywgJ21zRmxleEdyb3cnLCAnbXNGbGV4TmVnYXRpdmUnLCAnbXNGbGV4T3JkZXInLCAnbXNGbGV4UG9zaXRpdmUnLCAnbXNGbGV4U2hyaW5rJywgJ21zR3JpZENvbHVtbicsICdtc0dyaWRDb2x1bW5TcGFuJywgJ21zR3JpZFJvdycsICdtc0dyaWRSb3dTcGFuJywgJ1dlYmtpdEFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50JywgJ1dlYmtpdEJveEZsZXgnLCAnV2ViS2l0Qm94RmxleEdyb3VwJywgJ1dlYmtpdEJveE9yZGluYWxHcm91cCcsICdXZWJraXRDb2x1bW5Db3VudCcsICdXZWJraXRDb2x1bW5zJywgJ1dlYmtpdEZsZXgnLCAnV2Via2l0RmxleEdyb3cnLCAnV2Via2l0RmxleFBvc2l0aXZlJywgJ1dlYmtpdEZsZXhTaHJpbmsnLCAnV2Via2l0TGluZUNsYW1wJ10pO1xuZnVuY3Rpb24gaXNVbml0bGVzc051bWJlciAobmFtZSkge1xuICByZXR1cm4gdW5pdGxlc3NOdW1iZXJzLmhhcyhuYW1lKTtcbn1cblxudmFyIGFsaWFzZXMgPSBuZXcgTWFwKFtbJ2FjY2VwdENoYXJzZXQnLCAnYWNjZXB0LWNoYXJzZXQnXSwgWydodG1sRm9yJywgJ2ZvciddLCBbJ2h0dHBFcXVpdicsICdodHRwLWVxdWl2J10sIC8vIEhUTUwgYW5kIFNWRyBhdHRyaWJ1dGVzLCBidXQgdGhlIFNWRyBhdHRyaWJ1dGUgaXMgY2FzZSBzZW5zaXRpdmUuXSxcblsnY3Jvc3NPcmlnaW4nLCAnY3Jvc3NvcmlnaW4nXSwgLy8gVGhpcyBpcyBhIGxpc3Qgb2YgYWxsIFNWRyBhdHRyaWJ1dGVzIHRoYXQgbmVlZCBzcGVjaWFsIGNhc2luZy5cbi8vIFJlZ3VsYXIgYXR0cmlidXRlcyB0aGF0IGp1c3QgYWNjZXB0IHN0cmluZ3MuXSxcblsnYWNjZW50SGVpZ2h0JywgJ2FjY2VudC1oZWlnaHQnXSwgWydhbGlnbm1lbnRCYXNlbGluZScsICdhbGlnbm1lbnQtYmFzZWxpbmUnXSwgWydhcmFiaWNGb3JtJywgJ2FyYWJpYy1mb3JtJ10sIFsnYmFzZWxpbmVTaGlmdCcsICdiYXNlbGluZS1zaGlmdCddLCBbJ2NhcEhlaWdodCcsICdjYXAtaGVpZ2h0J10sIFsnY2xpcFBhdGgnLCAnY2xpcC1wYXRoJ10sIFsnY2xpcFJ1bGUnLCAnY2xpcC1ydWxlJ10sIFsnY29sb3JJbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24nXSwgWydjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyddLCBbJ2NvbG9yUHJvZmlsZScsICdjb2xvci1wcm9maWxlJ10sIFsnY29sb3JSZW5kZXJpbmcnLCAnY29sb3ItcmVuZGVyaW5nJ10sIFsnZG9taW5hbnRCYXNlbGluZScsICdkb21pbmFudC1iYXNlbGluZSddLCBbJ2VuYWJsZUJhY2tncm91bmQnLCAnZW5hYmxlLWJhY2tncm91bmQnXSwgWydmaWxsT3BhY2l0eScsICdmaWxsLW9wYWNpdHknXSwgWydmaWxsUnVsZScsICdmaWxsLXJ1bGUnXSwgWydmbG9vZENvbG9yJywgJ2Zsb29kLWNvbG9yJ10sIFsnZmxvb2RPcGFjaXR5JywgJ2Zsb29kLW9wYWNpdHknXSwgWydmb250RmFtaWx5JywgJ2ZvbnQtZmFtaWx5J10sIFsnZm9udFNpemUnLCAnZm9udC1zaXplJ10sIFsnZm9udFNpemVBZGp1c3QnLCAnZm9udC1zaXplLWFkanVzdCddLCBbJ2ZvbnRTdHJldGNoJywgJ2ZvbnQtc3RyZXRjaCddLCBbJ2ZvbnRTdHlsZScsICdmb250LXN0eWxlJ10sIFsnZm9udFZhcmlhbnQnLCAnZm9udC12YXJpYW50J10sIFsnZm9udFdlaWdodCcsICdmb250LXdlaWdodCddLCBbJ2dseXBoTmFtZScsICdnbHlwaC1uYW1lJ10sIFsnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLCAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCddLCBbJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCddLCBbJ2hvcml6QWR2WCcsICdob3Jpei1hZHYteCddLCBbJ2hvcml6T3JpZ2luWCcsICdob3Jpei1vcmlnaW4teCddLCBbJ2ltYWdlUmVuZGVyaW5nJywgJ2ltYWdlLXJlbmRlcmluZyddLCBbJ2xldHRlclNwYWNpbmcnLCAnbGV0dGVyLXNwYWNpbmcnXSwgWydsaWdodGluZ0NvbG9yJywgJ2xpZ2h0aW5nLWNvbG9yJ10sIFsnbWFya2VyRW5kJywgJ21hcmtlci1lbmQnXSwgWydtYXJrZXJNaWQnLCAnbWFya2VyLW1pZCddLCBbJ21hcmtlclN0YXJ0JywgJ21hcmtlci1zdGFydCddLCBbJ292ZXJsaW5lUG9zaXRpb24nLCAnb3ZlcmxpbmUtcG9zaXRpb24nXSwgWydvdmVybGluZVRoaWNrbmVzcycsICdvdmVybGluZS10aGlja25lc3MnXSwgWydwYWludE9yZGVyJywgJ3BhaW50LW9yZGVyJ10sIFsncGFub3NlLTEnLCAncGFub3NlLTEnXSwgWydwb2ludGVyRXZlbnRzJywgJ3BvaW50ZXItZXZlbnRzJ10sIFsncmVuZGVyaW5nSW50ZW50JywgJ3JlbmRlcmluZy1pbnRlbnQnXSwgWydzaGFwZVJlbmRlcmluZycsICdzaGFwZS1yZW5kZXJpbmcnXSwgWydzdG9wQ29sb3InLCAnc3RvcC1jb2xvciddLCBbJ3N0b3BPcGFjaXR5JywgJ3N0b3Atb3BhY2l0eSddLCBbJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJ10sIFsnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyddLCBbJ3N0cm9rZURhc2hhcnJheScsICdzdHJva2UtZGFzaGFycmF5J10sIFsnc3Ryb2tlRGFzaG9mZnNldCcsICdzdHJva2UtZGFzaG9mZnNldCddLCBbJ3N0cm9rZUxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVjYXAnXSwgWydzdHJva2VMaW5lam9pbicsICdzdHJva2UtbGluZWpvaW4nXSwgWydzdHJva2VNaXRlcmxpbWl0JywgJ3N0cm9rZS1taXRlcmxpbWl0J10sIFsnc3Ryb2tlT3BhY2l0eScsICdzdHJva2Utb3BhY2l0eSddLCBbJ3N0cm9rZVdpZHRoJywgJ3N0cm9rZS13aWR0aCddLCBbJ3RleHRBbmNob3InLCAndGV4dC1hbmNob3InXSwgWyd0ZXh0RGVjb3JhdGlvbicsICd0ZXh0LWRlY29yYXRpb24nXSwgWyd0ZXh0UmVuZGVyaW5nJywgJ3RleHQtcmVuZGVyaW5nJ10sIFsndHJhbnNmb3JtT3JpZ2luJywgJ3RyYW5zZm9ybS1vcmlnaW4nXSwgWyd1bmRlcmxpbmVQb3NpdGlvbicsICd1bmRlcmxpbmUtcG9zaXRpb24nXSwgWyd1bmRlcmxpbmVUaGlja25lc3MnLCAndW5kZXJsaW5lLXRoaWNrbmVzcyddLCBbJ3VuaWNvZGVCaWRpJywgJ3VuaWNvZGUtYmlkaSddLCBbJ3VuaWNvZGVSYW5nZScsICd1bmljb2RlLXJhbmdlJ10sIFsndW5pdHNQZXJFbScsICd1bml0cy1wZXItZW0nXSwgWyd2QWxwaGFiZXRpYycsICd2LWFscGhhYmV0aWMnXSwgWyd2SGFuZ2luZycsICd2LWhhbmdpbmcnXSwgWyd2SWRlb2dyYXBoaWMnLCAndi1pZGVvZ3JhcGhpYyddLCBbJ3ZNYXRoZW1hdGljYWwnLCAndi1tYXRoZW1hdGljYWwnXSwgWyd2ZWN0b3JFZmZlY3QnLCAndmVjdG9yLWVmZmVjdCddLCBbJ3ZlcnRBZHZZJywgJ3ZlcnQtYWR2LXknXSwgWyd2ZXJ0T3JpZ2luWCcsICd2ZXJ0LW9yaWdpbi14J10sIFsndmVydE9yaWdpblknLCAndmVydC1vcmlnaW4teSddLCBbJ3dvcmRTcGFjaW5nJywgJ3dvcmQtc3BhY2luZyddLCBbJ3dyaXRpbmdNb2RlJywgJ3dyaXRpbmctbW9kZSddLCBbJ3htbG5zWGxpbmsnLCAneG1sbnM6eGxpbmsnXSwgWyd4SGVpZ2h0JywgJ3gtaGVpZ2h0J11dKTtcbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZUFsaWFzIChuYW1lKSB7XG4gIHJldHVybiBhbGlhc2VzLmdldChuYW1lKSB8fCBuYW1lO1xufVxuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgYnV0dG9uOiB0cnVlLFxuICBjaGVja2JveDogdHJ1ZSxcbiAgaW1hZ2U6IHRydWUsXG4gIGhpZGRlbjogdHJ1ZSxcbiAgcmFkaW86IHRydWUsXG4gIHJlc2V0OiB0cnVlLFxuICBzdWJtaXQ6IHRydWVcbn07XG5mdW5jdGlvbiBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKHRhZ05hbWUsIHByb3BzKSB7XG4gIHtcbiAgICBpZiAoIShoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLm9uSW5wdXQgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMudmFsdWUgPT0gbnVsbCkpIHtcbiAgICAgIGlmICh0YWdOYW1lID09PSAnc2VsZWN0Jykge1xuICAgICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgc2V0IGBvbkNoYW5nZWAuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEocHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuY2hlY2tlZCA9PSBudWxsKSkge1xuICAgICAgZXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYXJpYVByb3BlcnRpZXMgPSB7XG4gICdhcmlhLWN1cnJlbnQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1kZXNjcmlwdGlvbic6IDAsXG4gICdhcmlhLWRldGFpbHMnOiAwLFxuICAnYXJpYS1kaXNhYmxlZCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWhpZGRlbic6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWludmFsaWQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAwLFxuICAnYXJpYS1sYWJlbCc6IDAsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gIC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4gICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICdhcmlhLWNoZWNrZWQnOiAwLFxuICAnYXJpYS1leHBhbmRlZCc6IDAsXG4gICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAnYXJpYS1tb2RhbCc6IDAsXG4gICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICdhcmlhLW9yaWVudGF0aW9uJzogMCxcbiAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgJ2FyaWEtcmVhZG9ubHknOiAwLFxuICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgJ2FyaWEtc29ydCc6IDAsXG4gICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXRvbWljJzogMCxcbiAgJ2FyaWEtYnVzeSc6IDAsXG4gICdhcmlhLWxpdmUnOiAwLFxuICAnYXJpYS1yZWxldmFudCc6IDAsXG4gIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgJ2FyaWEtZ3JhYmJlZCc6IDAsXG4gIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAnYXJpYS1jb2xjb3VudCc6IDAsXG4gICdhcmlhLWNvbGluZGV4JzogMCxcbiAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICdhcmlhLWNvbnRyb2xzJzogMCxcbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAnYXJpYS1mbG93dG8nOiAwLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgJ2FyaWEtb3ducyc6IDAsXG4gICdhcmlhLXBvc2luc2V0JzogMCxcbiAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICdhcmlhLXJvd3NwYW4nOiAwLFxuICAnYXJpYS1zZXRzaXplJzogMFxufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMkMSA9IHt9O1xudmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciByQVJJQUNhbWVsJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkkMSh0YWdOYW1lLCBuYW1lKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgYXJpYU5hbWUgPSAnYXJpYS0nICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGNvcnJlY3ROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoYXJpYU5hbWUpID8gYXJpYU5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLicsIG5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cblxuXG4gICAgICBpZiAobmFtZSAhPT0gY29ycmVjdE5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgY29ycmVjdE5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IG51bGw7IC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuXG4gICAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cblxuXG4gICAgICBpZiAobmFtZSAhPT0gc3RhbmRhcmROYW1lKSB7XG4gICAgICAgIGVycm9yKCdVbmtub3duIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHN0YW5kYXJkTmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSk7XG5cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtYXJpYS1wcm9wcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtYXJpYS1wcm9wcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICBpZiAodHlwZSAhPT0gJ2lucHV0JyAmJiB0eXBlICE9PSAndGV4dGFyZWEnICYmIHR5cGUgIT09ICdzZWxlY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BzICE9IG51bGwgJiYgcHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICAgIGRpZFdhcm5WYWx1ZU51bGwgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMubXVsdGlwbGUpIHtcbiAgICAgICAgZXJyb3IoJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBhcnJheSB3aGVuIGBtdWx0aXBsZWAgaXMgc2V0IHRvIGB0cnVlYCAnICsgJ3RvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsIHR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4nLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDdXN0b21FbGVtZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMuXG4gICAgLy8gV2UgZG9uJ3QgbWluZCB0aGlzIGxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgYWxsb3dlZCBhdHRyaWJ1dGUgbGlzdCwgYmUgc3VyZSB0b1xuLy8gYWxzbyBhZGQgdGhlbSB0byB0aGlzIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3QgbmFtZVxuLy8gd2FybmluZ3MuXG52YXIgcG9zc2libGVTdGFuZGFyZE5hbWVzID0ge1xuICAvLyBIVE1MXG4gIGFjY2VwdDogJ2FjY2VwdCcsXG4gIGFjY2VwdGNoYXJzZXQ6ICdhY2NlcHRDaGFyc2V0JyxcbiAgJ2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuICBhY2Nlc3NrZXk6ICdhY2Nlc3NLZXknLFxuICBhY3Rpb246ICdhY3Rpb24nLFxuICBhbGxvd2Z1bGxzY3JlZW46ICdhbGxvd0Z1bGxTY3JlZW4nLFxuICBhbHQ6ICdhbHQnLFxuICBhczogJ2FzJyxcbiAgYXN5bmM6ICdhc3luYycsXG4gIGF1dG9jYXBpdGFsaXplOiAnYXV0b0NhcGl0YWxpemUnLFxuICBhdXRvY29tcGxldGU6ICdhdXRvQ29tcGxldGUnLFxuICBhdXRvY29ycmVjdDogJ2F1dG9Db3JyZWN0JyxcbiAgYXV0b2ZvY3VzOiAnYXV0b0ZvY3VzJyxcbiAgYXV0b3BsYXk6ICdhdXRvUGxheScsXG4gIGF1dG9zYXZlOiAnYXV0b1NhdmUnLFxuICBjYXB0dXJlOiAnY2FwdHVyZScsXG4gIGNlbGxwYWRkaW5nOiAnY2VsbFBhZGRpbmcnLFxuICBjZWxsc3BhY2luZzogJ2NlbGxTcGFjaW5nJyxcbiAgY2hhbGxlbmdlOiAnY2hhbGxlbmdlJyxcbiAgY2hhcnNldDogJ2NoYXJTZXQnLFxuICBjaGVja2VkOiAnY2hlY2tlZCcsXG4gIGNoaWxkcmVuOiAnY2hpbGRyZW4nLFxuICBjaXRlOiAnY2l0ZScsXG4gIGNsYXNzOiAnY2xhc3NOYW1lJyxcbiAgY2xhc3NpZDogJ2NsYXNzSUQnLFxuICBjbGFzc25hbWU6ICdjbGFzc05hbWUnLFxuICBjb2xzOiAnY29scycsXG4gIGNvbHNwYW46ICdjb2xTcGFuJyxcbiAgY29udGVudDogJ2NvbnRlbnQnLFxuICBjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuICBjb250ZXh0bWVudTogJ2NvbnRleHRNZW51JyxcbiAgY29udHJvbHM6ICdjb250cm9scycsXG4gIGNvbnRyb2xzbGlzdDogJ2NvbnRyb2xzTGlzdCcsXG4gIGNvb3JkczogJ2Nvb3JkcycsXG4gIGNyb3Nzb3JpZ2luOiAnY3Jvc3NPcmlnaW4nLFxuICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyxcbiAgZGF0YTogJ2RhdGEnLFxuICBkYXRldGltZTogJ2RhdGVUaW1lJyxcbiAgZGVmYXVsdDogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkaXNhYmxlcGljdHVyZWlucGljdHVyZTogJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJyxcbiAgZGlzYWJsZXJlbW90ZXBsYXliYWNrOiAnZGlzYWJsZVJlbW90ZVBsYXliYWNrJyxcbiAgZG93bmxvYWQ6ICdkb3dubG9hZCcsXG4gIGRyYWdnYWJsZTogJ2RyYWdnYWJsZScsXG4gIGVuY3R5cGU6ICdlbmNUeXBlJyxcbiAgZW50ZXJrZXloaW50OiAnZW50ZXJLZXlIaW50JyxcbiAgZmV0Y2hwcmlvcml0eTogJ2ZldGNoUHJpb3JpdHknLFxuICBmb3I6ICdodG1sRm9yJyxcbiAgZm9ybTogJ2Zvcm0nLFxuICBmb3JtbWV0aG9kOiAnZm9ybU1ldGhvZCcsXG4gIGZvcm1hY3Rpb246ICdmb3JtQWN0aW9uJyxcbiAgZm9ybWVuY3R5cGU6ICdmb3JtRW5jVHlwZScsXG4gIGZvcm1ub3ZhbGlkYXRlOiAnZm9ybU5vVmFsaWRhdGUnLFxuICBmb3JtdGFyZ2V0OiAnZm9ybVRhcmdldCcsXG4gIGZyYW1lYm9yZGVyOiAnZnJhbWVCb3JkZXInLFxuICBoZWFkZXJzOiAnaGVhZGVycycsXG4gIGhlaWdodDogJ2hlaWdodCcsXG4gIGhpZGRlbjogJ2hpZGRlbicsXG4gIGhpZ2g6ICdoaWdoJyxcbiAgaHJlZjogJ2hyZWYnLFxuICBocmVmbGFuZzogJ2hyZWZMYW5nJyxcbiAgaHRtbGZvcjogJ2h0bWxGb3InLFxuICBodHRwZXF1aXY6ICdodHRwRXF1aXYnLFxuICAnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnLFxuICBpY29uOiAnaWNvbicsXG4gIGlkOiAnaWQnLFxuICBpbWFnZXNpemVzOiAnaW1hZ2VTaXplcycsXG4gIGltYWdlc3Jjc2V0OiAnaW1hZ2VTcmNTZXQnLFxuICBpbm5lcmh0bWw6ICdpbm5lckhUTUwnLFxuICBpbnB1dG1vZGU6ICdpbnB1dE1vZGUnLFxuICBpbnRlZ3JpdHk6ICdpbnRlZ3JpdHknLFxuICBpczogJ2lzJyxcbiAgaXRlbWlkOiAnaXRlbUlEJyxcbiAgaXRlbXByb3A6ICdpdGVtUHJvcCcsXG4gIGl0ZW1yZWY6ICdpdGVtUmVmJyxcbiAgaXRlbXNjb3BlOiAnaXRlbVNjb3BlJyxcbiAgaXRlbXR5cGU6ICdpdGVtVHlwZScsXG4gIGtleXBhcmFtczogJ2tleVBhcmFtcycsXG4gIGtleXR5cGU6ICdrZXlUeXBlJyxcbiAga2luZDogJ2tpbmQnLFxuICBsYWJlbDogJ2xhYmVsJyxcbiAgbGFuZzogJ2xhbmcnLFxuICBsaXN0OiAnbGlzdCcsXG4gIGxvb3A6ICdsb29wJyxcbiAgbG93OiAnbG93JyxcbiAgbWFuaWZlc3Q6ICdtYW5pZmVzdCcsXG4gIG1hcmdpbndpZHRoOiAnbWFyZ2luV2lkdGgnLFxuICBtYXJnaW5oZWlnaHQ6ICdtYXJnaW5IZWlnaHQnLFxuICBtYXg6ICdtYXgnLFxuICBtYXhsZW5ndGg6ICdtYXhMZW5ndGgnLFxuICBtZWRpYTogJ21lZGlhJyxcbiAgbWVkaWFncm91cDogJ21lZGlhR3JvdXAnLFxuICBtZXRob2Q6ICdtZXRob2QnLFxuICBtaW46ICdtaW4nLFxuICBtaW5sZW5ndGg6ICdtaW5MZW5ndGgnLFxuICBtdWx0aXBsZTogJ211bHRpcGxlJyxcbiAgbXV0ZWQ6ICdtdXRlZCcsXG4gIG5hbWU6ICduYW1lJyxcbiAgbm9tb2R1bGU6ICdub01vZHVsZScsXG4gIG5vbmNlOiAnbm9uY2UnLFxuICBub3ZhbGlkYXRlOiAnbm9WYWxpZGF0ZScsXG4gIG9wZW46ICdvcGVuJyxcbiAgb3B0aW11bTogJ29wdGltdW0nLFxuICBwYXR0ZXJuOiAncGF0dGVybicsXG4gIHBsYWNlaG9sZGVyOiAncGxhY2Vob2xkZXInLFxuICBwbGF5c2lubGluZTogJ3BsYXlzSW5saW5lJyxcbiAgcG9zdGVyOiAncG9zdGVyJyxcbiAgcHJlbG9hZDogJ3ByZWxvYWQnLFxuICBwcm9maWxlOiAncHJvZmlsZScsXG4gIHJhZGlvZ3JvdXA6ICdyYWRpb0dyb3VwJyxcbiAgcmVhZG9ubHk6ICdyZWFkT25seScsXG4gIHJlZmVycmVycG9saWN5OiAncmVmZXJyZXJQb2xpY3knLFxuICByZWw6ICdyZWwnLFxuICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgcmV2ZXJzZWQ6ICdyZXZlcnNlZCcsXG4gIHJvbGU6ICdyb2xlJyxcbiAgcm93czogJ3Jvd3MnLFxuICByb3dzcGFuOiAncm93U3BhbicsXG4gIHNhbmRib3g6ICdzYW5kYm94JyxcbiAgc2NvcGU6ICdzY29wZScsXG4gIHNjb3BlZDogJ3Njb3BlZCcsXG4gIHNjcm9sbGluZzogJ3Njcm9sbGluZycsXG4gIHNlYW1sZXNzOiAnc2VhbWxlc3MnLFxuICBzZWxlY3RlZDogJ3NlbGVjdGVkJyxcbiAgc2hhcGU6ICdzaGFwZScsXG4gIHNpemU6ICdzaXplJyxcbiAgc2l6ZXM6ICdzaXplcycsXG4gIHNwYW46ICdzcGFuJyxcbiAgc3BlbGxjaGVjazogJ3NwZWxsQ2hlY2snLFxuICBzcmM6ICdzcmMnLFxuICBzcmNkb2M6ICdzcmNEb2MnLFxuICBzcmNsYW5nOiAnc3JjTGFuZycsXG4gIHNyY3NldDogJ3NyY1NldCcsXG4gIHN0YXJ0OiAnc3RhcnQnLFxuICBzdGVwOiAnc3RlcCcsXG4gIHN0eWxlOiAnc3R5bGUnLFxuICBzdW1tYXJ5OiAnc3VtbWFyeScsXG4gIHRhYmluZGV4OiAndGFiSW5kZXgnLFxuICB0YXJnZXQ6ICd0YXJnZXQnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHlwZTogJ3R5cGUnLFxuICB1c2VtYXA6ICd1c2VNYXAnLFxuICB2YWx1ZTogJ3ZhbHVlJyxcbiAgd2lkdGg6ICd3aWR0aCcsXG4gIHdtb2RlOiAnd21vZGUnLFxuICB3cmFwOiAnd3JhcCcsXG4gIC8vIFNWR1xuICBhYm91dDogJ2Fib3V0JyxcbiAgYWNjZW50aGVpZ2h0OiAnYWNjZW50SGVpZ2h0JyxcbiAgJ2FjY2VudC1oZWlnaHQnOiAnYWNjZW50SGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogJ2FjY3VtdWxhdGUnLFxuICBhZGRpdGl2ZTogJ2FkZGl0aXZlJyxcbiAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICBhbGxvd3Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAnYWxwaGFiZXRpYycsXG4gIGFtcGxpdHVkZTogJ2FtcGxpdHVkZScsXG4gIGFyYWJpY2Zvcm06ICdhcmFiaWNGb3JtJyxcbiAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICBhc2NlbnQ6ICdhc2NlbnQnLFxuICBhdHRyaWJ1dGVuYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZXR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6ICdhemltdXRoJyxcbiAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlbGluZXNoaWZ0OiAnYmFzZWxpbmVTaGlmdCcsXG4gICdiYXNlbGluZS1zaGlmdCc6ICdiYXNlbGluZVNoaWZ0JyxcbiAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJib3g6ICdiYm94JyxcbiAgYmVnaW46ICdiZWdpbicsXG4gIGJpYXM6ICdiaWFzJyxcbiAgYnk6ICdieScsXG4gIGNhbGNtb2RlOiAnY2FsY01vZGUnLFxuICBjYXBoZWlnaHQ6ICdjYXBIZWlnaHQnLFxuICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICBjbGlwOiAnY2xpcCcsXG4gIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAnY2xpcC1wYXRoJzogJ2NsaXBQYXRoJyxcbiAgY2xpcHBhdGh1bml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgJ2NsaXAtcnVsZSc6ICdjbGlwUnVsZScsXG4gIGNvbG9yOiAnY29sb3InLFxuICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6ICdjb2xvckludGVycG9sYXRpb24nLFxuICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gIGNvbG9ycHJvZmlsZTogJ2NvbG9yUHJvZmlsZScsXG4gICdjb2xvci1wcm9maWxlJzogJ2NvbG9yUHJvZmlsZScsXG4gIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAnY29sb3ItcmVuZGVyaW5nJzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgY29udGVudHNjcmlwdHR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgY3g6ICdjeCcsXG4gIGN5OiAnY3knLFxuICBkOiAnZCcsXG4gIGRhdGF0eXBlOiAnZGF0YXR5cGUnLFxuICBkZWNlbGVyYXRlOiAnZGVjZWxlcmF0ZScsXG4gIGRlc2NlbnQ6ICdkZXNjZW50JyxcbiAgZGlmZnVzZWNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAnZGlyZWN0aW9uJyxcbiAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICBkaXZpc29yOiAnZGl2aXNvcicsXG4gIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2RvbWluYW50QmFzZWxpbmUnLFxuICBkdXI6ICdkdXInLFxuICBkeDogJ2R4JyxcbiAgZHk6ICdkeScsXG4gIGVkZ2Vtb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246ICdlbGV2YXRpb24nLFxuICBlbmFibGViYWNrZ3JvdW5kOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgZW5kOiAnZW5kJyxcbiAgZXhwb25lbnQ6ICdleHBvbmVudCcsXG4gIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsb3BhY2l0eTogJ2ZpbGxPcGFjaXR5JyxcbiAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gIGZpbGxydWxlOiAnZmlsbFJ1bGUnLFxuICAnZmlsbC1ydWxlJzogJ2ZpbGxSdWxlJyxcbiAgZmlsdGVyOiAnZmlsdGVyJyxcbiAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVydW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kb3BhY2l0eTogJ2Zsb29kT3BhY2l0eScsXG4gICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gIGZsb29kY29sb3I6ICdmbG9vZENvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJzogJ2Zsb29kQ29sb3InLFxuICBmb2N1c2FibGU6ICdmb2N1c2FibGUnLFxuICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgZm9udHNpemU6ICdmb250U2l6ZScsXG4gICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICBmb250c2l6ZWFkanVzdDogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnZm9udFNpemVBZGp1c3QnLFxuICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgJ2ZvbnQtc3RyZXRjaCc6ICdmb250U3RyZXRjaCcsXG4gIGZvbnRzdHlsZTogJ2ZvbnRTdHlsZScsXG4gICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gIGZvbnR2YXJpYW50OiAnZm9udFZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50JzogJ2ZvbnRWYXJpYW50JyxcbiAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAnZm9udC13ZWlnaHQnOiAnZm9udFdlaWdodCcsXG4gIGZvcm1hdDogJ2Zvcm1hdCcsXG4gIGZyb206ICdmcm9tJyxcbiAgZng6ICdmeCcsXG4gIGZ5OiAnZnknLFxuICBnMTogJ2cxJyxcbiAgZzI6ICdnMicsXG4gIGdseXBobmFtZTogJ2dseXBoTmFtZScsXG4gICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50dW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnLFxuICBob3JpemFkdng6ICdob3JpekFkdlgnLFxuICAnaG9yaXotYWR2LXgnOiAnaG9yaXpBZHZYJyxcbiAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgJ2hvcml6LW9yaWdpbi14JzogJ2hvcml6T3JpZ2luWCcsXG4gIGlkZW9ncmFwaGljOiAnaWRlb2dyYXBoaWMnLFxuICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlbmRlcmluZyc6ICdpbWFnZVJlbmRlcmluZycsXG4gIGluMjogJ2luMicsXG4gIGluOiAnaW4nLFxuICBpbmxpc3Q6ICdpbmxpc3QnLFxuICBpbnRlcmNlcHQ6ICdpbnRlcmNlcHQnLFxuICBrMTogJ2sxJyxcbiAgazI6ICdrMicsXG4gIGszOiAnazMnLFxuICBrNDogJ2s0JyxcbiAgazogJ2snLFxuICBrZXJuZWxtYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWx1bml0bGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6ICdrZXJuaW5nJyxcbiAga2V5cG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5c3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXl0aW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoYWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyc3BhY2luZzogJ2xldHRlclNwYWNpbmcnLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAnbGV0dGVyU3BhY2luZycsXG4gIGxpZ2h0aW5nY29sb3I6ICdsaWdodGluZ0NvbG9yJyxcbiAgJ2xpZ2h0aW5nLWNvbG9yJzogJ2xpZ2h0aW5nQ29sb3InLFxuICBsaW1pdGluZ2NvbmVhbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6ICdsb2NhbCcsXG4gIG1hcmtlcmVuZDogJ21hcmtlckVuZCcsXG4gICdtYXJrZXItZW5kJzogJ21hcmtlckVuZCcsXG4gIG1hcmtlcmhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlcm1pZDogJ21hcmtlck1pZCcsXG4gICdtYXJrZXItbWlkJzogJ21hcmtlck1pZCcsXG4gIG1hcmtlcnN0YXJ0OiAnbWFya2VyU3RhcnQnLFxuICAnbWFya2VyLXN0YXJ0JzogJ21hcmtlclN0YXJ0JyxcbiAgbWFya2VydW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcndpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAnbWFzaycsXG4gIG1hc2tjb250ZW50dW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza3VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAnbWF0aGVtYXRpY2FsJyxcbiAgbW9kZTogJ21vZGUnLFxuICBudW1vY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogJ29mZnNldCcsXG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgb3BlcmF0b3I6ICdvcGVyYXRvcicsXG4gIG9yZGVyOiAnb3JkZXInLFxuICBvcmllbnQ6ICdvcmllbnQnLFxuICBvcmllbnRhdGlvbjogJ29yaWVudGF0aW9uJyxcbiAgb3JpZ2luOiAnb3JpZ2luJyxcbiAgb3ZlcmZsb3c6ICdvdmVyZmxvdycsXG4gIG92ZXJsaW5lcG9zaXRpb246ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgJ292ZXJsaW5lLXBvc2l0aW9uJzogJ292ZXJsaW5lUG9zaXRpb24nLFxuICBvdmVybGluZXRoaWNrbmVzczogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ292ZXJsaW5lLXRoaWNrbmVzcyc6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gIHBhaW50b3JkZXI6ICdwYWludE9yZGVyJyxcbiAgJ3BhaW50LW9yZGVyJzogJ3BhaW50T3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlMScsXG4gICdwYW5vc2UtMSc6ICdwYW5vc2UxJyxcbiAgcGF0aGxlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuY29udGVudHVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm50cmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVybnVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlcmV2ZW50czogJ3BvaW50ZXJFdmVudHMnLFxuICAncG9pbnRlci1ldmVudHMnOiAncG9pbnRlckV2ZW50cycsXG4gIHBvaW50czogJ3BvaW50cycsXG4gIHBvaW50c2F0eDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c2F0eTogJ3BvaW50c0F0WScsXG4gIHBvaW50c2F0ejogJ3BvaW50c0F0WicsXG4gIHByZWZpeDogJ3ByZWZpeCcsXG4gIHByZXNlcnZlYWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVhc3BlY3RyYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmV1bml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcHJvcGVydHk6ICdwcm9wZXJ0eScsXG4gIHI6ICdyJyxcbiAgcmFkaXVzOiAncmFkaXVzJyxcbiAgcmVmeDogJ3JlZlgnLFxuICByZWZ5OiAncmVmWScsXG4gIHJlbmRlcmluZ2ludGVudDogJ3JlbmRlcmluZ0ludGVudCcsXG4gICdyZW5kZXJpbmctaW50ZW50JzogJ3JlbmRlcmluZ0ludGVudCcsXG4gIHJlcGVhdGNvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXRkdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZGV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZGZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc291cmNlOiAncmVzb3VyY2UnLFxuICByZXN0YXJ0OiAncmVzdGFydCcsXG4gIHJlc3VsdDogJ3Jlc3VsdCcsXG4gIHJlc3VsdHM6ICdyZXN1bHRzJyxcbiAgcm90YXRlOiAncm90YXRlJyxcbiAgcng6ICdyeCcsXG4gIHJ5OiAncnknLFxuICBzY2FsZTogJ3NjYWxlJyxcbiAgc2VjdXJpdHk6ICdzZWN1cml0eScsXG4gIHNlZWQ6ICdzZWVkJyxcbiAgc2hhcGVyZW5kZXJpbmc6ICdzaGFwZVJlbmRlcmluZycsXG4gICdzaGFwZS1yZW5kZXJpbmcnOiAnc2hhcGVSZW5kZXJpbmcnLFxuICBzbG9wZTogJ3Nsb3BlJyxcbiAgc3BhY2luZzogJ3NwYWNpbmcnLFxuICBzcGVjdWxhcmNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyZXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6ICdzcGVlZCcsXG4gIHNwcmVhZG1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0b2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGRkZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogJ3N0ZW1oJyxcbiAgc3RlbXY6ICdzdGVtdicsXG4gIHN0aXRjaHRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wY29sb3I6ICdzdG9wQ29sb3InLFxuICAnc3RvcC1jb2xvcic6ICdzdG9wQ29sb3InLFxuICBzdG9wb3BhY2l0eTogJ3N0b3BPcGFjaXR5JyxcbiAgJ3N0b3Atb3BhY2l0eSc6ICdzdG9wT3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJzogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2h0aGlja25lc3M6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJzogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICBzdHJpbmc6ICdzdHJpbmcnLFxuICBzdHJva2U6ICdzdHJva2UnLFxuICBzdHJva2VkYXNoYXJyYXk6ICdzdHJva2VEYXNoYXJyYXknLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdzdHJva2VEYXNoYXJyYXknLFxuICBzdHJva2VkYXNob2Zmc2V0OiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgc3Ryb2tlbGluZWNhcDogJ3N0cm9rZUxpbmVjYXAnLFxuICAnc3Ryb2tlLWxpbmVjYXAnOiAnc3Ryb2tlTGluZWNhcCcsXG4gIHN0cm9rZWxpbmVqb2luOiAnc3Ryb2tlTGluZWpvaW4nLFxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ3N0cm9rZUxpbmVqb2luJyxcbiAgc3Ryb2tlbWl0ZXJsaW1pdDogJ3N0cm9rZU1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gIHN0cm9rZXdpZHRoOiAnc3Ryb2tlV2lkdGgnLFxuICAnc3Ryb2tlLXdpZHRoJzogJ3N0cm9rZVdpZHRoJyxcbiAgc3Ryb2tlb3BhY2l0eTogJ3N0cm9rZU9wYWNpdHknLFxuICAnc3Ryb2tlLW9wYWNpdHknOiAnc3Ryb2tlT3BhY2l0eScsXG4gIHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzogJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsXG4gIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsXG4gIHN1cmZhY2VzY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbWxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZXZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0eDogJ3RhcmdldFgnLFxuICB0YXJnZXR5OiAndGFyZ2V0WScsXG4gIHRleHRhbmNob3I6ICd0ZXh0QW5jaG9yJyxcbiAgJ3RleHQtYW5jaG9yJzogJ3RleHRBbmNob3InLFxuICB0ZXh0ZGVjb3JhdGlvbjogJ3RleHREZWNvcmF0aW9uJyxcbiAgJ3RleHQtZGVjb3JhdGlvbic6ICd0ZXh0RGVjb3JhdGlvbicsXG4gIHRleHRsZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdGV4dHJlbmRlcmluZzogJ3RleHRSZW5kZXJpbmcnLFxuICAndGV4dC1yZW5kZXJpbmcnOiAndGV4dFJlbmRlcmluZycsXG4gIHRvOiAndG8nLFxuICB0cmFuc2Zvcm06ICd0cmFuc2Zvcm0nLFxuICB0cmFuc2Zvcm1vcmlnaW46ICd0cmFuc2Zvcm1PcmlnaW4nLFxuICAndHJhbnNmb3JtLW9yaWdpbic6ICd0cmFuc2Zvcm1PcmlnaW4nLFxuICB0eXBlb2Y6ICd0eXBlb2YnLFxuICB1MTogJ3UxJyxcbiAgdTI6ICd1MicsXG4gIHVuZGVybGluZXBvc2l0aW9uOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICAndW5kZXJsaW5lLXBvc2l0aW9uJzogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgdW5kZXJsaW5ldGhpY2tuZXNzOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ3VuZGVybGluZS10aGlja25lc3MnOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgdW5pY29kZTogJ3VuaWNvZGUnLFxuICB1bmljb2RlYmlkaTogJ3VuaWNvZGVCaWRpJyxcbiAgJ3VuaWNvZGUtYmlkaSc6ICd1bmljb2RlQmlkaScsXG4gIHVuaWNvZGVyYW5nZTogJ3VuaWNvZGVSYW5nZScsXG4gICd1bmljb2RlLXJhbmdlJzogJ3VuaWNvZGVSYW5nZScsXG4gIHVuaXRzcGVyZW06ICd1bml0c1BlckVtJyxcbiAgJ3VuaXRzLXBlci1lbSc6ICd1bml0c1BlckVtJyxcbiAgdW5zZWxlY3RhYmxlOiAndW5zZWxlY3RhYmxlJyxcbiAgdmFscGhhYmV0aWM6ICd2QWxwaGFiZXRpYycsXG4gICd2LWFscGhhYmV0aWMnOiAndkFscGhhYmV0aWMnLFxuICB2YWx1ZXM6ICd2YWx1ZXMnLFxuICB2ZWN0b3JlZmZlY3Q6ICd2ZWN0b3JFZmZlY3QnLFxuICAndmVjdG9yLWVmZmVjdCc6ICd2ZWN0b3JFZmZlY3QnLFxuICB2ZXJzaW9uOiAndmVyc2lvbicsXG4gIHZlcnRhZHZ5OiAndmVydEFkdlknLFxuICAndmVydC1hZHYteSc6ICd2ZXJ0QWR2WScsXG4gIHZlcnRvcmlnaW54OiAndmVydE9yaWdpblgnLFxuICAndmVydC1vcmlnaW4teCc6ICd2ZXJ0T3JpZ2luWCcsXG4gIHZlcnRvcmlnaW55OiAndmVydE9yaWdpblknLFxuICAndmVydC1vcmlnaW4teSc6ICd2ZXJ0T3JpZ2luWScsXG4gIHZoYW5naW5nOiAndkhhbmdpbmcnLFxuICAndi1oYW5naW5nJzogJ3ZIYW5naW5nJyxcbiAgdmlkZW9ncmFwaGljOiAndklkZW9ncmFwaGljJyxcbiAgJ3YtaWRlb2dyYXBoaWMnOiAndklkZW9ncmFwaGljJyxcbiAgdmlld2JveDogJ3ZpZXdCb3gnLFxuICB2aWV3dGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6ICd2aXNpYmlsaXR5JyxcbiAgdm1hdGhlbWF0aWNhbDogJ3ZNYXRoZW1hdGljYWwnLFxuICAndi1tYXRoZW1hdGljYWwnOiAndk1hdGhlbWF0aWNhbCcsXG4gIHZvY2FiOiAndm9jYWInLFxuICB3aWR0aHM6ICd3aWR0aHMnLFxuICB3b3Jkc3BhY2luZzogJ3dvcmRTcGFjaW5nJyxcbiAgJ3dvcmQtc3BhY2luZyc6ICd3b3JkU3BhY2luZycsXG4gIHdyaXRpbmdtb2RlOiAnd3JpdGluZ01vZGUnLFxuICAnd3JpdGluZy1tb2RlJzogJ3dyaXRpbmdNb2RlJyxcbiAgeDE6ICd4MScsXG4gIHgyOiAneDInLFxuICB4OiAneCcsXG4gIHhjaGFubmVsc2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgeGhlaWdodDogJ3hIZWlnaHQnLFxuICAneC1oZWlnaHQnOiAneEhlaWdodCcsXG4gIHhsaW5rYWN0dWF0ZTogJ3hsaW5rQWN0dWF0ZScsXG4gICd4bGluazphY3R1YXRlJzogJ3hsaW5rQWN0dWF0ZScsXG4gIHhsaW5rYXJjcm9sZTogJ3hsaW5rQXJjcm9sZScsXG4gICd4bGluazphcmNyb2xlJzogJ3hsaW5rQXJjcm9sZScsXG4gIHhsaW5raHJlZjogJ3hsaW5rSHJlZicsXG4gICd4bGluazpocmVmJzogJ3hsaW5rSHJlZicsXG4gIHhsaW5rcm9sZTogJ3hsaW5rUm9sZScsXG4gICd4bGluazpyb2xlJzogJ3hsaW5rUm9sZScsXG4gIHhsaW5rc2hvdzogJ3hsaW5rU2hvdycsXG4gICd4bGluazpzaG93JzogJ3hsaW5rU2hvdycsXG4gIHhsaW5rdGl0bGU6ICd4bGlua1RpdGxlJyxcbiAgJ3hsaW5rOnRpdGxlJzogJ3hsaW5rVGl0bGUnLFxuICB4bGlua3R5cGU6ICd4bGlua1R5cGUnLFxuICAneGxpbms6dHlwZSc6ICd4bGlua1R5cGUnLFxuICB4bWxiYXNlOiAneG1sQmFzZScsXG4gICd4bWw6YmFzZSc6ICd4bWxCYXNlJyxcbiAgeG1sbGFuZzogJ3htbExhbmcnLFxuICAneG1sOmxhbmcnOiAneG1sTGFuZycsXG4gIHhtbG5zOiAneG1sbnMnLFxuICAneG1sOnNwYWNlJzogJ3htbFNwYWNlJyxcbiAgeG1sbnN4bGluazogJ3htbG5zWGxpbmsnLFxuICAneG1sbnM6eGxpbmsnOiAneG1sbnNYbGluaycsXG4gIHhtbHNwYWNlOiAneG1sU3BhY2UnLFxuICB5MTogJ3kxJyxcbiAgeTI6ICd5MicsXG4gIHk6ICd5JyxcbiAgeWNoYW5uZWxzZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxuICB6OiAneicsXG4gIHpvb21hbmRwYW46ICd6b29tQW5kUGFuJ1xufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciBFVkVOVF9OQU1FX1JFR0VYID0gL15vbi4vO1xudmFyIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vO1xudmFyIHJBUklBID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJykgO1xudmFyIHJBUklBQ2FtZWwgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJykgO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBldmVudFJlZ2lzdHJ5KSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIGVycm9yKCdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHtcbiAgICAgIC8vIEFjdGlvbnMgYXJlIHNwZWNpYWwgYmVjYXVzZSB1bmxpa2UgZXZlbnRzIHRoZXkgY2FuIGhhdmUgb3RoZXIgdmFsdWUgdHlwZXMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnZm9ybScgJiYgbmFtZSA9PT0gJ2FjdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnaW5wdXQnICYmIG5hbWUgPT09ICdmb3JtQWN0aW9uJykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdidXR0b24nICYmIG5hbWUgPT09ICdmb3JtQWN0aW9uJykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBXZSBjYW4ndCByZWx5IG9uIHRoZSBldmVudCBzeXN0ZW0gYmVpbmcgaW5qZWN0ZWQgb24gdGhlIHNlcnZlci5cblxuXG4gICAgaWYgKGV2ZW50UmVnaXN0cnkgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMgPSBldmVudFJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMsXG4gICAgICAgICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IGV2ZW50UmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcztcblxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCByZWdpc3RyYXRpb25OYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJywgbmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gJyArICdSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4nLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIExldCB0aGUgQVJJQSBhdHRyaWJ1dGUgaG9vayB2YWxpZGF0ZSBBUklBIGF0dHJpYnV0ZXNcblxuXG4gICAgaWYgKHJBUklBLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbC50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpbm5lcmh0bWwnKSB7XG4gICAgICBlcnJvcignRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2FyaWEnKSB7XG4gICAgICBlcnJvcignVGhlIGBhcmlhYCBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgaW4gUmVhY3QuICcgKyAnUGFzcyBpbmRpdmlkdWFsIGBhcmlhLWAgYXR0cmlidXRlcyBpbnN0ZWFkLicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lzJyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLicsIHR5cGVvZiB2YWx1ZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgTmFOIGZvciB0aGUgYCVzYCBhdHRyaWJ1dGUuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJywgbmFtZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBLbm93biBhdHRyaWJ1dGVzIHNob3VsZCBtYXRjaCB0aGUgY2FzaW5nIHNwZWNpZmllZCBpbiB0aGUgcHJvcGVydHkgY29uZmlnLlxuXG5cbiAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV07XG5cbiAgICAgIGlmIChzdGFuZGFyZE5hbWUgIT09IG5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgRE9NIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHN0YW5kYXJkTmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZSAhPT0gbG93ZXJDYXNlZE5hbWUpIHtcbiAgICAgIC8vIFVua25vd24gYXR0cmlidXRlcyBzaG91bGQgaGF2ZSBsb3dlcmNhc2UgY2FzaW5nIHNpbmNlIHRoYXQncyBob3cgdGhleVxuICAgICAgLy8gd2lsbCBiZSBjYXNlZCBhbnl3YXkgd2l0aCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgZXJyb3IoJ1JlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSAnICsgJ2ludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSAnICsgJ2F0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gJyArICdJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlICcgKyAnaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcblxuXG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICBjYXNlICdzdHlsZSc6XG4gICAgICBjYXNlICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnOlxuICAgICAgY2FzZSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJzpcbiAgICAgIGNhc2UgJ2RlZmF1bHRWYWx1ZSc6IC8vIFJlc2VydmVkXG5cbiAgICAgIGNhc2UgJ2RlZmF1bHRDaGVja2VkJzpcbiAgICAgIGNhc2UgJ2lubmVySFRNTCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICB7XG4gICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdhdXRvRm9jdXMnOlxuICAgICAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgICBjYXNlICdtdWx0aXBsZSc6XG4gICAgICAgICAgICBjYXNlICdtdXRlZCc6XG4gICAgICAgICAgICBjYXNlICdzZWxlY3RlZCc6XG4gICAgICAgICAgICBjYXNlICdjb250ZW50RWRpdGFibGUnOlxuICAgICAgICAgICAgY2FzZSAnc3BlbGxDaGVjayc6XG4gICAgICAgICAgICBjYXNlICdkcmFnZ2FibGUnOlxuICAgICAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgICAgY2FzZSAnYXV0b1JldmVyc2UnOlxuICAgICAgICAgICAgY2FzZSAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCc6XG4gICAgICAgICAgICBjYXNlICdmb2N1c2FibGUnOlxuICAgICAgICAgICAgY2FzZSAncHJlc2VydmVBbHBoYSc6XG4gICAgICAgICAgICBjYXNlICdhbGxvd0Z1bGxTY3JlZW4nOlxuICAgICAgICAgICAgY2FzZSAnYXN5bmMnOlxuICAgICAgICAgICAgY2FzZSAnYXV0b1BsYXknOlxuICAgICAgICAgICAgY2FzZSAnY29udHJvbHMnOlxuICAgICAgICAgICAgY2FzZSAnZGVmYXVsdCc6XG4gICAgICAgICAgICBjYXNlICdkZWZlcic6XG4gICAgICAgICAgICBjYXNlICdkaXNhYmxlZCc6XG4gICAgICAgICAgICBjYXNlICdkaXNhYmxlUGljdHVyZUluUGljdHVyZSc6XG4gICAgICAgICAgICBjYXNlICdkaXNhYmxlUmVtb3RlUGxheWJhY2snOlxuICAgICAgICAgICAgY2FzZSAnZm9ybU5vVmFsaWRhdGUnOlxuICAgICAgICAgICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgICAgICAgIGNhc2UgJ2xvb3AnOlxuICAgICAgICAgICAgY2FzZSAnbm9Nb2R1bGUnOlxuICAgICAgICAgICAgY2FzZSAnbm9WYWxpZGF0ZSc6XG4gICAgICAgICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgICAgIGNhc2UgJ3BsYXlzSW5saW5lJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlYWRPbmx5JzpcbiAgICAgICAgICAgIGNhc2UgJ3JlcXVpcmVkJzpcbiAgICAgICAgICAgIGNhc2UgJ3JldmVyc2VkJzpcbiAgICAgICAgICAgIGNhc2UgJ3Njb3BlZCc6XG4gICAgICAgICAgICBjYXNlICdzZWFtbGVzcyc6XG4gICAgICAgICAgICBjYXNlICdpdGVtU2NvcGUnOlxuICAgICAgICAgICAgY2FzZSAnY2FwdHVyZSc6XG4gICAgICAgICAgICBjYXNlICdkb3dubG9hZCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBCb29sZWFuIHByb3BlcnRpZXMgY2FuIGFjY2VwdCBib29sZWFuIHZhbHVlc1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeCA9PT0gJ2RhdGEtJyB8fCBwcmVmaXggPT09ICdhcmlhLScpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS4nLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBuYW1lLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIC8vIFdhcm4gd2hlbiBhIGtub3duIGF0dHJpYnV0ZSBpcyBhIGJhZCB0eXBlXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXYXJuIHdoZW4gcGFzc2luZyB0aGUgc3RyaW5ncyAnZmFsc2UnIG9yICd0cnVlJyBpbnRvIGEgYm9vbGVhbiBwcm9wXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnZmFsc2UnIHx8IHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgICAgICBjYXNlICdtdWx0aXBsZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ211dGVkJzpcbiAgICAgICAgICAgICAgY2FzZSAnYWxsb3dGdWxsU2NyZWVuJzpcbiAgICAgICAgICAgICAgY2FzZSAnYXN5bmMnOlxuICAgICAgICAgICAgICBjYXNlICdhdXRvUGxheSc6XG4gICAgICAgICAgICAgIGNhc2UgJ2NvbnRyb2xzJzpcbiAgICAgICAgICAgICAgY2FzZSAnZGVmYXVsdCc6XG4gICAgICAgICAgICAgIGNhc2UgJ2RlZmVyJzpcbiAgICAgICAgICAgICAgY2FzZSAnZGlzYWJsZWQnOlxuICAgICAgICAgICAgICBjYXNlICdkaXNhYmxlUGljdHVyZUluUGljdHVyZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVSZW1vdGVQbGF5YmFjayc6XG4gICAgICAgICAgICAgIGNhc2UgJ2Zvcm1Ob1ZhbGlkYXRlJzpcbiAgICAgICAgICAgICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgICAgICAgICAgY2FzZSAnbG9vcCc6XG4gICAgICAgICAgICAgIGNhc2UgJ25vTW9kdWxlJzpcbiAgICAgICAgICAgICAgY2FzZSAnbm9WYWxpZGF0ZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICAgICAgICBjYXNlICdwbGF5c0lubGluZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ3JlYWRPbmx5JzpcbiAgICAgICAgICAgICAgY2FzZSAncmVxdWlyZWQnOlxuICAgICAgICAgICAgICBjYXNlICdyZXZlcnNlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3Njb3BlZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3NlYW1sZXNzJzpcbiAgICAgICAgICAgICAgY2FzZSAnaXRlbVNjb3BlJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9yKCdSZWNlaXZlZCB0aGUgc3RyaW5nIGAlc2AgZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiAnICsgJyVzICcgKyAnRGlkIHlvdSBtZWFuICVzPXslc30/JywgdmFsdWUsIG5hbWUsIHZhbHVlID09PSAnZmFsc2UnID8gJ1RoZSBicm93c2VyIHdpbGwgaW50ZXJwcmV0IGl0IGFzIGEgdHJ1dGh5IHZhbHVlLicgOiAnQWx0aG91Z2ggdGhpcyB3b3JrcywgaXQgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZCBpZiB5b3UgcGFzcyB0aGUgc3RyaW5nIFwiZmFsc2VcIi4nLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FyblVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gIHtcbiAgICB2YXIgdW5rbm93blByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGV2ZW50UmVnaXN0cnkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciAnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gIGlmIChpc0N1c3RvbUVsZW1lbnQodHlwZSkgfHwgdHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSk7XG59XG5cbi8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbnZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG52YXIgbXNQYXR0ZXJuJDEgPSAvXi1tcy0vO1xudmFyIGh5cGhlblBhdHRlcm4gPSAvLSguKS9nOyAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cblxudmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xudmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbnZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xudmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG52YXIgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGh5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lKSB7XG4gIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCAvLyBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gICAgLy8gKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICAgIC8vIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAgICBjYW1lbGl6ZShuYW1lLnJlcGxhY2UobXNQYXR0ZXJuJDEsICdtcy0nKSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lKSB7XG4gIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoXCJTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb24uIFwiICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJywgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuXG4gICAgZXJyb3IoJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkobmFtZSwgdmFsdWUpIHtcbiAge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG5cbiAgICBlcnJvcignYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FyblZhbGlkU3R5bGUobmFtZSwgdmFsdWUpIHtcbiAge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldENyb3NzT3JpZ2luU3RyaW5nKGlucHV0KSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGlucHV0ID09PSAndXNlLWNyZWRlbnRpYWxzJyA/IGlucHV0IDogJyc7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vLyBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxudmFyIG1hdGNoSHRtbFJlZ0V4cCA9IC9bXCInJjw+XS87XG4vKipcbiAqIEVzY2FwZXMgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBIVE1MIGVudGl0aWVzIGluIGEgZ2l2ZW4gaHRtbCBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmcgSFRNTCBzdHJpbmcgdG8gZXNjYXBlIGZvciBsYXRlciBpbnNlcnRpb25cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICB7XG4gICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oc3RyaW5nKTtcbiAgfVxuXG4gIHZhciBzdHIgPSAnJyArIHN0cmluZztcbiAgdmFyIG1hdGNoID0gbWF0Y2hIdG1sUmVnRXhwLmV4ZWMoc3RyKTtcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBlc2NhcGU7XG4gIHZhciBodG1sID0gJyc7XG4gIHZhciBpbmRleDtcbiAgdmFyIGxhc3RJbmRleCA9IDA7XG5cbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgLy8gXCJcbiAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM4OlxuICAgICAgICAvLyAmXG4gICAgICAgIGVzY2FwZSA9ICcmYW1wOyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM5OlxuICAgICAgICAvLyAnXG4gICAgICAgIGVzY2FwZSA9ICcmI3gyNzsnOyAvLyBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sOyB1c2VkIHRvIGJlICcmIzM5J1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDYwOlxuICAgICAgICAvLyA8XG4gICAgICAgIGVzY2FwZSA9ICcmbHQ7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIC8vID5cbiAgICAgICAgZXNjYXBlID0gJyZndDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICBodG1sICs9IGVzY2FwZTtcbiAgfVxuXG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG59IC8vIGVuZCBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuXG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBUZXh0IHZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cblxuXG5mdW5jdGlvbiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KSB7XG4gIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB0ZXh0ID09PSAnbnVtYmVyJykge1xuICAgIC8vIHRoaXMgc2hvcnRjaXJjdWl0IGhlbHBzIHBlcmYgZm9yIHR5cGVzIHRoYXQgd2Uga25vdyB3aWxsIG5ldmVyIGhhdmVcbiAgICAvLyBzcGVjaWFsIGNoYXJhY3RlcnMsIGVzcGVjaWFsbHkgZ2l2ZW4gdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgb2Z0ZW5cbiAgICAvLyBmb3IgbnVtZXJpYyBkb20gaWRzLlxuICAgIHJldHVybiAnJyArIHRleHQ7XG4gIH1cblxuICByZXR1cm4gZXNjYXBlSHRtbCh0ZXh0KTtcbn1cblxudmFyIHVwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICovXG5cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShuYW1lKSB7XG4gIHJldHVybiBuYW1lLnJlcGxhY2UodXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbi8vIGFuZCBhbnkgbmV3bGluZSBvciB0YWIgYXJlIGZpbHRlcmVkIG91dCBhcyBpZiB0aGV5J3JlIG5vdCBwYXJ0IG9mIHRoZSBVUkwuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1wYXJzaW5nXG4vLyBUYWIgb3IgbmV3bGluZSBhcmUgZGVmaW5lZCBhcyBcXHJcXG5cXHQ6XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktdGFiLW9yLW5ld2xpbmVcbi8vIEEgQzAgY29udHJvbCBpcyBhIGNvZGUgcG9pbnQgaW4gdGhlIHJhbmdlIFxcdTAwMDAgTlVMTCB0byBcXHUwMDFGXG4vLyBJTkZPUk1BVElPTiBTRVBBUkFUT1IgT05FLCBpbmNsdXNpdmU6XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYzAtY29udHJvbC1vci1zcGFjZVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbnZhciBpc0phdmFTY3JpcHRQcm90b2NvbCA9IC9eW1xcdTAwMDAtXFx1MDAxRiBdKmpbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qdltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSpzW1xcclxcblxcdF0qY1tcXHJcXG5cXHRdKnJbXFxyXFxuXFx0XSppW1xcclxcblxcdF0qcFtcXHJcXG5cXHRdKnRbXFxyXFxuXFx0XSpcXDovaTtcbnZhciBkaWRXYXJuID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHNhbml0aXplVVJMKHVybCkge1xuICAvLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBzeW1ib2xzIGhlcmUgYmVjYXVzZSB0aGV5IGdldCBmaWx0ZXJlZCBvdXQgZWxzZXdoZXJlLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgdmFyIHN0cmluZ2lmaWVkVVJMID0gJycgKyB1cmw7XG5cbiAge1xuICAgIGlmICghZGlkV2FybiAmJiBpc0phdmFTY3JpcHRQcm90b2NvbC50ZXN0KHN0cmluZ2lmaWVkVVJMKSkge1xuICAgICAgZGlkV2FybiA9IHRydWU7XG5cbiAgICAgIGVycm9yKCdBIGZ1dHVyZSB2ZXJzaW9uIG9mIFJlYWN0IHdpbGwgYmxvY2sgamF2YXNjcmlwdDogVVJMcyBhcyBhIHNlY3VyaXR5IHByZWNhdXRpb24uICcgKyAnVXNlIGV2ZW50IGhhbmRsZXJzIGluc3RlYWQgaWYgeW91IGNhbi4gSWYgeW91IG5lZWQgdG8gZ2VuZXJhdGUgdW5zYWZlIEhUTUwgdHJ5ICcgKyAndXNpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgaW5zdGVhZC4gUmVhY3Qgd2FzIHBhc3NlZCAlcy4nLCBKU09OLnN0cmluZ2lmeShzdHJpbmdpZmllZFVSTCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1cmw7XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLy8gVGhlIGJ1aWxkIHNjcmlwdCBpcyBhdCBzY3JpcHRzL3JvbGx1cC9nZW5lcmF0ZS1pbmxpbmUtZml6ei1ydW50aW1lLmpzLlxuLy8gUnVuIGB5YXJuIGdlbmVyYXRlLWlubGluZS1maXp6LXJ1bnRpbWVgIHRvIGdlbmVyYXRlLlxudmFyIGNsaWVudFJlbmRlckJvdW5kYXJ5ID0gJyRSWD1mdW5jdGlvbihiLGMsZCxlKXt2YXIgYT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKTthJiYoYj1hLnByZXZpb3VzU2libGluZyxiLmRhdGE9XCIkIVwiLGE9YS5kYXRhc2V0LGMmJihhLmRnc3Q9YyksZCYmKGEubXNnPWQpLGUmJihhLnN0Y2s9ZSksYi5fcmVhY3RSZXRyeSYmYi5fcmVhY3RSZXRyeSgpKX07JztcbnZhciBjb21wbGV0ZUJvdW5kYXJ5ID0gJyRSQz1mdW5jdGlvbihiLGMsZSl7Yz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChjKTtjLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYyk7dmFyIGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7aWYoYSl7Yj1hLnByZXZpb3VzU2libGluZztpZihlKWIuZGF0YT1cIiQhXCIsYS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWRnc3RcIixlKTtlbHNle2U9Yi5wYXJlbnROb2RlO2E9Yi5uZXh0U2libGluZzt2YXIgZj0wO2Rve2lmKGEmJjg9PT1hLm5vZGVUeXBlKXt2YXIgZD1hLmRhdGE7aWYoXCIvJFwiPT09ZClpZigwPT09ZilicmVhaztlbHNlIGYtLTtlbHNlXCIkXCIhPT1kJiZcIiQ/XCIhPT1kJiZcIiQhXCIhPT1kfHxmKyt9ZD1hLm5leHRTaWJsaW5nO2UucmVtb3ZlQ2hpbGQoYSk7YT1kfXdoaWxlKGEpO2Zvcig7Yy5maXJzdENoaWxkOyllLmluc2VydEJlZm9yZShjLmZpcnN0Q2hpbGQsYSk7Yi5kYXRhPVwiJFwifWIuX3JlYWN0UmV0cnkmJmIuX3JlYWN0UmV0cnkoKX19Oyc7XG52YXIgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXMgPSAnJFJNPW5ldyBNYXA7XFxuJFJSPWZ1bmN0aW9uKHIsdCx3KXtmb3IodmFyIHU9JFJDLG49JFJNLHA9bmV3IE1hcCxxPWRvY3VtZW50LGcsYixoPXEucXVlcnlTZWxlY3RvckFsbChcImxpbmtbZGF0YS1wcmVjZWRlbmNlXSxzdHlsZVtkYXRhLXByZWNlZGVuY2VdXCIpLHY9W10saz0wO2I9aFtrKytdOylcIm5vdCBhbGxcIj09PWIuZ2V0QXR0cmlidXRlKFwibWVkaWFcIik/di5wdXNoKGIpOihcIkxJTktcIj09PWIudGFnTmFtZSYmbi5zZXQoYi5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLGIpLHAuc2V0KGIuZGF0YXNldC5wcmVjZWRlbmNlLGc9YikpO2I9MDtoPVtdO3ZhciBsLGE7Zm9yKGs9ITA7Oyl7aWYoayl7dmFyIGY9d1tiKytdO2lmKCFmKXtrPSExO2I9MDtjb250aW51ZX12YXIgYz0hMSxtPTA7dmFyIGQ9ZlttKytdO2lmKGE9bi5nZXQoZCkpe3ZhciBlPWEuX3A7Yz0hMH1lbHNle2E9cS5jcmVhdGVFbGVtZW50KFwibGlua1wiKTthLmhyZWY9ZDthLnJlbD1cInN0eWxlc2hlZXRcIjtmb3IoYS5kYXRhc2V0LnByZWNlZGVuY2U9XFxubD1mW20rK107ZT1mW20rK107KWEuc2V0QXR0cmlidXRlKGUsZlttKytdKTtlPWEuX3A9bmV3IFByb21pc2UoZnVuY3Rpb24oeCx5KXthLm9ubG9hZD14O2Eub25lcnJvcj15fSk7bi5zZXQoZCxhKX1kPWEuZ2V0QXR0cmlidXRlKFwibWVkaWFcIik7IWV8fFwibFwiPT09ZS5zfHxkJiYhbWF0Y2hNZWRpYShkKS5tYXRjaGVzfHxoLnB1c2goZSk7aWYoYyljb250aW51ZX1lbHNle2E9dltiKytdO2lmKCFhKWJyZWFrO2w9YS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXByZWNlZGVuY2VcIik7YS5yZW1vdmVBdHRyaWJ1dGUoXCJtZWRpYVwiKX1jPXAuZ2V0KGwpfHxnO2M9PT1nJiYoZz1hKTtwLnNldChsLGEpO2M/Yy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLGMubmV4dFNpYmxpbmcpOihjPXEuaGVhZCxjLmluc2VydEJlZm9yZShhLGMuZmlyc3RDaGlsZCkpfVByb21pc2UuYWxsKGgpLnRoZW4odS5iaW5kKG51bGwscix0LFwiXCIpLHUuYmluZChudWxsLHIsdCxcIlJlc291cmNlIGZhaWxlZCB0byBsb2FkXCIpKX07JztcbnZhciBjb21wbGV0ZVNlZ21lbnQgPSAnJFJTPWZ1bmN0aW9uKGEsYil7YT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKTtiPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2ZvcihhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSk7YS5maXJzdENoaWxkOyliLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEuZmlyc3RDaGlsZCxiKTtiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYil9Oyc7XG52YXIgZm9ybVJlcGxheWluZyA9ICdhZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsZnVuY3Rpb24oYSl7aWYoIWEuZGVmYXVsdFByZXZlbnRlZCl7dmFyIGM9YS50YXJnZXQsZD1hLnN1Ym1pdHRlcixlPWMuYWN0aW9uLGI9ZDtpZihkKXt2YXIgZj1kLmdldEF0dHJpYnV0ZShcImZvcm1BY3Rpb25cIik7bnVsbCE9ZiYmKGU9ZixiPW51bGwpfVwiamF2YXNjcmlwdDp0aHJvdyBuZXcgRXJyb3IoXFwnQSBSZWFjdCBmb3JtIHdhcyB1bmV4cGVjdGVkbHkgc3VibWl0dGVkLlxcJylcIj09PWUmJihhLnByZXZlbnREZWZhdWx0KCksYj8oYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksYS5uYW1lPWIubmFtZSxhLnZhbHVlPWIudmFsdWUsYi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLGIpLGI9bmV3IEZvcm1EYXRhKGMpLGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKSk6Yj1uZXcgRm9ybURhdGEoYyksYT1jLmdldFJvb3ROb2RlKCksKGEuJCRyZWFjdEZvcm1SZXBsYXk9YS4kJHJlYWN0Rm9ybVJlcGxheXx8W10pLnB1c2goYyxcXG5kLGIpKX19KTsnO1xuXG5mdW5jdGlvbiBnZXRWYWx1ZURlc2NyaXB0b3JFeHBlY3RpbmdPYmplY3RGb3JXYXJuaW5nKHRoaW5nKSB7XG4gIHJldHVybiB0aGluZyA9PT0gbnVsbCA/ICdgbnVsbGAnIDogdGhpbmcgPT09IHVuZGVmaW5lZCA/ICdgdW5kZWZpbmVkYCcgOiB0aGluZyA9PT0gJycgPyAnYW4gZW1wdHkgc3RyaW5nJyA6IFwic29tZXRoaW5nIHdpdGggdHlwZSBcXFwiXCIgKyB0eXBlb2YgdGhpbmcgKyBcIlxcXCJcIjtcbn1cblxuLy8gc2FtZSBvYmplY3QgYWNyb3NzIGFsbCB0cmFuc2l0aW9ucy5cblxudmFyIHNoYXJlZE5vdFBlbmRpbmdPYmplY3QgPSB7XG4gIHBlbmRpbmc6IGZhbHNlLFxuICBkYXRhOiBudWxsLFxuICBtZXRob2Q6IG51bGwsXG4gIGFjdGlvbjogbnVsbFxufTtcbnZhciBOb3RQZW5kaW5nID0gT2JqZWN0LmZyZWV6ZShzaGFyZWROb3RQZW5kaW5nT2JqZWN0KSA7XG5cbnZhciBSZWFjdERPTVNoYXJlZEludGVybmFscyA9IFJlYWN0RE9NLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG52YXIgUmVhY3RET01DdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLkRpc3BhdGNoZXI7XG52YXIgUmVhY3RET01TZXJ2ZXJEaXNwYXRjaGVyID0ge1xuICBwcmVmZXRjaEROUzogcHJlZmV0Y2hETlMsXG4gIHByZWNvbm5lY3Q6IHByZWNvbm5lY3QsXG4gIHByZWxvYWQ6IHByZWxvYWQsXG4gIHByZWxvYWRNb2R1bGU6IHByZWxvYWRNb2R1bGUsXG4gIHByZWluaXRTdHlsZTogcHJlaW5pdFN0eWxlLFxuICBwcmVpbml0U2NyaXB0OiBwcmVpbml0U2NyaXB0LFxuICBwcmVpbml0TW9kdWxlU2NyaXB0OiBwcmVpbml0TW9kdWxlU2NyaXB0XG59O1xuZnVuY3Rpb24gcHJlcGFyZUhvc3REaXNwYXRjaGVyKCkge1xuICBSZWFjdERPTUN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBSZWFjdERPTVNlcnZlckRpc3BhdGNoZXI7XG59IC8vIFdlIG1ha2UgZXZlcnkgcHJvcGVydHkgb2YgdGhlIGRlc2NyaXB0b3Igb3B0aW9uYWwgYmVjYXVzZSBpdCBpcyBub3QgYSBjb250cmFjdCB0aGF0XG52YXIgU2NyaXB0U3RyZWFtaW5nRm9ybWF0ID0gMDtcbnZhciBEYXRhU3RyZWFtaW5nRm9ybWF0ID0gMTtcbnZhciBOb3RoaW5nU2VudFxuLyogICAgICAgICAgICAgICAgICAgICAgKi9cbj0gMDtcbnZhciBTZW50Q29tcGxldGVTZWdtZW50RnVuY3Rpb25cbi8qICAgICAgKi9cbj0gMTtcbnZhciBTZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uXG4vKiAgICAgKi9cbj0gMjtcbnZhciBTZW50Q2xpZW50UmVuZGVyRnVuY3Rpb25cbi8qICAgICAgICAgKi9cbj0gNDtcbnZhciBTZW50U3R5bGVJbnNlcnRpb25GdW5jdGlvblxuLyogICAgICAgKi9cbj0gODtcbnZhciBTZW50Rm9ybVJlcGxheWluZ1J1bnRpbWVcbi8qICAgICAgICAgKi9cbj0gMTY7IC8vIFBlciByZXF1ZXN0LCBnbG9iYWwgc3RhdGUgdGhhdCBpcyBub3QgY29udGV4dHVhbCB0byB0aGUgcmVuZGVyaW5nIHN1YnRyZWUuXG4vLyBUaGlzIGNhbm5vdCBiZSByZXN1bWVkIGFuZCB0aGVyZWZvcmUgc2hvdWxkIG9ubHkgY29udGFpbiB0aGluZ3MgdGhhdCBhcmVcbi8vIHRlbXBvcmFyeSB3b3JraW5nIHN0YXRlIG9yIGFyZSBuZXZlciB1c2VkIGluIHRoZSBwcmVyZW5kZXIgcGFzcy5cbi8vIENyZWRlbnRpYWxzIGhlcmUgYXJlIHRoaW5ncyB0aGF0IGFmZmVjdCB3aGV0aGVyIGEgYnJvd3NlciB3aWxsIG1ha2UgYSByZXF1ZXN0XG4vLyBhcyB3ZWxsIGFzIHRoaW5ncyB0aGF0IGFmZmVjdCB3aGljaCBjb25uZWN0aW9uIHRoZSBicm93c2VyIHdpbGwgdXNlIGZvciB0aGF0IHJlcXVlc3QuXG4vLyBXZSB3YW50IHRoZXNlIHRvIGJlIGFsaWduZWQgYWNyb3NzIHByZWxvYWRzIGFuZCByZXNvdXJjZXMgYmVjYXVzZSBvdGhlcndpc2UgdGhlIHByZWxvYWRcbi8vIHdpbGwgYmUgd2FzdGVkLlxuLy8gV2UgaW52ZXN0aWdhdGVkIHdoZXRoZXIgcmVmZXJyZXJQb2xpY3kgc2hvdWxkIGJlIGluY2x1ZGVkIGhlcmUgYnV0IGZyb20gZXhwZXJpbWVudGF0aW9uXG4vLyBpdCBzZWVtcyB0aGF0IGJyb3dzZXJzIGRvIG5vdCB0cmVhdCB0aGlzIGFzIHBhcnQgb2YgdGhlIGh0dHAgY2FjaGUga2V5IGFuZCBkb2VzIG5vdCBhZmZlY3Rcbi8vIHdoaWNoIGNvbm5lY3Rpb24gaXMgdXNlZC5cblxudmFyIEVYSVNUUyA9IG51bGw7IC8vIFRoaXMgY29uc3RhbnQgaXMgdG8gbWFyayBwcmVsb2FkcyB0aGF0IGhhdmUgbm8gdW5pcXVlIGNyZWRlbnRpYWxzXG4vLyB0byBjb252ZXkuIEl0IHNob3VsZCBuZXZlciBiZSBjaGVja2VkIGJ5IGlkZW50aXR5IGFuZCB3ZSBzaG91bGQgbm90XG4vLyBhc3N1bWUgUHJlbG9hZCB2YWx1ZXMgaW4gUmVzdW1hYmxlU3RhdGUgZXF1YWwgdGhpcyB2YWx1ZSBiZWNhdXNlIHRoZXlcbi8vIHdpbGwgaGF2ZSBjb21lIGZyb20gc29tZSBwYXJzZWQgaW5wdXQuXG5cbnZhciBQUkVMT0FEX05PX0NSRURTID0gW107XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShQUkVMT0FEX05PX0NSRURTKTtcbn0gLy8gUGVyIHJlc3BvbnNlLCBnbG9iYWwgc3RhdGUgdGhhdCBpcyBub3QgY29udGV4dHVhbCB0byB0aGUgcmVuZGVyaW5nIHN1YnRyZWUuXG4vLyBUaGlzIGlzIHJlc3VtYWJsZSBhbmQgdGhlcmVmb3JlIHNob3VsZCBiZSBzZXJpYWxpemFibGUuXG5cblxudmFyIGRhdGFFbGVtZW50UXVvdGVkRW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj48L3RlbXBsYXRlPicpO1xudmFyIHN0YXJ0SW5saW5lU2NyaXB0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8c2NyaXB0PicpO1xudmFyIGVuZElubGluZVNjcmlwdCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9zY3JpcHQ+Jyk7XG52YXIgc3RhcnRTY3JpcHRTcmMgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzY3JpcHQgc3JjPVwiJyk7XG52YXIgc3RhcnRNb2R1bGVTcmMgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzY3JpcHQgdHlwZT1cIm1vZHVsZVwiIHNyYz1cIicpO1xudmFyIHNjcmlwdE5vbmNlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBub25jZT1cIicpO1xudmFyIHNjcmlwdEludGVnaXJ0eSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgaW50ZWdyaXR5PVwiJyk7XG52YXIgc2NyaXB0Q3Jvc3NPcmlnaW4gPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGNyb3Nzb3JpZ2luPVwiJyk7XG52YXIgZW5kQXN5bmNTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGFzeW5jPVwiXCI+PC9zY3JpcHQ+Jyk7XG4vKipcbiAqIFRoaXMgZXNjYXBpbmcgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gd29yayB3aXRoIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgYW5kIGltcG9ydE1hcCBvbmx5LlxuICogYmVjYXVzZSB3ZSBrbm93IHdlIGFyZSBlc2NhcGluZyB0aGUgZW50aXJlIHNjcmlwdC4gV2UgY2FuIGF2b2lkIGZvciBpbnN0YW5jZVxuICogZXNjYXBpbmcgaHRtbCBjb21tZW50IHN0cmluZyBzZXF1ZW5jZXMgdGhhdCBhcmUgdmFsaWQgamF2YXNjcmlwdCBhcyB3ZWxsIGJlY2F1c2VcbiAqIGlmIHRoZXJlIGFyZSBubyBzZWJzZXF1ZW50IDxzY3JpcHQgc2VxdWVuY2VzIHRoZSBodG1sIHBhcnNlciB3aWxsIG5ldmVyIGVudGVyXG4gKiBzY3JpcHQgZGF0YSBkb3VibGUgZXNjYXBlZCBzdGF0ZSAoc2VlOiBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUzL3N5bnRheC5odG1sI3NjcmlwdC1kYXRhLWRvdWJsZS1lc2NhcGVkLXN0YXRlKVxuICpcbiAqIFdoaWxlIHVudHJ1c3RlZCBzY3JpcHQgY29udGVudCBzaG91bGQgYmUgbWFkZSBzYWZlIGJlZm9yZSB1c2luZyB0aGlzIGFwaSBpdCB3aWxsXG4gKiBlbnN1cmUgdGhhdCB0aGUgc2NyaXB0IGNhbm5vdCBiZSBlYXJseSB0ZXJtaW5hdGVkIG9yIG5ldmVyIHRlcm1pbmF0ZWQgc3RhdGVcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVCb290c3RyYXBBbmRJbXBvcnRNYXBTY3JpcHRDb250ZW50KHNjcmlwdFRleHQpIHtcbiAge1xuICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKHNjcmlwdFRleHQpO1xuICB9XG5cbiAgcmV0dXJuICgnJyArIHNjcmlwdFRleHQpLnJlcGxhY2Uoc2NyaXB0UmVnZXgsIHNjcmlwdFJlcGxhY2VyKTtcbn1cblxudmFyIHNjcmlwdFJlZ2V4ID0gLyg8XFwvfDwpKHMpKGNyaXB0KS9naTtcblxudmFyIHNjcmlwdFJlcGxhY2VyID0gZnVuY3Rpb24gKG1hdGNoLCBwcmVmaXgsIHMsIHN1ZmZpeCkge1xuICByZXR1cm4gXCJcIiArIHByZWZpeCArIChzID09PSAncycgPyBcIlxcXFx1MDA3M1wiIDogXCJcXFxcdTAwNTNcIikgKyBzdWZmaXg7XG59O1xuXG52YXIgaW1wb3J0TWFwU2NyaXB0U3RhcnQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzY3JpcHQgdHlwZT1cImltcG9ydG1hcFwiPicpO1xudmFyIGltcG9ydE1hcFNjcmlwdEVuZCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9zY3JpcHQ+Jyk7IC8vIFNpbmNlIHdlIHN0b3JlIGhlYWRlcnMgYXMgc3RyaW5ncyB3ZSBkZWFsIHdpdGggdGhlaXIgbGVuZ3RoIGluIHV0ZjE2IGNvZGUgdW5pdHNcbi8vIHJhdGhlciB0aGFuIHZpc3VhbCBjaGFyYWN0ZXJzIG9yIHRoZSB1dGY4IGVuY29kaW5nIHRoYXQgaXMgdXNlZCBmb3IgbW9zdCBiaW5hcnlcbi8vIHNlcmlhbGl6YXRpb24uIFNvbWUgY29tbW9uIEhUVFAgc2VydmVycyBvbmx5IGFsbG93IGZvciBoZWFkZXJzIHRvIGJlIDRrQiBpbiBsZW5ndGguXG4vLyBXZSBjaG9vc2UgYSBkZWZhdWx0IGxlbmd0aCB0aGF0IGlzIGxpa2VseSB0byBiZSB3ZWxsIHVuZGVyIHRoaXMgYWxyZWFkeSBsaW1pdGVkIGxlbmd0aCBob3dldmVyXG4vLyBwYXRob2xvZ2ljYWwgY2FzZXMgbWF5IHN0aWxsIGNhdXNlIHRoZSB1dGYtOCBlbmNvZGluZyBvZiB0aGUgaGVhZGVycyB0byBhcHByb2FjaCB0aGlzIGxpbWl0LlxuLy8gSXQgc2hvdWxkIGFsc28gYmUgbm90ZWQgdGhhdCB0aGlzIG1heGltdW0gaXMgYSBzb2Z0IG1heGltdW0uIHdlIGhhdmUgbm90IHJlYWNoZWQgdGhlIGxpbWl0IHdlIHdpbGxcbi8vIGFsbG93IG9uZSBtb3JlIGhlYWRlciB0byBiZSBjYXB0dXJlZCB3aGljaCBtZWFucyBpbiBwcmFjdGljZSBpZiB0aGUgbGltaXQgaXMgYXBwcm9hY2hlZCBpdCB3aWxsIGJlIGV4Y2VlZGVkXG5cbnZhciBERUZBVUxUX0hFQURFUlNfQ0FQQUNJVFlfSU5fVVRGMTZfQ09ERV9VTklUUyA9IDIwMDA7IC8vIEFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIHdoYXQgd2UndmUgYWxyZWFkeSB3cml0dGVuIHNvIHdlIGNhbiByZWZlciBiYWNrIHRvIGl0LlxuLy8gaWYgcGFzc2VkIGV4dGVybmFsUnVudGltZUNvbmZpZyBhbmQgdGhlIGVuYWJsZUZpenpFeHRlcm5hbFJ1bnRpbWUgZmVhdHVyZSBmbGFnXG4vLyBpcyBzZXQsIHRoZSBzZXJ2ZXIgd2lsbCBzZW5kIGluc3RydWN0aW9ucyB2aWEgZGF0YSBhdHRyaWJ1dGVzIChpbnN0ZWFkIG9mIGlubGluZSBzY3JpcHRzKVxuXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJTdGF0ZShyZXN1bWFibGVTdGF0ZSwgbm9uY2UsIGV4dGVybmFsUnVudGltZUNvbmZpZywgaW1wb3J0TWFwLCBvbkhlYWRlcnMsIG1heEhlYWRlcnNMZW5ndGgpIHtcbiAgdmFyIGlubGluZVNjcmlwdFdpdGhOb25jZSA9IG5vbmNlID09PSB1bmRlZmluZWQgPyBzdGFydElubGluZVNjcmlwdCA6IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCBub25jZT1cIicgKyBlc2NhcGVUZXh0Rm9yQnJvd3Nlcihub25jZSkgKyAnXCI+Jyk7XG4gIHZhciBpZFByZWZpeCA9IHJlc3VtYWJsZVN0YXRlLmlkUHJlZml4O1xuICB2YXIgYm9vdHN0cmFwQ2h1bmtzID0gW107XG4gIHZhciBleHRlcm5hbFJ1bnRpbWVTY3JpcHQgPSBudWxsO1xuICB2YXIgYm9vdHN0cmFwU2NyaXB0Q29udGVudCA9IHJlc3VtYWJsZVN0YXRlLmJvb3RzdHJhcFNjcmlwdENvbnRlbnQsXG4gICAgICBib290c3RyYXBTY3JpcHRzID0gcmVzdW1hYmxlU3RhdGUuYm9vdHN0cmFwU2NyaXB0cyxcbiAgICAgIGJvb3RzdHJhcE1vZHVsZXMgPSByZXN1bWFibGVTdGF0ZS5ib290c3RyYXBNb2R1bGVzO1xuXG4gIGlmIChib290c3RyYXBTY3JpcHRDb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICBib290c3RyYXBDaHVua3MucHVzaChpbmxpbmVTY3JpcHRXaXRoTm9uY2UsIHN0cmluZ1RvQ2h1bmsoZXNjYXBlQm9vdHN0cmFwQW5kSW1wb3J0TWFwU2NyaXB0Q29udGVudChib290c3RyYXBTY3JpcHRDb250ZW50KSksIGVuZElubGluZVNjcmlwdCk7XG4gIH1cblxuICB7XG5cbiAgICBpZiAoZXh0ZXJuYWxSdW50aW1lQ29uZmlnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgZXh0ZXJuYWxSdW50aW1lQ29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBleHRlcm5hbFJ1bnRpbWVTY3JpcHQgPSB7XG4gICAgICAgICAgc3JjOiBleHRlcm5hbFJ1bnRpbWVDb25maWcsXG4gICAgICAgICAgY2h1bmtzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBwdXNoU2NyaXB0SW1wbChleHRlcm5hbFJ1bnRpbWVTY3JpcHQuY2h1bmtzLCB7XG4gICAgICAgICAgc3JjOiBleHRlcm5hbFJ1bnRpbWVDb25maWcsXG4gICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgaW50ZWdyaXR5OiB1bmRlZmluZWQsXG4gICAgICAgICAgbm9uY2U6IG5vbmNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXh0ZXJuYWxSdW50aW1lU2NyaXB0ID0ge1xuICAgICAgICAgIHNyYzogZXh0ZXJuYWxSdW50aW1lQ29uZmlnLnNyYyxcbiAgICAgICAgICBjaHVua3M6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHB1c2hTY3JpcHRJbXBsKGV4dGVybmFsUnVudGltZVNjcmlwdC5jaHVua3MsIHtcbiAgICAgICAgICBzcmM6IGV4dGVybmFsUnVudGltZUNvbmZpZy5zcmMsXG4gICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgaW50ZWdyaXR5OiBleHRlcm5hbFJ1bnRpbWVDb25maWcuaW50ZWdyaXR5LFxuICAgICAgICAgIG5vbmNlOiBub25jZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaW1wb3J0TWFwQ2h1bmtzID0gW107XG5cbiAgaWYgKGltcG9ydE1hcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIG1hcCA9IGltcG9ydE1hcDtcbiAgICBpbXBvcnRNYXBDaHVua3MucHVzaChpbXBvcnRNYXBTY3JpcHRTdGFydCk7XG4gICAgaW1wb3J0TWFwQ2h1bmtzLnB1c2goc3RyaW5nVG9DaHVuayhlc2NhcGVCb290c3RyYXBBbmRJbXBvcnRNYXBTY3JpcHRDb250ZW50KEpTT04uc3RyaW5naWZ5KG1hcCkpKSk7XG4gICAgaW1wb3J0TWFwQ2h1bmtzLnB1c2goaW1wb3J0TWFwU2NyaXB0RW5kKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAob25IZWFkZXJzICYmIHR5cGVvZiBtYXhIZWFkZXJzTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKG1heEhlYWRlcnNMZW5ndGggPD0gMCkge1xuICAgICAgICBlcnJvcignUmVhY3QgZXhwZWN0ZWQgYSBwb3NpdGl2ZSBub24temVybyBgbWF4SGVhZGVyc0xlbmd0aGAgb3B0aW9uIGJ1dCBmb3VuZCAlcyBpbnN0ZWFkLiBXaGVuIHVzaW5nIHRoZSBgb25IZWFkZXJzYCBvcHRpb24geW91IG1heSBzdXBwbHkgYW4gb3B0aW9uYWwgYG1heEhlYWRlcnNMZW5ndGhgIG9wdGlvbiBhcyB3ZWxsIGhvd2V2ZXIsIHdoZW4gc2V0dGluZyB0aGlzIHZhbHVlIHRvIHplcm8gb3IgbGVzcyBubyBoZWFkZXJzIHdpbGwgYmUgY2FwdHVyZWQuJywgbWF4SGVhZGVyc0xlbmd0aCA9PT0gMCA/ICd6ZXJvJyA6IG1heEhlYWRlcnNMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoZWFkZXJzID0gb25IZWFkZXJzID8ge1xuICAgIHByZWNvbm5lY3RzOiAnJyxcbiAgICBmb250UHJlbG9hZHM6ICcnLFxuICAgIGhpZ2hJbWFnZVByZWxvYWRzOiAnJyxcbiAgICByZW1haW5pbmdDYXBhY2l0eTogdHlwZW9mIG1heEhlYWRlcnNMZW5ndGggPT09ICdudW1iZXInID8gbWF4SGVhZGVyc0xlbmd0aCA6IERFRkFVTFRfSEVBREVSU19DQVBBQ0lUWV9JTl9VVEYxNl9DT0RFX1VOSVRTXG4gIH0gOiBudWxsO1xuICB2YXIgcmVuZGVyU3RhdGUgPSB7XG4gICAgcGxhY2Vob2xkZXJQcmVmaXg6IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhpZFByZWZpeCArICdQOicpLFxuICAgIHNlZ21lbnRQcmVmaXg6IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhpZFByZWZpeCArICdTOicpLFxuICAgIGJvdW5kYXJ5UHJlZml4OiBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoaWRQcmVmaXggKyAnQjonKSxcbiAgICBzdGFydElubGluZVNjcmlwdDogaW5saW5lU2NyaXB0V2l0aE5vbmNlLFxuICAgIGh0bWxDaHVua3M6IG51bGwsXG4gICAgaGVhZENodW5rczogbnVsbCxcbiAgICBleHRlcm5hbFJ1bnRpbWVTY3JpcHQ6IGV4dGVybmFsUnVudGltZVNjcmlwdCxcbiAgICBib290c3RyYXBDaHVua3M6IGJvb3RzdHJhcENodW5rcyxcbiAgICBvbkhlYWRlcnM6IG9uSGVhZGVycyxcbiAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgIHJlc2V0czoge1xuICAgICAgZm9udDoge30sXG4gICAgICBkbnM6IHt9LFxuICAgICAgY29ubmVjdDoge1xuICAgICAgICBkZWZhdWx0OiB7fSxcbiAgICAgICAgYW5vbnltb3VzOiB7fSxcbiAgICAgICAgY3JlZGVudGlhbHM6IHt9XG4gICAgICB9LFxuICAgICAgaW1hZ2U6IHt9LFxuICAgICAgc3R5bGU6IHt9XG4gICAgfSxcbiAgICBjaGFyc2V0Q2h1bmtzOiBbXSxcbiAgICBwcmVjb25uZWN0Q2h1bmtzOiBbXSxcbiAgICBpbXBvcnRNYXBDaHVua3M6IGltcG9ydE1hcENodW5rcyxcbiAgICBwcmVsb2FkQ2h1bmtzOiBbXSxcbiAgICBob2lzdGFibGVDaHVua3M6IFtdLFxuICAgIC8vIGNsZWFyZWQgb24gZmx1c2hcbiAgICBwcmVjb25uZWN0czogbmV3IFNldCgpLFxuICAgIGZvbnRQcmVsb2FkczogbmV3IFNldCgpLFxuICAgIGhpZ2hJbWFnZVByZWxvYWRzOiBuZXcgU2V0KCksXG4gICAgLy8gdXNlZEltYWdlUHJlbG9hZHM6IG5ldyBTZXQoKSxcbiAgICBzdHlsZXM6IG5ldyBNYXAoKSxcbiAgICBib290c3RyYXBTY3JpcHRzOiBuZXcgU2V0KCksXG4gICAgc2NyaXB0czogbmV3IFNldCgpLFxuICAgIGJ1bGtQcmVsb2FkczogbmV3IFNldCgpLFxuICAgIHByZWxvYWRzOiB7XG4gICAgICBpbWFnZXM6IG5ldyBNYXAoKSxcbiAgICAgIHN0eWxlc2hlZXRzOiBuZXcgTWFwKCksXG4gICAgICBzY3JpcHRzOiBuZXcgTWFwKCksXG4gICAgICBtb2R1bGVTY3JpcHRzOiBuZXcgTWFwKClcbiAgICB9LFxuICAgIG5vbmNlOiBub25jZSxcbiAgICAvLyBsaWtlIGEgbW9kdWxlIGdsb2JhbCBmb3IgY3VycmVudGx5IHJlbmRlcmluZyBib3VuZGFyeVxuICAgIGJvdW5kYXJ5UmVzb3VyY2VzOiBudWxsLFxuICAgIHN0eWxlc1RvSG9pc3Q6IGZhbHNlXG4gIH07XG5cbiAgaWYgKGJvb3RzdHJhcFNjcmlwdHMgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9vdHN0cmFwU2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNjcmlwdENvbmZpZyA9IGJvb3RzdHJhcFNjcmlwdHNbaV07XG4gICAgICB2YXIgc3JjID0gdm9pZCAwLFxuICAgICAgICAgIGNyb3NzT3JpZ2luID0gdm9pZCAwLFxuICAgICAgICAgIGludGVncml0eSA9IHZvaWQgMDtcbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgcmVsOiAncHJlbG9hZCcsXG4gICAgICAgIGFzOiAnc2NyaXB0JyxcbiAgICAgICAgZmV0Y2hQcmlvcml0eTogJ2xvdycsXG4gICAgICAgIG5vbmNlOiBub25jZVxuICAgICAgfTtcblxuICAgICAgaWYgKHR5cGVvZiBzY3JpcHRDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHByb3BzLmhyZWYgPSBzcmMgPSBzY3JpcHRDb25maWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wcy5ocmVmID0gc3JjID0gc2NyaXB0Q29uZmlnLnNyYztcbiAgICAgICAgcHJvcHMuaW50ZWdyaXR5ID0gaW50ZWdyaXR5ID0gdHlwZW9mIHNjcmlwdENvbmZpZy5pbnRlZ3JpdHkgPT09ICdzdHJpbmcnID8gc2NyaXB0Q29uZmlnLmludGVncml0eSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcHJvcHMuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbiA9IHR5cGVvZiBzY3JpcHRDb25maWcgPT09ICdzdHJpbmcnIHx8IHNjcmlwdENvbmZpZy5jcm9zc09yaWdpbiA9PSBudWxsID8gdW5kZWZpbmVkIDogc2NyaXB0Q29uZmlnLmNyb3NzT3JpZ2luID09PSAndXNlLWNyZWRlbnRpYWxzJyA/ICd1c2UtY3JlZGVudGlhbHMnIDogJyc7XG4gICAgICB9XG5cbiAgICAgIHByZWxvYWRCb290c3RyYXBTY3JpcHRPck1vZHVsZShyZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIHNyYywgcHJvcHMpO1xuICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goc3RhcnRTY3JpcHRTcmMsIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoc3JjKSkpO1xuXG4gICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goc2NyaXB0Tm9uY2UsIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIobm9uY2UpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW50ZWdyaXR5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChzY3JpcHRJbnRlZ2lydHksIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaW50ZWdyaXR5KSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNyb3NzT3JpZ2luID09PSAnc3RyaW5nJykge1xuICAgICAgICBib290c3RyYXBDaHVua3MucHVzaChzY3JpcHRDcm9zc09yaWdpbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcihjcm9zc09yaWdpbikpKTtcbiAgICAgIH1cblxuICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goZW5kQXN5bmNTY3JpcHQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChib290c3RyYXBNb2R1bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYm9vdHN0cmFwTW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfc2NyaXB0Q29uZmlnID0gYm9vdHN0cmFwTW9kdWxlc1tfaV07XG5cbiAgICAgIHZhciBfc3JjID0gdm9pZCAwLFxuICAgICAgICAgIF9jcm9zc09yaWdpbiA9IHZvaWQgMCxcbiAgICAgICAgICBfaW50ZWdyaXR5ID0gdm9pZCAwO1xuXG4gICAgICB2YXIgX3Byb3BzID0ge1xuICAgICAgICByZWw6ICdtb2R1bGVwcmVsb2FkJyxcbiAgICAgICAgZmV0Y2hQcmlvcml0eTogJ2xvdycsXG4gICAgICAgIG5vbmNlOiBub25jZVxuICAgICAgfTtcblxuICAgICAgaWYgKHR5cGVvZiBfc2NyaXB0Q29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBfcHJvcHMuaHJlZiA9IF9zcmMgPSBfc2NyaXB0Q29uZmlnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Byb3BzLmhyZWYgPSBfc3JjID0gX3NjcmlwdENvbmZpZy5zcmM7XG4gICAgICAgIF9wcm9wcy5pbnRlZ3JpdHkgPSBfaW50ZWdyaXR5ID0gdHlwZW9mIF9zY3JpcHRDb25maWcuaW50ZWdyaXR5ID09PSAnc3RyaW5nJyA/IF9zY3JpcHRDb25maWcuaW50ZWdyaXR5IDogdW5kZWZpbmVkO1xuICAgICAgICBfcHJvcHMuY3Jvc3NPcmlnaW4gPSBfY3Jvc3NPcmlnaW4gPSB0eXBlb2YgX3NjcmlwdENvbmZpZyA9PT0gJ3N0cmluZycgfHwgX3NjcmlwdENvbmZpZy5jcm9zc09yaWdpbiA9PSBudWxsID8gdW5kZWZpbmVkIDogX3NjcmlwdENvbmZpZy5jcm9zc09yaWdpbiA9PT0gJ3VzZS1jcmVkZW50aWFscycgPyAndXNlLWNyZWRlbnRpYWxzJyA6ICcnO1xuICAgICAgfVxuXG4gICAgICBwcmVsb2FkQm9vdHN0cmFwU2NyaXB0T3JNb2R1bGUocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBfc3JjLCBfcHJvcHMpO1xuICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goc3RhcnRNb2R1bGVTcmMsIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoX3NyYykpKTtcblxuICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHNjcmlwdE5vbmNlLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKG5vbmNlKSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIF9pbnRlZ3JpdHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHNjcmlwdEludGVnaXJ0eSwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihfaW50ZWdyaXR5KSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIF9jcm9zc09yaWdpbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYm9vdHN0cmFwQ2h1bmtzLnB1c2goc2NyaXB0Q3Jvc3NPcmlnaW4sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoX2Nyb3NzT3JpZ2luKSkpO1xuICAgICAgfVxuXG4gICAgICBib290c3RyYXBDaHVua3MucHVzaChlbmRBc3luY1NjcmlwdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlbmRlclN0YXRlO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVzdW1hYmxlU3RhdGUoaWRlbnRpZmllclByZWZpeCwgZXh0ZXJuYWxSdW50aW1lQ29uZmlnLCBib290c3RyYXBTY3JpcHRDb250ZW50LCBib290c3RyYXBTY3JpcHRzLCBib290c3RyYXBNb2R1bGVzKSB7XG4gIHZhciBpZFByZWZpeCA9IGlkZW50aWZpZXJQcmVmaXggPT09IHVuZGVmaW5lZCA/ICcnIDogaWRlbnRpZmllclByZWZpeDtcbiAgdmFyIHN0cmVhbWluZ0Zvcm1hdCA9IFNjcmlwdFN0cmVhbWluZ0Zvcm1hdDtcblxuICB7XG4gICAgaWYgKGV4dGVybmFsUnVudGltZUNvbmZpZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdHJlYW1pbmdGb3JtYXQgPSBEYXRhU3RyZWFtaW5nRm9ybWF0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaWRQcmVmaXg6IGlkUHJlZml4LFxuICAgIG5leHRGb3JtSUQ6IDAsXG4gICAgc3RyZWFtaW5nRm9ybWF0OiBzdHJlYW1pbmdGb3JtYXQsXG4gICAgYm9vdHN0cmFwU2NyaXB0Q29udGVudDogYm9vdHN0cmFwU2NyaXB0Q29udGVudCxcbiAgICBib290c3RyYXBTY3JpcHRzOiBib290c3RyYXBTY3JpcHRzLFxuICAgIGJvb3RzdHJhcE1vZHVsZXM6IGJvb3RzdHJhcE1vZHVsZXMsXG4gICAgaW5zdHJ1Y3Rpb25zOiBOb3RoaW5nU2VudCxcbiAgICBoYXNCb2R5OiBmYWxzZSxcbiAgICBoYXNIdG1sOiBmYWxzZSxcbiAgICAvLyBAVE9ETyBhZGQgYm9vdHN0cmFwIHNjcmlwdCB0byBpbXBsaWNpdCBwcmVsb2Fkc1xuICAgIC8vIHBlcnNpc3RlbnRcbiAgICB1bmtub3duUmVzb3VyY2VzOiB7fSxcbiAgICBkbnNSZXNvdXJjZXM6IHt9LFxuICAgIGNvbm5lY3RSZXNvdXJjZXM6IHtcbiAgICAgIGRlZmF1bHQ6IHt9LFxuICAgICAgYW5vbnltb3VzOiB7fSxcbiAgICAgIGNyZWRlbnRpYWxzOiB7fVxuICAgIH0sXG4gICAgaW1hZ2VSZXNvdXJjZXM6IHt9LFxuICAgIHN0eWxlUmVzb3VyY2VzOiB7fSxcbiAgICBzY3JpcHRSZXNvdXJjZXM6IHt9LFxuICAgIG1vZHVsZVVua25vd25SZXNvdXJjZXM6IHt9LFxuICAgIG1vZHVsZVNjcmlwdFJlc291cmNlczoge31cbiAgfTtcbn1cbi8vIG1vZGVzLiBXZSBvbmx5IGluY2x1ZGUgdGhlIHZhcmlhbnRzIGFzIHRoZXkgbWF0dGVyIGZvciB0aGUgc2FrZSBvZiBvdXIgcHVycG9zZXMuXG4vLyBXZSBkb24ndCBhY3R1YWxseSBwcm92aWRlIHRoZSBuYW1lc3BhY2UgdGhlcmVmb3JlIHdlIHVzZSBjb25zdGFudHMgaW5zdGVhZCBvZiB0aGUgc3RyaW5nLlxuXG52YXIgUk9PVF9IVE1MX01PREUgPSAwOyAvLyBVc2VkIGZvciB0aGUgcm9vdCBtb3N0IGVsZW1lbnQgdGFnLlxuLy8gV2UgaGF2ZSBhIGxlc3MgdGhhbiBIVE1MX0hUTUxfTU9ERSBjaGVjayBlbHNld2hlcmUuIElmIHlvdSBhZGQgbW9yZSBjYXNlcyBoZXJlLCBtYWtlIHN1cmUgaXRcbi8vIHN0aWxsIG1ha2VzIHNlbnNlXG5cbnZhciBIVE1MX0hUTUxfTU9ERSA9IDE7IC8vIFVzZWQgZm9yIHRoZSA8aHRtbD4gaWYgaXQgaXMgYXQgdGhlIHRvcCBsZXZlbC5cblxudmFyIEhUTUxfTU9ERSA9IDI7XG52YXIgU1ZHX01PREUgPSAzO1xudmFyIE1BVEhNTF9NT0RFID0gNDtcbnZhciBIVE1MX1RBQkxFX01PREUgPSA1O1xudmFyIEhUTUxfVEFCTEVfQk9EWV9NT0RFID0gNjtcbnZhciBIVE1MX1RBQkxFX1JPV19NT0RFID0gNztcbnZhciBIVE1MX0NPTEdST1VQX01PREUgPSA4OyAvLyBXZSBoYXZlIGEgZ3JlYXRlciB0aGFuIEhUTUxfVEFCTEVfTU9ERSBjaGVjayBlbHNld2hlcmUuIElmIHlvdSBhZGQgbW9yZSBjYXNlcyBoZXJlLCBtYWtlIHN1cmUgaXRcbi8vIHN0aWxsIG1ha2VzIHNlbnNlXG5cbnZhciBOT19TQ09QRSA9XG4vKiAgICAgICAgICovXG4wO1xudmFyIE5PU0NSSVBUX1NDT1BFID1cbi8qICAgKi9cbjE7XG52YXIgUElDVFVSRV9TQ09QRSA9XG4vKiAgICAqL1xuMjsgLy8gTGV0cyB1cyBrZWVwIHRyYWNrIG9mIGNvbnRleHR1YWwgc3RhdGUgYW5kIHBpY2sgaXQgYmFjayB1cCBhZnRlciBzdXNwZW5kaW5nLlxuXG5mdW5jdGlvbiBjcmVhdGVGb3JtYXRDb250ZXh0KGluc2VydGlvbk1vZGUsIHNlbGVjdGVkVmFsdWUsIHRhZ1Njb3BlKSB7XG4gIHJldHVybiB7XG4gICAgaW5zZXJ0aW9uTW9kZTogaW5zZXJ0aW9uTW9kZSxcbiAgICBzZWxlY3RlZFZhbHVlOiBzZWxlY3RlZFZhbHVlLFxuICAgIHRhZ1Njb3BlOiB0YWdTY29wZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSb290Rm9ybWF0Q29udGV4dChuYW1lc3BhY2VVUkkpIHtcbiAgdmFyIGluc2VydGlvbk1vZGUgPSBuYW1lc3BhY2VVUkkgPT09ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgPyBTVkdfTU9ERSA6IG5hbWVzcGFjZVVSSSA9PT0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnID8gTUFUSE1MX01PREUgOiBST09UX0hUTUxfTU9ERTtcbiAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoaW5zZXJ0aW9uTW9kZSwgbnVsbCwgTk9fU0NPUEUpO1xufVxuZnVuY3Rpb24gZ2V0Q2hpbGRGb3JtYXRDb250ZXh0KHBhcmVudENvbnRleHQsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ25vc2NyaXB0JzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSB8IE5PU0NSSVBUX1NDT1BFKTtcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG5cbiAgICBjYXNlICdzdmcnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoU1ZHX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuXG4gICAgY2FzZSAncGljdHVyZSc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUgfCBQSUNUVVJFX1NDT1BFKTtcblxuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoTUFUSE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuXG4gICAgY2FzZSAnZm9yZWlnbk9iamVjdCc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuICAgIC8vIFRhYmxlIHBhcmVudHMgYXJlIHNwZWNpYWwgaW4gdGhhdCB0aGVpciBjaGlsZHJlbiBjYW4gb25seSBiZSBjcmVhdGVkIGF0IGFsbCBpZiB0aGV5J3JlXG4gICAgLy8gd3JhcHBlZCBpbiBhIHRhYmxlIHBhcmVudC4gU28gd2UgbmVlZCB0byBlbmNvZGUgdGhhdCB3ZSdyZSBlbnRlcmluZyB0aGlzIG1vZGUuXG5cbiAgICBjYXNlICd0YWJsZSc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX1RBQkxFX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuXG4gICAgY2FzZSAndGhlYWQnOlxuICAgIGNhc2UgJ3Rib2R5JzpcbiAgICBjYXNlICd0Zm9vdCc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX1RBQkxFX0JPRFlfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG5cbiAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX0NPTEdST1VQX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuXG4gICAgY2FzZSAndHInOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9UQUJMRV9ST1dfTU9ERSwgbnVsbCwgcGFyZW50Q29udGV4dC50YWdTY29wZSk7XG4gIH1cblxuICBpZiAocGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlID49IEhUTUxfVEFCTEVfTU9ERSkge1xuICAgIC8vIFdoYXRldmVyIHRhZyB0aGlzIHdhcywgaXQgd2Fzbid0IGEgdGFibGUgcGFyZW50IG9yIG90aGVyIHNwZWNpYWwgcGFyZW50LCBzbyB3ZSBtdXN0IGhhdmVcbiAgICAvLyBlbnRlcmVkIHBsYWluIEhUTUwgYWdhaW4uXG4gICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcbiAgfVxuXG4gIGlmIChwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFJPT1RfSFRNTF9NT0RFKSB7XG4gICAgaWYgKHR5cGUgPT09ICdodG1sJykge1xuICAgICAgLy8gV2UndmUgZW1pdHRlZCB0aGUgcm9vdCBhbmQgaXMgbm93IGluIDxodG1sPiBtb2RlLlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9IVE1MX01PREUsIG51bGwsIHBhcmVudENvbnRleHQudGFnU2NvcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSd2ZSBlbWl0dGVkIHRoZSByb290IGFuZCBpcyBub3cgaW4gcGxhaW4gSFRNTCBtb2RlLlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBIVE1MX0hUTUxfTU9ERSkge1xuICAgIC8vIFdlJ3ZlIGVtaXR0ZWQgdGhlIGRvY3VtZW50IGVsZW1lbnQgYW5kIGlzIG5vdyBpbiBwbGFpbiBIVE1MIG1vZGUuXG4gICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsLCBwYXJlbnRDb250ZXh0LnRhZ1Njb3BlKTtcbiAgfVxuXG4gIHJldHVybiBwYXJlbnRDb250ZXh0O1xufVxuZnVuY3Rpb24gbWFrZUlkKHJlc3VtYWJsZVN0YXRlLCB0cmVlSWQsIGxvY2FsSWQpIHtcbiAgdmFyIGlkUHJlZml4ID0gcmVzdW1hYmxlU3RhdGUuaWRQcmVmaXg7XG4gIHZhciBpZCA9ICc6JyArIGlkUHJlZml4ICsgJ1InICsgdHJlZUlkOyAvLyBVbmxlc3MgdGhpcyBpcyB0aGUgZmlyc3QgaWQgYXQgdGhpcyBsZXZlbCwgYXBwZW5kIGEgbnVtYmVyIGF0IHRoZSBlbmRcbiAgLy8gdGhhdCByZXByZXNlbnRzIHRoZSBwb3NpdGlvbiBvZiB0aGlzIHVzZUlkIGhvb2sgYW1vbmcgYWxsIHRoZSB1c2VJZFxuICAvLyBob29rcyBmb3IgdGhpcyBmaWJlci5cblxuICBpZiAobG9jYWxJZCA+IDApIHtcbiAgICBpZCArPSAnSCcgKyBsb2NhbElkLnRvU3RyaW5nKDMyKTtcbiAgfVxuXG4gIHJldHVybiBpZCArICc6Jztcbn1cblxuZnVuY3Rpb24gZW5jb2RlSFRNTFRleHROb2RlKHRleHQpIHtcbiAgcmV0dXJuIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpO1xufVxuXG52YXIgdGV4dFNlcGFyYXRvciA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPCEtLSAtLT4nKTtcbmZ1bmN0aW9uIHB1c2hUZXh0SW5zdGFuY2UodGFyZ2V0LCB0ZXh0LCByZW5kZXJTdGF0ZSwgdGV4dEVtYmVkZGVkKSB7XG4gIGlmICh0ZXh0ID09PSAnJykge1xuICAgIC8vIEVtcHR5IHRleHQgZG9lc24ndCBoYXZlIGEgRE9NIG5vZGUgcmVwcmVzZW50YXRpb24gYW5kIHRoZSBoeWRyYXRpb24gaXMgYXdhcmUgb2YgdGhpcy5cbiAgICByZXR1cm4gdGV4dEVtYmVkZGVkO1xuICB9XG5cbiAgaWYgKHRleHRFbWJlZGRlZCkge1xuICAgIHRhcmdldC5wdXNoKHRleHRTZXBhcmF0b3IpO1xuICB9XG5cbiAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUodGV4dCkpKTtcbiAgcmV0dXJuIHRydWU7XG59IC8vIENhbGxlZCB3aGVuIEZpenogaXMgZG9uZSB3aXRoIGEgU2VnbWVudC4gQ3VycmVudGx5IHRoZSBvbmx5IHB1cnBvc2UgaXMgdG8gY29uZGl0aW9uYWxseVxuLy8gZW1pdCBhIHRleHQgc2VwYXJhdG9yIHdoZW4gd2UgZG9uJ3Qga25vdyBmb3Igc3VyZSBpdCBpcyBzYWZlIHRvIG9taXRcblxuZnVuY3Rpb24gcHVzaFNlZ21lbnRGaW5hbGUodGFyZ2V0LCByZW5kZXJTdGF0ZSwgbGFzdFB1c2hlZFRleHQsIHRleHRFbWJlZGRlZCkge1xuICBpZiAobGFzdFB1c2hlZFRleHQgJiYgdGV4dEVtYmVkZGVkKSB7XG4gICAgdGFyZ2V0LnB1c2godGV4dFNlcGFyYXRvcik7XG4gIH1cbn1cbnZhciBzdHlsZU5hbWVDYWNoZSA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpIHtcbiAgdmFyIGNodW5rID0gc3R5bGVOYW1lQ2FjaGUuZ2V0KHN0eWxlTmFtZSk7XG5cbiAgaWYgKGNodW5rICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY2h1bms7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpKSk7XG4gIHN0eWxlTmFtZUNhY2hlLnNldChzdHlsZU5hbWUsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBzdHlsZUF0dHJpYnV0ZVN0YXJ0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgc3R5bGU9XCInKTtcbnZhciBzdHlsZUFzc2lnbiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnOicpO1xudmFyIHN0eWxlU2VwYXJhdG9yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc7Jyk7XG5cbmZ1bmN0aW9uIHB1c2hTdHlsZUF0dHJpYnV0ZSh0YXJnZXQsIHN0eWxlKSB7XG4gIGlmICh0eXBlb2Ygc3R5bGUgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsICcgKyBcIm5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyAnZW0nfX0gd2hlbiBcIiArICd1c2luZyBKU1guJyk7XG4gIH1cblxuICB2YXIgaXNGaXJzdCA9IHRydWU7XG5cbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHN0eWxlLCBzdHlsZU5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3QgYXJiaXRyYXJ5IENTU1xuICAgIC8vIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAgIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAgIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuXG4gICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZVtzdHlsZU5hbWVdO1xuXG4gICAgaWYgKHN0eWxlVmFsdWUgPT0gbnVsbCB8fCB0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHN0eWxlVmFsdWUgPT09ICcnKSB7XG4gICAgICAvLyBUT0RPOiBXZSB1c2VkIHRvIHNldCBlbXB0eSBzdHJpbmcgYXMgYSBzdHlsZSB3aXRoIGFuIGVtcHR5IHZhbHVlLiBEb2VzIHRoYXQgZXZlciBtYWtlIHNlbnNlP1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG5hbWVDaHVuayA9IHZvaWQgMDtcbiAgICB2YXIgdmFsdWVDaHVuayA9IHZvaWQgMDtcbiAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuXG4gICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgIG5hbWVDaHVuayA9IHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoc3R5bGVOYW1lKSk7XG5cbiAgICAgIHtcbiAgICAgICAgY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHN0eWxlVmFsdWUsIHN0eWxlTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlQ2h1bmsgPSBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCgnJyArIHN0eWxlVmFsdWUpLnRyaW0oKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIG5hbWVDaHVuayA9IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKTtcblxuICAgICAgaWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoc3R5bGVWYWx1ZSAhPT0gMCAmJiAhaXNVbml0bGVzc051bWJlcihzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgdmFsdWVDaHVuayA9IHN0cmluZ1RvQ2h1bmsoc3R5bGVWYWx1ZSArICdweCcpOyAvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlQ2h1bmsgPSBzdHJpbmdUb0NodW5rKCcnICsgc3R5bGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24oc3R5bGVWYWx1ZSwgc3R5bGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlQ2h1bmsgPSBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCgnJyArIHN0eWxlVmFsdWUpLnRyaW0oKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICBpc0ZpcnN0ID0gZmFsc2U7IC8vIElmIGl0J3MgZmlyc3QsIHdlIGRvbid0IG5lZWQgYW55IHNlcGFyYXRvcnMgcHJlZml4ZWQuXG5cbiAgICAgIHRhcmdldC5wdXNoKHN0eWxlQXR0cmlidXRlU3RhcnQsIG5hbWVDaHVuaywgc3R5bGVBc3NpZ24sIHZhbHVlQ2h1bmspO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQucHVzaChzdHlsZVNlcGFyYXRvciwgbmFtZUNodW5rLCBzdHlsZUFzc2lnbiwgdmFsdWVDaHVuayk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc0ZpcnN0KSB7XG4gICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlRW5kKTtcbiAgfVxufVxuXG52YXIgYXR0cmlidXRlU2VwYXJhdG9yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgJyk7XG52YXIgYXR0cmlidXRlQXNzaWduID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc9XCInKTtcbnZhciBhdHRyaWJ1dGVFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiJyk7XG52YXIgYXR0cmlidXRlRW1wdHlTdHJpbmcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJz1cIlwiJyk7XG5cbmZ1bmN0aW9uIHB1c2hCb29sZWFuQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgdmFsdWUpIC8vIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxue1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N5bWJvbCcpIHtcbiAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsobmFtZSksIGF0dHJpYnV0ZUVtcHR5U3RyaW5nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgdmFsdWUpIC8vIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxue1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N5bWJvbCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsobmFtZSksIGF0dHJpYnV0ZUFzc2lnbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VGb3JtRmllbGRQcmVmaXgocmVzdW1hYmxlU3RhdGUpIHtcbiAgdmFyIGlkID0gcmVzdW1hYmxlU3RhdGUubmV4dEZvcm1JRCsrO1xuICByZXR1cm4gcmVzdW1hYmxlU3RhdGUuaWRQcmVmaXggKyBpZDtcbn0gLy8gU2luY2UgdGhpcyB3aWxsIGxpa2VseSBiZSByZXBlYXRlZCBhIGxvdCBpbiB0aGUgSFRNTCwgd2UgdXNlIGEgbW9yZSBjb25jaXNlIG1lc3NhZ2Vcbi8vIHRoYW4gb24gdGhlIGNsaWVudCBhbmQgaG9wZWZ1bGx5IGl0J3MgZ29vZ2xlYWJsZS5cblxuXG52YXIgYWN0aW9uSmF2YVNjcmlwdFVSTCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlciggLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNjcmlwdC11cmxcblwiamF2YXNjcmlwdDp0aHJvdyBuZXcgRXJyb3IoJ0EgUmVhY3QgZm9ybSB3YXMgdW5leHBlY3RlZGx5IHN1Ym1pdHRlZC4nKVwiKSk7XG52YXIgc3RhcnRIaWRkZW5JbnB1dENodW5rID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8aW5wdXQgdHlwZT1cImhpZGRlblwiJyk7XG5cbmZ1bmN0aW9uIHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkKHZhbHVlLCBrZXkpIHtcbiAgdmFyIHRhcmdldCA9IHRoaXM7XG4gIHRhcmdldC5wdXNoKHN0YXJ0SGlkZGVuSW5wdXRDaHVuayk7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbGUvQmxvYiBmaWVsZHMgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIGluIHByb2dyZXNzaXZlIGZvcm1zLiAnICsgJ0l0IHByb2JhYmx5IG1lYW5zIHlvdSBhcmUgY2xvc2luZyBvdmVyIGJpbmFyeSBkYXRhIG9yIEZvcm1EYXRhIGluIGEgU2VydmVyIEFjdGlvbi4nKTtcbiAgfVxuXG4gIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAnbmFtZScsIGtleSk7XG4gIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAndmFsdWUnLCB2YWx1ZSk7XG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyk7XG59XG5cbmZ1bmN0aW9uIHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkcyh0YXJnZXQsIGZvcm1EYXRhKSB7XG4gIGlmIChmb3JtRGF0YSAhPT0gbnVsbCkge1xuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogRm9ybURhdGEgaGFzIGZvckVhY2guXG4gICAgZm9ybURhdGEuZm9yRWFjaChwdXNoQWRkaXRpb25hbEZvcm1GaWVsZCwgdGFyZ2V0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoRm9ybUFjdGlvbkF0dHJpYnV0ZSh0YXJnZXQsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUsIGZvcm1NZXRob2QsIGZvcm1UYXJnZXQsIG5hbWUpIHtcbiAgdmFyIGZvcm1EYXRhID0gbnVsbDtcblxuICBpZiAodHlwZW9mIGZvcm1BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBGdW5jdGlvbiBmb3JtIGFjdGlvbnMgY2Fubm90IGNvbnRyb2wgdGhlIGZvcm0gcHJvcGVydGllc1xuICAgIHtcbiAgICAgIGlmIChuYW1lICE9PSBudWxsICYmICFkaWRXYXJuRm9ybUFjdGlvbk5hbWUpIHtcbiAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25OYW1lID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignQ2Fubm90IHNwZWNpZnkgYSBcIm5hbWVcIiBwcm9wIGZvciBhIGJ1dHRvbiB0aGF0IHNwZWNpZmllcyBhIGZ1bmN0aW9uIGFzIGEgZm9ybUFjdGlvbi4gJyArICdSZWFjdCBuZWVkcyBpdCB0byBlbmNvZGUgd2hpY2ggYWN0aW9uIHNob3VsZCBiZSBpbnZva2VkLiBJdCB3aWxsIGdldCBvdmVycmlkZGVuLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGZvcm1FbmNUeXBlICE9PSBudWxsIHx8IGZvcm1NZXRob2QgIT09IG51bGwpICYmICFkaWRXYXJuRm9ybUFjdGlvbk1ldGhvZCkge1xuICAgICAgICBkaWRXYXJuRm9ybUFjdGlvbk1ldGhvZCA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ0Nhbm5vdCBzcGVjaWZ5IGEgZm9ybUVuY1R5cGUgb3IgZm9ybU1ldGhvZCBmb3IgYSBidXR0b24gdGhhdCBzcGVjaWZpZXMgYSAnICsgJ2Z1bmN0aW9uIGFzIGEgZm9ybUFjdGlvbi4gUmVhY3QgcHJvdmlkZXMgdGhvc2UgYXV0b21hdGljYWxseS4gVGhleSB3aWxsIGdldCBvdmVycmlkZGVuLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9ybVRhcmdldCAhPT0gbnVsbCAmJiAhZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQpIHtcbiAgICAgICAgZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQgPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdDYW5ub3Qgc3BlY2lmeSBhIGZvcm1UYXJnZXQgZm9yIGEgYnV0dG9uIHRoYXQgc3BlY2lmaWVzIGEgZnVuY3Rpb24gYXMgYSBmb3JtQWN0aW9uLiAnICsgJ1RoZSBmdW5jdGlvbiB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSB3aW5kb3cuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGN1c3RvbUFjdGlvbiA9IGZvcm1BY3Rpb24uJCRGT1JNX0FDVElPTjtcblxuICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGFjdGlvbiBoYXMgYSBjdXN0b20gcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQgZm9ybSB0aGF0IGNhbiBzdWJtaXQgdGhlIGZvcm1cbiAgICAgIC8vIGJhY2sgdG8gdGhlIHNlcnZlciBpZiBpdCdzIGludm9rZWQgYmVmb3JlIGh5ZHJhdGlvbi4gU3VjaCBhcyBhIFNlcnZlciBBY3Rpb24uXG4gICAgICB2YXIgcHJlZml4ID0gbWFrZUZvcm1GaWVsZFByZWZpeChyZXN1bWFibGVTdGF0ZSk7XG4gICAgICB2YXIgY3VzdG9tRmllbGRzID0gZm9ybUFjdGlvbi4kJEZPUk1fQUNUSU9OKHByZWZpeCk7XG4gICAgICBuYW1lID0gY3VzdG9tRmllbGRzLm5hbWU7XG4gICAgICBmb3JtQWN0aW9uID0gY3VzdG9tRmllbGRzLmFjdGlvbiB8fCAnJztcbiAgICAgIGZvcm1FbmNUeXBlID0gY3VzdG9tRmllbGRzLmVuY1R5cGU7XG4gICAgICBmb3JtTWV0aG9kID0gY3VzdG9tRmllbGRzLm1ldGhvZDtcbiAgICAgIGZvcm1UYXJnZXQgPSBjdXN0b21GaWVsZHMudGFyZ2V0O1xuICAgICAgZm9ybURhdGEgPSBjdXN0b21GaWVsZHMuZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0IGEgamF2YXNjcmlwdCBVUkwgdGhhdCBkb2Vzbid0IGRvIGFueXRoaW5nLiBXZSBkb24ndCBleHBlY3QgdGhpcyB0byBiZSBpbnZva2VkXG4gICAgICAvLyBiZWNhdXNlIHdlJ2xsIHByZXZlbnREZWZhdWx0IGluIHRoZSBGaXp6IHJ1bnRpbWUsIGJ1dCBpdCBjYW4gaGFwcGVuIGlmIGEgZm9ybSBpc1xuICAgICAgLy8gbWFudWFsbHkgc3VibWl0dGVkIG9yIGlmIHNvbWVvbmUgY2FsbHMgc3RvcFByb3BhZ2F0aW9uIGJlZm9yZSBSZWFjdCBnZXRzIHRoZSBldmVudC5cbiAgICAgIC8vIElmIENTUCBpcyB1c2VkIHRvIGJsb2NrIGphdmFzY3JpcHQ6IFVSTHMgdGhhdCdzIGZpbmUgdG9vLiBJdCBqdXN0IHdvbid0IHNob3cgdGhpc1xuICAgICAgLy8gZXJyb3IgbWVzc2FnZSBidXQgdGhlIFVSTCB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuaygnZm9ybUFjdGlvbicpLCBhdHRyaWJ1dGVBc3NpZ24sIGFjdGlvbkphdmFTY3JpcHRVUkwsIGF0dHJpYnV0ZUVuZCk7XG4gICAgICBuYW1lID0gbnVsbDtcbiAgICAgIGZvcm1BY3Rpb24gPSBudWxsO1xuICAgICAgZm9ybUVuY1R5cGUgPSBudWxsO1xuICAgICAgZm9ybU1ldGhvZCA9IG51bGw7XG4gICAgICBmb3JtVGFyZ2V0ID0gbnVsbDtcbiAgICAgIGluamVjdEZvcm1SZXBsYXlpbmdSdW50aW1lKHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAnbmFtZScsIG5hbWUpO1xuICB9XG5cbiAgaWYgKGZvcm1BY3Rpb24gIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAnZm9ybUFjdGlvbicsIGZvcm1BY3Rpb24pO1xuICB9XG5cbiAgaWYgKGZvcm1FbmNUeXBlICE9IG51bGwpIHtcbiAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgJ2Zvcm1FbmNUeXBlJywgZm9ybUVuY1R5cGUpO1xuICB9XG5cbiAgaWYgKGZvcm1NZXRob2QgIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAnZm9ybU1ldGhvZCcsIGZvcm1NZXRob2QpO1xuICB9XG5cbiAgaWYgKGZvcm1UYXJnZXQgIT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAnZm9ybVRhcmdldCcsIGZvcm1UYXJnZXQpO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1EYXRhO1xufVxuXG5mdW5jdGlvbiBwdXNoQXR0cmlidXRlKHRhcmdldCwgbmFtZSwgdmFsdWUpIC8vIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxue1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAvLyBUaGVzZSBhcmUgdmVyeSBjb21tb24gcHJvcHMgYW5kIHRoZXJlZm9yZSBhcmUgaW4gdGhlIGJlZ2lubmluZyBvZiB0aGUgc3dpdGNoLlxuICAgIC8vIFRPRE86IGFyaWEtbGFiZWwgaXMgYSB2ZXJ5IGNvbW1vbiBwcm9wIGJ1dCBhbGxvd3MgYm9vbGVhbnMgc28gaXMgbm90IGxpa2UgdGhlIG90aGVyc1xuICAgIC8vIGJ1dCBzaG91bGQgaWRlYWxseSBnbyBpbiB0aGlzIGxpc3QgdG9vLlxuICAgIGNhc2UgJ2NsYXNzTmFtZSc6XG4gICAgICB7XG4gICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAnY2xhc3MnLCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAndGFiSW5kZXgnOlxuICAgICAge1xuICAgICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3RhYmluZGV4JywgdmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ2Rpcic6XG4gICAgY2FzZSAncm9sZSc6XG4gICAgY2FzZSAndmlld0JveCc6XG4gICAgY2FzZSAnd2lkdGgnOlxuICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICB7XG4gICAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc3R5bGUnOlxuICAgICAge1xuICAgICAgICBwdXNoU3R5bGVBdHRyaWJ1dGUodGFyZ2V0LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3NyYyc6XG4gICAgY2FzZSAnaHJlZic6XG4gICAgLy8gRmFsbCB0aHJvdWdoIHRvIHRoZSBsYXN0IGNhc2Ugd2hpY2ggc2hvdWxkbid0IHJlbW92ZSBlbXB0eSBzdHJpbmdzLlxuXG4gICAgY2FzZSAnYWN0aW9uJzpcbiAgICBjYXNlICdmb3JtQWN0aW9uJzpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogQ29uc2lkZXIgb25seSBzcGVjaWFsIGNhc2luZyB0aGVzZSBmb3IgZWFjaCB0YWcuXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNhbml0aXplZFZhbHVlID0gc2FuaXRpemVVUkwoJycgKyB2YWx1ZSk7XG4gICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHNhbml0aXplZFZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2RlZmF1bHRWYWx1ZSc6XG4gICAgY2FzZSAnZGVmYXVsdENoZWNrZWQnOiAvLyBUaGVzZSBzaG91bGRuJ3QgYmUgc2V0IGFzIGF0dHJpYnV0ZXMgb24gZ2VuZXJpYyBIVE1MIGVsZW1lbnRzLlxuXG4gICAgY2FzZSAnaW5uZXJIVE1MJzogLy8gTXVzdCB1c2UgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgaW5zdGVhZC5cblxuICAgIGNhc2UgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc6XG4gICAgY2FzZSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJzpcbiAgICAgIC8vIElnbm9yZWQuIFRoZXNlIGFyZSBidWlsdC1pbiB0byBSZWFjdCBvbiB0aGUgY2xpZW50LlxuICAgICAgcmV0dXJuO1xuXG4gICAgY2FzZSAnYXV0b0ZvY3VzJzpcbiAgICBjYXNlICdtdWx0aXBsZSc6XG4gICAgY2FzZSAnbXV0ZWQnOlxuICAgICAge1xuICAgICAgICBwdXNoQm9vbGVhbkF0dHJpYnV0ZSh0YXJnZXQsIG5hbWUudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlICd4bGlua0hyZWYnOlxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3Nhbml0aXplZFZhbHVlID0gc2FuaXRpemVVUkwoJycgKyB2YWx1ZSk7XG5cbiAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKCd4bGluazpocmVmJyksIGF0dHJpYnV0ZUFzc2lnbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcihfc2FuaXRpemVkVmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAnY29udGVudEVkaXRhYmxlJzpcbiAgICBjYXNlICdzcGVsbENoZWNrJzpcbiAgICBjYXNlICdkcmFnZ2FibGUnOlxuICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICBjYXNlICdhdXRvUmV2ZXJzZSc6XG4gICAgY2FzZSAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCc6XG4gICAgY2FzZSAnZm9jdXNhYmxlJzpcbiAgICBjYXNlICdwcmVzZXJ2ZUFscGhhJzpcbiAgICAgIHtcbiAgICAgICAgLy8gQm9vbGVhbmlzaCBTdHJpbmdcbiAgICAgICAgLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbiAgICAgICAgLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuICAgICAgICAvLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsobmFtZSksIGF0dHJpYnV0ZUFzc2lnbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAnYWxsb3dGdWxsU2NyZWVuJzpcbiAgICBjYXNlICdhc3luYyc6XG4gICAgY2FzZSAnYXV0b1BsYXknOlxuICAgIGNhc2UgJ2NvbnRyb2xzJzpcbiAgICBjYXNlICdkZWZhdWx0JzpcbiAgICBjYXNlICdkZWZlcic6XG4gICAgY2FzZSAnZGlzYWJsZWQnOlxuICAgIGNhc2UgJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJzpcbiAgICBjYXNlICdkaXNhYmxlUmVtb3RlUGxheWJhY2snOlxuICAgIGNhc2UgJ2Zvcm1Ob1ZhbGlkYXRlJzpcbiAgICBjYXNlICdoaWRkZW4nOlxuICAgIGNhc2UgJ2xvb3AnOlxuICAgIGNhc2UgJ25vTW9kdWxlJzpcbiAgICBjYXNlICdub1ZhbGlkYXRlJzpcbiAgICBjYXNlICdvcGVuJzpcbiAgICBjYXNlICdwbGF5c0lubGluZSc6XG4gICAgY2FzZSAncmVhZE9ubHknOlxuICAgIGNhc2UgJ3JlcXVpcmVkJzpcbiAgICBjYXNlICdyZXZlcnNlZCc6XG4gICAgY2FzZSAnc2NvcGVkJzpcbiAgICBjYXNlICdzZWFtbGVzcyc6XG4gICAgY2FzZSAnaXRlbVNjb3BlJzpcbiAgICAgIHtcbiAgICAgICAgLy8gQm9vbGVhblxuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsobmFtZSksIGF0dHJpYnV0ZUVtcHR5U3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2NhcHR1cmUnOlxuICAgIGNhc2UgJ2Rvd25sb2FkJzpcbiAgICAgIHtcbiAgICAgICAgLy8gT3ZlcmxvYWRlZCBCb29sZWFuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlRW1wdHlTdHJpbmcpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBmYWxzZSkgOyBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlICdjb2xzJzpcbiAgICBjYXNlICdyb3dzJzpcbiAgICBjYXNlICdzaXplJzpcbiAgICBjYXNlICdzcGFuJzpcbiAgICAgIHtcbiAgICAgICAgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtYmVycy5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdzeW1ib2wnICYmICFpc05hTih2YWx1ZSkgJiYgdmFsdWUgPj0gMSkge1xuICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlICdyb3dTcGFuJzpcbiAgICBjYXNlICdzdGFydCc6XG4gICAgICB7XG4gICAgICAgIC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIG51bWJlcnMuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJyAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3hsaW5rQWN0dWF0ZSc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3hsaW5rOmFjdHVhdGUnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bGlua0FyY3JvbGUnOlxuICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICd4bGluazphcmNyb2xlJywgdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuXG4gICAgY2FzZSAneGxpbmtSb2xlJzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneGxpbms6cm9sZScsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3hsaW5rU2hvdyc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3hsaW5rOnNob3cnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bGlua1RpdGxlJzpcbiAgICAgIHB1c2hTdHJpbmdBdHRyaWJ1dGUodGFyZ2V0LCAneGxpbms6dGl0bGUnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd4bGlua1R5cGUnOlxuICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICd4bGluazp0eXBlJywgdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuXG4gICAgY2FzZSAneG1sQmFzZSc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3htbDpiYXNlJywgdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuXG4gICAgY2FzZSAneG1sTGFuZyc6XG4gICAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ3htbDpsYW5nJywgdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuXG4gICAgY2FzZSAneG1sU3BhY2UnOlxuICAgICAgcHVzaFN0cmluZ0F0dHJpYnV0ZSh0YXJnZXQsICd4bWw6c3BhY2UnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKCAvLyBzaG91bGRJZ25vcmVBdHRyaWJ1dGVcbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBmaWx0ZXJlZCBvdXQgbnVsbC91bmRlZmluZWQgYW5kIHJlc2VydmVkIHdvcmRzLlxuICAgICAgbmFtZS5sZW5ndGggPiAyICYmIChuYW1lWzBdID09PSAnbycgfHwgbmFtZVswXSA9PT0gJ08nKSAmJiAobmFtZVsxXSA9PT0gJ24nIHx8IG5hbWVbMV0gPT09ICdOJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IGdldEF0dHJpYnV0ZUFsaWFzKG5hbWUpO1xuXG4gICAgICBpZiAoaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAvLyBzaG91bGRSZW1vdmVBdHRyaWJ1dGVcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDUpO1xuXG4gICAgICAgICAgICAgIGlmIChwcmVmaXggIT09ICdkYXRhLScgJiYgcHJlZml4ICE9PSAnYXJpYS0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsoYXR0cmlidXRlTmFtZSksIGF0dHJpYnV0ZUFzc2lnbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgfVxuXG4gIH1cbn1cblxudmFyIGVuZE9mU3RhcnRUYWcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJz4nKTtcbnZhciBlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJy8+Jyk7XG5cbmZ1bmN0aW9uIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKSB7XG4gIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5uZXJIVE1MICE9PSAnb2JqZWN0JyB8fCAhKCdfX2h0bWwnIGluIGlubmVySFRNTCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gJyArICdQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rhbmdlcm91c2x5LXNldC1pbm5lci1odG1sICcgKyAnZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGh0bWwgPSBpbm5lckhUTUwuX19odG1sO1xuXG4gICAgaWYgKGh0bWwgIT09IG51bGwgJiYgaHRtbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKGh0bWwpO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKCcnICsgaHRtbCkpO1xuICAgIH1cbiAgfVxufSAvLyBUT0RPOiBNb3ZlIHRoZXNlIHRvIFJlbmRlclN0YXRlIHNvIHRoYXQgd2Ugd2FybiBmb3IgZXZlcnkgcmVxdWVzdC5cbi8vIEl0IHdvdWxkIGhlbHAgZGVidWdnaW5nIGluIHN0YXRlZnVsIHNlcnZlcnMgKGUuZy4gc2VydmljZSB3b3JrZXIpLlxuXG5cbnZhciBkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MID0gZmFsc2U7XG52YXIgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSBmYWxzZTtcbnZhciBkaWRXYXJuRm9ybUFjdGlvblR5cGUgPSBmYWxzZTtcbnZhciBkaWRXYXJuRm9ybUFjdGlvbk5hbWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuRm9ybUFjdGlvblRhcmdldCA9IGZhbHNlO1xudmFyIGRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgcHJvcE5hbWUpIHtcbiAge1xuICAgIHZhciB2YWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YXIgYXJyYXkgPSBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFhcnJheSkge1xuICAgICAgICBlcnJvcignVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLicsIHByb3BOYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoIXByb3BzLm11bHRpcGxlICYmIGFycmF5KSB7XG4gICAgICAgIGVycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLicsIHByb3BOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0U2VsZWN0KHRhcmdldCwgcHJvcHMpIHtcbiAge1xuICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ3NlbGVjdCcsIHByb3BzKTtcbiAgICBjaGVja1NlbGVjdFByb3AocHJvcHMsICd2YWx1ZScpO1xuICAgIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgJ2RlZmF1bHRWYWx1ZScpO1xuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUpIHtcbiAgICAgIGVycm9yKCdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ3NlbGVjdCcpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIC8vIFRPRE86IFRoaXMgZG9lc24ndCByZWFsbHkgbWFrZSBzZW5zZSBmb3Igc2VsZWN0IHNpbmNlIGl0IGNhbid0IHVzZSB0aGUgY29udHJvbGxlZFxuICAgICAgICAgIC8vIHZhbHVlIGluIHRoZSBpbm5lckhUTUwuXG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RlZmF1bHRWYWx1ZSc6XG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAvLyBUaGVzZSBhcmUgc2V0IG9uIHRoZSBDb250ZXh0IGluc3RlYWQgYW5kIGFwcGxpZWQgdG8gdGhlIG5lc3RlZCBvcHRpb25zLlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJzsgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZW50ICs9IGNoaWxkO1xuXG4gICAge1xuICAgICAgaWYgKCFkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuICYmIHR5cGVvZiBjaGlsZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGNoaWxkICE9PSAnbnVtYmVyJykge1xuICAgICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignQ2Fubm90IGluZmVyIHRoZSBvcHRpb24gdmFsdWUgb2YgY29tcGxleCBjaGlsZHJlbi4gJyArICdQYXNzIGEgYHZhbHVlYCBwcm9wIG9yIHVzZSBhIHBsYWluIHN0cmluZyBhcyBjaGlsZHJlbiB0byA8b3B0aW9uPi4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY29udGVudDtcbn1cblxudmFyIHNlbGVjdGVkTWFya2VyQXR0cmlidXRlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgc2VsZWN0ZWQ9XCJcIicpO1xuXG5mdW5jdGlvbiBwdXNoU3RhcnRPcHRpb24odGFyZ2V0LCBwcm9wcywgZm9ybWF0Q29udGV4dCkge1xuICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IGZvcm1hdENvbnRleHQuc2VsZWN0ZWRWYWx1ZTtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygnb3B0aW9uJykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgdmFsdWUgPSBudWxsO1xuICB2YXIgc2VsZWN0ZWQgPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzZWxlY3RlZCc6XG4gICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgc2VsZWN0ZWQgPSBwcm9wVmFsdWU7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAgICAgICAgICAgIGlmICghZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24pIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpO1xuXG4gICAgICAgICAgICAgIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICB2YWx1ZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSBmYWxsdGhyb3VnaCB0byBhbHNvIHNldCB0aGUgYXR0cmlidXRlIG9uIHRoZSBub2RlLlxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGVjdGVkVmFsdWUgIT0gbnVsbCkge1xuICAgIHZhciBzdHJpbmdWYWx1ZTtcblxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCAndmFsdWUnKTtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGlmIChpbm5lckhUTUwgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIWRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MKSB7XG4gICAgICAgICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbklubmVySFRNTCA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdQYXNzIGEgYHZhbHVlYCBwcm9wIGlmIHlvdSBzZXQgZGFuZ2Vyb3VzbHlJbm5lckhUTUwgc28gUmVhY3Qga25vd3MgJyArICd3aGljaCB2YWx1ZSBzaG91bGQgYmUgc2VsZWN0ZWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0cmluZ1ZhbHVlID0gZmxhdHRlbk9wdGlvbkNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShzZWxlY3RlZFZhbHVlKSkge1xuICAgICAgLy8gbXVsdGlwbGVcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihzZWxlY3RlZFZhbHVlW2ldLCAndmFsdWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2ID0gJycgKyBzZWxlY3RlZFZhbHVlW2ldO1xuXG4gICAgICAgIGlmICh2ID09PSBzdHJpbmdWYWx1ZSkge1xuICAgICAgICAgIHRhcmdldC5wdXNoKHNlbGVjdGVkTWFya2VyQXR0cmlidXRlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oc2VsZWN0ZWRWYWx1ZSwgJ3NlbGVjdC52YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoJycgKyBzZWxlY3RlZFZhbHVlID09PSBzdHJpbmdWYWx1ZSkge1xuICAgICAgICB0YXJnZXQucHVzaChzZWxlY3RlZE1hcmtlckF0dHJpYnV0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHNlbGVjdGVkKSB7XG4gICAgdGFyZ2V0LnB1c2goc2VsZWN0ZWRNYXJrZXJBdHRyaWJ1dGUpO1xuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG52YXIgZm9ybVJlcGxheWluZ1J1bnRpbWVTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoZm9ybVJlcGxheWluZyk7XG5cbmZ1bmN0aW9uIGluamVjdEZvcm1SZXBsYXlpbmdSdW50aW1lKHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSkge1xuICAvLyBJZiB3ZSBoYXZlbid0IHNlbnQgaXQgeWV0LCBpbmplY3QgdGhlIHJ1bnRpbWUgdGhhdCB0cmFja3Mgc3VibWl0dGVkIEpTIGFjdGlvbnNcbiAgLy8gZm9yIGxhdGVyIHJlcGxheWluZyBieSBGaWJlci4gSWYgd2UgdXNlIGFuIGV4dGVybmFsIHJ1bnRpbWUsIHdlIGRvbid0IG5lZWRcbiAgLy8gdG8gZW1pdCBhbnl0aGluZy4gSXQncyBhbHdheXMgdXNlZC5cbiAgaWYgKChyZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgJiBTZW50Rm9ybVJlcGxheWluZ1J1bnRpbWUpID09PSBOb3RoaW5nU2VudCAmJiAoIXJlbmRlclN0YXRlLmV4dGVybmFsUnVudGltZVNjcmlwdCkpIHtcbiAgICByZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudEZvcm1SZXBsYXlpbmdSdW50aW1lO1xuICAgIHJlbmRlclN0YXRlLmJvb3RzdHJhcENodW5rcy51bnNoaWZ0KHJlbmRlclN0YXRlLnN0YXJ0SW5saW5lU2NyaXB0LCBmb3JtUmVwbGF5aW5nUnVudGltZVNjcmlwdCwgZW5kSW5saW5lU2NyaXB0KTtcbiAgfVxufVxuXG52YXIgZm9ybVN0YXRlTWFya2VySXNNYXRjaGluZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPCEtLUYhLS0+Jyk7XG52YXIgZm9ybVN0YXRlTWFya2VySXNOb3RNYXRjaGluZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPCEtLUYtLT4nKTtcbmZ1bmN0aW9uIHB1c2hGb3JtU3RhdGVNYXJrZXJJc01hdGNoaW5nKHRhcmdldCkge1xuICB0YXJnZXQucHVzaChmb3JtU3RhdGVNYXJrZXJJc01hdGNoaW5nKTtcbn1cbmZ1bmN0aW9uIHB1c2hGb3JtU3RhdGVNYXJrZXJJc05vdE1hdGNoaW5nKHRhcmdldCkge1xuICB0YXJnZXQucHVzaChmb3JtU3RhdGVNYXJrZXJJc05vdE1hdGNoaW5nKTtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0Rm9ybSh0YXJnZXQsIHByb3BzLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUpIHtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygnZm9ybScpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG4gIHZhciBmb3JtQWN0aW9uID0gbnVsbDtcbiAgdmFyIGZvcm1FbmNUeXBlID0gbnVsbDtcbiAgdmFyIGZvcm1NZXRob2QgPSBudWxsO1xuICB2YXIgZm9ybVRhcmdldCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhY3Rpb24nOlxuICAgICAgICAgIGZvcm1BY3Rpb24gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZW5jVHlwZSc6XG4gICAgICAgICAgZm9ybUVuY1R5cGUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbWV0aG9kJzpcbiAgICAgICAgICBmb3JtTWV0aG9kID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgZm9ybVRhcmdldCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBmb3JtRGF0YSA9IG51bGw7XG4gIHZhciBmb3JtQWN0aW9uTmFtZSA9IG51bGw7XG5cbiAgaWYgKHR5cGVvZiBmb3JtQWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRnVuY3Rpb24gZm9ybSBhY3Rpb25zIGNhbm5vdCBjb250cm9sIHRoZSBmb3JtIHByb3BlcnRpZXNcbiAgICB7XG4gICAgICBpZiAoKGZvcm1FbmNUeXBlICE9PSBudWxsIHx8IGZvcm1NZXRob2QgIT09IG51bGwpICYmICFkaWRXYXJuRm9ybUFjdGlvbk1ldGhvZCkge1xuICAgICAgICBkaWRXYXJuRm9ybUFjdGlvbk1ldGhvZCA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ0Nhbm5vdCBzcGVjaWZ5IGEgZW5jVHlwZSBvciBtZXRob2QgZm9yIGEgZm9ybSB0aGF0IHNwZWNpZmllcyBhICcgKyAnZnVuY3Rpb24gYXMgdGhlIGFjdGlvbi4gUmVhY3QgcHJvdmlkZXMgdGhvc2UgYXV0b21hdGljYWxseS4gJyArICdUaGV5IHdpbGwgZ2V0IG92ZXJyaWRkZW4uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtVGFyZ2V0ICE9PSBudWxsICYmICFkaWRXYXJuRm9ybUFjdGlvblRhcmdldCkge1xuICAgICAgICBkaWRXYXJuRm9ybUFjdGlvblRhcmdldCA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ0Nhbm5vdCBzcGVjaWZ5IGEgdGFyZ2V0IGZvciBhIGZvcm0gdGhhdCBzcGVjaWZpZXMgYSBmdW5jdGlvbiBhcyB0aGUgYWN0aW9uLiAnICsgJ1RoZSBmdW5jdGlvbiB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSB3aW5kb3cuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGN1c3RvbUFjdGlvbiA9IGZvcm1BY3Rpb24uJCRGT1JNX0FDVElPTjtcblxuICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGFjdGlvbiBoYXMgYSBjdXN0b20gcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQgZm9ybSB0aGF0IGNhbiBzdWJtaXQgdGhlIGZvcm1cbiAgICAgIC8vIGJhY2sgdG8gdGhlIHNlcnZlciBpZiBpdCdzIGludm9rZWQgYmVmb3JlIGh5ZHJhdGlvbi4gU3VjaCBhcyBhIFNlcnZlciBBY3Rpb24uXG4gICAgICB2YXIgcHJlZml4ID0gbWFrZUZvcm1GaWVsZFByZWZpeChyZXN1bWFibGVTdGF0ZSk7XG4gICAgICB2YXIgY3VzdG9tRmllbGRzID0gZm9ybUFjdGlvbi4kJEZPUk1fQUNUSU9OKHByZWZpeCk7XG4gICAgICBmb3JtQWN0aW9uID0gY3VzdG9tRmllbGRzLmFjdGlvbiB8fCAnJztcbiAgICAgIGZvcm1FbmNUeXBlID0gY3VzdG9tRmllbGRzLmVuY1R5cGU7XG4gICAgICBmb3JtTWV0aG9kID0gY3VzdG9tRmllbGRzLm1ldGhvZDtcbiAgICAgIGZvcm1UYXJnZXQgPSBjdXN0b21GaWVsZHMudGFyZ2V0O1xuICAgICAgZm9ybURhdGEgPSBjdXN0b21GaWVsZHMuZGF0YTtcbiAgICAgIGZvcm1BY3Rpb25OYW1lID0gY3VzdG9tRmllbGRzLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNldCBhIGphdmFzY3JpcHQgVVJMIHRoYXQgZG9lc24ndCBkbyBhbnl0aGluZy4gV2UgZG9uJ3QgZXhwZWN0IHRoaXMgdG8gYmUgaW52b2tlZFxuICAgICAgLy8gYmVjYXVzZSB3ZSdsbCBwcmV2ZW50RGVmYXVsdCBpbiB0aGUgRml6eiBydW50aW1lLCBidXQgaXQgY2FuIGhhcHBlbiBpZiBhIGZvcm0gaXNcbiAgICAgIC8vIG1hbnVhbGx5IHN1Ym1pdHRlZCBvciBpZiBzb21lb25lIGNhbGxzIHN0b3BQcm9wYWdhdGlvbiBiZWZvcmUgUmVhY3QgZ2V0cyB0aGUgZXZlbnQuXG4gICAgICAvLyBJZiBDU1AgaXMgdXNlZCB0byBibG9jayBqYXZhc2NyaXB0OiBVUkxzIHRoYXQncyBmaW5lIHRvby4gSXQganVzdCB3b24ndCBzaG93IHRoaXNcbiAgICAgIC8vIGVycm9yIG1lc3NhZ2UgYnV0IHRoZSBVUkwgd2lsbCBiZSBsb2dnZWQuXG4gICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsoJ2FjdGlvbicpLCBhdHRyaWJ1dGVBc3NpZ24sIGFjdGlvbkphdmFTY3JpcHRVUkwsIGF0dHJpYnV0ZUVuZCk7XG4gICAgICBmb3JtQWN0aW9uID0gbnVsbDtcbiAgICAgIGZvcm1FbmNUeXBlID0gbnVsbDtcbiAgICAgIGZvcm1NZXRob2QgPSBudWxsO1xuICAgICAgZm9ybVRhcmdldCA9IG51bGw7XG4gICAgICBpbmplY3RGb3JtUmVwbGF5aW5nUnVudGltZShyZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmb3JtQWN0aW9uICE9IG51bGwpIHtcbiAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgJ2FjdGlvbicsIGZvcm1BY3Rpb24pO1xuICB9XG5cbiAgaWYgKGZvcm1FbmNUeXBlICE9IG51bGwpIHtcbiAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgJ2VuY1R5cGUnLCBmb3JtRW5jVHlwZSk7XG4gIH1cblxuICBpZiAoZm9ybU1ldGhvZCAhPSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICdtZXRob2QnLCBmb3JtTWV0aG9kKTtcbiAgfVxuXG4gIGlmIChmb3JtVGFyZ2V0ICE9IG51bGwpIHtcbiAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgJ3RhcmdldCcsIGZvcm1UYXJnZXQpO1xuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG5cbiAgaWYgKGZvcm1BY3Rpb25OYW1lICE9PSBudWxsKSB7XG4gICAgdGFyZ2V0LnB1c2goc3RhcnRIaWRkZW5JbnB1dENodW5rKTtcbiAgICBwdXNoU3RyaW5nQXR0cmlidXRlKHRhcmdldCwgJ25hbWUnLCBmb3JtQWN0aW9uTmFtZSk7XG4gICAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKTtcbiAgICBwdXNoQWRkaXRpb25hbEZvcm1GaWVsZHModGFyZ2V0LCBmb3JtRGF0YSk7XG4gIH1cblxuICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG5cbiAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2UgY2hpbGRyZW4gYXMgYSBzdHJpbmcgdG8gYXZvaWQgdGhlIHVubmVjZXNzYXJ5IGNvbW1lbnQuXG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGFmdGVyIHRoZSBnZW5lcmFsIG9wdGltaXphdGlvbiBpcyBpbiBwbGFjZS5cbiAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVuY29kZUhUTUxUZXh0Tm9kZShjaGlsZHJlbikpKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gcHVzaElucHV0KHRhcmdldCwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSkge1xuICB7XG4gICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnaW5wdXQnLCBwcm9wcyk7XG4gIH1cblxuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdpbnB1dCcpKTtcbiAgdmFyIG5hbWUgPSBudWxsO1xuICB2YXIgZm9ybUFjdGlvbiA9IG51bGw7XG4gIHZhciBmb3JtRW5jVHlwZSA9IG51bGw7XG4gIHZhciBmb3JtTWV0aG9kID0gbnVsbDtcbiAgdmFyIGZvcm1UYXJnZXQgPSBudWxsO1xuICB2YXIgdmFsdWUgPSBudWxsO1xuICB2YXIgZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgdmFyIGNoZWNrZWQgPSBudWxsO1xuICB2YXIgZGVmYXVsdENoZWNrZWQgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCcgKyBcIiBpcyBhIHNlbGYtY2xvc2luZyB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIFwiICsgJ3VzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuXG4gICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgIG5hbWUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZm9ybUFjdGlvbic6XG4gICAgICAgICAgZm9ybUFjdGlvbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb3JtRW5jVHlwZSc6XG4gICAgICAgICAgZm9ybUVuY1R5cGUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZm9ybU1ldGhvZCc6XG4gICAgICAgICAgZm9ybU1ldGhvZCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb3JtVGFyZ2V0JzpcbiAgICAgICAgICBmb3JtVGFyZ2V0ID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RlZmF1bHRDaGVja2VkJzpcbiAgICAgICAgICBkZWZhdWx0Q2hlY2tlZCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkZWZhdWx0VmFsdWUnOlxuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICBjaGVja2VkID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICB2YWx1ZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoZm9ybUFjdGlvbiAhPT0gbnVsbCAmJiBwcm9wcy50eXBlICE9PSAnaW1hZ2UnICYmIHByb3BzLnR5cGUgIT09ICdzdWJtaXQnICYmICFkaWRXYXJuRm9ybUFjdGlvblR5cGUpIHtcbiAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSA9IHRydWU7XG5cbiAgICAgIGVycm9yKCdBbiBpbnB1dCBjYW4gb25seSBzcGVjaWZ5IGEgZm9ybUFjdGlvbiBhbG9uZyB3aXRoIHR5cGU9XCJzdWJtaXRcIiBvciB0eXBlPVwiaW1hZ2VcIi4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZm9ybURhdGEgPSBwdXNoRm9ybUFjdGlvbkF0dHJpYnV0ZSh0YXJnZXQsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUsIGZvcm1NZXRob2QsIGZvcm1UYXJnZXQsIG5hbWUpO1xuXG4gIHtcbiAgICBpZiAoY2hlY2tlZCAhPT0gbnVsbCAmJiBkZWZhdWx0Q2hlY2tlZCAhPT0gbnVsbCAmJiAhZGlkV2FybkRlZmF1bHRDaGVja2VkKSB7XG4gICAgICBlcnJvcignJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggY2hlY2tlZCBhbmQgZGVmYXVsdENoZWNrZWQgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgIGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiAhZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlKSB7XG4gICAgICBlcnJvcignJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycsICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuXG4gICAgICBkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjaGVja2VkICE9PSBudWxsKSB7XG4gICAgcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0LCAnY2hlY2tlZCcsIGNoZWNrZWQpO1xuICB9IGVsc2UgaWYgKGRlZmF1bHRDaGVja2VkICE9PSBudWxsKSB7XG4gICAgcHVzaEJvb2xlYW5BdHRyaWJ1dGUodGFyZ2V0LCAnY2hlY2tlZCcsIGRlZmF1bHRDaGVja2VkKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCAndmFsdWUnLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdFZhbHVlICE9PSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsICd2YWx1ZScsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpOyAvLyBXZSBwbGFjZSBhbnkgYWRkaXRpb25hbCBoaWRkZW4gZm9ybSBmaWVsZHMgYWZ0ZXIgdGhlIGlucHV0LlxuXG4gIHB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkcyh0YXJnZXQsIGZvcm1EYXRhKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydEJ1dHRvbih0YXJnZXQsIHByb3BzLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUpIHtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygnYnV0dG9uJykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcbiAgdmFyIG5hbWUgPSBudWxsO1xuICB2YXIgZm9ybUFjdGlvbiA9IG51bGw7XG4gIHZhciBmb3JtRW5jVHlwZSA9IG51bGw7XG4gIHZhciBmb3JtTWV0aG9kID0gbnVsbDtcbiAgdmFyIGZvcm1UYXJnZXQgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgbmFtZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb3JtQWN0aW9uJzpcbiAgICAgICAgICBmb3JtQWN0aW9uID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1FbmNUeXBlJzpcbiAgICAgICAgICBmb3JtRW5jVHlwZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb3JtTWV0aG9kJzpcbiAgICAgICAgICBmb3JtTWV0aG9kID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zvcm1UYXJnZXQnOlxuICAgICAgICAgIGZvcm1UYXJnZXQgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGZvcm1BY3Rpb24gIT09IG51bGwgJiYgcHJvcHMudHlwZSAhPSBudWxsICYmIHByb3BzLnR5cGUgIT09ICdzdWJtaXQnICYmICFkaWRXYXJuRm9ybUFjdGlvblR5cGUpIHtcbiAgICAgIGRpZFdhcm5Gb3JtQWN0aW9uVHlwZSA9IHRydWU7XG5cbiAgICAgIGVycm9yKCdBIGJ1dHRvbiBjYW4gb25seSBzcGVjaWZ5IGEgZm9ybUFjdGlvbiBhbG9uZyB3aXRoIHR5cGU9XCJzdWJtaXRcIiBvciBubyB0eXBlLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmb3JtRGF0YSA9IHB1c2hGb3JtQWN0aW9uQXR0cmlidXRlKHRhcmdldCwgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBmb3JtQWN0aW9uLCBmb3JtRW5jVHlwZSwgZm9ybU1ldGhvZCwgZm9ybVRhcmdldCwgbmFtZSk7XG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpOyAvLyBXZSBwbGFjZSBhbnkgYWRkaXRpb25hbCBoaWRkZW4gZm9ybSBmaWVsZHMgd2UgbmVlZCB0byBpbmNsdWRlIGluc2lkZSB0aGUgYnV0dG9uIGl0c2VsZi5cblxuICBwdXNoQWRkaXRpb25hbEZvcm1GaWVsZHModGFyZ2V0LCBmb3JtRGF0YSk7XG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcblxuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgIC8vIFNwZWNpYWwgY2FzZSBjaGlsZHJlbiBhcyBhIHN0cmluZyB0byBhdm9pZCB0aGUgdW5uZWNlc3NhcnkgY29tbWVudC5cbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBzcGVjaWFsIGNhc2UgYWZ0ZXIgdGhlIGdlbmVyYWwgb3B0aW1pemF0aW9uIGlzIGluIHBsYWNlLlxuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZW5jb2RlSFRNTFRleHROb2RlKGNoaWxkcmVuKSkpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRUZXh0QXJlYSh0YXJnZXQsIHByb3BzKSB7XG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCd0ZXh0YXJlYScsIHByb3BzKTtcblxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUpIHtcbiAgICAgIGVycm9yKCdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCd0ZXh0YXJlYScpKTtcbiAgdmFyIHZhbHVlID0gbnVsbDtcbiAgdmFyIGRlZmF1bHRWYWx1ZSA9IG51bGw7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIHZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RlZmF1bHRWYWx1ZSc6XG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHZhbHVlID09PSBudWxsICYmIGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCkge1xuICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7IC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG5cbiAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICB7XG4gICAgICBlcnJvcignVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJyk7XG4gICAgICB9IC8vIFRPRE86IHJlbW92ZSB0aGUgY29lcmNpb24gYW5kIHRoZSBERVYgY2hlY2sgYmVsb3cgYmVjYXVzZSBpdCB3aWxsXG4gICAgICAvLyBhbHdheXMgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIGNvZXJjaW9uIHNldmVyYWwgbGluZXMgYmVsb3cgaXQuICMyMjMwOVxuXG5cbiAgICAgIHtcbiAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oY2hpbGRyZW5bMF0pO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9ICcnICsgY2hpbGRyZW5bMF07XG4gICAgfVxuXG4gICAge1xuICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIHZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlWzBdID09PSAnXFxuJykge1xuICAgIC8vIHRleHQvaHRtbCBpZ25vcmVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlc2UgdGFncyBpZiBpdCdzIGEgbmV3bGluZVxuICAgIC8vIFByZWZlciB0byBicmVhayBhcHBsaWNhdGlvbi94bWwgb3ZlciB0ZXh0L2h0bWwgKGZvciBub3cpIGJ5IGFkZGluZ1xuICAgIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcbiAgICAvLyB0ZXh0YXJlYXMsIHJlcGxhY2luZyBcIl5cXG5cIiB3aXRoIFwiXFxyXFxuXCIgZG9lc24ndCBnZXQgZWF0ZW4sIGFuZCB0aGUgZmlyc3RcbiAgICAvLyBcXHIgaXMgbm9ybWFsaXplZCBvdXQgYnkgSFRNTFRleHRBcmVhRWxlbWVudCN2YWx1ZS4pXG4gICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cbiAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNlbGVtZW50LXJlc3RyaWN0aW9ucz5cbiAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNuZXdsaW5lcz5cbiAgICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXG4gICAgLy8gIGZyb20gPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHk+XG4gICAgdGFyZ2V0LnB1c2gobGVhZGluZ05ld2xpbmUpO1xuICB9IC8vIFRvU3RyaW5nIGFuZCBwdXNoIGRpcmVjdGx5IGluc3RlYWQgb2YgcmVjdXJzZSBvdmVyIGNoaWxkcmVuLlxuICAvLyBXZSBkb24ndCByZWFsbHkgc3VwcG9ydCBjb21wbGV4IGNoaWxkcmVuIGluIHRoZSB2YWx1ZSBhbnl3YXkuXG4gIC8vIFRoaXMgYWxzbyBjdXJyZW50bHkgYXZvaWRzIGEgdHJhaWxpbmcgY29tbWVudCBub2RlIHdoaWNoIGJyZWFrcyB0ZXh0YXJlYS5cblxuXG4gIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsICd2YWx1ZScpO1xuICAgIH1cblxuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZW5jb2RlSFRNTFRleHROb2RlKCcnICsgdmFsdWUpKSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaE1ldGEodGFyZ2V0LCBwcm9wcywgcmVuZGVyU3RhdGUsIHRleHRFbWJlZGRlZCwgaW5zZXJ0aW9uTW9kZSwgbm9zY3JpcHRUYWdJblNjb3BlKSB7XG4gIHtcbiAgICBpZiAoaW5zZXJ0aW9uTW9kZSA9PT0gU1ZHX01PREUgfHwgbm9zY3JpcHRUYWdJblNjb3BlIHx8IHByb3BzLml0ZW1Qcm9wICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0LCBwcm9wcywgJ21ldGEnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRleHRFbWJlZGRlZCkge1xuICAgICAgICAvLyBUaGlzIGxpbmsgZm9sbG93cyB0ZXh0IGJ1dCB3ZSBhcmVuJ3Qgd3JpdGluZyBhIHRhZy4gd2hpbGUgbm90IGFzIGVmZmljaWVudCBhcyBwb3NzaWJsZSB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIGJlIHNhZmUgYW5kIGFzc3VtZSB0ZXh0IHdpbGwgZm9sbG93IGJ5IGluc2VydGluZyBhIHRleHRTZXBhcmF0b3JcbiAgICAgICAgdGFyZ2V0LnB1c2godGV4dFNlcGFyYXRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcHJvcHMuY2hhclNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHB1c2hTZWxmQ2xvc2luZyhyZW5kZXJTdGF0ZS5jaGFyc2V0Q2h1bmtzLCBwcm9wcywgJ21ldGEnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcHMubmFtZSA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgICAgICAvLyBcInZpZXdwb3J0XCIgaXNuJ3QgcmVsYXRlZCB0byBwcmVjb25uZWN0IGJ1dCBpdCBoYXMgdGhlIHJpZ2h0IHByaW9yaXR5XG4gICAgICAgIHJldHVybiBwdXNoU2VsZkNsb3NpbmcocmVuZGVyU3RhdGUucHJlY29ubmVjdENodW5rcywgcHJvcHMsICdtZXRhJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcHVzaFNlbGZDbG9zaW5nKHJlbmRlclN0YXRlLmhvaXN0YWJsZUNodW5rcywgcHJvcHMsICdtZXRhJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hMaW5rKHRhcmdldCwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgdGV4dEVtYmVkZGVkLCBpbnNlcnRpb25Nb2RlLCBub3NjcmlwdFRhZ0luU2NvcGUpIHtcbiAge1xuICAgIHZhciByZWwgPSBwcm9wcy5yZWw7XG4gICAgdmFyIGhyZWYgPSBwcm9wcy5ocmVmO1xuICAgIHZhciBwcmVjZWRlbmNlID0gcHJvcHMucHJlY2VkZW5jZTtcblxuICAgIGlmIChpbnNlcnRpb25Nb2RlID09PSBTVkdfTU9ERSB8fCBub3NjcmlwdFRhZ0luU2NvcGUgfHwgcHJvcHMuaXRlbVByb3AgIT0gbnVsbCB8fCB0eXBlb2YgcmVsICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgaHJlZiAhPT0gJ3N0cmluZycgfHwgaHJlZiA9PT0gJycpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHJlbCA9PT0gJ3N0eWxlc2hlZXQnICYmIHR5cGVvZiBwcm9wcy5wcmVjZWRlbmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0eXBlb2YgaHJlZiAhPT0gJ3N0cmluZycgfHwgIWhyZWYpIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdCBlbmNvdW50ZXJlZCBhIGA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgLi4uLz5gIHdpdGggYSBgcHJlY2VkZW5jZWAgcHJvcCBhbmQgZXhwZWN0ZWQgdGhlIGBocmVmYCBwcm9wIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZyBidXQgZWNvdW50ZXJlZCAlcyBpbnN0ZWFkLiBJZiB5b3VyIGludGVudCB3YXMgdG8gaGF2ZSBSZWFjdCBob2lzdCBhbmQgZGVkdXBsY2lhdGUgdGhpcyBzdHlsZXNoZWV0IHVzaW5nIHRoZSBgcHJlY2VkZW5jZWAgcHJvcCBlbnN1cmUgdGhlcmUgaXMgYSBub24tZW1wdHkgc3RyaW5nIGBocmVmYCBwcm9wIGFzIHdlbGwsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLicsIGdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmcoaHJlZikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwdXNoTGlua0ltcGwodGFyZ2V0LCBwcm9wcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMucmVsID09PSAnc3R5bGVzaGVldCcpIHtcbiAgICAgIC8vIFRoaXMgPGxpbms+IG1heSBob2lzdGFibGUgYXMgYSBTdHlsZXNoZWV0IFJlc291cmNlLCBvdGhlcndpc2UgaXQgd2lsbCBlbWl0IGluIHBsYWNlXG4gICAgICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoaHJlZik7XG5cbiAgICAgIGlmICh0eXBlb2YgcHJlY2VkZW5jZSAhPT0gJ3N0cmluZycgfHwgcHJvcHMuZGlzYWJsZWQgIT0gbnVsbCB8fCBwcm9wcy5vbkxvYWQgfHwgcHJvcHMub25FcnJvcikge1xuICAgICAgICAvLyBUaGlzIHN0eWxlc2hlZXQgaXMgZWl0aGVyIG5vdCBvcHRlZCBpbnRvIFJlc291cmNlIHNlbWFudGljcyBvciBoYXMgY29uZmxpY3RpbmcgcHJvcGVydGllcyB3aGljaFxuICAgICAgICAvLyBkaXNxdWFsaWZ5IGl0IGZvciBzdWNoLiBXZSBjYW4gc3RpbGwgY3JlYXRlIGEgcHJlbG9hZCByZXNvdXJjZSB0byBoZWxwIGl0IGxvYWQgZmFzdGVyIG9uIHRoZVxuICAgICAgICAvLyBjbGllbnRcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgcHJlY2VkZW5jZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5kaXNhYmxlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGVycm9yKCdSZWFjdCBlbmNvdW50ZXJlZCBhIGA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgLi4uLz5gIHdpdGggYSBgcHJlY2VkZW5jZWAgcHJvcCBhbmQgYSBgZGlzYWJsZWRgIHByb3AuIFRoZSBwcmVzZW5jZSBvZiB0aGUgYGRpc2FibGVkYCBwcm9wIGluZGljYXRlcyBhbiBpbnRlbnQgdG8gbWFuYWdlIHRoZSBzdHlsZXNoZWV0IGFjdGl2ZSBzdGF0ZSBmcm9tIHlvdXIgZnJvbSB5b3VyIENvbXBvbmVudCBjb2RlIGFuZCBSZWFjdCB3aWxsIG5vdCBob2lzdCBvciBkZWR1cGxpY2F0ZSB0aGlzIHN0eWxlc2hlZXQuIElmIHlvdXIgaW50ZW50IHdhcyB0byBoYXZlIFJlYWN0IGhvaXN0IGFuZCBkZWR1cGxjaWF0ZSB0aGlzIHN0eWxlc2hlZXQgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIHJlbW92ZSB0aGUgYGRpc2FibGVkYCBwcm9wLCBvdGhlcndpc2UgcmVtb3ZlIHRoZSBgcHJlY2VkZW5jZWAgcHJvcC4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcHMub25Mb2FkIHx8IHByb3BzLm9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BEZXNjcmlwdGlvbiA9IHByb3BzLm9uTG9hZCAmJiBwcm9wcy5vbkVycm9yID8gJ2BvbkxvYWRgIGFuZCBgb25FcnJvcmAgcHJvcHMnIDogcHJvcHMub25Mb2FkID8gJ2BvbkxvYWRgIHByb3AnIDogJ2BvbkVycm9yYCBwcm9wJztcblxuICAgICAgICAgICAgICBlcnJvcignUmVhY3QgZW5jb3VudGVyZWQgYSBgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIC4uLi8+YCB3aXRoIGEgYHByZWNlZGVuY2VgIHByb3AgYW5kICVzLiBUaGUgcHJlc2VuY2Ugb2YgbG9hZGluZyBhbmQgZXJyb3IgaGFuZGxlcnMgaW5kaWNhdGVzIGFuIGludGVudCB0byBtYW5hZ2UgdGhlIHN0eWxlc2hlZXQgbG9hZGluZyBzdGF0ZSBmcm9tIHlvdXIgZnJvbSB5b3VyIENvbXBvbmVudCBjb2RlIGFuZCBSZWFjdCB3aWxsIG5vdCBob2lzdCBvciBkZWR1cGxpY2F0ZSB0aGlzIHN0eWxlc2hlZXQuIElmIHlvdXIgaW50ZW50IHdhcyB0byBoYXZlIFJlYWN0IGhvaXN0IGFuZCBkZWR1cGxjaWF0ZSB0aGlzIHN0eWxlc2hlZXQgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIHJlbW92ZSB0aGUgJXMsIG90aGVyd2lzZSByZW1vdmUgdGhlIGBwcmVjZWRlbmNlYCBwcm9wLicsIHByb3BEZXNjcmlwdGlvbiwgcHJvcERlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHVzaExpbmtJbXBsKHRhcmdldCwgcHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBzdHlsZXNoZWV0IHJlZmVycyB0byBhIFJlc291cmNlIGFuZCB3ZSBjcmVhdGUgYSBuZXcgb25lIGlmIG5lY2Vzc2FyeVxuICAgICAgICB2YXIgc3R5bGVRdWV1ZSA9IHJlbmRlclN0YXRlLnN0eWxlcy5nZXQocHJlY2VkZW5jZSk7XG4gICAgICAgIHZhciBoYXNLZXkgPSByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgICB2YXIgcmVzb3VyY2VTdGF0ZSA9IGhhc0tleSA/IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2tleV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHJlc291cmNlU3RhdGUgIT09IEVYSVNUUykge1xuICAgICAgICAgIC8vIFdlIGFyZSBnb2luZyB0byBjcmVhdGUgdGhpcyByZXNvdXJjZSBub3cgc28gaXQgaXMgbWFya2VkIGFzIEV4aXN0c1xuICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzW2tleV0gPSBFWElTVFM7IC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2UndmUgZW5jb3VudGVyZWQgdGhpcyBwcmVjZWRlbmNlIHdlIG5lZWRcbiAgICAgICAgICAvLyB0byBjcmVhdGUgYSBTdHlsZVF1ZXVlXG5cbiAgICAgICAgICBpZiAoIXN0eWxlUXVldWUpIHtcbiAgICAgICAgICAgIHN0eWxlUXVldWUgPSB7XG4gICAgICAgICAgICAgIHByZWNlZGVuY2U6IHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSkpLFxuICAgICAgICAgICAgICBydWxlczogW10sXG4gICAgICAgICAgICAgIGhyZWZzOiBbXSxcbiAgICAgICAgICAgICAgc2hlZXRzOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuc2V0KHByZWNlZGVuY2UsIHN0eWxlUXVldWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZXNvdXJjZSA9IHtcbiAgICAgICAgICAgIHN0YXRlOiBQRU5ESU5HJDEsXG4gICAgICAgICAgICBwcm9wczogc3R5bGVzaGVldFByb3BzRnJvbVJhd1Byb3BzKHByb3BzKVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocmVzb3VyY2VTdGF0ZSkge1xuICAgICAgICAgICAgLy8gV2hlbiByZXNvdXJjZVN0YXRlIGlzIHRydXR5IGl0IGlzIGEgUHJlbG9hZCBzdGF0ZS4gV2UgY2FzdCBpdCBmb3IgY2xhcml0eVxuICAgICAgICAgICAgdmFyIHByZWxvYWRTdGF0ZSA9IHJlc291cmNlU3RhdGU7XG5cbiAgICAgICAgICAgIGlmIChwcmVsb2FkU3RhdGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKHJlc291cmNlLnByb3BzLCBwcmVsb2FkU3RhdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJlbG9hZFJlc291cmNlID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuc3R5bGVzaGVldHMuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIGlmIChwcmVsb2FkUmVzb3VyY2UgJiYgcHJlbG9hZFJlc291cmNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gVGhlIFByZWxvYWQgZm9yIHRoaXMgcmVzb3VyY2Ugd2FzIGNyZWF0ZWQgaW4gdGhpcyByZW5kZXIgcGFzcyBhbmQgaGFzIG5vdCBmbHVzaGVkIHlldCBzb1xuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNsZWFyIGl0IHRvIGF2b2lkIGl0IGZsdXNoaW5nLlxuICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2UubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEVpdGhlciB0aGUgcHJlbG9hZCByZXNvdXJjZSBmcm9tIHRoaXMgcmVuZGVyIGFscmVhZHkgZmx1c2hlZCBpbiB0aGlzIHJlbmRlciBwYXNzXG4gICAgICAgICAgICAgIC8vIG9yIHRoZSBwcmVsb2FkIGZsdXNoZWQgaW4gYSBwcmlvciBwYXNzIChwcmVyZW5kZXIpLiBJbiBlaXRoZXIgY2FzZSB3ZSBuZWVkIHRvIG1hcmtcbiAgICAgICAgICAgICAgLy8gdGhpcyByZXNvdXJjZSBhcyBhbHJlYWR5IGhhdmluZyBiZWVuIHByZWxvYWRlZC5cbiAgICAgICAgICAgICAgcmVzb3VyY2Uuc3RhdGUgPSBQUkVMT0FERUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBXZSBhZGQgdGhlIG5ld2x5IGNyZWF0ZWQgcmVzb3VyY2UgdG8gb3VyIFN0eWxlUXVldWUgYW5kIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgIC8vIHRyYWNrIHRoZSByZXNvdXJjZSB3aXRoIHRoZSBjdXJyZW50bHkgcmVuZGVyaW5nIGJvdW5kYXJ5XG5cblxuICAgICAgICAgIHN0eWxlUXVldWUuc2hlZXRzLnNldChrZXksIHJlc291cmNlKTtcblxuICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS5ib3VuZGFyeVJlc291cmNlcykge1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUuYm91bmRhcnlSZXNvdXJjZXMuc3R5bGVzaGVldHMuYWRkKHJlc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gV2UgbmVlZCB0byB0cmFjayB3aGV0aGVyIHRoaXMgYm91bmRhcnkgc2hvdWxkIHdhaXQgb24gdGhpcyByZXNvdXJjZSBvciBub3QuXG4gICAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgcmVzb3VyY2Ugc2hvdWxkIGFsd2F5cyBleGlzdCBzaW5jZSB3ZSBlaXRoZXIgaGFkIGl0IG9yIGp1c3QgY3JlYXRlZFxuICAgICAgICAgIC8vIGl0LiBIb3dldmVyLCBpdCdzIHBvc3NpYmxlIHdoZW4geW91IHJlc3VtZSB0aGF0IHRoZSBzdHlsZSBoYXMgYWxyZWFkeSBiZWVuIGVtaXR0ZWRcbiAgICAgICAgICAvLyBhbmQgdGhlbiBpdCB3b3VsZG4ndCBiZSByZWNyZWF0ZWQgaW4gdGhlIFJlbmRlclN0YXRlIGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gdHJhY2tcbiAgICAgICAgICAvLyBpdCBhZ2FpbiBzaW5jZSB3ZSBzaG91bGQndmUgaG9pc3RlZCBpdCB0byB0aGUgc2hlbGwgYWxyZWFkeS5cbiAgICAgICAgICBpZiAoc3R5bGVRdWV1ZSkge1xuICAgICAgICAgICAgdmFyIF9yZXNvdXJjZSA9IHN0eWxlUXVldWUuc2hlZXRzLmdldChrZXkpO1xuXG4gICAgICAgICAgICBpZiAoX3Jlc291cmNlKSB7XG4gICAgICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS5ib3VuZGFyeVJlc291cmNlcykge1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmJvdW5kYXJ5UmVzb3VyY2VzLnN0eWxlc2hlZXRzLmFkZChfcmVzb3VyY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRFbWJlZGRlZCkge1xuICAgICAgICAgIC8vIFRoaXMgbGluayBmb2xsb3dzIHRleHQgYnV0IHdlIGFyZW4ndCB3cml0aW5nIGEgdGFnLiB3aGlsZSBub3QgYXMgZWZmaWNpZW50IGFzIHBvc3NpYmxlIHdlIG5lZWRcbiAgICAgICAgICAvLyB0byBiZSBzYWZlIGFuZCBhc3N1bWUgdGV4dCB3aWxsIGZvbGxvdyBieSBpbnNlcnRpbmcgYSB0ZXh0U2VwYXJhdG9yXG4gICAgICAgICAgdGFyZ2V0LnB1c2godGV4dFNlcGFyYXRvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BzLm9uTG9hZCB8fCBwcm9wcy5vbkVycm9yKSB7XG4gICAgICAvLyBXaGVuIHVzaW5nIGxvYWQgaGFuZGxlcnMgd2UgY2Fubm90IGhvaXN0IGFuZCBuZWVkIHRvIGVtaXQgbGlua3MgaW4gcGxhY2VcbiAgICAgIHJldHVybiBwdXNoTGlua0ltcGwodGFyZ2V0LCBwcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIGNhbiBob2lzdCB0aGlzIGxpbmsgc28gd2UgbWF5IG5lZWQgdG8gZW1pdCBhIHRleHQgc2VwYXJhdG9yLlxuICAgICAgLy8gQFRPRE8gcmVmYWN0b3IgdGV4dCBzZXBhcmF0b3JzIHNvIHdlIGRvbid0IGhhdmUgdG8gZGVmZW5zaXZlbHkgYWRkXG4gICAgICAvLyB0aGVtIHdoZW4gd2UgZG9uJ3QgZW5kIHVwIGVtaXR0aW5nIGEgdGFnIGFzIGEgcmVzdWx0IG9mIHB1c2hTdGFydEluc3RhbmNlXG4gICAgICBpZiAodGV4dEVtYmVkZGVkKSB7XG4gICAgICAgIC8vIFRoaXMgbGluayBmb2xsb3dzIHRleHQgYnV0IHdlIGFyZW4ndCB3cml0aW5nIGEgdGFnLiB3aGlsZSBub3QgYXMgZWZmaWNpZW50IGFzIHBvc3NpYmxlIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gYmUgc2FmZSBhbmQgYXNzdW1lIHRleHQgd2lsbCBmb2xsb3cgYnkgaW5zZXJ0aW5nIGEgdGV4dFNlcGFyYXRvclxuICAgICAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wcy5yZWwpIHtcbiAgICAgICAgY2FzZSAncHJlY29ubmVjdCc6XG4gICAgICAgIGNhc2UgJ2Rucy1wcmVmZXRjaCc6XG4gICAgICAgICAgcmV0dXJuIHB1c2hMaW5rSW1wbChyZW5kZXJTdGF0ZS5wcmVjb25uZWN0Q2h1bmtzLCBwcm9wcyk7XG5cbiAgICAgICAgY2FzZSAncHJlbG9hZCc6XG4gICAgICAgICAgcmV0dXJuIHB1c2hMaW5rSW1wbChyZW5kZXJTdGF0ZS5wcmVsb2FkQ2h1bmtzLCBwcm9wcyk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gcHVzaExpbmtJbXBsKHJlbmRlclN0YXRlLmhvaXN0YWJsZUNodW5rcywgcHJvcHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoTGlua0ltcGwodGFyZ2V0LCBwcm9wcykge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdsaW5rJykpO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW5rJyArIFwiIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgXCIgKyAndXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0eWxlKHRhcmdldCwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgdGV4dEVtYmVkZGVkLCBpbnNlcnRpb25Nb2RlLCBub3NjcmlwdFRhZ0luU2NvcGUpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAnY2hpbGRyZW4nKSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgY2hpbGQgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLmxlbmd0aCA8IDIgPyBjaGlsZHJlblswXSA6IG51bGwgOiBjaGlsZHJlbjtcblxuICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdzeW1ib2wnIHx8IEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgIHZhciBjaGlsZFR5cGUgPSB0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicgPyAnYSBGdW5jdGlvbicgOiB0eXBlb2YgY2hpbGQgPT09ICdzeW1ib2wnID8gJ2EgU3libW9sJyA6ICdhbiBBcnJheSc7XG5cbiAgICAgICAgZXJyb3IoJ1JlYWN0IGV4cGVjdCBjaGlsZHJlbiBvZiA8c3R5bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgb3Igb2JqZWN0IHdpdGggYSBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgJXMgaW5zdGVhZC4gJyArICdJbiBicm93c2VycyBzdHlsZSBFbGVtZW50cyBjYW4gb25seSBoYXZlIGBUZXh0YCBOb2RlcyBhcyBjaGlsZHJlbi4nLCBjaGlsZFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICB2YXIgcHJlY2VkZW5jZSA9IHByb3BzLnByZWNlZGVuY2U7XG4gICAgdmFyIGhyZWYgPSBwcm9wcy5ocmVmO1xuXG4gICAgaWYgKGluc2VydGlvbk1vZGUgPT09IFNWR19NT0RFIHx8IG5vc2NyaXB0VGFnSW5TY29wZSB8fCBwcm9wcy5pdGVtUHJvcCAhPSBudWxsIHx8IHR5cGVvZiBwcmVjZWRlbmNlICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgaHJlZiAhPT0gJ3N0cmluZycgfHwgaHJlZiA9PT0gJycpIHtcbiAgICAgIC8vIFRoaXMgc3R5bGUgdGFnIGlzIG5vdCBhYmxlIHRvIGJlIHR1cm5lZCBpbnRvIGEgU3R5bGUgUmVzb3VyY2VcbiAgICAgIHJldHVybiBwdXNoU3R5bGVJbXBsKHRhcmdldCwgcHJvcHMpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChocmVmLmluY2x1ZGVzKCcgJykpIHtcbiAgICAgICAgZXJyb3IoJ1JlYWN0IGV4cGVjdGVkIHRoZSBgaHJlZmAgcHJvcCBmb3IgYSA8c3R5bGU+IHRhZyBvcHRpbmcgaW50byBob2lzdGluZyBzZW1hbnRpY3MgdXNpbmcgdGhlIGBwcmVjZWRlbmNlYCBwcm9wIHRvIG5vdCBoYXZlIGFueSBzcGFjZXMgYnV0IGVjb3VudGVyZWQgc3BhY2VzIGluc3RlYWQuIHVzaW5nIHNwYWNlcyBpbiB0aGlzIHByb3Agd2lsbCBjYXVzZSBoeWRyYXRpb24gb2YgdGhpcyBzdHlsZSB0byBmYWlsIG9uIHRoZSBjbGllbnQuIFRoZSBocmVmIGZvciB0aGUgPHN0eWxlPiB3aGVyZSB0aGlzIG9jdXJyZWQgaXMgXCIlc1wiLicsIGhyZWYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleShocmVmKTtcbiAgICB2YXIgc3R5bGVRdWV1ZSA9IHJlbmRlclN0YXRlLnN0eWxlcy5nZXQocHJlY2VkZW5jZSk7XG4gICAgdmFyIGhhc0tleSA9IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgdmFyIHJlc291cmNlU3RhdGUgPSBoYXNLZXkgPyByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1trZXldIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHJlc291cmNlU3RhdGUgIT09IEVYSVNUUykge1xuICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIGNyZWF0ZSB0aGlzIHJlc291cmNlIG5vdyBzbyBpdCBpcyBtYXJrZWQgYXMgRXhpc3RzXG4gICAgICByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1trZXldID0gRVhJU1RTO1xuXG4gICAgICB7XG4gICAgICAgIGlmIChyZXNvdXJjZVN0YXRlKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IGVuY291bnRlcmVkIGEgaG9pc3RhYmxlIHN0eWxlIHRhZyBmb3IgdGhlIHNhbWUgaHJlZiBhcyBhIHByZWxvYWQ6IFwiJXNcIi4gV2hlbiB1c2luZyBhIHN0eWxlIHRhZyB0byBpbmxpbmUgc3R5bGVzIHlvdSBzaG91bGQgbm90IGFsc28gcHJlbG9hZCBpdCBhcyBhIHN0eWxzaGVldC4nLCBocmVmKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXN0eWxlUXVldWUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSd2ZSBlbmNvdW50ZXJlZCB0aGlzIHByZWNlZGVuY2Ugd2UgbmVlZFxuICAgICAgICAvLyB0byBjcmVhdGUgYSBTdHlsZVF1ZXVlLlxuICAgICAgICBzdHlsZVF1ZXVlID0ge1xuICAgICAgICAgIHByZWNlZGVuY2U6IHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSkpLFxuICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICBocmVmczogW3N0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaHJlZikpXSxcbiAgICAgICAgICBzaGVldHM6IG5ldyBNYXAoKVxuICAgICAgICB9O1xuICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZXMuc2V0KHByZWNlZGVuY2UsIHN0eWxlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZWVuIHRoaXMgcHJlY2VkZW5jZSBiZWZvcmUgYW5kIG5lZWQgdG8gdHJhY2sgdGhpcyBocmVmXG4gICAgICAgIHN0eWxlUXVldWUuaHJlZnMucHVzaChzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGhyZWYpKSk7XG4gICAgICB9XG5cbiAgICAgIHB1c2hTdHlsZUNvbnRlbnRzKHN0eWxlUXVldWUucnVsZXMsIHByb3BzKTtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGVRdWV1ZSkge1xuICAgICAgLy8gV2UgbmVlZCB0byB0cmFjayB3aGV0aGVyIHRoaXMgYm91bmRhcnkgc2hvdWxkIHdhaXQgb24gdGhpcyByZXNvdXJjZSBvciBub3QuXG4gICAgICAvLyBUeXBpY2FsbHkgdGhpcyByZXNvdXJjZSBzaG91bGQgYWx3YXlzIGV4aXN0IHNpbmNlIHdlIGVpdGhlciBoYWQgaXQgb3IganVzdCBjcmVhdGVkXG4gICAgICAvLyBpdC4gSG93ZXZlciwgaXQncyBwb3NzaWJsZSB3aGVuIHlvdSByZXN1bWUgdGhhdCB0aGUgc3R5bGUgaGFzIGFscmVhZHkgYmVlbiBlbWl0dGVkXG4gICAgICAvLyBhbmQgdGhlbiBpdCB3b3VsZG4ndCBiZSByZWNyZWF0ZWQgaW4gdGhlIFJlbmRlclN0YXRlIGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gdHJhY2tcbiAgICAgIC8vIGl0IGFnYWluIHNpbmNlIHdlIHNob3VsZCd2ZSBob2lzdGVkIGl0IHRvIHRoZSBzaGVsbCBhbHJlYWR5LlxuICAgICAgaWYgKHJlbmRlclN0YXRlLmJvdW5kYXJ5UmVzb3VyY2VzKSB7XG4gICAgICAgIHJlbmRlclN0YXRlLmJvdW5kYXJ5UmVzb3VyY2VzLnN0eWxlcy5hZGQoc3R5bGVRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRleHRFbWJlZGRlZCkge1xuICAgICAgLy8gVGhpcyBsaW5rIGZvbGxvd3MgdGV4dCBidXQgd2UgYXJlbid0IHdyaXRpbmcgYSB0YWcuIHdoaWxlIG5vdCBhcyBlZmZpY2llbnQgYXMgcG9zc2libGUgd2UgbmVlZFxuICAgICAgLy8gdG8gYmUgc2FmZSBhbmQgYXNzdW1lIHRleHQgd2lsbCBmb2xsb3cgYnkgaW5zZXJ0aW5nIGEgdGV4dFNlcGFyYXRvclxuICAgICAgdGFyZ2V0LnB1c2godGV4dFNlcGFyYXRvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hTdHlsZUltcGwodGFyZ2V0LCBwcm9wcykge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdzdHlsZScpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICB2YXIgY2hpbGQgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLmxlbmd0aCA8IDIgPyBjaGlsZHJlblswXSA6IG51bGwgOiBjaGlsZHJlbjtcblxuICBpZiAodHlwZW9mIGNoaWxkICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjaGlsZCAhPT0gJ3N5bWJvbCcgJiYgY2hpbGQgIT09IG51bGwgJiYgY2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoJycgKyBjaGlsZCkpKTtcbiAgfVxuXG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgdGFyZ2V0LnB1c2goZW5kQ2h1bmtGb3JUYWcoJ3N0eWxlJykpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0eWxlQ29udGVudHModGFyZ2V0LCBwcm9wcykge1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjaGlsZCA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4ubGVuZ3RoIDwgMiA/IGNoaWxkcmVuWzBdIDogbnVsbCA6IGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlb2YgY2hpbGQgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNoaWxkICE9PSAnc3ltYm9sJyAmJiBjaGlsZCAhPT0gbnVsbCAmJiBjaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcignJyArIGNoaWxkKSkpO1xuICB9XG5cbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICByZXR1cm47XG59XG5cbmZ1bmN0aW9uIHB1c2hJbWcodGFyZ2V0LCBwcm9wcywgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBwaWN0dXJlVGFnSW5TY29wZSkge1xuICB2YXIgc3JjID0gcHJvcHMuc3JjLFxuICAgICAgc3JjU2V0ID0gcHJvcHMuc3JjU2V0O1xuXG4gIGlmIChwcm9wcy5sb2FkaW5nICE9PSAnbGF6eScgJiYgKHNyYyB8fCBzcmNTZXQpICYmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyB8fCBzcmMgPT0gbnVsbCkgJiYgKHR5cGVvZiBzcmNTZXQgPT09ICdzdHJpbmcnIHx8IHNyY1NldCA9PSBudWxsKSAmJiBwcm9wcy5mZXRjaFByaW9yaXR5ICE9PSAnbG93JyAmJiBwaWN0dXJlVGFnSW5TY29wZSA9PT0gZmFsc2UgJiYgLy8gV2UgZXhjbHVkZSBkYXRhIFVSSXMgaW4gc3JjIGFuZCBzcmNTZXQgc2luY2UgdGhlc2Ugc2hvdWxkIG5vdCBiZSBwcmVsb2FkZWRcbiAgISh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyAmJiBzcmNbNF0gPT09ICc6JyAmJiAoc3JjWzBdID09PSAnZCcgfHwgc3JjWzBdID09PSAnRCcpICYmIChzcmNbMV0gPT09ICdhJyB8fCBzcmNbMV0gPT09ICdBJykgJiYgKHNyY1syXSA9PT0gJ3QnIHx8IHNyY1syXSA9PT0gJ1QnKSAmJiAoc3JjWzNdID09PSAnYScgfHwgc3JjWzNdID09PSAnQScpKSAmJiAhKHR5cGVvZiBzcmNTZXQgPT09ICdzdHJpbmcnICYmIHNyY1NldFs0XSA9PT0gJzonICYmIChzcmNTZXRbMF0gPT09ICdkJyB8fCBzcmNTZXRbMF0gPT09ICdEJykgJiYgKHNyY1NldFsxXSA9PT0gJ2EnIHx8IHNyY1NldFsxXSA9PT0gJ0EnKSAmJiAoc3JjU2V0WzJdID09PSAndCcgfHwgc3JjU2V0WzJdID09PSAnVCcpICYmIChzcmNTZXRbM10gPT09ICdhJyB8fCBzcmNTZXRbM10gPT09ICdBJykpKSB7XG4gICAgLy8gV2UgaGF2ZSBhIHN1c3BlbnNleSBpbWFnZSBhbmQgb3VnaHQgdG8gcHJlbG9hZCBpdCB0byBvcHRpbWl6ZSB0aGUgbG9hZGluZyBvZiBkaXNwbGF5IGJsb2NraW5nXG4gICAgLy8gcmVzdW1hYmxlU3RhdGUuXG4gICAgdmFyIHNpemVzID0gdHlwZW9mIHByb3BzLnNpemVzID09PSAnc3RyaW5nJyA/IHByb3BzLnNpemVzIDogdW5kZWZpbmVkO1xuICAgIHZhciBrZXkgPSBnZXRJbWFnZVJlc291cmNlS2V5KHNyYywgc3JjU2V0LCBzaXplcyk7XG4gICAgdmFyIHByb21vdGFibGVQcmVsb2FkcyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLmltYWdlcztcbiAgICB2YXIgcmVzb3VyY2UgPSBwcm9tb3RhYmxlUHJlbG9hZHMuZ2V0KGtleSk7XG5cbiAgICBpZiAocmVzb3VyY2UpIHtcbiAgICAgIC8vIFdlIGNvbnNpZGVyIHdoZXRoZXIgdGhpcyBwcmVsb2FkIGNhbiBiZSBwcm9tb3RlZCB0byBoaWdoZXIgcHJpb3JpdHkgZmx1c2hpbmcgcXVldWUuXG4gICAgICAvLyBUaGUgb25seSB0aW1lIGEgcmVzb3VyY2Ugd2lsbCBleGlzdCBoZXJlIGlzIGlmIGl0IHdhcyBjcmVhdGVkIGR1cmluZyB0aGlzIHJlbmRlclxuICAgICAgLy8gYW5kIHdhcyBub3QgYWxyZWFkeSBpbiB0aGUgaGlnaCBwcmlvcml0eSBxdWV1ZS5cbiAgICAgIGlmIChwcm9wcy5mZXRjaFByaW9yaXR5ID09PSAnaGlnaCcgfHwgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuc2l6ZSA8IDEwKSB7XG4gICAgICAgIC8vIERlbGV0ZSB0aGUgcmVzb3VyY2UgZnJvbSB0aGUgbWFwIHNpbmNlIHdlIGFyZSBwcm9tb3RpbmcgaXQgYW5kIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gcmVlbnRlciB0aGlzIGJyYW5jaCBpbiBhIHNlY29uZCBwYXNzIGZvciBkdXBsaWNhdGUgaW1nIGhyZWZzLlxuICAgICAgICBwcm9tb3RhYmxlUHJlbG9hZHMuZGVsZXRlKGtleSk7IC8vICRGbG93Rml4TWUgLSBGbG93IHNob3VsZCB1bmRlcnN0YW5kIHRoYXQgdGhpcyBpcyBhIFJlc291cmNlIGlmIHRoZSBjb25kaXRpb24gd2FzIHRydWVcblxuICAgICAgICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5hZGQocmVzb3VyY2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXJlc3VtYWJsZVN0YXRlLmltYWdlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIC8vIFdlIG11c3QgY29uc3RydWN0IGEgbmV3IHByZWxvYWQgcmVzb3VyY2VcbiAgICAgIHJlc3VtYWJsZVN0YXRlLmltYWdlUmVzb3VyY2VzW2tleV0gPSBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgdmFyIGNyb3NzT3JpZ2luID0gZ2V0Q3Jvc3NPcmlnaW5TdHJpbmcocHJvcHMuY3Jvc3NPcmlnaW4pO1xuICAgICAgdmFyIGhlYWRlcnMgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgdmFyIGhlYWRlcjtcblxuICAgICAgaWYgKGhlYWRlcnMgJiYgaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSA+IDAgJiYgKCAvLyB0aGlzIGlzIGEgaHVlcmlzdGljIHNpbWlsYXIgdG8gY2FwcGluZyBlbGVtZW50IHByZWxvYWRzIHRvIDEwIHVubGVzcyBleHBsaWNpdGx5XG4gICAgICAvLyBmZXRjaFByaW9yaXR5PVwiaGlnaFwiLiBXZSB1c2UgbGVuZ3RoIGhlcmUgd2hpY2ggbWVhbnMgaXQgd2lsbCBmaXQgZmV3ZXIgaW1hZ2VzIHdoZW5cbiAgICAgIC8vIHRoZSB1cmxzIGFyZSBsb25nIGFuZCBtb3JlIHdoZW4gc2hvcnQuIGFyZ3VhYmx5IGJ5dGUgc2l6ZSBpcyBhIGJldHRlciBodWVyaXN0aWMgYmVjYXVzZVxuICAgICAgLy8gaXQgZGlyZWN0bHkgdHJhbnNsYXRlcyB0byBob3cgbXVjaCB3ZSBzZW5kIGRvd24gYmVmb3JlIGNvbnRlbnQgaXMgYWN0dWFsbHkgc2Vlbi5cbiAgICAgIC8vIFdlIGNvdWxkIHVuaWZ5IHRoZSBjb3VudHMgYW5kIGFsc28gbWFrZSBpdCBzbyB0aGUgdG90YWwgaXMgdHJhY2tlZCByZWdhcmRsZXNzIG9mXG4gICAgICAvLyBmbHVzaGluZyBvdXRwdXQgYnV0IHNpbmNlIHRoZSBoZWFkZXJzIGFyZSBsaWtlbHkgdG8gYmUgZ28gZWFybGllciB0aGFuIGNvbnRlbnRcbiAgICAgIC8vIHRoZXkgZG9uJ3QgcmVhbGx5IGNvbmZsaWN0IHNvIGZvciBub3cgSSd2ZSBrZXB0IHRoZW0gc2VwYXJhdGVcbiAgICAgIHByb3BzLmZldGNoUHJpb3JpdHkgPT09ICdoaWdoJyB8fCBoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzLmxlbmd0aCA8IDUwMCkgJiYgKCAvLyBXZSBtYW51YWxseSBjb25zdHJ1Y3QgdGhlIG9wdGlvbnMgZm9yIHRoZSBwcmVsb2FkIG9ubHkgZnJvbSBzdHJpbmdzLiBXZSBkb24ndCB3YW50IHRvIHBvbGx1dGVcbiAgICAgIC8vIHRoZSBwYXJhbXMgbGlzdCB3aXRoIGFyYml0cmFyeSBwcm9wcyBhbmQgaWYgd2UgY29waWVkIGV2ZXJ5dGhpbmcgb3ZlciBhcyBpdCB3ZSBtaWdodCBnZXRcbiAgICAgIC8vIGNvZXJjaW9uIGVycm9ycy4gV2UgaGF2ZSBjaGVja3MgZm9yIHRoaXMgaW4gRGV2IGJ1dCBpdCBzZWVtcyBzYWZlciB0byBqdXN0IG9ubHkgYWNjZXB0IHZhbHVlc1xuICAgICAgLy8gdGhhdCBhcmUgc3RyaW5nc1xuICAgICAgaGVhZGVyID0gZ2V0UHJlbG9hZEFzSGVhZGVyKHNyYywgJ2ltYWdlJywge1xuICAgICAgICBpbWFnZVNyY1NldDogcHJvcHMuc3JjU2V0LFxuICAgICAgICBpbWFnZVNpemVzOiBwcm9wcy5zaXplcyxcbiAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgICBpbnRlZ3JpdHk6IHByb3BzLmludGVncml0eSxcbiAgICAgICAgbm9uY2U6IHByb3BzLm5vbmNlLFxuICAgICAgICB0eXBlOiBwcm9wcy50eXBlLFxuICAgICAgICBmZXRjaFByaW9yaXR5OiBwcm9wcy5mZXRjaFByaW9yaXR5LFxuICAgICAgICByZWZlcnJlclBvbGljeTogcHJvcHMucmVmZXJlclBvbGljeVxuICAgICAgfSksIC8vIFdlIGFsd2F5cyBjb25zdW1lIHRoZSBoZWFkZXIgbGVuZ3RoIHNpbmNlIG9uY2Ugd2UgZmluZCBvbmUgaGVhZGVyIHRoYXQgZG9lc24ndCBmaXRcbiAgICAgIC8vIHdlIGFzc3VtZSBhbGwgdGhlIHJlc3Qgd29uJ3QgYXMgd2VsbC4gVGhpcyBpcyB0byBhdm9pZCBnZXR0aW5nIGludG8gYSBzaXR1YXRpb25cbiAgICAgIC8vIHdoZXJlIHdlIGhhdmUgYSB2ZXJ5IHNtYWxsIHJlbWFpbmluZyBjYXBhY2l0eSBidXQgbm8gaGVhZGVycyB3aWxsIGV2ZXIgZml0IGFuZCB3ZSBlbmRcbiAgICAgIC8vIHVwIGNvbnN0YW50bHkgdHJ5aW5nIHRvIHNlZSBpZiB0aGUgbmV4dCByZXNvdXJjZSBtaWdodCBtYWtlIGl0LiBJbiB0aGUgZnV0dXJlIHdlIGNhblxuICAgICAgLy8gbWFrZSB0aGlzIGJlaGF2aW9yIGRpZmZlcmVudCBiZXR3ZWVuIHJlbmRlciBhbmQgcHJlcmVuZGVyIHNpbmNlIGluIHRoZSBsYXR0ZXIgY2FzZVxuICAgICAgLy8gd2UgYXJlIGxlc3Mgc2Vuc2l0aXZlIHRvIHRoZSBjdXJyZW50IHJlcXVlc3RzIHJ1bnRpbWUgcGVyIGFuZCBtb3JlIHNlbnNpdGl2ZSB0byBtYXhpbWl6aW5nXG4gICAgICAvLyBoZWFkZXJzLlxuICAgICAgKGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgLT0gaGVhZGVyLmxlbmd0aCkgPj0gMikpIHtcbiAgICAgICAgLy8gSWYgd2UgcG9zdHBvbmUgaW4gdGhlIHNoZWxsIHdlIHdpbGwgc3RpbGwgZW1pdCB0aGlzIHByZWxvYWQgc28gd2UgdHJhY2tcbiAgICAgICAgLy8gaXQgdG8gbWFrZSBzdXJlIHdlIGRvbid0IHJlc2V0IGl0LlxuICAgICAgICByZW5kZXJTdGF0ZS5yZXNldHMuaW1hZ2Vba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFM7XG5cbiAgICAgICAgaWYgKGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMpIHtcbiAgICAgICAgICBoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzICs9ICcsICc7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dOiB3ZSBhc3NpZ24gaGVhZGVyIGR1cmluZyB0aGUgaWYgY29uZGl0aW9uXG5cblxuICAgICAgICBoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzICs9IGhlYWRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc291cmNlID0gW107XG4gICAgICAgIHB1c2hMaW5rSW1wbChyZXNvdXJjZSwge1xuICAgICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICAgIGFzOiAnaW1hZ2UnLFxuICAgICAgICAgIC8vIFRoZXJlIGlzIGEgYnVnIGluIFNhZmFyaSB3aGVyZSBpbWFnZVNyY1NldCBpcyBub3QgcmVzcGVjdGVkIG9uIHByZWxvYWQgbGlua3NcbiAgICAgICAgICAvLyBzbyB3ZSBvbWl0IHRoZSBocmVmIGhlcmUgaWYgd2UgaGF2ZSBpbWFnZVNyY1NldCBiL2Mgc2FmYXJpIHdpbGwgbG9hZCB0aGUgd3JvbmcgaW1hZ2UuXG4gICAgICAgICAgLy8gVGhpcyBoYXJtcyBvbGRlciBicm93ZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgaW1hZ2VTcmNTZXQgYnkgbWFraW5nIHRoZWlyIHByZWxvYWRzIG5vdCB3b3JrXG4gICAgICAgICAgLy8gYnV0IHRoaXMgcG9wdWxhdGlvbiBpcyBzaHJpbmtpbmcgZmFzdCBhbmQgaXMgYWxyZWFkeSBzbWFsbCBzbyB3ZSBhY2NlcHQgdGhpcyB0cmFkZW9mZi5cbiAgICAgICAgICBocmVmOiBzcmNTZXQgPyB1bmRlZmluZWQgOiBzcmMsXG4gICAgICAgICAgaW1hZ2VTcmNTZXQ6IHNyY1NldCxcbiAgICAgICAgICBpbWFnZVNpemVzOiBzaXplcyxcbiAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgaW50ZWdyaXR5OiBwcm9wcy5pbnRlZ3JpdHksXG4gICAgICAgICAgdHlwZTogcHJvcHMudHlwZSxcbiAgICAgICAgICBmZXRjaFByaW9yaXR5OiBwcm9wcy5mZXRjaFByaW9yaXR5LFxuICAgICAgICAgIHJlZmVycmVyUG9saWN5OiBwcm9wcy5yZWZlcnJlclBvbGljeVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocHJvcHMuZmV0Y2hQcmlvcml0eSA9PT0gJ2hpZ2gnIHx8IHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLnNpemUgPCAxMCkge1xuICAgICAgICAgIHJlbmRlclN0YXRlLmhpZ2hJbWFnZVByZWxvYWRzLmFkZChyZXNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChyZXNvdXJjZSk7IC8vIFdlIGNhbiBidW1wIHRoZSBwcmlvcml0eSB1cCBpZiB0aGUgc2FtZSBpbWcgaXMgcmVuZGVyZWQgbGF0ZXJcbiAgICAgICAgICAvLyB3aXRoIGZldGNoUHJpb3JpdHk9XCJoaWdoXCJcblxuICAgICAgICAgIHByb21vdGFibGVQcmVsb2Fkcy5zZXQoa2V5LCByZXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHVzaFNlbGZDbG9zaW5nKHRhcmdldCwgcHJvcHMsICdpbWcnKTtcbn1cblxuZnVuY3Rpb24gcHVzaFNlbGZDbG9zaW5nKHRhcmdldCwgcHJvcHMsIHRhZykge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRhZyArIFwiIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgXCIgKyAndXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0TWVudUl0ZW0odGFyZ2V0LCBwcm9wcykge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdtZW51aXRlbScpKTtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWVudWl0ZW1zIGNhbm5vdCBoYXZlIGBjaGlsZHJlbmAgbm9yIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHB1c2hUaXRsZSh0YXJnZXQsIHByb3BzLCByZW5kZXJTdGF0ZSwgaW5zZXJ0aW9uTW9kZSwgbm9zY3JpcHRUYWdJblNjb3BlKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgJ2NoaWxkcmVuJykpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgdmFyIGNoaWxkID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5sZW5ndGggPCAyID8gY2hpbGRyZW5bMF0gOiBudWxsIDogY2hpbGRyZW47XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIGVycm9yKCdSZWFjdCBleHBlY3RzIHRoZSBgY2hpbGRyZW5gIHByb3Agb2YgPHRpdGxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kIGFuIEFycmF5IHdpdGggbGVuZ3RoICVzIGluc3RlYWQuJyArICcgQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGBjaGlsZHJlbmAgb2YgPHRpdGxlPiB0YWdzIHRvIGEgc2luZ2xlIHN0cmluZyB2YWx1ZScgKyAnIHdoaWNoIGlzIHdoeSBBcnJheXMgb2YgbGVuZ3RoIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3Qgc3VwcG9ydGVkLiBXaGVuIHVzaW5nIEpTWCBpdCBjYW4gYmUgY29tbW9uZyB0byBjb21iaW5lIHRleHQgbm9kZXMgYW5kIHZhbHVlIG5vZGVzLicgKyAnIEZvciBleGFtcGxlOiA8dGl0bGU+aGVsbG8ge25hbWVPZlVzZXJ9PC90aXRsZT4uIFdoaWxlIG5vdCBpbW1lZGlhdGVseSBhcHBhcmVudCwgYGNoaWxkcmVuYCBpbiB0aGlzIGNhc2UgaXMgYW4gQXJyYXkgd2l0aCBsZW5ndGggMi4gSWYgeW91ciBgY2hpbGRyZW5gIHByb3AnICsgJyBpcyB1c2luZyB0aGlzIGZvcm0gdHJ5IHJld3JpdGluZyBpdCB1c2luZyBhIHRlbXBsYXRlIHN0cmluZzogPHRpdGxlPntgaGVsbG8gJHtuYW1lT2ZVc2VyfWB9PC90aXRsZT4uJywgY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgdmFyIGNoaWxkVHlwZSA9IHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJyA/ICdhIEZ1bmN0aW9uJyA6ICdhIFN5Ym1vbCc7XG5cbiAgICAgICAgZXJyb3IoJ1JlYWN0IGV4cGVjdCBjaGlsZHJlbiBvZiA8dGl0bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgJXMgaW5zdGVhZC4nICsgJyBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0byBiZSBhYmxlIHRvIGNvbnZlcnQgY2hpbGRyZW4gb2YgPHRpdGxlPicgKyAnIHRhZ3MgdG8gYSBzaW5nbGUgc3RyaW5nIHZhbHVlLicsIGNoaWxkVHlwZSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkICYmIGNoaWxkLnRvU3RyaW5nID09PSB7fS50b1N0cmluZykge1xuICAgICAgICBpZiAoY2hpbGQuJCR0eXBlb2YgIT0gbnVsbCkge1xuICAgICAgICAgIGVycm9yKCdSZWFjdCBleHBlY3RzIHRoZSBgY2hpbGRyZW5gIHByb3Agb2YgPHRpdGxlPiB0YWdzIHRvIGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIG9iamVjdCB3aXRoIGEgbm92ZWwgYHRvU3RyaW5nYCBtZXRob2QgYnV0IGZvdW5kIGFuIG9iamVjdCB0aGF0IGFwcGVhcnMgdG8gYmUnICsgJyBhIFJlYWN0IGVsZW1lbnQgd2hpY2ggbmV2ZXIgaW1wbGVtZW50cyBhIHN1aXRhYmxlIGB0b1N0cmluZ2AgbWV0aG9kLiBCcm93c2VycyB0cmVhdCBhbGwgY2hpbGQgTm9kZXMgb2YgPHRpdGxlPiB0YWdzIGFzIFRleHQgY29udGVudCBhbmQgUmVhY3QgZXhwZWN0cyB0bycgKyAnIGJlIGFibGUgdG8gY29udmVydCBjaGlsZHJlbiBvZiA8dGl0bGU+IHRhZ3MgdG8gYSBzaW5nbGUgc3RyaW5nIHZhbHVlIHdoaWNoIGlzIHdoeSByZW5kZXJpbmcgUmVhY3QgZWxlbWVudHMgaXMgbm90IHN1cHBvcnRlZC4gSWYgdGhlIGBjaGlsZHJlbmAgb2YgPHRpdGxlPiBpcycgKyAnIGEgUmVhY3QgQ29tcG9uZW50IHRyeSBtb3ZpbmcgdGhlIDx0aXRsZT4gdGFnIGludG8gdGhhdCBjb21wb25lbnQuIElmIHRoZSBgY2hpbGRyZW5gIG9mIDx0aXRsZT4gaXMgc29tZSBIVE1MIG1hcmt1cCBjaGFuZ2UgaXQgdG8gYmUgVGV4dCBvbmx5IHRvIGJlIHZhbGlkIEhUTUwuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IGV4cGVjdHMgdGhlIGBjaGlsZHJlbmAgcHJvcCBvZiA8dGl0bGU+IHRhZ3MgdG8gYmUgYSBzdHJpbmcsIG51bWJlciwgb3Igb2JqZWN0IHdpdGggYSBub3ZlbCBgdG9TdHJpbmdgIG1ldGhvZCBidXQgZm91bmQgYW4gb2JqZWN0IHRoYXQgZG9lcyBub3QgaW1wbGVtZW50JyArICcgYSBzdWl0YWJsZSBgdG9TdHJpbmdgIG1ldGhvZC4gQnJvd3NlcnMgdHJlYXQgYWxsIGNoaWxkIE5vZGVzIG9mIDx0aXRsZT4gdGFncyBhcyBUZXh0IGNvbnRlbnQgYW5kIFJlYWN0IGV4cGVjdHMgdG8gYmUgYWJsZSB0byBjb252ZXJ0IGNoaWxkcmVuIG9mIDx0aXRsZT4gdGFncycgKyAnIHRvIGEgc2luZ2xlIHN0cmluZyB2YWx1ZS4gVXNpbmcgdGhlIGRlZmF1bHQgYHRvU3RyaW5nYCBtZXRob2QgYXZhaWxhYmxlIG9uIGV2ZXJ5IG9iamVjdCBpcyBhbG1vc3QgY2VydGFpbmx5IGFuIGVycm9yLiBDb25zaWRlciB3aGV0aGVyIHRoZSBgY2hpbGRyZW5gIG9mIHRoaXMgPHRpdGxlPicgKyAnIGlzIGFuIG9iamVjdCBpbiBlcnJvciBhbmQgY2hhbmdlIGl0IHRvIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSBpZiBzby4gT3RoZXJ3aXNlIGltcGxlbWVudCBhIGB0b1N0cmluZ2AgbWV0aG9kIHRoYXQgUmVhY3QgY2FuIHVzZSB0byBwcm9kdWNlIGEgdmFsaWQgPHRpdGxlPi4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoaW5zZXJ0aW9uTW9kZSAhPT0gU1ZHX01PREUgJiYgIW5vc2NyaXB0VGFnSW5TY29wZSAmJiBwcm9wcy5pdGVtUHJvcCA9PSBudWxsKSB7XG4gICAgICBwdXNoVGl0bGVJbXBsKHJlbmRlclN0YXRlLmhvaXN0YWJsZUNodW5rcywgcHJvcHMpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwdXNoVGl0bGVJbXBsKHRhcmdldCwgcHJvcHMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoVGl0bGVJbXBsKHRhcmdldCwgcHJvcHMpIHtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygndGl0bGUnKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgdmFyIGNoaWxkID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5sZW5ndGggPCAyID8gY2hpbGRyZW5bMF0gOiBudWxsIDogY2hpbGRyZW47XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY2hpbGQgIT09ICdzeW1ib2wnICYmIGNoaWxkICE9PSBudWxsICYmIGNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCcnICsgY2hpbGQpKSk7XG4gIH1cblxuICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gIHRhcmdldC5wdXNoKGVuZENodW5rRm9yVGFnKCd0aXRsZScpKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydEhlYWQodGFyZ2V0LCBwcm9wcywgcmVuZGVyU3RhdGUsIGluc2VydGlvbk1vZGUpIHtcbiAge1xuICAgIGlmIChpbnNlcnRpb25Nb2RlIDwgSFRNTF9NT0RFICYmIHJlbmRlclN0YXRlLmhlYWRDaHVua3MgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgPGhlYWQ+IGlzIHRoZSBEb2N1bWVudC5oZWFkIGFuZCBzaG91bGQgYmUgcGFydCBvZiB0aGUgcHJlYW1ibGVcbiAgICAgIHJlbmRlclN0YXRlLmhlYWRDaHVua3MgPSBbXTtcbiAgICAgIHJldHVybiBwdXNoU3RhcnRHZW5lcmljRWxlbWVudChyZW5kZXJTdGF0ZS5oZWFkQ2h1bmtzLCBwcm9wcywgJ2hlYWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyA8aGVhZD4gaXMgZGVlcCBhbmQgaXMgbGlrZWx5IGp1c3QgYW4gZXJyb3IuIHdlIGVtaXQgaXQgaW5saW5lIHRob3VnaC5cbiAgICAgIC8vIFZhbGlkYXRpb24gc2hvdWxkIHdhcm4gdGhhdCB0aGlzIHRhZyBpcyB0aGUgdGhlIHdyb25nIHNwb3QuXG4gICAgICByZXR1cm4gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0LCBwcm9wcywgJ2hlYWQnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0SHRtbCh0YXJnZXQsIHByb3BzLCByZW5kZXJTdGF0ZSwgaW5zZXJ0aW9uTW9kZSkge1xuICB7XG4gICAgaWYgKGluc2VydGlvbk1vZGUgPT09IFJPT1RfSFRNTF9NT0RFICYmIHJlbmRlclN0YXRlLmh0bWxDaHVua3MgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgPGh0bWw+IGlzIHRoZSBEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgYW5kIHNob3VsZCBiZSBwYXJ0IG9mIHRoZSBwcmVhbWJsZVxuICAgICAgcmVuZGVyU3RhdGUuaHRtbENodW5rcyA9IFtkb2N0eXBlQ2h1bmtdO1xuICAgICAgcmV0dXJuIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHJlbmRlclN0YXRlLmh0bWxDaHVua3MsIHByb3BzLCAnaHRtbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIDxodG1sPiBpcyBkZWVwIGFuZCBpcyBsaWtlbHkganVzdCBhbiBlcnJvci4gd2UgZW1pdCBpdCBpbmxpbmUgdGhvdWdoLlxuICAgICAgLy8gVmFsaWRhdGlvbiBzaG91bGQgd2FybiB0aGF0IHRoaXMgdGFnIGlzIHRoZSB0aGUgd3Jvbmcgc3BvdC5cbiAgICAgIHJldHVybiBwdXNoU3RhcnRHZW5lcmljRWxlbWVudCh0YXJnZXQsIHByb3BzLCAnaHRtbCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoU2NyaXB0KHRhcmdldCwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgdGV4dEVtYmVkZGVkLCBpbnNlcnRpb25Nb2RlLCBub3NjcmlwdFRhZ0luU2NvcGUpIHtcbiAge1xuICAgIHZhciBhc3luY1Byb3AgPSBwcm9wcy5hc3luYztcblxuICAgIGlmICh0eXBlb2YgcHJvcHMuc3JjICE9PSAnc3RyaW5nJyB8fCAhcHJvcHMuc3JjIHx8ICEoYXN5bmNQcm9wICYmIHR5cGVvZiBhc3luY1Byb3AgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGFzeW5jUHJvcCAhPT0gJ3N5bWJvbCcpIHx8IHByb3BzLm9uTG9hZCB8fCBwcm9wcy5vbkVycm9yIHx8IGluc2VydGlvbk1vZGUgPT09IFNWR19NT0RFIHx8IG5vc2NyaXB0VGFnSW5TY29wZSB8fCBwcm9wcy5pdGVtUHJvcCAhPSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHNjcmlwdCB3aWxsIG5vdCBiZSBhIHJlc291cmNlLCB3ZSBiYWlsb3V0IGVhcmx5IGFuZCBlbWl0IGl0IGluIHBsYWNlLlxuICAgICAgcmV0dXJuIHB1c2hTY3JpcHRJbXBsKHRhcmdldCwgcHJvcHMpO1xuICAgIH1cblxuICAgIHZhciBzcmMgPSBwcm9wcy5zcmM7XG4gICAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KHNyYyk7IC8vIFdlIGNhbiBtYWtlIHRoaXMgPHNjcmlwdD4gaW50byBhIFNjcmlwdFJlc291cmNlXG5cbiAgICB2YXIgcmVzb3VyY2VzLCBwcmVsb2FkcztcblxuICAgIGlmIChwcm9wcy50eXBlID09PSAnbW9kdWxlJykge1xuICAgICAgcmVzb3VyY2VzID0gcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzO1xuICAgICAgcHJlbG9hZHMgPSByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5tb2R1bGVTY3JpcHRzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXM7XG4gICAgICBwcmVsb2FkcyA9IHJlbmRlclN0YXRlLnByZWxvYWRzLnNjcmlwdHM7XG4gICAgfVxuXG4gICAgdmFyIGhhc0tleSA9IHJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgIHZhciByZXNvdXJjZVN0YXRlID0gaGFzS2V5ID8gcmVzb3VyY2VzW2tleV0gOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAocmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTKSB7XG4gICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gY3JlYXRlIHRoaXMgcmVzb3VyY2Ugbm93IHNvIGl0IGlzIG1hcmtlZCBhcyBFeGlzdHNcbiAgICAgIHJlc291cmNlc1trZXldID0gRVhJU1RTO1xuICAgICAgdmFyIHNjcmlwdFByb3BzID0gcHJvcHM7XG5cbiAgICAgIGlmIChyZXNvdXJjZVN0YXRlKSB7XG4gICAgICAgIC8vIFdoZW4gcmVzb3VyY2VTdGF0ZSBpcyB0cnV0eSBpdCBpcyBhIFByZWxvYWQgc3RhdGUuIFdlIGNhc3QgaXQgZm9yIGNsYXJpdHlcbiAgICAgICAgdmFyIHByZWxvYWRTdGF0ZSA9IHJlc291cmNlU3RhdGU7XG5cbiAgICAgICAgaWYgKHByZWxvYWRTdGF0ZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBzY3JpcHRQcm9wcyA9IGFzc2lnbih7fSwgcHJvcHMpO1xuICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKHNjcmlwdFByb3BzLCBwcmVsb2FkU3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZWxvYWRSZXNvdXJjZSA9IHByZWxvYWRzLmdldChrZXkpO1xuXG4gICAgICAgIGlmIChwcmVsb2FkUmVzb3VyY2UpIHtcbiAgICAgICAgICAvLyB0aGUgcHJlbG9hZCByZXNvdXJjZSBleGlzdHMgd2FzIGNyZWF0ZWQgaW4gdGhpcyByZW5kZXIuIE5vdyB0aGF0IHdlIGhhdmVcbiAgICAgICAgICAvLyBhIHNjcmlwdCByZXNvdXJjZSB3aGljaCB3aWxsIGVtaXQgZWFybGllciB0aGFuIGEgcHJlbG9hZCB3b3VsZCBpZiBpdFxuICAgICAgICAgIC8vIGhhc24ndCBhbHJlYWR5IGZsdXNoZWQgd2UgcHJldmVudCBpdCBmcm9tIGZsdXNoaW5nIGJ5IHplcm9pbmcgdGhlIGxlbmd0aFxuICAgICAgICAgIHByZWxvYWRSZXNvdXJjZS5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciByZXNvdXJjZSA9IFtdOyAvLyBBZGQgdG8gdGhlIHNjcmlwdCBmbHVzaGluZyBxdWV1ZVxuXG4gICAgICByZW5kZXJTdGF0ZS5zY3JpcHRzLmFkZChyZXNvdXJjZSk7IC8vIGVuY29kZSB0aGUgdGFnIGFzIENodW5rc1xuXG4gICAgICBwdXNoU2NyaXB0SW1wbChyZXNvdXJjZSwgc2NyaXB0UHJvcHMpO1xuICAgIH1cblxuICAgIGlmICh0ZXh0RW1iZWRkZWQpIHtcbiAgICAgIC8vIFRoaXMgc2NyaXB0IGZvbGxvd3MgdGV4dCBidXQgd2UgYXJlbid0IHdyaXRpbmcgYSB0YWcuIHdoaWxlIG5vdCBhcyBlZmZpY2llbnQgYXMgcG9zc2libGUgd2UgbmVlZFxuICAgICAgLy8gdG8gYmUgc2FmZSBhbmQgYXNzdW1lIHRleHQgd2lsbCBmb2xsb3cgYnkgaW5zZXJ0aW5nIGEgdGV4dFNlcGFyYXRvclxuICAgICAgdGFyZ2V0LnB1c2godGV4dFNlcGFyYXRvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFNjcmlwdEltcGwodGFyZ2V0LCBwcm9wcykge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdzY3JpcHQnKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcblxuICB7XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwgJiYgdHlwZW9mIGNoaWxkcmVuICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGRlc2NyaXB0aXZlU3RhdGVtZW50ID0gdHlwZW9mIGNoaWxkcmVuID09PSAnbnVtYmVyJyA/ICdhIG51bWJlciBmb3IgY2hpbGRyZW4nIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyAnYW4gYXJyYXkgZm9yIGNoaWxkcmVuJyA6ICdzb21ldGhpbmcgdW5leHBlY3RlZCBmb3IgY2hpbGRyZW4nO1xuXG4gICAgICBlcnJvcignQSBzY3JpcHQgZWxlbWVudCB3YXMgcmVuZGVyZWQgd2l0aCAlcy4gSWYgc2NyaXB0IGVsZW1lbnQgaGFzIGNoaWxkcmVuIGl0IG11c3QgYmUgYSBzaW5nbGUgc3RyaW5nLicgKyAnIENvbnNpZGVyIHVzaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIG9yIHBhc3NpbmcgYSBwbGFpbiBzdHJpbmcgYXMgY2hpbGRyZW4uJywgZGVzY3JpcHRpdmVTdGF0ZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcblxuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZW5jb2RlSFRNTFRleHROb2RlKGNoaWxkcmVuKSkpO1xuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kQ2h1bmtGb3JUYWcoJ3NjcmlwdCcpKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHRhcmdldCwgcHJvcHMsIHRhZykge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcblxuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgIC8vIFNwZWNpYWwgY2FzZSBjaGlsZHJlbiBhcyBhIHN0cmluZyB0byBhdm9pZCB0aGUgdW5uZWNlc3NhcnkgY29tbWVudC5cbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBzcGVjaWFsIGNhc2UgYWZ0ZXIgdGhlIGdlbmVyYWwgb3B0aW1pemF0aW9uIGlzIGluIHBsYWNlLlxuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZW5jb2RlSFRNTFRleHROb2RlKGNoaWxkcmVuKSkpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRDdXN0b21FbGVtZW50KHRhcmdldCwgcHJvcHMsIHRhZykge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wS2V5O1xuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgIHB1c2hTdHlsZUF0dHJpYnV0ZSh0YXJnZXQsIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJzpcbiAgICAgICAgY2FzZSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJzpcbiAgICAgICAgICAvLyBJZ25vcmVkLiBUaGVzZSBhcmUgYnVpbHQtaW4gdG8gUmVhY3Qgb24gdGhlIGNsaWVudC5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjbGFzc05hbWUnOlxuXG4gICAgICAgIC8vIGludGVudGlvbmFsIGZhbGx0aHJvdWdoXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoaXNBdHRyaWJ1dGVOYW1lU2FmZShwcm9wS2V5KSAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzeW1ib2wnKSB7XG5cbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhhdHRyaWJ1dGVOYW1lKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHByb3BWYWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxudmFyIGxlYWRpbmdOZXdsaW5lID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcXG4nKTtcblxuZnVuY3Rpb24gcHVzaFN0YXJ0UHJlZm9ybWF0dGVkRWxlbWVudCh0YXJnZXQsIHByb3BzLCB0YWcpIHtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyh0YWcpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpOyAvLyB0ZXh0L2h0bWwgaWdub3JlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZXNlIHRhZ3MgaWYgaXQncyBhIG5ld2xpbmVcbiAgLy8gUHJlZmVyIHRvIGJyZWFrIGFwcGxpY2F0aW9uL3htbCBvdmVyIHRleHQvaHRtbCAoZm9yIG5vdykgYnkgYWRkaW5nXG4gIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcbiAgLy8gdGV4dGFyZWFzLCByZXBsYWNpbmcgXCJeXFxuXCIgd2l0aCBcIlxcclxcblwiIGRvZXNuJ3QgZ2V0IGVhdGVuLCBhbmQgdGhlIGZpcnN0XG4gIC8vIFxcciBpcyBub3JtYWxpemVkIG91dCBieSBIVE1MVGV4dEFyZWFFbGVtZW50I3ZhbHVlLilcbiAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cbiAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudC1yZXN0cmljdGlvbnM+XG4gIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI25ld2xpbmVzPlxuICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXG4gIC8vICBmcm9tIDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5PlxuICAvLyBUT0RPOiBUaGlzIGRvZXNuJ3QgZGVhbCB3aXRoIHRoZSBjYXNlIHdoZXJlIHRoZSBjaGlsZCBpcyBhbiBhcnJheVxuICAvLyBvciBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgc3RyaW5nLlxuXG4gIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5uZXJIVE1MICE9PSAnb2JqZWN0JyB8fCAhKCdfX2h0bWwnIGluIGlubmVySFRNTCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gJyArICdQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rhbmdlcm91c2x5LXNldC1pbm5lci1odG1sICcgKyAnZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGh0bWwgPSBpbm5lckhUTUwuX19odG1sO1xuXG4gICAgaWYgKGh0bWwgIT09IG51bGwgJiYgaHRtbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGh0bWwgPT09ICdzdHJpbmcnICYmIGh0bWwubGVuZ3RoID4gMCAmJiBodG1sWzBdID09PSAnXFxuJykge1xuICAgICAgICB0YXJnZXQucHVzaChsZWFkaW5nTmV3bGluZSwgc3RyaW5nVG9DaHVuayhodG1sKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oaHRtbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKCcnICsgaHRtbCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnICYmIGNoaWxkcmVuWzBdID09PSAnXFxuJykge1xuICAgIHRhcmdldC5wdXNoKGxlYWRpbmdOZXdsaW5lKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn0gLy8gV2UgYWNjZXB0IGFueSB0YWcgdG8gYmUgcmVuZGVyZWQgYnV0IHNpbmNlIHRoaXMgZ2V0cyBpbmplY3RlZCBpbnRvIGFyYml0cmFyeVxuLy8gSFRNTCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBpdCdzIGEgc2FmZSB0YWcuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lXG5cblxudmFyIFZBTElEX1RBR19SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aOl9cXC5cXC1cXGRdKiQvOyAvLyBTaW1wbGlmaWVkIHN1YnNldFxuXG52YXIgdmFsaWRhdGVkVGFnQ2FjaGUgPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSB7XG4gIHZhciB0YWdTdGFydENodW5rID0gdmFsaWRhdGVkVGFnQ2FjaGUuZ2V0KHRhZyk7XG5cbiAgaWYgKHRhZ1N0YXJ0Q2h1bmsgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghVkFMSURfVEFHX1JFR0VYLnRlc3QodGFnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0YWc6IFwiICsgdGFnKTtcbiAgICB9XG5cbiAgICB0YWdTdGFydENodW5rID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8JyArIHRhZyk7XG4gICAgdmFsaWRhdGVkVGFnQ2FjaGUuc2V0KHRhZywgdGFnU3RhcnRDaHVuayk7XG4gIH1cblxuICByZXR1cm4gdGFnU3RhcnRDaHVuaztcbn1cblxudmFyIGRvY3R5cGVDaHVuayA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPCFET0NUWVBFIGh0bWw+Jyk7XG5mdW5jdGlvbiBwdXNoU3RhcnRJbnN0YW5jZSh0YXJnZXQsIHR5cGUsIHByb3BzLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIGZvcm1hdENvbnRleHQsIHRleHRFbWJlZGRlZCkge1xuICB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMsIG51bGwpO1xuXG4gICAgaWYgKCFwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgJiYgcHJvcHMuY29udGVudEVkaXRhYmxlICYmIHByb3BzLmNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIGVycm9yKCdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSAhPT0gU1ZHX01PREUgJiYgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlICE9PSBNQVRITUxfTU9ERSkge1xuICAgICAgaWYgKHR5cGUuaW5kZXhPZignLScpID09PSAtMSAmJiB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IHR5cGUpIHtcbiAgICAgICAgZXJyb3IoJzwlcyAvPiBpcyB1c2luZyBpbmNvcnJlY3QgY2FzaW5nLiAnICsgJ1VzZSBQYXNjYWxDYXNlIGZvciBSZWFjdCBjb21wb25lbnRzLCAnICsgJ29yIGxvd2VyY2FzZSBmb3IgSFRNTCBlbGVtZW50cy4nLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdkaXYnOlxuICAgIGNhc2UgJ3NwYW4nOlxuICAgIGNhc2UgJ3N2Zyc6XG4gICAgY2FzZSAncGF0aCc6XG4gICAgY2FzZSAnYSc6XG4gICAgY2FzZSAnZyc6XG4gICAgY2FzZSAncCc6XG4gICAgY2FzZSAnbGknOlxuICAgICAgLy8gRmFzdCB0cmFjayB2ZXJ5IGNvbW1vbiB0YWdzXG4gICAgICBicmVhaztcbiAgICAvLyBTcGVjaWFsIHRhZ3NcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0U2VsZWN0KHRhcmdldCwgcHJvcHMpO1xuXG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHJldHVybiBwdXNoU3RhcnRPcHRpb24odGFyZ2V0LCBwcm9wcywgZm9ybWF0Q29udGV4dCk7XG5cbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0VGV4dEFyZWEodGFyZ2V0LCBwcm9wcyk7XG5cbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICByZXR1cm4gcHVzaElucHV0KHRhcmdldCwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSk7XG5cbiAgICBjYXNlICdidXR0b24nOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydEJ1dHRvbih0YXJnZXQsIHByb3BzLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUpO1xuXG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0Rm9ybSh0YXJnZXQsIHByb3BzLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUpO1xuXG4gICAgY2FzZSAnbWVudWl0ZW0nOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydE1lbnVJdGVtKHRhcmdldCwgcHJvcHMpO1xuXG4gICAgY2FzZSAndGl0bGUnOlxuICAgICAgcmV0dXJuIHB1c2hUaXRsZSh0YXJnZXQsIHByb3BzLCByZW5kZXJTdGF0ZSwgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlLCAhIShmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgTk9TQ1JJUFRfU0NPUEUpKSA7XG5cbiAgICBjYXNlICdsaW5rJzpcbiAgICAgIHJldHVybiBwdXNoTGluayh0YXJnZXQsIHByb3BzLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIHRleHRFbWJlZGRlZCwgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlLCAhIShmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgTk9TQ1JJUFRfU0NPUEUpKTtcblxuICAgIGNhc2UgJ3NjcmlwdCc6XG4gICAgICByZXR1cm4gcHVzaFNjcmlwdCh0YXJnZXQsIHByb3BzLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIHRleHRFbWJlZGRlZCwgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlLCAhIShmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgTk9TQ1JJUFRfU0NPUEUpKSA7XG5cbiAgICBjYXNlICdzdHlsZSc6XG4gICAgICByZXR1cm4gcHVzaFN0eWxlKHRhcmdldCwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgdGV4dEVtYmVkZGVkLCBmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUsICEhKGZvcm1hdENvbnRleHQudGFnU2NvcGUgJiBOT1NDUklQVF9TQ09QRSkpO1xuXG4gICAgY2FzZSAnbWV0YSc6XG4gICAgICByZXR1cm4gcHVzaE1ldGEodGFyZ2V0LCBwcm9wcywgcmVuZGVyU3RhdGUsIHRleHRFbWJlZGRlZCwgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlLCAhIShmb3JtYXRDb250ZXh0LnRhZ1Njb3BlICYgTk9TQ1JJUFRfU0NPUEUpKTtcbiAgICAvLyBOZXdsaW5lIGVhdGluZyB0YWdzXG5cbiAgICBjYXNlICdsaXN0aW5nJzpcbiAgICBjYXNlICdwcmUnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gcHVzaFN0YXJ0UHJlZm9ybWF0dGVkRWxlbWVudCh0YXJnZXQsIHByb3BzLCB0eXBlKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2ltZyc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBwdXNoSW1nKHRhcmdldCwgcHJvcHMsIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgISEoZm9ybWF0Q29udGV4dC50YWdTY29wZSAmIFBJQ1RVUkVfU0NPUEUpKSA7XG4gICAgICB9XG4gICAgLy8gT21pdHRlZCBjbG9zZSB0YWdzXG5cbiAgICBjYXNlICdiYXNlJzpcbiAgICBjYXNlICdhcmVhJzpcbiAgICBjYXNlICdicic6XG4gICAgY2FzZSAnY29sJzpcbiAgICBjYXNlICdlbWJlZCc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2tleWdlbic6XG4gICAgY2FzZSAncGFyYW0nOlxuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgY2FzZSAndHJhY2snOlxuICAgIGNhc2UgJ3dicic6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0LCBwcm9wcywgdHlwZSk7XG4gICAgICB9XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLCB0aGF0IGFyZSBuZXZlciBjdXN0b20gZWxlbWVudHMuXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2N1c3RvbS1lbGVtZW50cy1jb3JlLWNvbmNlcHRzXG5cbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIFByZWFtYmxlIHN0YXJ0IHRhZ3NcblxuICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydEhlYWQodGFyZ2V0LCBwcm9wcywgcmVuZGVyU3RhdGUsIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSk7XG5cbiAgICBjYXNlICdodG1sJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHB1c2hTdGFydEh0bWwodGFyZ2V0LCBwcm9wcywgcmVuZGVyU3RhdGUsIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSk7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBpZiAodHlwZS5pbmRleE9mKCctJykgIT09IC0xKSB7XG4gICAgICAgICAgLy8gQ3VzdG9tIGVsZW1lbnRcbiAgICAgICAgICByZXR1cm4gcHVzaFN0YXJ0Q3VzdG9tRWxlbWVudCh0YXJnZXQsIHByb3BzLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9IC8vIEdlbmVyaWMgZWxlbWVudFxuXG5cbiAgcmV0dXJuIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHRhcmdldCwgcHJvcHMsIHR5cGUpO1xufVxudmFyIGVuZFRhZ0NhY2hlID0gbmV3IE1hcCgpO1xuXG5mdW5jdGlvbiBlbmRDaHVua0ZvclRhZyh0YWcpIHtcbiAgdmFyIGNodW5rID0gZW5kVGFnQ2FjaGUuZ2V0KHRhZyk7XG5cbiAgaWYgKGNodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICBjaHVuayA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC8nICsgdGFnICsgJz4nKTtcbiAgICBlbmRUYWdDYWNoZS5zZXQodGFnLCBjaHVuayk7XG4gIH1cblxuICByZXR1cm4gY2h1bms7XG59XG5cbmZ1bmN0aW9uIHB1c2hFbmRJbnN0YW5jZSh0YXJnZXQsIHR5cGUsIHByb3BzLCByZXN1bWFibGVTdGF0ZSwgZm9ybWF0Q29udGV4dCkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAvLyBXaGVuIGZsb2F0IGlzIG9uIHdlIGV4cGVjdCB0aXRsZSBhbmQgc2NyaXB0IHRhZ3MgdG8gYWx3YXlzIGJlIHB1c2hlZCBpblxuICAgIC8vIGEgdW5pdCBhbmQgbmV2ZXIgcmV0dXJuIGNoaWxkcmVuLiB3aGVuIHdlIGVuZCB1cCBwdXNoaW5nIHRoZSBlbmQgdGFnIHdlXG4gICAgLy8gd2FudCB0byBlbnN1cmUgdGhlcmUgaXMgbm8gZXh0cmEgY2xvc2luZyB0YWcgcHVzaGVkXG4gICAgY2FzZSAndGl0bGUnOlxuICAgIGNhc2UgJ3N0eWxlJzpcbiAgICBjYXNlICdzY3JpcHQnOlxuICAgIC8vIE9taXR0ZWQgY2xvc2UgdGFnc1xuICAgIC8vIFRPRE86IEluc3RlYWQgb2YgcmVwZWF0aW5nIHRoaXMgc3dpdGNoIHdlIGNvdWxkIHRyeSB0byBwYXNzIGEgZmxhZyBmcm9tIGFib3ZlLlxuICAgIC8vIFRoYXQgd291bGQgcmVxdWlyZSByZXR1cm5pbmcgYSB0dXBsZS4gV2hpY2ggbWlnaHQgYmUgb2sgaWYgaXQgZ2V0cyBpbmxpbmVkLlxuXG4gICAgY2FzZSAnYXJlYSc6XG4gICAgY2FzZSAnYmFzZSc6XG4gICAgY2FzZSAnYnInOlxuICAgIGNhc2UgJ2NvbCc6XG4gICAgY2FzZSAnZW1iZWQnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdrZXlnZW4nOlxuICAgIGNhc2UgJ2xpbmsnOlxuICAgIGNhc2UgJ21ldGEnOlxuICAgIGNhc2UgJ3BhcmFtJzpcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgIGNhc2UgJ3RyYWNrJzpcbiAgICBjYXNlICd3YnInOlxuICAgICAge1xuICAgICAgICAvLyBObyBjbG9zZSB0YWcgbmVlZGVkLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgLy8gUG9zdGFtYmxlIGVuZCB0YWdzXG4gICAgLy8gV2hlbiBmbG9hdCBpcyBlbmFibGVkIHdlIG9taXQgdGhlIGVuZCB0YWdzIGZvciBib2R5IGFuZCBodG1sIHdoZW5cbiAgICAvLyB0aGV5IHJlcHJlc2VudCB0aGUgRG9jdW1lbnQuYm9keSBhbmQgRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IE5vZGVzLlxuICAgIC8vIFRoaXMgaXMgc28gd2UgY2FuIHdpdGhob2xkIHRoZW0gdW50aWwgdGhlIHBvc3RhbWJsZSB3aGVuIHdlIGtub3dcbiAgICAvLyB3ZSB3b24ndCBlbWl0IGFueSBtb3JlIHRhZ3NcblxuICAgIGNhc2UgJ2JvZHknOlxuICAgICAge1xuICAgICAgICBpZiAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlIDw9IEhUTUxfSFRNTF9NT0RFKSB7XG4gICAgICAgICAgcmVzdW1hYmxlU3RhdGUuaGFzQm9keSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdodG1sJzpcbiAgICAgIGlmIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFJPT1RfSFRNTF9NT0RFKSB7XG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLmhhc0h0bWwgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kQ2h1bmtGb3JUYWcodHlwZSkpO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJvb3RzdHJhcChkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUpIHtcbiAgdmFyIGJvb3RzdHJhcENodW5rcyA9IHJlbmRlclN0YXRlLmJvb3RzdHJhcENodW5rcztcbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgYm9vdHN0cmFwQ2h1bmtzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGJvb3RzdHJhcENodW5rc1tpXSk7XG4gIH1cblxuICBpZiAoaSA8IGJvb3RzdHJhcENodW5rcy5sZW5ndGgpIHtcbiAgICB2YXIgbGFzdENodW5rID0gYm9vdHN0cmFwQ2h1bmtzW2ldO1xuICAgIGJvb3RzdHJhcENodW5rcy5sZW5ndGggPSAwO1xuICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBsYXN0Q2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQ29tcGxldGVkUm9vdChkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUpIHtcbiAgcmV0dXJuIHdyaXRlQm9vdHN0cmFwKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSk7XG59IC8vIFN0cnVjdHVyYWwgTm9kZXNcbi8vIEEgcGxhY2Vob2xkZXIgaXMgYSBub2RlIGluc2lkZSBhIGhpZGRlbiBwYXJ0aWFsIHRyZWUgdGhhdCBjYW4gYmUgZmlsbGVkIGluIGxhdGVyLCBidXQgYmVmb3JlXG4vLyBkaXNwbGF5LiBJdCdzIG5ldmVyIHZpc2libGUgdG8gdXNlcnMuIFdlIHVzZSB0aGUgdGVtcGxhdGUgdGFnIGJlY2F1c2UgaXQgY2FuIGJlIHVzZWQgaW4gZXZlcnlcbi8vIHR5cGUgb2YgcGFyZW50LiA8c2NyaXB0PiB0YWdzIGFsc28gd29yayBpbiBldmVyeSBvdGhlciB0YWcgZXhjZXB0IDxjb2xncm91cD4uXG5cbnZhciBwbGFjZWhvbGRlcjEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZSBpZD1cIicpO1xudmFyIHBsYWNlaG9sZGVyMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+PC90ZW1wbGF0ZT4nKTtcbmZ1bmN0aW9uIHdyaXRlUGxhY2Vob2xkZXIoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLCBpZCkge1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBwbGFjZWhvbGRlcjEpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5wbGFjZWhvbGRlclByZWZpeCk7XG4gIHZhciBmb3JtYXR0ZWRJRCA9IHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZm9ybWF0dGVkSUQpO1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgcGxhY2Vob2xkZXIyKTtcbn0gLy8gU3VzcGVuc2UgYm91bmRhcmllcyBhcmUgZW5jb2RlZCBhcyBjb21tZW50cy5cblxudmFyIHN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPCEtLSQtLT4nKTtcbnZhciBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5MSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPCEtLSQ/LS0+PHRlbXBsYXRlIGlkPVwiJyk7XG52YXIgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPjwvdGVtcGxhdGU+Jyk7XG52YXIgc3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhLS0kIS0tPicpO1xudmFyIGVuZFN1c3BlbnNlQm91bmRhcnkgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhLS0vJC0tPicpO1xudmFyIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlJyk7XG52YXIgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIicpO1xudmFyIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBkYXRhLWRnc3Q9XCInKTtcbnZhciBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFCID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgZGF0YS1tc2c9XCInKTtcbnZhciBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFDID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgZGF0YS1zdGNrPVwiJyk7XG52YXIgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc+PC90ZW1wbGF0ZT4nKTtcbmZ1bmN0aW9uIHdyaXRlU3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSkge1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KTtcbn1cbmZ1bmN0aW9uIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUsIGlkKSB7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkxKTtcblxuICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIElEIG11c3QgaGF2ZSBiZWVuIGFzc2lnbmVkIGJlZm9yZSB3ZSBjYW4gY29tcGxldGUgdGhlIGJvdW5kYXJ5LicpO1xuICB9XG5cbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuYm91bmRhcnlQcmVmaXgpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTIpO1xufVxuZnVuY3Rpb24gd3JpdGVTdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUsIGVycm9yRGlnZXN0LCBlcnJvck1lc3NzYWdlLCBlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gIHZhciByZXN1bHQ7XG4gIHJlc3VsdCA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5KTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxKTtcblxuICBpZiAoZXJyb3JEaWdlc3QpIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBKTtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yRGlnZXN0KSkpO1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbCk7XG4gIH1cblxuICB7XG4gICAgaWYgKGVycm9yTWVzc3NhZ2UpIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUIpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvck1lc3NzYWdlKSkpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsKTtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3JDb21wb25lbnRTdGFjaykge1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQyk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yQ29tcG9uZW50U3RhY2spKSk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwpO1xuICAgIH1cbiAgfVxuXG4gIHJlc3VsdCA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB3cml0ZUVuZENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlKSB7XG4gIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTdXNwZW5zZUJvdW5kYXJ5KTtcbn1cbmZ1bmN0aW9uIHdyaXRlRW5kUGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlKSB7XG4gIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTdXNwZW5zZUJvdW5kYXJ5KTtcbn1cbmZ1bmN0aW9uIHdyaXRlRW5kQ2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZSkge1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU3VzcGVuc2VCb3VuZGFyeSk7XG59XG52YXIgc3RhcnRTZWdtZW50SFRNTCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPGRpdiBoaWRkZW4gaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRIVE1MMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudEhUTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvZGl2PicpO1xudmFyIHN0YXJ0U2VnbWVudFNWRyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50U1ZHMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudFNWRyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9zdmc+Jyk7XG52YXIgc3RhcnRTZWdtZW50TWF0aE1MID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8bWF0aCBhcmlhLWhpZGRlbj1cInRydWVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50TWF0aE1MMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudE1hdGhNTCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9tYXRoPicpO1xudmFyIHN0YXJ0U2VnbWVudFRhYmxlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGFibGUgaGlkZGVuIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50VGFibGUyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKTtcbnZhciBlbmRTZWdtZW50VGFibGUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvdGFibGU+Jyk7XG52YXIgc3RhcnRTZWdtZW50VGFibGVCb2R5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGFibGUgaGlkZGVuPjx0Ym9keSBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudFRhYmxlQm9keTIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRUYWJsZUJvZHkgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvdGJvZHk+PC90YWJsZT4nKTtcbnZhciBzdGFydFNlZ21lbnRUYWJsZVJvdyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbj48dHIgaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRUYWJsZVJvdzIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRUYWJsZVJvdyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC90cj48L3RhYmxlPicpO1xudmFyIHN0YXJ0U2VnbWVudENvbEdyb3VwID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGFibGUgaGlkZGVuPjxjb2xncm91cCBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudENvbEdyb3VwMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudENvbEdyb3VwID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L2NvbGdyb3VwPjwvdGFibGU+Jyk7XG5mdW5jdGlvbiB3cml0ZVN0YXJ0U2VnbWVudChkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUsIGZvcm1hdENvbnRleHQsIGlkKSB7XG4gIHN3aXRjaCAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKSB7XG4gICAgY2FzZSBST09UX0hUTUxfTU9ERTpcbiAgICBjYXNlIEhUTUxfSFRNTF9NT0RFOlxuICAgIGNhc2UgSFRNTF9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRIVE1MKTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRIVE1MMik7XG4gICAgICB9XG5cbiAgICBjYXNlIFNWR19NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRTVkcpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFNWRzIpO1xuICAgICAgfVxuXG4gICAgY2FzZSBNQVRITUxfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50TWF0aE1MKTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRNYXRoTUwyKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZSk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGUyKTtcbiAgICAgIH1cbiAgICAvLyBUT0RPOiBGb3IgdGhlIHJlc3Qgb2YgdGhlc2UsIHRoZXJlIHdpbGwgYmUgZXh0cmEgd3JhcHBlciBub2RlcyB0aGF0IG5ldmVyXG4gICAgLy8gZ2V0IGRlbGV0ZWQgZnJvbSB0aGUgZG9jdW1lbnQuIFdlIG5lZWQgdG8gZGVsZXRlIHRoZSB0YWJsZSB0b28gYXMgcGFydFxuICAgIC8vIG9mIHRoZSBpbmplY3RlZCBzY3JpcHRzLiBUaGV5IGFyZSBpbnZpc2libGUgdGhvdWdoIHNvIGl0J3Mgbm90IHRvbyB0ZXJyaWJsZVxuICAgIC8vIGFuZCBpdCdzIGtpbmQgb2YgYW4gZWRnZSBjYXNlIHRvIHN1c3BlbmQgaW4gYSB0YWJsZS4gVG90YWxseSBzdXBwb3J0ZWQgdGhvdWdoLlxuXG4gICAgY2FzZSBIVE1MX1RBQkxFX0JPRFlfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGVCb2R5KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZUJvZHkyKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9ST1dfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGVSb3cpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlUm93Mik7XG4gICAgICB9XG5cbiAgICBjYXNlIEhUTUxfQ09MR1JPVVBfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50Q29sR3JvdXApO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudENvbEdyb3VwMik7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaW5zZXJ0aW9uIG1vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHdyaXRlRW5kU2VnbWVudChkZXN0aW5hdGlvbiwgZm9ybWF0Q29udGV4dCkge1xuICBzd2l0Y2ggKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSkge1xuICAgIGNhc2UgUk9PVF9IVE1MX01PREU6XG4gICAgY2FzZSBIVE1MX0hUTUxfTU9ERTpcbiAgICBjYXNlIEhUTUxfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRIVE1MKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU1ZHX01PREU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50U1ZHKTtcbiAgICAgIH1cblxuICAgIGNhc2UgTUFUSE1MX01PREU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50TWF0aE1MKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9NT0RFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudFRhYmxlKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9CT0RZX01PREU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50VGFibGVCb2R5KTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9ST1dfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRUYWJsZVJvdyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEhUTUxfQ09MR1JPVVBfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRDb2xHcm91cCk7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaW5zZXJ0aW9uIG1vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gIH1cbn1cbnZhciBjb21wbGV0ZVNlZ21lbnRTY3JpcHQxRnVsbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjb21wbGV0ZVNlZ21lbnQgKyAnJFJTKFwiJyk7XG52YXIgY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyRSUyhcIicpO1xudmFyIGNvbXBsZXRlU2VnbWVudFNjcmlwdDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiLFwiJyk7XG52YXIgY29tcGxldGVTZWdtZW50U2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIik8L3NjcmlwdD4nKTtcbnZhciBjb21wbGV0ZVNlZ21lbnREYXRhMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlIGRhdGEtcnNpPVwiXCIgZGF0YS1zaWQ9XCInKTtcbnZhciBjb21wbGV0ZVNlZ21lbnREYXRhMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1waWQ9XCInKTtcbnZhciBjb21wbGV0ZVNlZ21lbnREYXRhRW5kID0gZGF0YUVsZW1lbnRRdW90ZWRFbmQ7XG5mdW5jdGlvbiB3cml0ZUNvbXBsZXRlZFNlZ21lbnRJbnN0cnVjdGlvbihkZXN0aW5hdGlvbiwgcmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBjb250ZW50U2VnbWVudElEKSB7XG4gIHZhciBzY3JpcHRGb3JtYXQgPSByZXN1bWFibGVTdGF0ZS5zdHJlYW1pbmdGb3JtYXQgPT09IFNjcmlwdFN0cmVhbWluZ0Zvcm1hdDtcblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc3RhcnRJbmxpbmVTY3JpcHQpO1xuXG4gICAgaWYgKChyZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgJiBTZW50Q29tcGxldGVTZWdtZW50RnVuY3Rpb24pID09PSBOb3RoaW5nU2VudCkge1xuICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgd2Ugd3JpdGUgdGhpcywgd2UnbGwgbmVlZCB0byBpbmNsdWRlIHRoZSBmdWxsIGltcGxlbWVudGF0aW9uLlxuICAgICAgcmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zIHw9IFNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbjtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFGdWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRnV0dXJlIGNhbGxzIGNhbiBqdXN0IHJldXNlIHRoZSBzYW1lIGZ1bmN0aW9uLlxuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnREYXRhMSk7XG4gIH0gLy8gV3JpdGUgZnVuY3Rpb24gYXJndW1lbnRzLCB3aGljaCBhcmUgc3RyaW5nIGxpdGVyYWxzXG5cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgdmFyIGZvcm1hdHRlZElEID0gc3RyaW5nVG9DaHVuayhjb250ZW50U2VnbWVudElELnRvU3RyaW5nKDE2KSk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGZvcm1hdHRlZElEKTtcblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0Mik7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50RGF0YTIpO1xuICB9XG5cbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUucGxhY2Vob2xkZXJQcmVmaXgpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBmb3JtYXR0ZWRJRCk7XG5cbiAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnRTY3JpcHRFbmQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnREYXRhRW5kKTtcbiAgfVxufVxudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxRnVsbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjb21wbGV0ZUJvdW5kYXJ5ICsgJyRSQyhcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxUGFydGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnJFJDKFwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxRnVsbEJvdGggPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoY29tcGxldGVCb3VuZGFyeSArIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzICsgJyRSUihcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzICsgJyRSUihcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MVBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyRSUihcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIixcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzYSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIsJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVNjcmlwdDNiID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHRFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyk8L3NjcmlwdD4nKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5RGF0YTEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZSBkYXRhLXJjaT1cIlwiIGRhdGEtYmlkPVwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNEYXRhMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlIGRhdGEtcnJpPVwiXCIgZGF0YS1iaWQ9XCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5RGF0YTIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtc2lkPVwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeURhdGEzYSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIgZGF0YS1zdHk9XCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5RGF0YUVuZCA9IGRhdGFFbGVtZW50UXVvdGVkRW5kO1xuZnVuY3Rpb24gd3JpdGVDb21wbGV0ZWRCb3VuZGFyeUluc3RydWN0aW9uKGRlc3RpbmF0aW9uLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIGlkLCBib3VuZGFyeVJlc291cmNlcykge1xuICB2YXIgcmVxdWlyZXNTdHlsZUluc2VydGlvbjtcblxuICB7XG4gICAgcmVxdWlyZXNTdHlsZUluc2VydGlvbiA9IHJlbmRlclN0YXRlLnN0eWxlc1RvSG9pc3Q7IC8vIElmIG5lY2Vzc2FyeSBzdHlsZXNoZWV0cyB3aWxsIGJlIGZsdXNoZWQgd2l0aCB0aGlzIGluc3RydWN0aW9uLlxuICAgIC8vIEFueSBzdHlsZSB0YWdzIG5vdCB5ZXQgaG9pc3RlZCBpbiB0aGUgRG9jdW1lbnQgd2lsbCBhbHNvIGJlIGhvaXN0ZWQuXG4gICAgLy8gV2UgcmVzZXQgdGhpcyBzdGF0ZSBzaW5jZSBhZnRlciB0aGlzIGluc3RydWN0aW9uIGV4ZWN1dGVzIGFsbCBzdHlsZXNcbiAgICAvLyB1cCB0byB0aGlzIHBvaW50IHdpbGwgaGF2ZSBiZWVuIGhvaXN0ZWRcblxuICAgIHJlbmRlclN0YXRlLnN0eWxlc1RvSG9pc3QgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBzY3JpcHRGb3JtYXQgPSByZXN1bWFibGVTdGF0ZS5zdHJlYW1pbmdGb3JtYXQgPT09IFNjcmlwdFN0cmVhbWluZ0Zvcm1hdDtcblxuICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuc3RhcnRJbmxpbmVTY3JpcHQpO1xuXG4gICAgaWYgKHJlcXVpcmVzU3R5bGVJbnNlcnRpb24pIHtcbiAgICAgIGlmICgocmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zICYgU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbikgPT09IE5vdGhpbmdTZW50KSB7XG4gICAgICAgIHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyB8PSBTZW50U3R5bGVJbnNlcnRpb25GdW5jdGlvbiB8IFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb247XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsb25lUHJlY29tcHV0ZWRDaHVuayhjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsQm90aCkpO1xuICAgICAgfSBlbHNlIGlmICgocmVzdW1hYmxlU3RhdGUuaW5zdHJ1Y3Rpb25zICYgU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb24pID09PSBOb3RoaW5nU2VudCkge1xuICAgICAgICByZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudFN0eWxlSW5zZXJ0aW9uRnVuY3Rpb247XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxQYXJ0aWFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MVBhcnRpYWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIFNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24pID09PSBOb3RoaW5nU2VudCkge1xuICAgICAgICByZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbjtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFGdWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxUGFydGlhbCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChyZXF1aXJlc1N0eWxlSW5zZXJ0aW9uKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc0RhdGExKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeURhdGExKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaWRDaHVuayA9IHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuYm91bmRhcnlQcmVmaXgpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBpZENodW5rKTsgLy8gV3JpdGUgZnVuY3Rpb24gYXJndW1lbnRzLCB3aGljaCBhcmUgc3RyaW5nIGFuZCBhcnJheSBsaXRlcmFsc1xuXG4gIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0Mik7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeURhdGEyKTtcbiAgfVxuXG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlbmRlclN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBpZENodW5rKTtcblxuICBpZiAocmVxdWlyZXNTdHlsZUluc2VydGlvbikge1xuICAgIC8vIFNjcmlwdCBhbmQgZGF0YSB3cml0ZXJzIG11c3QgZm9ybWF0IHRoaXMgZGlmZmVyZW50bHk6XG4gICAgLy8gIC0gc2NyaXB0IHdyaXRlciBlbWl0cyBhbiBhcnJheSBsaXRlcmFsLCB3aG9zZSBzdHJpbmcgZWxlbWVudHMgYXJlXG4gICAgLy8gICAgZXNjYXBlZCBmb3IgamF2YXNjcmlwdCAgZS5nLiBbXCJBXCIsIFwiQlwiXVxuICAgIC8vICAtIGRhdGEgd3JpdGVyIGVtaXRzIGEgc3RyaW5nIGxpdGVyYWwsIHdoaWNoIGlzIGVzY2FwZWQgYXMgaHRtbFxuICAgIC8vICAgIGUuZy4gWyYjMzQ7QSYjMzQ7LCAmIzM0O0ImIzM0O11cbiAgICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2EpOyAvLyBib3VuZGFyeVJlc291cmNlcyBlbmNvZGVzIGFuIGFycmF5IGxpdGVyYWxcblxuICAgICAgd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jaWVzSW5KUyhkZXN0aW5hdGlvbiwgYm91bmRhcnlSZXNvdXJjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5RGF0YTNhKTtcbiAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY2llc0luQXR0cihkZXN0aW5hdGlvbiwgYm91bmRhcnlSZXNvdXJjZXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0M2IpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB3cml0ZU1vcmU7XG5cbiAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgIHdyaXRlTW9yZSA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHRFbmQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlTW9yZSA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlEYXRhRW5kKTtcbiAgfVxuXG4gIHJldHVybiB3cml0ZUJvb3RzdHJhcChkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUpICYmIHdyaXRlTW9yZTtcbn1cbnZhciBjbGllbnRSZW5kZXJTY3JpcHQxRnVsbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjbGllbnRSZW5kZXJCb3VuZGFyeSArICc7JFJYKFwiJyk7XG52YXIgY2xpZW50UmVuZGVyU2NyaXB0MVBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyRSWChcIicpO1xudmFyIGNsaWVudFJlbmRlclNjcmlwdDFBID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIicpO1xudmFyIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcsJyk7XG52YXIgY2xpZW50UmVuZGVyU2NyaXB0RW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcpPC9zY3JpcHQ+Jyk7XG52YXIgY2xpZW50UmVuZGVyRGF0YTEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZSBkYXRhLXJ4aT1cIlwiIGRhdGEtYmlkPVwiJyk7XG52YXIgY2xpZW50UmVuZGVyRGF0YTIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtZGdzdD1cIicpO1xudmFyIGNsaWVudFJlbmRlckRhdGEzID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLW1zZz1cIicpO1xudmFyIGNsaWVudFJlbmRlckRhdGE0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLXN0Y2s9XCInKTtcbnZhciBjbGllbnRSZW5kZXJEYXRhRW5kID0gZGF0YUVsZW1lbnRRdW90ZWRFbmQ7XG5mdW5jdGlvbiB3cml0ZUNsaWVudFJlbmRlckJvdW5kYXJ5SW5zdHJ1Y3Rpb24oZGVzdGluYXRpb24sIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgaWQsIGVycm9yRGlnZXN0LCBlcnJvck1lc3NhZ2UsIGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgdmFyIHNjcmlwdEZvcm1hdCA9IHJlc3VtYWJsZVN0YXRlLnN0cmVhbWluZ0Zvcm1hdCA9PT0gU2NyaXB0U3RyZWFtaW5nRm9ybWF0O1xuXG4gIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZW5kZXJTdGF0ZS5zdGFydElubGluZVNjcmlwdCk7XG5cbiAgICBpZiAoKHJlc3VtYWJsZVN0YXRlLmluc3RydWN0aW9ucyAmIFNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbikgPT09IE5vdGhpbmdTZW50KSB7XG4gICAgICAvLyBUaGUgZmlyc3QgdGltZSB3ZSB3cml0ZSB0aGlzLCB3ZSdsbCBuZWVkIHRvIGluY2x1ZGUgdGhlIGZ1bGwgaW1wbGVtZW50YXRpb24uXG4gICAgICByZXN1bWFibGVTdGF0ZS5pbnN0cnVjdGlvbnMgfD0gU2VudENsaWVudFJlbmRlckZ1bmN0aW9uO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyU2NyaXB0MUZ1bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGdXR1cmUgY2FsbHMgY2FuIGp1c3QgcmV1c2UgdGhlIHNhbWUgZnVuY3Rpb24uXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJTY3JpcHQxUGFydGlhbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIDx0ZW1wbGF0ZSBkYXRhLXJ4aT1cIlwiIGRhdGEtYmlkPVwiXG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyRGF0YTEpO1xuICB9XG5cbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVuZGVyU3RhdGUuYm91bmRhcnlQcmVmaXgpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuXG4gIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICAvLyBcIiBuZWVkcyB0byBiZSBpbnNlcnRlZCBmb3Igc2NyaXB0cywgc2luY2UgQXJnSW50ZXJzdGl0dWFsIGRvZXMgbm90IGNvbnRhaW5cbiAgICAvLyBsZWFkaW5nIG9yIHRyYWlsaW5nIHF1b3Rlc1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlclNjcmlwdDFBKTtcbiAgfVxuXG4gIGlmIChlcnJvckRpZ2VzdCB8fCBlcnJvck1lc3NhZ2UgfHwgZXJyb3JDb21wb25lbnRTdGFjaykge1xuICAgIGlmIChzY3JpcHRGb3JtYXQpIHtcbiAgICAgIC8vICxcIkpTT05TdHJpbmdcIlxuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWwpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoZXJyb3JEaWdlc3QgfHwgJycpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFwiIGRhdGEtZGdzdD1cIkhUTUxTdHJpbmdcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlckRhdGEyKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JEaWdlc3QgfHwgJycpKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVycm9yTWVzc2FnZSB8fCBlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gICAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgICAgLy8gLFwiSlNPTlN0cmluZ1wiXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvck1lc3NhZ2UgfHwgJycpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFwiIGRhdGEtbXNnPVwiSFRNTFN0cmluZ1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyRGF0YTMpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvck1lc3NhZ2UgfHwgJycpKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgICAvLyAsXCJKU09OU3RyaW5nXCJcbiAgICBpZiAoc2NyaXB0Rm9ybWF0KSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvckNvbXBvbmVudFN0YWNrKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBcIiBkYXRhLXN0Y2s9XCJIVE1MU3RyaW5nXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJEYXRhNCk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yQ29tcG9uZW50U3RhY2spKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNjcmlwdEZvcm1hdCkge1xuICAgIC8vID48L3NjcmlwdD5cbiAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyU2NyaXB0RW5kKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBcIj48L3RlbXBsYXRlPlxuICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJEYXRhRW5kKTtcbiAgfVxufVxudmFyIHJlZ2V4Rm9ySlNTdHJpbmdzSW5JbnN0cnVjdGlvblNjcmlwdHMgPSAvWzxcXHUyMDI4XFx1MjAyOV0vZztcblxuZnVuY3Rpb24gZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGlucHV0KSB7XG4gIHZhciBlc2NhcGVkID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICByZXR1cm4gZXNjYXBlZC5yZXBsYWNlKHJlZ2V4Rm9ySlNTdHJpbmdzSW5JbnN0cnVjdGlvblNjcmlwdHMsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgIC8vIHNhbnRpemluZyBicmVha2luZyBvdXQgb2Ygc3RyaW5ncyBhbmQgc2NyaXB0IHRhZ3NcbiAgICAgIGNhc2UgJzwnOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTAwM2NcIjtcblxuICAgICAgY2FzZSBcIlxcdTIwMjhcIjpcbiAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI4XCI7XG5cbiAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgIHJldHVybiBcIlxcXFx1MjAyOVwiO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbnZhciByZWdleEZvckpTU3RyaW5nc0luU2NyaXB0cyA9IC9bJj48XFx1MjAyOFxcdTIwMjldL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGlucHV0KSB7XG4gIHZhciBlc2NhcGVkID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICByZXR1cm4gZXNjYXBlZC5yZXBsYWNlKHJlZ2V4Rm9ySlNTdHJpbmdzSW5TY3JpcHRzLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICAvLyBzYW50aXppbmcgYnJlYWtpbmcgb3V0IG9mIHN0cmluZ3MgYW5kIHNjcmlwdCB0YWdzXG4gICAgICBjYXNlICcmJzpcbiAgICAgICAgcmV0dXJuIFwiXFxcXHUwMDI2XCI7XG5cbiAgICAgIGNhc2UgJz4nOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTAwM2VcIjtcblxuICAgICAgY2FzZSAnPCc6XG4gICAgICAgIHJldHVybiBcIlxcXFx1MDAzY1wiO1xuXG4gICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjhcIjtcblxuICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI5XCI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMgZW5jb3VudGVyZWQgYSBtYXRjaCBpdCBkb2VzIG5vdCBrbm93IGhvdyB0byByZXBsYWNlLiB0aGlzIG1lYW5zIHRoZSBtYXRjaCByZWdleCBhbmQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgYXJlIG5vIGxvbmdlciBpbiBzeW5jLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG52YXIgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHN0eWxlIG1lZGlhPVwibm90IGFsbFwiIGRhdGEtcHJlY2VkZW5jZT1cIicpO1xudmFyIGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGRhdGEtaHJlZj1cIicpO1xudmFyIGxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjMgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGxhdGVTdHlsZVRhZ1RlbXBsYXRlQ2xvc2UgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvc3R5bGU+Jyk7IC8vIFRyYWNrcyB3aGV0aGVyIHRoZSBib3VuZGFyeSBjdXJyZW50bHkgZmx1c2hpbmcgaXMgZmx1c2hpZ24gc3R5bGUgdGFncyBvciBoYXMgYW55XG4vLyBzdHlsZXNoZWV0IGRlcGVuZGVuY2llcyBub3QgZmx1c2hlZCBpbiB0aGUgUHJlYW1ibGUuXG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgPSBmYWxzZTsgLy8gQWN0cyBhcyBhIHJldHVybiB2YWx1ZSBmb3IgdGhlIGZvckVhY2ggZXhlY3V0aW9uIG9mIHN0eWxlIHRhZyBmbHVzaGluZy5cblxudmFyIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkgPSB0cnVlO1xuXG5mdW5jdGlvbiBmbHVzaFN0eWxlVGFnc0xhdGVGb3JCb3VuZGFyeShzdHlsZVF1ZXVlKSB7XG4gIHZhciBydWxlcyA9IHN0eWxlUXVldWUucnVsZXM7XG4gIHZhciBocmVmcyA9IHN0eWxlUXVldWUuaHJlZnM7XG5cbiAge1xuICAgIGlmIChydWxlcy5sZW5ndGggPiAwICYmIGhyZWZzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZXJyb3IoJ1JlYWN0IGV4cGVjdGVkIHRvIGhhdmUgYXQgbGVhc3Qgb25lIGhyZWYgZm9yIGFuIGEgaG9pc3RhYmxlIHN0eWxlIGJ1dCBmb3VuZCBub25lLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpID0gMDtcblxuICBpZiAoaHJlZnMubGVuZ3RoKSB7XG4gICAgd3JpdGVDaHVuayh0aGlzLCBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4xKTtcbiAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlUXVldWUucHJlY2VkZW5jZSk7XG4gICAgd3JpdGVDaHVuayh0aGlzLCBsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4yKTtcblxuICAgIGZvciAoOyBpIDwgaHJlZnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB3cml0ZUNodW5rKHRoaXMsIGhyZWZzW2ldKTtcbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3BhY2VTZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIHdyaXRlQ2h1bmsodGhpcywgaHJlZnNbaV0pO1xuICAgIHdyaXRlQ2h1bmsodGhpcywgbGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMyk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgcnVsZXNbaV0pO1xuICAgIH1cblxuICAgIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkgPSB3cml0ZUNodW5rQW5kUmV0dXJuKHRoaXMsIGxhdGVTdHlsZVRhZ1RlbXBsYXRlQ2xvc2UpOyAvLyBXZSB3cm90ZSBzdHlsZSB0YWdzIGZvciB0aGlzIGJvdW5kYXJ5IGFuZCB3ZSBtYXkgbmVlZCB0byBlbWl0IGEgc2NyaXB0XG4gICAgLy8gdG8gaG9pc3QgdGhlbS5cblxuICAgIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9IHRydWU7IC8vIHN0eWxlIHJlc291cmNlcyBjYW4gZmx1c2ggY29udGludW91c2x5IHNpbmNlIG1vcmUgcnVsZXMgbWF5IGJlIHdyaXR0ZW4gaW50b1xuICAgIC8vIHRoZW0gd2l0aCBuZXcgaHJlZnMuIEluc3RlYWQgb2YgbWFya2luZyBpdCBmbHVzaGVkLCB3ZSBzaW1wbHkgcmVzZXQgdGhlIGNodW5rc1xuICAgIC8vIGFuZCBocmVmc1xuXG4gICAgcnVsZXMubGVuZ3RoID0gMDtcbiAgICBocmVmcy5sZW5ndGggPSAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1N0eWxlc1RvSG9pc3Qoc3R5bGVzaGVldCkge1xuICAvLyBXZSBuZWVkIHRvIHJldmVhbCBib3VuZGFyaWVzIHdpdGggc3R5bGVzIHdoZW5ldmVyIGEgc3R5bGVzaGVldCBpdCBkZXBlbmRzIG9uIGlzIGVpdGhlclxuICAvLyBub3QgZmx1c2hlZCBvciBmbHVzaGVkIGFmdGVyIHRoZSBwcmVhbWJsZSAoc2hlbGwpLlxuICBpZiAoc3R5bGVzaGVldC5zdGF0ZSAhPT0gUFJFQU1CTEUpIHtcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3cml0ZVJlc291cmNlc0ZvckJvdW5kYXJ5KGRlc3RpbmF0aW9uLCBib3VuZGFyeVJlc291cmNlcywgcmVuZGVyU3RhdGUpIHtcbiAgLy8gUmVzZXQgdGhlc2Ugb24gZWFjaCBpbnZvY2F0aW9uLCB0aGV5IGFyZSBvbmx5IHNhZmUgdG8gcmVhZCBpbiB0aGlzIGZ1bmN0aW9uXG4gIGN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5SGFzU3R5bGVzVG9Ib2lzdCA9IGZhbHNlO1xuICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5ID0gdHJ1ZTsgLy8gRmx1c2ggc3R5bGUgdGFncyBmb3IgZWFjaCBwcmVjZWRlbmNlIHRoaXMgYm91bmRhcnkgZGVwZW5kcyBvblxuXG4gIGJvdW5kYXJ5UmVzb3VyY2VzLnN0eWxlcy5mb3JFYWNoKGZsdXNoU3R5bGVUYWdzTGF0ZUZvckJvdW5kYXJ5LCBkZXN0aW5hdGlvbik7IC8vIERldGVybWluZSBpZiB0aGlzIGJvdW5kYXJ5IGhhcyBzdHlsZXNoZWV0cyB0aGF0IG5lZWQgdG8gYmUgYXdhaXRlZCB1cG9uIGNvbXBsZXRpb25cblxuICBib3VuZGFyeVJlc291cmNlcy5zdHlsZXNoZWV0cy5mb3JFYWNoKGhhc1N0eWxlc1RvSG9pc3QpO1xuXG4gIGlmIChjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QpIHtcbiAgICByZW5kZXJTdGF0ZS5zdHlsZXNUb0hvaXN0ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5O1xufVxuXG5mdW5jdGlvbiBmbHVzaFJlc291cmNlKHJlc291cmNlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICB3cml0ZUNodW5rKHRoaXMsIHJlc291cmNlW2ldKTtcbiAgfVxuXG4gIHJlc291cmNlLmxlbmd0aCA9IDA7XG59XG5cbnZhciBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZSA9IFtdO1xuXG5mdW5jdGlvbiBmbHVzaFN0eWxlSW5QcmVhbWJsZShzdHlsZXNoZWV0LCBrZXksIG1hcCkge1xuICAvLyBXZSBzdGlsbCBuZWVkIHRvIGVuY29kZSBzdHlsZXNoZWV0IGNodW5rc1xuICAvLyBiZWNhdXNlIHVubGlrZSBtb3N0IEhvaXN0YWJsZXMgYW5kIFJlc291cmNlcyB3ZSBkbyBub3QgZWFnZXJseSBlbmNvZGVcbiAgLy8gdGhlbSBkdXJpbmcgcmVuZGVyLiBUaGlzIGlzIGJlY2F1c2UgaWYgd2UgZmx1c2ggbGF0ZSB3ZSBoYXZlIHRvIHNlbmQgYVxuICAvLyBkaWZmZXJlbnQgZW5jb2RpbmcgYW5kIHdlIGRvbid0IHdhbnQgdG8gZW5jb2RlIG11bHRpcGxlIHRpbWVzXG4gIHB1c2hMaW5rSW1wbChzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZSwgc3R5bGVzaGVldC5wcm9wcyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVzaGVldEZsdXNoaW5nUXVldWVbaV0pO1xuICB9XG5cbiAgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoID0gMDtcbiAgc3R5bGVzaGVldC5zdGF0ZSA9IFBSRUFNQkxFO1xufVxuXG52YXIgc3R5bGVUYWdSZXNvdXJjZU9wZW4xID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8c3R5bGUgZGF0YS1wcmVjZWRlbmNlPVwiJyk7XG52YXIgc3R5bGVUYWdSZXNvdXJjZU9wZW4yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIiBkYXRhLWhyZWY9XCInKTtcbnZhciBzcGFjZVNlcGFyYXRvciA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnICcpO1xudmFyIHN0eWxlVGFnUmVzb3VyY2VPcGVuMyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgc3R5bGVUYWdSZXNvdXJjZUNsb3NlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3N0eWxlPicpO1xuXG5mdW5jdGlvbiBmbHVzaFN0eWxlc0luUHJlYW1ibGUoc3R5bGVRdWV1ZSwgcHJlY2VkZW5jZSkge1xuICB2YXIgaGFzU3R5bGVzaGVldHMgPSBzdHlsZVF1ZXVlLnNoZWV0cy5zaXplID4gMDtcbiAgc3R5bGVRdWV1ZS5zaGVldHMuZm9yRWFjaChmbHVzaFN0eWxlSW5QcmVhbWJsZSwgdGhpcyk7XG4gIHN0eWxlUXVldWUuc2hlZXRzLmNsZWFyKCk7XG4gIHZhciBydWxlcyA9IHN0eWxlUXVldWUucnVsZXM7XG4gIHZhciBocmVmcyA9IHN0eWxlUXVldWUuaHJlZnM7IC8vIElmIHdlIGRvbid0IGVtaXQgYW55IHN0eWxlc2hlZXRzIGF0IHRoaXMgcHJlY2VkZW5jZSB3ZSBzdGlsbCBuZWVkIHRvIG1haW50YWluIHRoZSBwcmVjZWRlbmNlXG4gIC8vIG9yZGVyIHNvIGV2ZW4gaWYgdGhlcmUgYXJlIG5vIHJ1bGVzIGZvciBzdHlsZSB0YWdzIGF0IHRoaXMgcHJlY2VkZW5jZSB3ZSBlbWl0IGFuIGVtcHR5IHN0eWxlXG4gIC8vIHRhZyB3aXRoIHRoZSBkYXRhLXByZWNlZGVuY2UgYXR0cmlidXRlXG5cbiAgaWYgKCFoYXNTdHlsZXNoZWV0cyB8fCBocmVmcy5sZW5ndGgpIHtcbiAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlVGFnUmVzb3VyY2VPcGVuMSk7XG4gICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZVF1ZXVlLnByZWNlZGVuY2UpO1xuICAgIHZhciBpID0gMDtcblxuICAgIGlmIChocmVmcy5sZW5ndGgpIHtcbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVUYWdSZXNvdXJjZU9wZW4yKTtcblxuICAgICAgZm9yICg7IGkgPCBocmVmcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgd3JpdGVDaHVuayh0aGlzLCBocmVmc1tpXSk7XG4gICAgICAgIHdyaXRlQ2h1bmsodGhpcywgc3BhY2VTZXBhcmF0b3IpO1xuICAgICAgfVxuXG4gICAgICB3cml0ZUNodW5rKHRoaXMsIGhyZWZzW2ldKTtcbiAgICB9XG5cbiAgICB3cml0ZUNodW5rKHRoaXMsIHN0eWxlVGFnUmVzb3VyY2VPcGVuMyk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdyaXRlQ2h1bmsodGhpcywgcnVsZXNbaV0pO1xuICAgIH1cblxuICAgIHdyaXRlQ2h1bmsodGhpcywgc3R5bGVUYWdSZXNvdXJjZUNsb3NlKTsgLy8gc3R5bGUgcmVzb3VyY2VzIGNhbiBmbHVzaCBjb250aW51b3VzbHkgc2luY2UgbW9yZSBydWxlcyBtYXkgYmUgd3JpdHRlbiBpbnRvXG4gICAgLy8gdGhlbSB3aXRoIG5ldyBocmVmcy4gSW5zdGVhZCBvZiBtYXJraW5nIGl0IGZsdXNoZWQsIHdlIHNpbXBseSByZXNldCB0aGUgY2h1bmtzXG4gICAgLy8gYW5kIGhyZWZzXG5cbiAgICBydWxlcy5sZW5ndGggPSAwO1xuICAgIGhyZWZzLmxlbmd0aCA9IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlbG9hZExhdGVTdHlsZShzdHlsZXNoZWV0KSB7XG4gIGlmIChzdHlsZXNoZWV0LnN0YXRlID09PSBQRU5ESU5HJDEpIHtcbiAgICBzdHlsZXNoZWV0LnN0YXRlID0gUFJFTE9BREVEO1xuICAgIHZhciBwcmVsb2FkUHJvcHMgPSBwcmVsb2FkQXNTdHlsZVByb3BzRnJvbVByb3BzKHN0eWxlc2hlZXQucHJvcHMuaHJlZiwgc3R5bGVzaGVldC5wcm9wcyk7XG4gICAgcHVzaExpbmtJbXBsKHN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlLCBwcmVsb2FkUHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgd3JpdGVDaHVuayh0aGlzLCBzdHlsZXNoZWV0Rmx1c2hpbmdRdWV1ZVtpXSk7XG4gICAgfVxuXG4gICAgc3R5bGVzaGVldEZsdXNoaW5nUXVldWUubGVuZ3RoID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVsb2FkTGF0ZVN0eWxlcyhzdHlsZVF1ZXVlKSB7XG4gIHN0eWxlUXVldWUuc2hlZXRzLmZvckVhY2gocHJlbG9hZExhdGVTdHlsZSwgdGhpcyk7XG4gIHN0eWxlUXVldWUuc2hlZXRzLmNsZWFyKCk7XG59IC8vIFdlIGRvbid0IGJvdGhlciByZXBvcnRpbmcgYmFja3ByZXNzdXJlIGF0IHRoZSBtb21lbnQgYmVjYXVzZSB3ZSBleHBlY3QgdG9cbi8vIGZsdXNoIHRoZSBlbnRpcmUgcHJlYW1ibGUgaW4gYSBzaW5nbGUgcGFzcy4gVGhpcyBwcm9iYWJseSBzaG91bGQgYmUgbW9kaWZpZWRcbi8vIGluIHRoZSBmdXR1cmUgdG8gYmUgYmFja3ByZXNzdXJlIHNlbnNpdGl2ZSBidXQgdGhhdCByZXF1aXJlcyBhIGxhcmdlciByZWZhY3RvclxuLy8gb2YgdGhlIGZsdXNoaW5nIGNvZGUgaW4gRml6ei5cblxuXG5mdW5jdGlvbiB3cml0ZVByZWFtYmxlKGRlc3RpbmF0aW9uLCByZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIHdpbGxGbHVzaEFsbFNlZ21lbnRzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgZXhhY3RseSBvbmNlIG9uIGV2ZXJ5IHJlcXVlc3RcbiAgaWYgKCF3aWxsRmx1c2hBbGxTZWdtZW50cyAmJiByZW5kZXJTdGF0ZS5leHRlcm5hbFJ1bnRpbWVTY3JpcHQpIHtcbiAgICAvLyBJZiB0aGUgcm9vdCBzZWdtZW50IGlzIGluY29tcGxldGUgZHVlIHRvIHN1c3BlbmRlZCB0YXNrc1xuICAgIC8vIChlLmcuIHdpbGxGbHVzaEFsbFNlZ21lbnRzID0gZmFsc2UpIGFuZCB3ZSBhcmUgdXNpbmcgZGF0YVxuICAgIC8vIHN0cmVhbWluZyBmb3JtYXQsIGVuc3VyZSB0aGUgZXh0ZXJuYWwgcnVudGltZSBpcyBzZW50LlxuICAgIC8vIChVc2VyIGNvZGUgY291bGQgY2hvb3NlIHRvIHNlbmQgdGhpcyBldmVuIGVhcmxpZXIgYnkgY2FsbGluZ1xuICAgIC8vICBwcmVpbml0KC4uLiksIGlmIHRoZXkga25vdyB0aGV5IHdpbGwgc3VzcGVuZCkuXG4gICAgdmFyIF9yZW5kZXJTdGF0ZSRleHRlcm5hbCA9IHJlbmRlclN0YXRlLmV4dGVybmFsUnVudGltZVNjcmlwdCxcbiAgICAgICAgc3JjID0gX3JlbmRlclN0YXRlJGV4dGVybmFsLnNyYyxcbiAgICAgICAgY2h1bmtzID0gX3JlbmRlclN0YXRlJGV4dGVybmFsLmNodW5rcztcbiAgICBpbnRlcm5hbFByZWluaXRTY3JpcHQocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBzcmMsIGNodW5rcyk7XG4gIH1cblxuICB2YXIgaHRtbENodW5rcyA9IHJlbmRlclN0YXRlLmh0bWxDaHVua3M7XG4gIHZhciBoZWFkQ2h1bmtzID0gcmVuZGVyU3RhdGUuaGVhZENodW5rcztcbiAgdmFyIGkgPSAwOyAvLyBFbWl0IG9wZW4gdGFncyBiZWZvcmUgSG9pc3RhYmxlcyBhbmQgUmVzb3VyY2VzXG5cbiAgaWYgKGh0bWxDaHVua3MpIHtcbiAgICAvLyBXZSBoYXZlIGFuIDxodG1sPiB0byBlbWl0IGFzIHBhcnQgb2YgdGhlIHByZWFtYmxlXG4gICAgZm9yIChpID0gMDsgaSA8IGh0bWxDaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGh0bWxDaHVua3NbaV0pO1xuICAgIH1cblxuICAgIGlmIChoZWFkQ2h1bmtzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaGVhZENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBoZWFkQ2h1bmtzW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgZGlkIG5vdCByZW5kZXIgYSBoZWFkIGJ1dCB3ZSBlbWl0dGVkIGFuIDxodG1sPiBzbyB3ZSBlbWl0IG9uZSBub3dcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0Q2h1bmtGb3JUYWcoJ2hlYWQnKSk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBlbmRPZlN0YXJ0VGFnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaGVhZENodW5rcykge1xuICAgIC8vIFdlIGRvIG5vdCBoYXZlIGFuIDxodG1sPiBidXQgd2UgZG8gaGF2ZSBhIDxoZWFkPlxuICAgIGZvciAoaSA9IDA7IGkgPCBoZWFkQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBoZWFkQ2h1bmtzW2ldKTtcbiAgICB9XG4gIH0gLy8gRW1pdCBoaWdoIHByaW9yaXR5IEhvaXN0YWJsZXNcblxuXG4gIHZhciBjaGFyc2V0Q2h1bmtzID0gcmVuZGVyU3RhdGUuY2hhcnNldENodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgY2hhcnNldENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNoYXJzZXRDaHVua3NbaV0pO1xuICB9XG5cbiAgY2hhcnNldENodW5rcy5sZW5ndGggPSAwOyAvLyBlbWl0IHByZWNvbm5lY3QgcmVzb3VyY2VzXG5cbiAgcmVuZGVyU3RhdGUucHJlY29ubmVjdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmNsZWFyKCk7XG4gIHZhciBwcmVjb25uZWN0Q2h1bmtzID0gcmVuZGVyU3RhdGUucHJlY29ubmVjdENodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgcHJlY29ubmVjdENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHByZWNvbm5lY3RDaHVua3NbaV0pO1xuICB9XG5cbiAgcHJlY29ubmVjdENodW5rcy5sZW5ndGggPSAwO1xuICByZW5kZXJTdGF0ZS5mb250UHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJlbmRlclN0YXRlLmZvbnRQcmVsb2Fkcy5jbGVhcigpO1xuICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuY2xlYXIoKTsgLy8gRmx1c2ggdW5ibG9ja2VkIHN0eWxlc2hlZXRzIGJ5IHByZWNlZGVuY2VcblxuICByZW5kZXJTdGF0ZS5zdHlsZXMuZm9yRWFjaChmbHVzaFN0eWxlc0luUHJlYW1ibGUsIGRlc3RpbmF0aW9uKTtcbiAgdmFyIGltcG9ydE1hcENodW5rcyA9IHJlbmRlclN0YXRlLmltcG9ydE1hcENodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaW1wb3J0TWFwQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgaW1wb3J0TWFwQ2h1bmtzW2ldKTtcbiAgfVxuXG4gIGltcG9ydE1hcENodW5rcy5sZW5ndGggPSAwO1xuICByZW5kZXJTdGF0ZS5ib290c3RyYXBTY3JpcHRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZW5kZXJTdGF0ZS5zY3JpcHRzLmZvckVhY2goZmx1c2hSZXNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZW5kZXJTdGF0ZS5zY3JpcHRzLmNsZWFyKCk7XG4gIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmNsZWFyKCk7IC8vIFdyaXRlIGVtYmVkZGluZyBwcmVsb2FkQ2h1bmtzXG5cbiAgdmFyIHByZWxvYWRDaHVua3MgPSByZW5kZXJTdGF0ZS5wcmVsb2FkQ2h1bmtzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwcmVsb2FkQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcHJlbG9hZENodW5rc1tpXSk7XG4gIH1cblxuICBwcmVsb2FkQ2h1bmtzLmxlbmd0aCA9IDA7IC8vIFdyaXRlIGVtYmVkZGluZyBob2lzdGFibGVDaHVua3NcblxuICB2YXIgaG9pc3RhYmxlQ2h1bmtzID0gcmVuZGVyU3RhdGUuaG9pc3RhYmxlQ2h1bmtzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob2lzdGFibGVDaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBob2lzdGFibGVDaHVua3NbaV0pO1xuICB9XG5cbiAgaG9pc3RhYmxlQ2h1bmtzLmxlbmd0aCA9IDA7IC8vIEZsdXNoIGNsb3NpbmcgaGVhZCBpZiBuZWNlc3NhcnlcblxuICBpZiAoaHRtbENodW5rcyAmJiBoZWFkQ2h1bmtzID09PSBudWxsKSB7XG4gICAgLy8gV2UgaGF2ZSBhbiA8aHRtbD4gcmVuZGVyZWQgYnV0IG5vIDxoZWFkPiByZW5kZXJlZC4gV2UgaG93ZXZlciBpbnNlcnRlZFxuICAgIC8vIGEgPGhlYWQ+IHVwIGFib3ZlIHNvIHdlIG5lZWQgdG8gZW1pdCB0aGUgPC9oZWFkPiBub3cuIFRoaXMgaXMgc2FmZSBiZWNhdXNlXG4gICAgLy8gaWYgdGhlIG1haW4gY29udGVudCBjb250YWluZWQgdGhlIDwvaGVhZD4gaXQgd291bGQgYWxzbyBoYXZlIHByb3ZpZGVkIGFcbiAgICAvLyA8aGVhZD4uIFRoaXMgbWVhbnMgdGhhdCBhbGwgdGhlIGNvbnRlbnQgaW5zaWRlIDxodG1sPiBpcyBlaXRoZXIgPGJvZHk+IG9yXG4gICAgLy8gaW52YWxpZCBIVE1MXG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZW5kQ2h1bmtGb3JUYWcoJ2hlYWQnKSk7XG4gIH1cbn0gLy8gV2UgZG9uJ3QgYm90aGVyIHJlcG9ydGluZyBiYWNrcHJlc3N1cmUgYXQgdGhlIG1vbWVudCBiZWNhdXNlIHdlIGV4cGVjdCB0b1xuLy8gZmx1c2ggdGhlIGVudGlyZSBwcmVhbWJsZSBpbiBhIHNpbmdsZSBwYXNzLiBUaGlzIHByb2JhYmx5IHNob3VsZCBiZSBtb2RpZmllZFxuLy8gaW4gdGhlIGZ1dHVyZSB0byBiZSBiYWNrcHJlc3N1cmUgc2Vuc2l0aXZlIGJ1dCB0aGF0IHJlcXVpcmVzIGEgbGFyZ2VyIHJlZmFjdG9yXG4vLyBvZiB0aGUgZmx1c2hpbmcgY29kZSBpbiBGaXp6LlxuXG5mdW5jdGlvbiB3cml0ZUhvaXN0YWJsZXMoZGVzdGluYXRpb24sIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSkge1xuICB2YXIgaSA9IDA7IC8vIEVtaXQgaGlnaCBwcmlvcml0eSBIb2lzdGFibGVzXG4gIC8vIFdlIG9taXQgY2hhcnNldENodW5rcyBiZWNhdXNlIHdlIGhhdmUgYWxyZWFkeSBzZW50IHRoZSBzaGVsbCBhbmQgaWYgaXQgd2Fzbid0XG4gIC8vIGFscmVhZHkgc2VudCBpdCBpcyB0b28gbGF0ZSBub3cuXG5cbiAgcmVuZGVyU3RhdGUucHJlY29ubmVjdHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJlbmRlclN0YXRlLnByZWNvbm5lY3RzLmNsZWFyKCk7XG4gIHZhciBwcmVjb25uZWN0Q2h1bmtzID0gcmVuZGVyU3RhdGUucHJlY29ubmVjdENodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgcHJlY29ubmVjdENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHByZWNvbm5lY3RDaHVua3NbaV0pO1xuICB9XG5cbiAgcHJlY29ubmVjdENodW5rcy5sZW5ndGggPSAwO1xuICByZW5kZXJTdGF0ZS5mb250UHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJlbmRlclN0YXRlLmZvbnRQcmVsb2Fkcy5jbGVhcigpO1xuICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmVuZGVyU3RhdGUuaGlnaEltYWdlUHJlbG9hZHMuY2xlYXIoKTsgLy8gUHJlbG9hZCBhbnkgc3R5bGVzaGVldHMuIHRoZXNlIHdpbGwgZW1pdCBpbiBhIHJlbmRlciBpbnN0cnVjdGlvbiB0aGF0IGZvbGxvd3MgdGhpc1xuICAvLyBidXQgd2Ugd2FudCB0byBraWNrIG9mZiBwcmVsb2FkaW5nIGFzIHNvb24gYXMgcG9zc2libGVcblxuICByZW5kZXJTdGF0ZS5zdHlsZXMuZm9yRWFjaChwcmVsb2FkTGF0ZVN0eWxlcywgZGVzdGluYXRpb24pOyAvLyBXZSBvbmx5IGhvaXN0IGltcG9ydG1hcHMgdGhhdCBhcmUgY29uZmlndXJlZCB0aHJvdWdoIGNyZWF0ZVJlc3BvbnNlIGFuZCB0aGF0IHdpbGxcbiAgLy8gYWx3YXlzIGZsdXNoIGluIHRoZSBwcmVhbWJsZS4gR2VuZXJhbGx5IHdlIGRvbid0IGV4cGVjdCBwZW9wbGUgdG8gcmVuZGVyIHRoZW0gYXNcbiAgLy8gdGFncyB3aGVuIHVzaW5nIFJlYWN0IGJ1dCBpZiB5b3UgZG8gdGhleSBhcmUgZ29pbmcgdG8gYmUgdHJlYXRlZCBsaWtlIHJlZ3VsYXIgaW5saW5lXG4gIC8vIHNjcmlwdHMgYW5kIGZsdXNoIGFmdGVyIG90aGVyIGhvaXN0YWJsZXMgd2hpY2ggaXMgcHJvYmxlbWF0aWNcbiAgLy8gYm9vdHN0cmFwIHNjcmlwdHMgc2hvdWxkIGZsdXNoIGFib3ZlIHNjcmlwdCBwcmlvcml0eSBidXQgdGhlc2UgY2FuIG9ubHkgZmx1c2ggaW4gdGhlIHByZWFtYmxlXG4gIC8vIHNvIHdlIGVsaWRlIHRoZSBjb2RlIGhlcmUgZm9yIHBlcmZvcm1hbmNlXG5cbiAgcmVuZGVyU3RhdGUuc2NyaXB0cy5mb3JFYWNoKGZsdXNoUmVzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmVuZGVyU3RhdGUuc2NyaXB0cy5jbGVhcigpO1xuICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuZm9yRWFjaChmbHVzaFJlc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5jbGVhcigpOyAvLyBXcml0ZSBlbWJlZGRpbmcgcHJlbG9hZENodW5rc1xuXG4gIHZhciBwcmVsb2FkQ2h1bmtzID0gcmVuZGVyU3RhdGUucHJlbG9hZENodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgcHJlbG9hZENodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHByZWxvYWRDaHVua3NbaV0pO1xuICB9XG5cbiAgcHJlbG9hZENodW5rcy5sZW5ndGggPSAwOyAvLyBXcml0ZSBlbWJlZGRpbmcgaG9pc3RhYmxlQ2h1bmtzXG5cbiAgdmFyIGhvaXN0YWJsZUNodW5rcyA9IHJlbmRlclN0YXRlLmhvaXN0YWJsZUNodW5rcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9pc3RhYmxlQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgaG9pc3RhYmxlQ2h1bmtzW2ldKTtcbiAgfVxuXG4gIGhvaXN0YWJsZUNodW5rcy5sZW5ndGggPSAwO1xufVxuZnVuY3Rpb24gd3JpdGVQb3N0YW1ibGUoZGVzdGluYXRpb24sIHJlc3VtYWJsZVN0YXRlKSB7XG4gIGlmIChyZXN1bWFibGVTdGF0ZS5oYXNCb2R5KSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZW5kQ2h1bmtGb3JUYWcoJ2JvZHknKSk7XG4gIH1cblxuICBpZiAocmVzdW1hYmxlU3RhdGUuaGFzSHRtbCkge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGVuZENodW5rRm9yVGFnKCdodG1sJykpO1xuICB9XG59XG52YXIgYXJyYXlGaXJzdE9wZW5CcmFja2V0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdbJyk7XG52YXIgYXJyYXlTdWJzZXF1ZW50T3BlbkJyYWNrZXQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyxbJyk7XG52YXIgYXJyYXlJbnRlcnN0aXRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJywnKTtcbnZhciBhcnJheUNsb3NlQnJhY2tldCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXScpOyAvLyBUaGlzIGZ1bmN0aW9uIHdyaXRlcyBhIDJEIGFycmF5IG9mIHN0cmluZ3MgdG8gYmUgZW1iZWRkZWQgaW4gamF2YXNjcmlwdC5cbi8vIEUuZy5cbi8vICBbW1wiSlNfZXNjYXBlZF9zdHJpbmcxXCIsIFwiSlNfZXNjYXBlZF9zdHJpbmcyXCJdXVxuXG5mdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmNpZXNJbkpTKGRlc3RpbmF0aW9uLCBib3VuZGFyeVJlc291cmNlcykge1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUZpcnN0T3BlbkJyYWNrZXQpO1xuICB2YXIgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheUZpcnN0T3BlbkJyYWNrZXQ7XG4gIGJvdW5kYXJ5UmVzb3VyY2VzLnN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHJlc291cmNlKSB7XG4gICAgaWYgKHJlc291cmNlLnN0YXRlID09PSBQUkVBTUJMRSkgOyBlbHNlIGlmIChyZXNvdXJjZS5zdGF0ZSA9PT0gTEFURSkge1xuICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIGVtaXQgdGhlIGhyZWYgYmVjYXVzZSB0aGlzIHJlc291cmNlIGZsdXNoZWQgaW4gYW4gZWFybGllclxuICAgICAgLy8gYm91bmRhcnkgYWxyZWFkeSB3aGljaCBlbmNvZGVkIHRoZSBhdHRyaWJ1dGVzIG5lY2Vzc2FyeSB0byBjb25zdHJ1Y3RcbiAgICAgIC8vIHRoZSByZXNvdXJjZSBpbnN0YW5jZSBvbiB0aGUgY2xpZW50LlxuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmspO1xuICAgICAgd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUhyZWZPbmx5SW5KUyhkZXN0aW5hdGlvbiwgcmVzb3VyY2UucHJvcHMuaHJlZik7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG4gICAgICBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5U3Vic2VxdWVudE9wZW5CcmFja2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGVtaXQgdGhlIHdob2xlIHJlc291cmNlIGZvciBpbnNlcnRpb24gb24gdGhlIGNsaWVudFxuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmspO1xuICAgICAgd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUluSlMoZGVzdGluYXRpb24sIHJlc291cmNlLnByb3BzLmhyZWYsIHJlc291cmNlLnByb3BzWydkYXRhLXByZWNlZGVuY2UnXSwgcmVzb3VyY2UucHJvcHMpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlDbG9zZUJyYWNrZXQpO1xuICAgICAgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldDtcbiAgICAgIHJlc291cmNlLnN0YXRlID0gTEFURTtcbiAgICB9XG4gIH0pO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG59XG4vKiBIZWxwZXIgZnVuY3Rpb25zICovXG5cblxuZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUhyZWZPbmx5SW5KUyhkZXN0aW5hdGlvbiwgaHJlZikge1xuICAvLyBXZSBzaG91bGQgYWN0dWFsbHkgZW5mb3JjZSB0aGlzIGVhcmxpZXIgd2hlbiB0aGUgcmVzb3VyY2UgaXMgY3JlYXRlZCBidXQgZm9yXG4gIC8vIG5vdyB3ZSBtYWtlIHN1cmUgd2UgYXJlIGFjdHVhbGx5IGRlYWxpbmcgd2l0aCBhIHN0cmluZyBoZXJlLlxuICB7XG4gICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihocmVmLCAnaHJlZicpO1xuICB9XG5cbiAgdmFyIGNvZXJjZWRIcmVmID0gJycgKyBocmVmO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGNvZXJjZWRIcmVmKSkpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SW5KUyhkZXN0aW5hdGlvbiwgaHJlZiwgcHJlY2VkZW5jZSwgcHJvcHMpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHZhciBjb2VyY2VkSHJlZiA9IHNhbml0aXplVVJMKCcnICsgaHJlZik7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoY29lcmNlZEhyZWYpKSk7XG5cbiAge1xuICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24ocHJlY2VkZW5jZSwgJ3ByZWNlZGVuY2UnKTtcbiAgfVxuXG4gIHZhciBjb2VyY2VkUHJlY2VkZW5jZSA9ICcnICsgcHJlY2VkZW5jZTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlJbnRlcnN0aXRpYWwpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTT2JqZWN0Rm9ySW5zdHJ1Y3Rpb25TY3JpcHRzKGNvZXJjZWRQcmVjZWRlbmNlKSkpO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnaHJlZic6XG4gICAgICAgIGNhc2UgJ3JlbCc6XG4gICAgICAgIGNhc2UgJ3ByZWNlZGVuY2UnOlxuICAgICAgICBjYXNlICdkYXRhLXByZWNlZGVuY2UnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpbmsnICsgXCIgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIiArICd1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluSlMoZGVzdGluYXRpb24sIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluSlMoZGVzdGluYXRpb24sIG5hbWUsIHZhbHVlKSAvLyBub3QgbnVsbCBvciB1bmRlZmluZWRcbntcbiAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBhdHRyaWJ1dGVWYWx1ZTtcblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgLy8gUmVzZXJ2ZWQgbmFtZXNcbiAgICBjYXNlICdpbm5lckhUTUwnOlxuICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICBjYXNlICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnOlxuICAgIGNhc2UgJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc6XG4gICAgY2FzZSAnc3R5bGUnOlxuICAgICAgLy8gSWdub3JlZFxuICAgICAgcmV0dXJuO1xuICAgIC8vIEF0dHJpYnV0ZSByZW5hbWVzXG5cbiAgICBjYXNlICdjbGFzc05hbWUnOlxuICAgICAge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lID0gJ2NsYXNzJztcblxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIEJvb2xlYW5zXG5cbiAgICBjYXNlICdoaWRkZW4nOlxuICAgICAge1xuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy8gU2FudGl6ZWQgVVJMc1xuXG4gICAgY2FzZSAnc3JjJzpcbiAgICBjYXNlICdocmVmJzpcbiAgICAgIHtcbiAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVVSTCh2YWx1ZSk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGlmICggLy8gdW5yZWNvZ25pemVkIGV2ZW50IGhhbmRsZXJzIGFyZSBub3QgU1NSJ2QgYW5kIHdlIChhcHBhcmVudGx5KVxuICAgICAgICAvLyB1c2Ugb24qIGFzIGh1ZXJpc3RpYyBmb3IgdGhlc2UgaGFuZGxlciBwcm9wc1xuICAgICAgICBuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIH1cbiAgfVxuXG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5SW50ZXJzdGl0aWFsKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyhhdHRyaWJ1dGVOYW1lKSkpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUludGVyc3RpdGlhbCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlSlNPYmplY3RGb3JJbnN0cnVjdGlvblNjcmlwdHMoYXR0cmlidXRlVmFsdWUpKSk7XG59IC8vIFRoaXMgZnVuY3Rpb24gd3JpdGVzIGEgMkQgYXJyYXkgb2Ygc3RyaW5ncyB0byBiZSBlbWJlZGRlZCBpbiBhbiBhdHRyaWJ1dGVcbi8vIHZhbHVlIGFuZCByZWFkIHdpdGggSlNPTi5wYXJzZSBpbiBSZWFjdERPTVNlcnZlckV4dGVybmFsUnVudGltZS5qc1xuLy8gRS5nLlxuLy8gIFtbJnF1b3Q7SlNPTl9lc2NhcGVkX3N0cmluZzEmcXVvdDssICZxdW90O0pTT05fZXNjYXBlZF9zdHJpbmcyJnF1b3Q7XV1cblxuXG5mdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmNpZXNJbkF0dHIoZGVzdGluYXRpb24sIGJvdW5kYXJ5UmVzb3VyY2VzKSB7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGFycmF5Rmlyc3RPcGVuQnJhY2tldCk7XG4gIHZhciBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayA9IGFycmF5Rmlyc3RPcGVuQnJhY2tldDtcbiAgYm91bmRhcnlSZXNvdXJjZXMuc3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAocmVzb3VyY2UpIHtcbiAgICBpZiAocmVzb3VyY2Uuc3RhdGUgPT09IFBSRUFNQkxFKSA7IGVsc2UgaWYgKHJlc291cmNlLnN0YXRlID09PSBMQVRFKSB7XG4gICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gZW1pdCB0aGUgaHJlZiBiZWNhdXNlIHRoaXMgcmVzb3VyY2UgZmx1c2hlZCBpbiBhbiBlYXJsaWVyXG4gICAgICAvLyBib3VuZGFyeSBhbHJlYWR5IHdoaWNoIGVuY29kZWQgdGhlIGF0dHJpYnV0ZXMgbmVjZXNzYXJ5IHRvIGNvbnN0cnVjdFxuICAgICAgLy8gdGhlIHJlc291cmNlIGluc3RhbmNlIG9uIHRoZSBjbGllbnQuXG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBuZXh0QXJyYXlPcGVuQnJhY2tDaHVuayk7XG4gICAgICB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SHJlZk9ubHlJbkF0dHIoZGVzdGluYXRpb24sIHJlc291cmNlLnByb3BzLmhyZWYpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlDbG9zZUJyYWNrZXQpO1xuICAgICAgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgbmVlZCB0byBlbWl0IHRoZSB3aG9sZSByZXNvdXJjZSBmb3IgaW5zZXJ0aW9uIG9uIHRoZSBjbGllbnRcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIG5leHRBcnJheU9wZW5CcmFja0NodW5rKTtcbiAgICAgIHdyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lJbkF0dHIoZGVzdGluYXRpb24sIHJlc291cmNlLnByb3BzLmhyZWYsIHJlc291cmNlLnByb3BzWydkYXRhLXByZWNlZGVuY2UnXSwgcmVzb3VyY2UucHJvcHMpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlDbG9zZUJyYWNrZXQpO1xuICAgICAgbmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsgPSBhcnJheVN1YnNlcXVlbnRPcGVuQnJhY2tldDtcbiAgICAgIHJlc291cmNlLnN0YXRlID0gTEFURTtcbiAgICB9XG4gIH0pO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUNsb3NlQnJhY2tldCk7XG59XG4vKiBIZWxwZXIgZnVuY3Rpb25zICovXG5cblxuZnVuY3Rpb24gd3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUhyZWZPbmx5SW5BdHRyKGRlc3RpbmF0aW9uLCBocmVmKSB7XG4gIC8vIFdlIHNob3VsZCBhY3R1YWxseSBlbmZvcmNlIHRoaXMgZWFybGllciB3aGVuIHRoZSByZXNvdXJjZSBpcyBjcmVhdGVkIGJ1dCBmb3JcbiAgLy8gbm93IHdlIG1ha2Ugc3VyZSB3ZSBhcmUgYWN0dWFsbHkgZGVhbGluZyB3aXRoIGEgc3RyaW5nIGhlcmUuXG4gIHtcbiAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKGhyZWYsICdocmVmJyk7XG4gIH1cblxuICB2YXIgY29lcmNlZEhyZWYgPSAnJyArIGhyZWY7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoSlNPTi5zdHJpbmdpZnkoY29lcmNlZEhyZWYpKSkpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmN5SW5BdHRyKGRlc3RpbmF0aW9uLCBocmVmLCBwcmVjZWRlbmNlLCBwcm9wcykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgdmFyIGNvZXJjZWRIcmVmID0gc2FuaXRpemVVUkwoJycgKyBocmVmKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihKU09OLnN0cmluZ2lmeShjb2VyY2VkSHJlZikpKSk7XG5cbiAge1xuICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24ocHJlY2VkZW5jZSwgJ3ByZWNlZGVuY2UnKTtcbiAgfVxuXG4gIHZhciBjb2VyY2VkUHJlY2VkZW5jZSA9ICcnICsgcHJlY2VkZW5jZTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlJbnRlcnN0aXRpYWwpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKEpTT04uc3RyaW5naWZ5KGNvZXJjZWRQcmVjZWRlbmNlKSkpKTtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2hyZWYnOlxuICAgICAgICBjYXNlICdyZWwnOlxuICAgICAgICBjYXNlICdwcmVjZWRlbmNlJzpcbiAgICAgICAgY2FzZSAnZGF0YS1wcmVjZWRlbmNlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW5rJyArIFwiIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgXCIgKyAndXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB3cml0ZVN0eWxlUmVzb3VyY2VBdHRyaWJ1dGVJbkF0dHIoZGVzdGluYXRpb24sIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHdyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluQXR0cihkZXN0aW5hdGlvbiwgbmFtZSwgdmFsdWUpIC8vIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxue1xuICB2YXIgYXR0cmlidXRlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGF0dHJpYnV0ZVZhbHVlO1xuXG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAvLyBSZXNlcnZlZCBuYW1lc1xuICAgIGNhc2UgJ2lubmVySFRNTCc6XG4gICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgIGNhc2UgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc6XG4gICAgY2FzZSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJzpcbiAgICBjYXNlICdzdHlsZSc6XG4gICAgICAvLyBJZ25vcmVkXG4gICAgICByZXR1cm47XG4gICAgLy8gQXR0cmlidXRlIHJlbmFtZXNcblxuICAgIGNhc2UgJ2NsYXNzTmFtZSc6XG4gICAgICB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWUgPSAnY2xhc3MnO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy8gQm9vbGVhbnNcblxuICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgICB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAvLyBTYW50aXplZCBVUkxzXG5cbiAgICBjYXNlICdzcmMnOlxuICAgIGNhc2UgJ2hyZWYnOlxuICAgICAge1xuICAgICAgICB2YWx1ZSA9IHNhbml0aXplVVJMKHZhbHVlKTtcblxuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCAvLyB1bnJlY29nbml6ZWQgZXZlbnQgaGFuZGxlcnMgYXJlIG5vdCBTU1InZCBhbmQgd2UgKGFwcGFyZW50bHkpXG4gICAgICAgIC8vIHVzZSBvbiogYXMgaHVlcmlzdGljIGZvciB0aGVzZSBoYW5kbGVyIHByb3BzXG4gICAgICAgIG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICB9XG5cbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYXJyYXlJbnRlcnN0aXRpYWwpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKEpTT04uc3RyaW5naWZ5KGF0dHJpYnV0ZU5hbWUpKSkpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBhcnJheUludGVyc3RpdGlhbCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoSlNPTi5zdHJpbmdpZnkoYXR0cmlidXRlVmFsdWUpKSkpO1xufVxuLyoqXG4gKiBSZXNvdXJjZXNcbiAqL1xuXG5cbnZhciBQRU5ESU5HJDEgPSAwO1xudmFyIFBSRUxPQURFRCA9IDE7XG52YXIgUFJFQU1CTEUgPSAyO1xudmFyIExBVEUgPSAzO1xuZnVuY3Rpb24gY3JlYXRlQm91bmRhcnlSZXNvdXJjZXMoKSB7XG4gIHJldHVybiB7XG4gICAgc3R5bGVzOiBuZXcgU2V0KCksXG4gICAgc3R5bGVzaGVldHM6IG5ldyBTZXQoKVxuICB9O1xufVxuZnVuY3Rpb24gc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVuZGVyU3RhdGUsIGJvdW5kYXJ5UmVzb3VyY2VzKSB7XG4gIHJlbmRlclN0YXRlLmJvdW5kYXJ5UmVzb3VyY2VzID0gYm91bmRhcnlSZXNvdXJjZXM7XG59XG5cbmZ1bmN0aW9uIGdldFJlc291cmNlS2V5KGhyZWYpIHtcbiAgcmV0dXJuIGhyZWY7XG59XG5cbmZ1bmN0aW9uIGdldEltYWdlUmVzb3VyY2VLZXkoaHJlZiwgaW1hZ2VTcmNTZXQsIGltYWdlU2l6ZXMpIHtcbiAgaWYgKGltYWdlU3JjU2V0KSB7XG4gICAgcmV0dXJuIGltYWdlU3JjU2V0ICsgJ1xcbicgKyAoaW1hZ2VTaXplcyB8fCAnJyk7XG4gIH1cblxuICByZXR1cm4gaHJlZjtcbn1cblxuZnVuY3Rpb24gcHJlZmV0Y2hETlMoaHJlZikge1xuXG4gIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcblxuICBpZiAoIXJlcXVlc3QpIHtcbiAgICAvLyBJbiBhc3luYyBjb250ZXh0cyB3ZSBjYW4gc29tZXRpbWVzIHJlc29sdmUgcmVzb3VyY2VzIGZyb20gQXN5bmNMb2NhbFN0b3JhZ2UuIElmIHdlIGNhbid0IHdlIGNhbiBhbHNvXG4gICAgLy8gcG9zc2libHkgZ2V0IHRoZW0gZnJvbSB0aGUgc3RhY2sgaWYgd2UgYXJlIG5vdCBpbiBhbiBhc3luYyBjb250ZXh0LiBTaW5jZSB3ZSB3ZXJlIG5vdCBhYmxlIHRvIHJlc29sdmVcbiAgICAvLyB0aGUgcmVzb3VyY2VzIGZvciB0aGlzIGNhbGwgaW4gZWl0aGVyIGNhc2Ugd2Ugb3B0IHRvIGRvIG5vdGhpbmcuIFdlIGNhbiBjb25zaWRlciBtYWtpbmcgdGhpcyBhIHdhcm5pbmdcbiAgICAvLyBidXQgdGhlcmUgbWF5IGJlIHRpbWVzIHdoZXJlIGNhbGxpbmcgYSBmdW5jdGlvbiBvdXRzaWRlIG9mIHJlbmRlciBpcyBpbnRlbnRpb25hbCAoaS5lLiB0byB3YXJtIHVwIGRhdGFcbiAgICAvLyBmZXRjaGluZykgYW5kIHdlIGRvbid0IHdhbnQgdG8gd2FybiBpbiB0aG9zZSBjYXNlcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVzdW1hYmxlU3RhdGUgPSBnZXRSZXN1bWFibGVTdGF0ZShyZXF1ZXN0KTtcbiAgdmFyIHJlbmRlclN0YXRlID0gZ2V0UmVuZGVyU3RhdGUocmVxdWVzdCk7XG5cbiAgaWYgKHR5cGVvZiBocmVmID09PSAnc3RyaW5nJyAmJiBocmVmKSB7XG4gICAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KGhyZWYpO1xuXG4gICAgaWYgKCFyZXN1bWFibGVTdGF0ZS5kbnNSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmVzdW1hYmxlU3RhdGUuZG5zUmVzb3VyY2VzW2tleV0gPSBFWElTVFM7XG4gICAgICB2YXIgaGVhZGVycyA9IHJlbmRlclN0YXRlLmhlYWRlcnM7XG4gICAgICB2YXIgaGVhZGVyO1xuXG4gICAgICBpZiAoaGVhZGVycyAmJiBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ID4gMCAmJiAoIC8vIENvbXB1dGUgdGhlIGhlYWRlciBzaW5jZSB3ZSBtaWdodCBiZSBhYmxlIHRvIGZpdCBpdCBpbiB0aGUgbWF4IGxlbmd0aFxuICAgICAgaGVhZGVyID0gZ2V0UHJlZmV0Y2hETlNBc0hlYWRlcihocmVmKSwgLy8gV2UgYWx3YXlzIGNvbnN1bWUgdGhlIGhlYWRlciBsZW5ndGggc2luY2Ugb25jZSB3ZSBmaW5kIG9uZSBoZWFkZXIgdGhhdCBkb2Vzbid0IGZpdFxuICAgICAgLy8gd2UgYXNzdW1lIGFsbCB0aGUgcmVzdCB3b24ndCBhcyB3ZWxsLiBUaGlzIGlzIHRvIGF2b2lkIGdldHRpbmcgaW50byBhIHNpdHVhdGlvblxuICAgICAgLy8gd2hlcmUgd2UgaGF2ZSBhIHZlcnkgc21hbGwgcmVtYWluaW5nIGNhcGFjaXR5IGJ1dCBubyBoZWFkZXJzIHdpbGwgZXZlciBmaXQgYW5kIHdlIGVuZFxuICAgICAgLy8gdXAgY29uc3RhbnRseSB0cnlpbmcgdG8gc2VlIGlmIHRoZSBuZXh0IHJlc291cmNlIG1pZ2h0IG1ha2UgaXQuIEluIHRoZSBmdXR1cmUgd2UgY2FuXG4gICAgICAvLyBtYWtlIHRoaXMgYmVoYXZpb3IgZGlmZmVyZW50IGJldHdlZW4gcmVuZGVyIGFuZCBwcmVyZW5kZXIgc2luY2UgaW4gdGhlIGxhdHRlciBjYXNlXG4gICAgICAvLyB3ZSBhcmUgbGVzcyBzZW5zaXRpdmUgdG8gdGhlIGN1cnJlbnQgcmVxdWVzdHMgcnVudGltZSBwZXIgYW5kIG1vcmUgc2Vuc2l0aXZlIHRvIG1heGltaXppbmdcbiAgICAgIC8vIGhlYWRlcnMuXG4gICAgICAoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoKSA+PSAyKSkge1xuICAgICAgICAvLyBTdG9yZSB0aGlzIGFzIHJlc2V0dGFibGUgaW4gY2FzZSB3ZSBhcmUgcHJlcmVuZGVyaW5nIGFuZCBwb3N0cG9uZSBpbiB0aGUgU2hlbGxcbiAgICAgICAgcmVuZGVyU3RhdGUucmVzZXRzLmRuc1trZXldID0gRVhJU1RTO1xuXG4gICAgICAgIGlmIChoZWFkZXJzLnByZWNvbm5lY3RzKSB7XG4gICAgICAgICAgaGVhZGVycy5wcmVjb25uZWN0cyArPSAnLCAnO1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXTogd2UgYXNzaWduIGhlYWRlciBkdXJpbmcgdGhlIGlmIGNvbmRpdGlvblxuXG5cbiAgICAgICAgaGVhZGVycy5wcmVjb25uZWN0cyArPSBoZWFkZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFbmNvZGUgYXMgZWxlbWVudFxuICAgICAgICB2YXIgcmVzb3VyY2UgPSBbXTtcbiAgICAgICAgcHVzaExpbmtJbXBsKHJlc291cmNlLCB7XG4gICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICByZWw6ICdkbnMtcHJlZmV0Y2gnXG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5hZGQocmVzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZsdXNoUmVzb3VyY2VzKHJlcXVlc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZWNvbm5lY3QoaHJlZiwgY3Jvc3NPcmlnaW4pIHtcblxuICB2YXIgcmVxdWVzdCA9IHJlc29sdmVSZXF1ZXN0KCk7XG5cbiAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgLy8gSW4gYXN5bmMgY29udGV4dHMgd2UgY2FuIHNvbWV0aW1lcyByZXNvbHZlIHJlc291cmNlcyBmcm9tIEFzeW5jTG9jYWxTdG9yYWdlLiBJZiB3ZSBjYW4ndCB3ZSBjYW4gYWxzb1xuICAgIC8vIHBvc3NpYmx5IGdldCB0aGVtIGZyb20gdGhlIHN0YWNrIGlmIHdlIGFyZSBub3QgaW4gYW4gYXN5bmMgY29udGV4dC4gU2luY2Ugd2Ugd2VyZSBub3QgYWJsZSB0byByZXNvbHZlXG4gICAgLy8gdGhlIHJlc291cmNlcyBmb3IgdGhpcyBjYWxsIGluIGVpdGhlciBjYXNlIHdlIG9wdCB0byBkbyBub3RoaW5nLiBXZSBjYW4gY29uc2lkZXIgbWFraW5nIHRoaXMgYSB3YXJuaW5nXG4gICAgLy8gYnV0IHRoZXJlIG1heSBiZSB0aW1lcyB3aGVyZSBjYWxsaW5nIGEgZnVuY3Rpb24gb3V0c2lkZSBvZiByZW5kZXIgaXMgaW50ZW50aW9uYWwgKGkuZS4gdG8gd2FybSB1cCBkYXRhXG4gICAgLy8gZmV0Y2hpbmcpIGFuZCB3ZSBkb24ndCB3YW50IHRvIHdhcm4gaW4gdGhvc2UgY2FzZXMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlc3VtYWJsZVN0YXRlID0gZ2V0UmVzdW1hYmxlU3RhdGUocmVxdWVzdCk7XG4gIHZhciByZW5kZXJTdGF0ZSA9IGdldFJlbmRlclN0YXRlKHJlcXVlc3QpO1xuXG4gIGlmICh0eXBlb2YgaHJlZiA9PT0gJ3N0cmluZycgJiYgaHJlZikge1xuICAgIHZhciBidWNrZXQgPSBjcm9zc09yaWdpbiA9PT0gJ3VzZS1jcmVkZW50aWFscycgPyAnY3JlZGVudGlhbHMnIDogdHlwZW9mIGNyb3NzT3JpZ2luID09PSAnc3RyaW5nJyA/ICdhbm9ueW1vdXMnIDogJ2RlZmF1bHQnO1xuICAgIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleShocmVmKTtcblxuICAgIGlmICghcmVzdW1hYmxlU3RhdGUuY29ubmVjdFJlc291cmNlc1tidWNrZXRdLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJlc3VtYWJsZVN0YXRlLmNvbm5lY3RSZXNvdXJjZXNbYnVja2V0XVtrZXldID0gRVhJU1RTO1xuICAgICAgdmFyIGhlYWRlcnMgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgdmFyIGhlYWRlcjtcblxuICAgICAgaWYgKGhlYWRlcnMgJiYgaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSA+IDAgJiYgKCAvLyBDb21wdXRlIHRoZSBoZWFkZXIgc2luY2Ugd2UgbWlnaHQgYmUgYWJsZSB0byBmaXQgaXQgaW4gdGhlIG1heCBsZW5ndGhcbiAgICAgIGhlYWRlciA9IGdldFByZWNvbm5lY3RBc0hlYWRlcihocmVmLCBjcm9zc09yaWdpbiksIC8vIFdlIGFsd2F5cyBjb25zdW1lIHRoZSBoZWFkZXIgbGVuZ3RoIHNpbmNlIG9uY2Ugd2UgZmluZCBvbmUgaGVhZGVyIHRoYXQgZG9lc24ndCBmaXRcbiAgICAgIC8vIHdlIGFzc3VtZSBhbGwgdGhlIHJlc3Qgd29uJ3QgYXMgd2VsbC4gVGhpcyBpcyB0byBhdm9pZCBnZXR0aW5nIGludG8gYSBzaXR1YXRpb25cbiAgICAgIC8vIHdoZXJlIHdlIGhhdmUgYSB2ZXJ5IHNtYWxsIHJlbWFpbmluZyBjYXBhY2l0eSBidXQgbm8gaGVhZGVycyB3aWxsIGV2ZXIgZml0IGFuZCB3ZSBlbmRcbiAgICAgIC8vIHVwIGNvbnN0YW50bHkgdHJ5aW5nIHRvIHNlZSBpZiB0aGUgbmV4dCByZXNvdXJjZSBtaWdodCBtYWtlIGl0LiBJbiB0aGUgZnV0dXJlIHdlIGNhblxuICAgICAgLy8gbWFrZSB0aGlzIGJlaGF2aW9yIGRpZmZlcmVudCBiZXR3ZWVuIHJlbmRlciBhbmQgcHJlcmVuZGVyIHNpbmNlIGluIHRoZSBsYXR0ZXIgY2FzZVxuICAgICAgLy8gd2UgYXJlIGxlc3Mgc2Vuc2l0aXZlIHRvIHRoZSBjdXJyZW50IHJlcXVlc3RzIHJ1bnRpbWUgcGVyIGFuZCBtb3JlIHNlbnNpdGl2ZSB0byBtYXhpbWl6aW5nXG4gICAgICAvLyBoZWFkZXJzLlxuICAgICAgKGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgLT0gaGVhZGVyLmxlbmd0aCkgPj0gMikpIHtcbiAgICAgICAgLy8gU3RvcmUgdGhpcyBpbiByZXNldHRhYmxlU3RhdGUgaW4gY2FzZSB3ZSBhcmUgcHJlcmVuZGluZyBhbmQgcG9zdHBvbmUgaW4gdGhlIFNoZWxsXG4gICAgICAgIHJlbmRlclN0YXRlLnJlc2V0cy5jb25uZWN0W2J1Y2tldF1ba2V5XSA9IEVYSVNUUztcblxuICAgICAgICBpZiAoaGVhZGVycy5wcmVjb25uZWN0cykge1xuICAgICAgICAgIGhlYWRlcnMucHJlY29ubmVjdHMgKz0gJywgJztcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl06IHdlIGFzc2lnbiBoZWFkZXIgZHVyaW5nIHRoZSBpZiBjb25kaXRpb25cblxuXG4gICAgICAgIGhlYWRlcnMucHJlY29ubmVjdHMgKz0gaGVhZGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc291cmNlID0gW107XG4gICAgICAgIHB1c2hMaW5rSW1wbChyZXNvdXJjZSwge1xuICAgICAgICAgIHJlbDogJ3ByZWNvbm5lY3QnLFxuICAgICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luXG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJTdGF0ZS5wcmVjb25uZWN0cy5hZGQocmVzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZsdXNoUmVzb3VyY2VzKHJlcXVlc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZWxvYWQoaHJlZiwgYXMsIG9wdGlvbnMpIHtcblxuICB2YXIgcmVxdWVzdCA9IHJlc29sdmVSZXF1ZXN0KCk7XG5cbiAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgLy8gSW4gYXN5bmMgY29udGV4dHMgd2UgY2FuIHNvbWV0aW1lcyByZXNvbHZlIHJlc291cmNlcyBmcm9tIEFzeW5jTG9jYWxTdG9yYWdlLiBJZiB3ZSBjYW4ndCB3ZSBjYW4gYWxzb1xuICAgIC8vIHBvc3NpYmx5IGdldCB0aGVtIGZyb20gdGhlIHN0YWNrIGlmIHdlIGFyZSBub3QgaW4gYW4gYXN5bmMgY29udGV4dC4gU2luY2Ugd2Ugd2VyZSBub3QgYWJsZSB0byByZXNvbHZlXG4gICAgLy8gdGhlIHJlc291cmNlcyBmb3IgdGhpcyBjYWxsIGluIGVpdGhlciBjYXNlIHdlIG9wdCB0byBkbyBub3RoaW5nLiBXZSBjYW4gY29uc2lkZXIgbWFraW5nIHRoaXMgYSB3YXJuaW5nXG4gICAgLy8gYnV0IHRoZXJlIG1heSBiZSB0aW1lcyB3aGVyZSBjYWxsaW5nIGEgZnVuY3Rpb24gb3V0c2lkZSBvZiByZW5kZXIgaXMgaW50ZW50aW9uYWwgKGkuZS4gdG8gd2FybSB1cCBkYXRhXG4gICAgLy8gZmV0Y2hpbmcpIGFuZCB3ZSBkb24ndCB3YW50IHRvIHdhcm4gaW4gdGhvc2UgY2FzZXMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlc3VtYWJsZVN0YXRlID0gZ2V0UmVzdW1hYmxlU3RhdGUocmVxdWVzdCk7XG4gIHZhciByZW5kZXJTdGF0ZSA9IGdldFJlbmRlclN0YXRlKHJlcXVlc3QpO1xuXG4gIGlmIChhcyAmJiBocmVmKSB7XG4gICAgc3dpdGNoIChhcykge1xuICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGltYWdlU3JjU2V0LCBpbWFnZVNpemVzLCBmZXRjaFByaW9yaXR5O1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGltYWdlU3JjU2V0ID0gb3B0aW9ucy5pbWFnZVNyY1NldDtcbiAgICAgICAgICAgIGltYWdlU2l6ZXMgPSBvcHRpb25zLmltYWdlU2l6ZXM7XG4gICAgICAgICAgICBmZXRjaFByaW9yaXR5ID0gb3B0aW9ucy5mZXRjaFByaW9yaXR5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBrZXkgPSBnZXRJbWFnZVJlc291cmNlS2V5KGhyZWYsIGltYWdlU3JjU2V0LCBpbWFnZVNpemVzKTtcblxuICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5pbWFnZVJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAvLyB3ZSBjYW4gcmV0dXJuIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGlzIHJlc291cmNlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdW1hYmxlU3RhdGUuaW1hZ2VSZXNvdXJjZXNba2V5XSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgdmFyIGhlYWRlcnMgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuICAgICAgICAgIHZhciBoZWFkZXI7XG5cbiAgICAgICAgICBpZiAoaGVhZGVycyAmJiBoZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ID4gMCAmJiBmZXRjaFByaW9yaXR5ID09PSAnaGlnaCcgJiYgKCAvLyBDb21wdXRlIHRoZSBoZWFkZXIgc2luY2Ugd2UgbWlnaHQgYmUgYWJsZSB0byBmaXQgaXQgaW4gdGhlIG1heCBsZW5ndGhcbiAgICAgICAgICBoZWFkZXIgPSBnZXRQcmVsb2FkQXNIZWFkZXIoaHJlZiwgYXMsIG9wdGlvbnMpLCAvLyBXZSBhbHdheXMgY29uc3VtZSB0aGUgaGVhZGVyIGxlbmd0aCBzaW5jZSBvbmNlIHdlIGZpbmQgb25lIGhlYWRlciB0aGF0IGRvZXNuJ3QgZml0XG4gICAgICAgICAgLy8gd2UgYXNzdW1lIGFsbCB0aGUgcmVzdCB3b24ndCBhcyB3ZWxsLiBUaGlzIGlzIHRvIGF2b2lkIGdldHRpbmcgaW50byBhIHNpdHVhdGlvblxuICAgICAgICAgIC8vIHdoZXJlIHdlIGhhdmUgYSB2ZXJ5IHNtYWxsIHJlbWFpbmluZyBjYXBhY2l0eSBidXQgbm8gaGVhZGVycyB3aWxsIGV2ZXIgZml0IGFuZCB3ZSBlbmRcbiAgICAgICAgICAvLyB1cCBjb25zdGFudGx5IHRyeWluZyB0byBzZWUgaWYgdGhlIG5leHQgcmVzb3VyY2UgbWlnaHQgbWFrZSBpdC4gSW4gdGhlIGZ1dHVyZSB3ZSBjYW5cbiAgICAgICAgICAvLyBtYWtlIHRoaXMgYmVoYXZpb3IgZGlmZmVyZW50IGJldHdlZW4gcmVuZGVyIGFuZCBwcmVyZW5kZXIgc2luY2UgaW4gdGhlIGxhdHRlciBjYXNlXG4gICAgICAgICAgLy8gd2UgYXJlIGxlc3Mgc2Vuc2l0aXZlIHRvIHRoZSBjdXJyZW50IHJlcXVlc3RzIHJ1bnRpbWUgcGVyIGFuZCBtb3JlIHNlbnNpdGl2ZSB0byBtYXhpbWl6aW5nXG4gICAgICAgICAgLy8gaGVhZGVycy5cbiAgICAgICAgICAoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoKSA+PSAyKSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgcG9zdHBvbmUgaW4gdGhlIHNoZWxsIHdlIHdpbGwgc3RpbGwgZW1pdCBhIHByZWxvYWQgYXMgYSBoZWFkZXIgc28gd2VcbiAgICAgICAgICAgIC8vIHRyYWNrIHRoaXMgdG8gbWFrZSBzdXJlIHdlIGRvbid0IHJlc2V0IGl0LlxuICAgICAgICAgICAgcmVuZGVyU3RhdGUucmVzZXRzLmltYWdlW2tleV0gPSBQUkVMT0FEX05PX0NSRURTO1xuXG4gICAgICAgICAgICBpZiAoaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2Fkcykge1xuICAgICAgICAgICAgICBoZWFkZXJzLmhpZ2hJbWFnZVByZWxvYWRzICs9ICcsICc7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXTogd2UgYXNzaWduIGhlYWRlciBkdXJpbmcgdGhlIGlmIGNvbmRpdGlvblxuXG5cbiAgICAgICAgICAgIGhlYWRlcnMuaGlnaEltYWdlUHJlbG9hZHMgKz0gaGVhZGVyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGhlYWRlcnMgdG8gd3JpdGUgdG8gd2UgaGF2ZSB0byBlbmNvZGUgYXMgZWxlbWVudHMgdG8gZmx1c2ggaW4gdGhlIGhlYWRcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgaGF2ZSBpbWFnZVNyY1NldCB0aGUgYnJvd3NlciBwcm9iYWJseSBjYW5ub3QgbG9hZCB0aGUgcmlnaHQgdmVyc2lvbiBmcm9tIGhlYWRlcnNcbiAgICAgICAgICAgIC8vICh0aGlzIHNob3VsZCBiZSB2ZXJpZmllZCBieSB0ZXN0aW5nKS4gRm9yIG5vdyB3ZSBhc3N1bWUgdGhlc2UgbmVlZCB0byBnbyBpbiB0aGUgaGVhZFxuICAgICAgICAgICAgLy8gYXMgZWxlbWVudHMgZXZlbiBpZiBoZWFkZXJzIGFyZSBhdmFpbGFibGUuXG4gICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBbXTtcbiAgICAgICAgICAgIHB1c2hMaW5rSW1wbChyZXNvdXJjZSwgYXNzaWduKHtcbiAgICAgICAgICAgICAgcmVsOiAncHJlbG9hZCcsXG4gICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgYnVnIGluIFNhZmFyaSB3aGVyZSBpbWFnZVNyY1NldCBpcyBub3QgcmVzcGVjdGVkIG9uIHByZWxvYWQgbGlua3NcbiAgICAgICAgICAgICAgLy8gc28gd2Ugb21pdCB0aGUgaHJlZiBoZXJlIGlmIHdlIGhhdmUgaW1hZ2VTcmNTZXQgYi9jIHNhZmFyaSB3aWxsIGxvYWQgdGhlIHdyb25nIGltYWdlLlxuICAgICAgICAgICAgICAvLyBUaGlzIGhhcm1zIG9sZGVyIGJyb3dlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpbWFnZVNyY1NldCBieSBtYWtpbmcgdGhlaXIgcHJlbG9hZHMgbm90IHdvcmtcbiAgICAgICAgICAgICAgLy8gYnV0IHRoaXMgcG9wdWxhdGlvbiBpcyBzaHJpbmtpbmcgZmFzdCBhbmQgaXMgYWxyZWFkeSBzbWFsbCBzbyB3ZSBhY2NlcHQgdGhpcyB0cmFkZW9mZi5cbiAgICAgICAgICAgICAgaHJlZjogaW1hZ2VTcmNTZXQgPyB1bmRlZmluZWQgOiBocmVmLFxuICAgICAgICAgICAgICBhczogYXNcbiAgICAgICAgICAgIH0sIG9wdGlvbnMpKTtcblxuICAgICAgICAgICAgaWYgKGZldGNoUHJpb3JpdHkgPT09ICdoaWdoJykge1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5oaWdoSW1hZ2VQcmVsb2Fkcy5hZGQocmVzb3VyY2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChyZXNvdXJjZSk7IC8vIFN0YXNoIHRoZSByZXNvdXJjZSBpbiBjYXNlIHdlIG5lZWQgdG8gcHJvbW90ZSBpdCB0byBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgICAgLy8gd2hlbiBhbiBpbWcgdGFnIGlzIHJlbmRlcmVkXG5cbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucHJlbG9hZHMuaW1hZ2VzLnNldChrZXksIHJlc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2tleSA9IGdldFJlc291cmNlS2V5KGhyZWYpO1xuXG4gICAgICAgICAgaWYgKHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KF9rZXkpKSB7XG4gICAgICAgICAgICAvLyB3ZSBjYW4gcmV0dXJuIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGlzIHJlc291cmNlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yZXNvdXJjZTIgPSBbXTtcbiAgICAgICAgICBwdXNoTGlua0ltcGwoX3Jlc291cmNlMiwgYXNzaWduKHtcbiAgICAgICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgIGFzOiBhc1xuICAgICAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1tfa2V5XSA9IG9wdGlvbnMgJiYgKHR5cGVvZiBvcHRpb25zLmNyb3NzT3JpZ2luID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkgPT09ICdzdHJpbmcnKSA/IFtvcHRpb25zLmNyb3NzT3JpZ2luLCBvcHRpb25zLmludGVncml0eV0gOiBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICAgIHJlbmRlclN0YXRlLnByZWxvYWRzLnN0eWxlc2hlZXRzLnNldChfa2V5LCBfcmVzb3VyY2UyKTtcbiAgICAgICAgICByZW5kZXJTdGF0ZS5idWxrUHJlbG9hZHMuYWRkKF9yZXNvdXJjZTIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NjcmlwdCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2tleTIgPSBnZXRSZXNvdXJjZUtleShocmVmKTtcblxuICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoX2tleTIpKSB7XG4gICAgICAgICAgICAvLyB3ZSBjYW4gcmV0dXJuIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGlzIHJlc291cmNlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yZXNvdXJjZTMgPSBbXTtcbiAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5zY3JpcHRzLnNldChfa2V5MiwgX3Jlc291cmNlMyk7XG4gICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChfcmVzb3VyY2UzKTtcbiAgICAgICAgICBwdXNoTGlua0ltcGwoX3Jlc291cmNlMywgYXNzaWduKHtcbiAgICAgICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgIGFzOiBhc1xuICAgICAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNbX2tleTJdID0gb3B0aW9ucyAmJiAodHlwZW9mIG9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBvcHRpb25zLmludGVncml0eSA9PT0gJ3N0cmluZycpID8gW29wdGlvbnMuY3Jvc3NPcmlnaW4sIG9wdGlvbnMuaW50ZWdyaXR5XSA6IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfa2V5MyA9IGdldFJlc291cmNlS2V5KGhyZWYpO1xuXG4gICAgICAgICAgdmFyIGhhc0FzVHlwZSA9IHJlc3VtYWJsZVN0YXRlLnVua25vd25SZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoYXMpO1xuICAgICAgICAgIHZhciByZXNvdXJjZXM7XG5cbiAgICAgICAgICBpZiAoaGFzQXNUeXBlKSB7XG4gICAgICAgICAgICByZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS51bmtub3duUmVzb3VyY2VzW2FzXTtcblxuICAgICAgICAgICAgaWYgKHJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShfa2V5MykpIHtcbiAgICAgICAgICAgICAgLy8gd2UgY2FuIHJldHVybiBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhpcyByZXNvdXJjZVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc291cmNlcyA9IHt9O1xuICAgICAgICAgICAgcmVzdW1hYmxlU3RhdGUudW5rbm93blJlc291cmNlc1thc10gPSByZXNvdXJjZXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb3VyY2VzW19rZXkzXSA9IFBSRUxPQURfTk9fQ1JFRFM7XG4gICAgICAgICAgdmFyIF9oZWFkZXJzID0gcmVuZGVyU3RhdGUuaGVhZGVycztcblxuICAgICAgICAgIHZhciBfaGVhZGVyO1xuXG4gICAgICAgICAgaWYgKF9oZWFkZXJzICYmIF9oZWFkZXJzLnJlbWFpbmluZ0NhcGFjaXR5ID4gMCAmJiBhcyA9PT0gJ2ZvbnQnICYmICggLy8gV2UgY29tcHV0ZSB0aGUgaGVhZGVyIGhlcmUgYmVjYXVzZSB3ZSBtaWdodCBiZSBhYmxlIHRvIGZpdCBpdCBpbiB0aGUgbWF4IGxlbmd0aFxuICAgICAgICAgIF9oZWFkZXIgPSBnZXRQcmVsb2FkQXNIZWFkZXIoaHJlZiwgYXMsIG9wdGlvbnMpLCAvLyBXZSBhbHdheXMgY29uc3VtZSB0aGUgaGVhZGVyIGxlbmd0aCBzaW5jZSBvbmNlIHdlIGZpbmQgb25lIGhlYWRlciB0aGF0IGRvZXNuJ3QgZml0XG4gICAgICAgICAgLy8gd2UgYXNzdW1lIGFsbCB0aGUgcmVzdCB3b24ndCBhcyB3ZWxsLiBUaGlzIGlzIHRvIGF2b2lkIGdldHRpbmcgaW50byBhIHNpdHVhdGlvblxuICAgICAgICAgIC8vIHdoZXJlIHdlIGhhdmUgYSB2ZXJ5IHNtYWxsIHJlbWFpbmluZyBjYXBhY2l0eSBidXQgbm8gaGVhZGVycyB3aWxsIGV2ZXIgZml0IGFuZCB3ZSBlbmRcbiAgICAgICAgICAvLyB1cCBjb25zdGFudGx5IHRyeWluZyB0byBzZWUgaWYgdGhlIG5leHQgcmVzb3VyY2UgbWlnaHQgbWFrZSBpdC4gSW4gdGhlIGZ1dHVyZSB3ZSBjYW5cbiAgICAgICAgICAvLyBtYWtlIHRoaXMgYmVoYXZpb3IgZGlmZmVyZW50IGJldHdlZW4gcmVuZGVyIGFuZCBwcmVyZW5kZXIgc2luY2UgaW4gdGhlIGxhdHRlciBjYXNlXG4gICAgICAgICAgLy8gd2UgYXJlIGxlc3Mgc2Vuc2l0aXZlIHRvIHRoZSBjdXJyZW50IHJlcXVlc3RzIHJ1bnRpbWUgcGVyIGFuZCBtb3JlIHNlbnNpdGl2ZSB0byBtYXhpbWl6aW5nXG4gICAgICAgICAgLy8gaGVhZGVycy5cbiAgICAgICAgICAoX2hlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgLT0gX2hlYWRlci5sZW5ndGgpID49IDIpKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBwb3N0cG9uZSBpbiB0aGUgc2hlbGwgd2Ugd2lsbCBzdGlsbCBlbWl0IHRoaXMgcHJlbG9hZCBzbyB3ZVxuICAgICAgICAgICAgLy8gdHJhY2sgaXQgaGVyZSB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVzZXQuXG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5yZXNldHMuZm9udFtfa2V5M10gPSBQUkVMT0FEX05PX0NSRURTO1xuXG4gICAgICAgICAgICBpZiAoX2hlYWRlcnMuZm9udFByZWxvYWRzKSB7XG4gICAgICAgICAgICAgIF9oZWFkZXJzLmZvbnRQcmVsb2FkcyArPSAnLCAnO1xuICAgICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl06IHdlIGFzc2lnbiBoZWFkZXIgZHVyaW5nIHRoZSBpZiBjb25kaXRpb25cblxuXG4gICAgICAgICAgICBfaGVhZGVycy5mb250UHJlbG9hZHMgKz0gX2hlYWRlcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgZWl0aGVyIGRvbid0IGhhdmUgaGVhZGVycyBvciB3ZSBhcmUgcHJlbG9hZGluZyBzb21ldGhpbmcgdGhhdCBkb2VzXG4gICAgICAgICAgICAvLyBub3Qgd2FycmFudCBlbGV2YXRlZCBwcmlvcml0eSBzbyB3ZSBlbmNvZGUgYXMgYW4gZWxlbWVudC5cbiAgICAgICAgICAgIHZhciBfcmVzb3VyY2U0ID0gW107XG5cbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFzc2lnbih7XG4gICAgICAgICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgICAgICBhczogYXNcbiAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICBwdXNoTGlua0ltcGwoX3Jlc291cmNlNCwgcHJvcHMpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGFzKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2ZvbnQnOlxuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmZvbnRQcmVsb2Fkcy5hZGQoX3Jlc291cmNlNCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuYnVsa1ByZWxvYWRzLmFkZChfcmVzb3VyY2U0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IC8vIElmIHdlIGdvdCB0aGlzIGZhciB3ZSBjcmVhdGVkIGEgbmV3IHJlc291cmNlXG5cblxuICAgIGZsdXNoUmVzb3VyY2VzKHJlcXVlc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZWxvYWRNb2R1bGUoaHJlZiwgb3B0aW9ucykge1xuXG4gIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcblxuICBpZiAoIXJlcXVlc3QpIHtcbiAgICAvLyBJbiBhc3luYyBjb250ZXh0cyB3ZSBjYW4gc29tZXRpbWVzIHJlc29sdmUgcmVzb3VyY2VzIGZyb20gQXN5bmNMb2NhbFN0b3JhZ2UuIElmIHdlIGNhbid0IHdlIGNhbiBhbHNvXG4gICAgLy8gcG9zc2libHkgZ2V0IHRoZW0gZnJvbSB0aGUgc3RhY2sgaWYgd2UgYXJlIG5vdCBpbiBhbiBhc3luYyBjb250ZXh0LiBTaW5jZSB3ZSB3ZXJlIG5vdCBhYmxlIHRvIHJlc29sdmVcbiAgICAvLyB0aGUgcmVzb3VyY2VzIGZvciB0aGlzIGNhbGwgaW4gZWl0aGVyIGNhc2Ugd2Ugb3B0IHRvIGRvIG5vdGhpbmcuIFdlIGNhbiBjb25zaWRlciBtYWtpbmcgdGhpcyBhIHdhcm5pbmdcbiAgICAvLyBidXQgdGhlcmUgbWF5IGJlIHRpbWVzIHdoZXJlIGNhbGxpbmcgYSBmdW5jdGlvbiBvdXRzaWRlIG9mIHJlbmRlciBpcyBpbnRlbnRpb25hbCAoaS5lLiB0byB3YXJtIHVwIGRhdGFcbiAgICAvLyBmZXRjaGluZykgYW5kIHdlIGRvbid0IHdhbnQgdG8gd2FybiBpbiB0aG9zZSBjYXNlcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVzdW1hYmxlU3RhdGUgPSBnZXRSZXN1bWFibGVTdGF0ZShyZXF1ZXN0KTtcbiAgdmFyIHJlbmRlclN0YXRlID0gZ2V0UmVuZGVyU3RhdGUocmVxdWVzdCk7XG5cbiAgaWYgKGhyZWYpIHtcbiAgICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoaHJlZik7XG4gICAgdmFyIGFzID0gb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5hcyA9PT0gJ3N0cmluZycgPyBvcHRpb25zLmFzIDogJ3NjcmlwdCc7XG4gICAgdmFyIHJlc291cmNlO1xuXG4gICAgc3dpdGNoIChhcykge1xuICAgICAgY2FzZSAnc2NyaXB0JzpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChyZXN1bWFibGVTdGF0ZS5tb2R1bGVTY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgLy8gd2UgY2FuIHJldHVybiBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhpcyByZXNvdXJjZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc291cmNlID0gW107XG4gICAgICAgICAgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW2tleV0gPSBvcHRpb25zICYmICh0eXBlb2Ygb3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5ID09PSAnc3RyaW5nJykgPyBbb3B0aW9ucy5jcm9zc09yaWdpbiwgb3B0aW9ucy5pbnRlZ3JpdHldIDogUFJFTE9BRF9OT19DUkVEUztcbiAgICAgICAgICByZW5kZXJTdGF0ZS5wcmVsb2Fkcy5tb2R1bGVTY3JpcHRzLnNldChrZXksIHJlc291cmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGhhc0FzVHlwZSA9IHJlc3VtYWJsZVN0YXRlLm1vZHVsZVVua25vd25SZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoYXMpO1xuICAgICAgICAgIHZhciByZXNvdXJjZXM7XG5cbiAgICAgICAgICBpZiAoaGFzQXNUeXBlKSB7XG4gICAgICAgICAgICByZXNvdXJjZXMgPSByZXN1bWFibGVTdGF0ZS51bmtub3duUmVzb3VyY2VzW2FzXTtcblxuICAgICAgICAgICAgaWYgKHJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgIC8vIHdlIGNhbiByZXR1cm4gaWYgd2UgYWxyZWFkeSBoYXZlIHRoaXMgcmVzb3VyY2VcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvdXJjZXMgPSB7fTtcbiAgICAgICAgICAgIHJlc3VtYWJsZVN0YXRlLm1vZHVsZVVua25vd25SZXNvdXJjZXNbYXNdID0gcmVzb3VyY2VzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc291cmNlID0gW107XG4gICAgICAgICAgcmVzb3VyY2VzW2tleV0gPSBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVzaExpbmtJbXBsKHJlc291cmNlLCBhc3NpZ24oe1xuICAgICAgcmVsOiAnbW9kdWxlcHJlbG9hZCcsXG4gICAgICBocmVmOiBocmVmXG4gICAgfSwgb3B0aW9ucykpO1xuICAgIHJlbmRlclN0YXRlLmJ1bGtQcmVsb2Fkcy5hZGQocmVzb3VyY2UpOyAvLyBJZiB3ZSBnb3QgdGhpcyBmYXIgd2UgY3JlYXRlZCBhIG5ldyByZXNvdXJjZVxuXG4gICAgZmx1c2hSZXNvdXJjZXMocmVxdWVzdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlaW5pdFN0eWxlKGhyZWYsIHByZWNlZGVuY2UsIG9wdGlvbnMpIHtcblxuICB2YXIgcmVxdWVzdCA9IHJlc29sdmVSZXF1ZXN0KCk7XG5cbiAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgLy8gSW4gYXN5bmMgY29udGV4dHMgd2UgY2FuIHNvbWV0aW1lcyByZXNvbHZlIHJlc291cmNlcyBmcm9tIEFzeW5jTG9jYWxTdG9yYWdlLiBJZiB3ZSBjYW4ndCB3ZSBjYW4gYWxzb1xuICAgIC8vIHBvc3NpYmx5IGdldCB0aGVtIGZyb20gdGhlIHN0YWNrIGlmIHdlIGFyZSBub3QgaW4gYW4gYXN5bmMgY29udGV4dC4gU2luY2Ugd2Ugd2VyZSBub3QgYWJsZSB0byByZXNvbHZlXG4gICAgLy8gdGhlIHJlc291cmNlcyBmb3IgdGhpcyBjYWxsIGluIGVpdGhlciBjYXNlIHdlIG9wdCB0byBkbyBub3RoaW5nLiBXZSBjYW4gY29uc2lkZXIgbWFraW5nIHRoaXMgYSB3YXJuaW5nXG4gICAgLy8gYnV0IHRoZXJlIG1heSBiZSB0aW1lcyB3aGVyZSBjYWxsaW5nIGEgZnVuY3Rpb24gb3V0c2lkZSBvZiByZW5kZXIgaXMgaW50ZW50aW9uYWwgKGkuZS4gdG8gd2FybSB1cCBkYXRhXG4gICAgLy8gZmV0Y2hpbmcpIGFuZCB3ZSBkb24ndCB3YW50IHRvIHdhcm4gaW4gdGhvc2UgY2FzZXMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlc3VtYWJsZVN0YXRlID0gZ2V0UmVzdW1hYmxlU3RhdGUocmVxdWVzdCk7XG4gIHZhciByZW5kZXJTdGF0ZSA9IGdldFJlbmRlclN0YXRlKHJlcXVlc3QpO1xuXG4gIGlmIChocmVmKSB7XG4gICAgcHJlY2VkZW5jZSA9IHByZWNlZGVuY2UgfHwgJ2RlZmF1bHQnO1xuICAgIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleShocmVmKTtcbiAgICB2YXIgc3R5bGVRdWV1ZSA9IHJlbmRlclN0YXRlLnN0eWxlcy5nZXQocHJlY2VkZW5jZSk7XG4gICAgdmFyIGhhc0tleSA9IHJlc3VtYWJsZVN0YXRlLnN0eWxlUmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgdmFyIHJlc291cmNlU3RhdGUgPSBoYXNLZXkgPyByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1trZXldIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHJlc291cmNlU3RhdGUgIT09IEVYSVNUUykge1xuICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIGNyZWF0ZSB0aGlzIHJlc291cmNlIG5vdyBzbyBpdCBpcyBtYXJrZWQgYXMgRXhpc3RzXG4gICAgICByZXN1bWFibGVTdGF0ZS5zdHlsZVJlc291cmNlc1trZXldID0gRVhJU1RTOyAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHdlJ3ZlIGVuY291bnRlcmVkIHRoaXMgcHJlY2VkZW5jZSB3ZSBuZWVkXG4gICAgICAvLyB0byBjcmVhdGUgYSBTdHlsZVF1ZXVlXG5cbiAgICAgIGlmICghc3R5bGVRdWV1ZSkge1xuICAgICAgICBzdHlsZVF1ZXVlID0ge1xuICAgICAgICAgIHByZWNlZGVuY2U6IHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIocHJlY2VkZW5jZSkpLFxuICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICBocmVmczogW10sXG4gICAgICAgICAgc2hlZXRzOiBuZXcgTWFwKClcbiAgICAgICAgfTtcbiAgICAgICAgcmVuZGVyU3RhdGUuc3R5bGVzLnNldChwcmVjZWRlbmNlLCBzdHlsZVF1ZXVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc291cmNlID0ge1xuICAgICAgICBzdGF0ZTogUEVORElORyQxLFxuICAgICAgICBwcm9wczogYXNzaWduKHtcbiAgICAgICAgICByZWw6ICdzdHlsZXNoZWV0JyxcbiAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgICdkYXRhLXByZWNlZGVuY2UnOiBwcmVjZWRlbmNlXG4gICAgICAgIH0sIG9wdGlvbnMpXG4gICAgICB9O1xuXG4gICAgICBpZiAocmVzb3VyY2VTdGF0ZSkge1xuICAgICAgICAvLyBXaGVuIHJlc291cmNlU3RhdGUgaXMgdHJ1dHkgaXQgaXMgYSBQcmVsb2FkIHN0YXRlLiBXZSBjYXN0IGl0IGZvciBjbGFyaXR5XG4gICAgICAgIHZhciBwcmVsb2FkU3RhdGUgPSByZXNvdXJjZVN0YXRlO1xuXG4gICAgICAgIGlmIChwcmVsb2FkU3RhdGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHMocmVzb3VyY2UucHJvcHMsIHByZWxvYWRTdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlbG9hZFJlc291cmNlID0gcmVuZGVyU3RhdGUucHJlbG9hZHMuc3R5bGVzaGVldHMuZ2V0KGtleSk7XG5cbiAgICAgICAgaWYgKHByZWxvYWRSZXNvdXJjZSAmJiBwcmVsb2FkUmVzb3VyY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIFRoZSBQcmVsb2FkIGZvciB0aGlzIHJlc291cmNlIHdhcyBjcmVhdGVkIGluIHRoaXMgcmVuZGVyIHBhc3MgYW5kIGhhcyBub3QgZmx1c2hlZCB5ZXQgc29cbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNsZWFyIGl0IHRvIGF2b2lkIGl0IGZsdXNoaW5nLlxuICAgICAgICAgIHByZWxvYWRSZXNvdXJjZS5sZW5ndGggPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEVpdGhlciB0aGUgcHJlbG9hZCByZXNvdXJjZSBmcm9tIHRoaXMgcmVuZGVyIGFscmVhZHkgZmx1c2hlZCBpbiB0aGlzIHJlbmRlciBwYXNzXG4gICAgICAgICAgLy8gb3IgdGhlIHByZWxvYWQgZmx1c2hlZCBpbiBhIHByaW9yIHBhc3MgKHByZXJlbmRlcikuIEluIGVpdGhlciBjYXNlIHdlIG5lZWQgdG8gbWFya1xuICAgICAgICAgIC8vIHRoaXMgcmVzb3VyY2UgYXMgYWxyZWFkeSBoYXZpbmcgYmVlbiBwcmVsb2FkZWQuXG4gICAgICAgICAgcmVzb3VyY2Uuc3RhdGUgPSBQUkVMT0FERUQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gV2UgYWRkIHRoZSBuZXdseSBjcmVhdGVkIHJlc291cmNlIHRvIG91ciBTdHlsZVF1ZXVlIGFuZCBpZiBuZWNlc3NhcnlcbiAgICAgIC8vIHRyYWNrIHRoZSByZXNvdXJjZSB3aXRoIHRoZSBjdXJyZW50bHkgcmVuZGVyaW5nIGJvdW5kYXJ5XG5cblxuICAgICAgc3R5bGVRdWV1ZS5zaGVldHMuc2V0KGtleSwgcmVzb3VyY2UpOyAvLyBOb3RpZnkgdGhlIHJlcXVlc3QgdGhhdCB0aGVyZSBhcmUgcmVzb3VyY2VzIHRvIGZsdXNoIGV2ZW4gaWYgbm8gd29yayBpcyBjdXJyZW50bHkgaGFwcGVuaW5nXG5cbiAgICAgIGZsdXNoUmVzb3VyY2VzKHJlcXVlc3QpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVpbml0U2NyaXB0KHNyYywgb3B0aW9ucykge1xuXG4gIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcblxuICBpZiAoIXJlcXVlc3QpIHtcbiAgICAvLyBJbiBhc3luYyBjb250ZXh0cyB3ZSBjYW4gc29tZXRpbWVzIHJlc29sdmUgcmVzb3VyY2VzIGZyb20gQXN5bmNMb2NhbFN0b3JhZ2UuIElmIHdlIGNhbid0IHdlIGNhbiBhbHNvXG4gICAgLy8gcG9zc2libHkgZ2V0IHRoZW0gZnJvbSB0aGUgc3RhY2sgaWYgd2UgYXJlIG5vdCBpbiBhbiBhc3luYyBjb250ZXh0LiBTaW5jZSB3ZSB3ZXJlIG5vdCBhYmxlIHRvIHJlc29sdmVcbiAgICAvLyB0aGUgcmVzb3VyY2VzIGZvciB0aGlzIGNhbGwgaW4gZWl0aGVyIGNhc2Ugd2Ugb3B0IHRvIGRvIG5vdGhpbmcuIFdlIGNhbiBjb25zaWRlciBtYWtpbmcgdGhpcyBhIHdhcm5pbmdcbiAgICAvLyBidXQgdGhlcmUgbWF5IGJlIHRpbWVzIHdoZXJlIGNhbGxpbmcgYSBmdW5jdGlvbiBvdXRzaWRlIG9mIHJlbmRlciBpcyBpbnRlbnRpb25hbCAoaS5lLiB0byB3YXJtIHVwIGRhdGFcbiAgICAvLyBmZXRjaGluZykgYW5kIHdlIGRvbid0IHdhbnQgdG8gd2FybiBpbiB0aG9zZSBjYXNlcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVzdW1hYmxlU3RhdGUgPSBnZXRSZXN1bWFibGVTdGF0ZShyZXF1ZXN0KTtcbiAgdmFyIHJlbmRlclN0YXRlID0gZ2V0UmVuZGVyU3RhdGUocmVxdWVzdCk7XG5cbiAgaWYgKHNyYykge1xuICAgIHZhciBrZXkgPSBnZXRSZXNvdXJjZUtleShzcmMpO1xuICAgIHZhciBoYXNLZXkgPSByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXMuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICB2YXIgcmVzb3VyY2VTdGF0ZSA9IGhhc0tleSA/IHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1trZXldIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHJlc291cmNlU3RhdGUgIT09IEVYSVNUUykge1xuICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIGNyZWF0ZSB0aGlzIHJlc291cmNlIG5vdyBzbyBpdCBpcyBtYXJrZWQgYXMgRXhpc3RzXG4gICAgICByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNba2V5XSA9IEVYSVNUUztcblxuICAgICAgdmFyIHByb3BzID0gYXNzaWduKHtcbiAgICAgICAgc3JjOiBzcmMsXG4gICAgICAgIGFzeW5jOiB0cnVlXG4gICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgaWYgKHJlc291cmNlU3RhdGUpIHtcbiAgICAgICAgLy8gV2hlbiByZXNvdXJjZVN0YXRlIGlzIHRydXR5IGl0IGlzIGEgUHJlbG9hZCBzdGF0ZS4gV2UgY2FzdCBpdCBmb3IgY2xhcml0eVxuICAgICAgICB2YXIgcHJlbG9hZFN0YXRlID0gcmVzb3VyY2VTdGF0ZTtcblxuICAgICAgICBpZiAocHJlbG9hZFN0YXRlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKHByb3BzLCBwcmVsb2FkU3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZWxvYWRSZXNvdXJjZSA9IHJlbmRlclN0YXRlLnByZWxvYWRzLnNjcmlwdHMuZ2V0KGtleSk7XG5cbiAgICAgICAgaWYgKHByZWxvYWRSZXNvdXJjZSkge1xuICAgICAgICAgIC8vIHRoZSBwcmVsb2FkIHJlc291cmNlIGV4aXN0cyB3YXMgY3JlYXRlZCBpbiB0aGlzIHJlbmRlci4gTm93IHRoYXQgd2UgaGF2ZVxuICAgICAgICAgIC8vIGEgc2NyaXB0IHJlc291cmNlIHdoaWNoIHdpbGwgZW1pdCBlYXJsaWVyIHRoYW4gYSBwcmVsb2FkIHdvdWxkIGlmIGl0XG4gICAgICAgICAgLy8gaGFzbid0IGFscmVhZHkgZmx1c2hlZCB3ZSBwcmV2ZW50IGl0IGZyb20gZmx1c2hpbmcgYnkgemVyb2luZyB0aGUgbGVuZ3RoXG4gICAgICAgICAgcHJlbG9hZFJlc291cmNlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJlc291cmNlID0gW107IC8vIEFkZCB0byB0aGUgc2NyaXB0IGZsdXNoaW5nIHF1ZXVlXG5cbiAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHJlc291cmNlKTsgLy8gZW5jb2RlIHRoZSB0YWcgYXMgQ2h1bmtzXG5cbiAgICAgIHB1c2hTY3JpcHRJbXBsKHJlc291cmNlLCBwcm9wcyk7IC8vIE5vdGlmeSB0aGUgcmVxdWVzdCB0aGF0IHRoZXJlIGFyZSByZXNvdXJjZXMgdG8gZmx1c2ggZXZlbiBpZiBubyB3b3JrIGlzIGN1cnJlbnRseSBoYXBwZW5pbmdcblxuICAgICAgZmx1c2hSZXNvdXJjZXMocmVxdWVzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZWluaXRNb2R1bGVTY3JpcHQoc3JjLCBvcHRpb25zKSB7XG5cbiAgdmFyIHJlcXVlc3QgPSByZXNvbHZlUmVxdWVzdCgpO1xuXG4gIGlmICghcmVxdWVzdCkge1xuICAgIC8vIEluIGFzeW5jIGNvbnRleHRzIHdlIGNhbiBzb21ldGltZXMgcmVzb2x2ZSByZXNvdXJjZXMgZnJvbSBBc3luY0xvY2FsU3RvcmFnZS4gSWYgd2UgY2FuJ3Qgd2UgY2FuIGFsc29cbiAgICAvLyBwb3NzaWJseSBnZXQgdGhlbSBmcm9tIHRoZSBzdGFjayBpZiB3ZSBhcmUgbm90IGluIGFuIGFzeW5jIGNvbnRleHQuIFNpbmNlIHdlIHdlcmUgbm90IGFibGUgdG8gcmVzb2x2ZVxuICAgIC8vIHRoZSByZXNvdXJjZXMgZm9yIHRoaXMgY2FsbCBpbiBlaXRoZXIgY2FzZSB3ZSBvcHQgdG8gZG8gbm90aGluZy4gV2UgY2FuIGNvbnNpZGVyIG1ha2luZyB0aGlzIGEgd2FybmluZ1xuICAgIC8vIGJ1dCB0aGVyZSBtYXkgYmUgdGltZXMgd2hlcmUgY2FsbGluZyBhIGZ1bmN0aW9uIG91dHNpZGUgb2YgcmVuZGVyIGlzIGludGVudGlvbmFsIChpLmUuIHRvIHdhcm0gdXAgZGF0YVxuICAgIC8vIGZldGNoaW5nKSBhbmQgd2UgZG9uJ3Qgd2FudCB0byB3YXJuIGluIHRob3NlIGNhc2VzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZXN1bWFibGVTdGF0ZSA9IGdldFJlc3VtYWJsZVN0YXRlKHJlcXVlc3QpO1xuICB2YXIgcmVuZGVyU3RhdGUgPSBnZXRSZW5kZXJTdGF0ZShyZXF1ZXN0KTtcblxuICBpZiAoc3JjKSB7XG4gICAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KHNyYyk7XG4gICAgdmFyIGhhc0tleSA9IHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgIHZhciByZXNvdXJjZVN0YXRlID0gaGFzS2V5ID8gcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW2tleV0gOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAocmVzb3VyY2VTdGF0ZSAhPT0gRVhJU1RTKSB7XG4gICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gY3JlYXRlIHRoaXMgcmVzb3VyY2Ugbm93IHNvIGl0IGlzIG1hcmtlZCBhcyBFeGlzdHNcbiAgICAgIHJlc3VtYWJsZVN0YXRlLm1vZHVsZVNjcmlwdFJlc291cmNlc1trZXldID0gRVhJU1RTO1xuXG4gICAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe1xuICAgICAgICBzcmM6IHNyYyxcbiAgICAgICAgdHlwZTogJ21vZHVsZScsXG4gICAgICAgIGFzeW5jOiB0cnVlXG4gICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgaWYgKHJlc291cmNlU3RhdGUpIHtcbiAgICAgICAgLy8gV2hlbiByZXNvdXJjZVN0YXRlIGlzIHRydXR5IGl0IGlzIGEgUHJlbG9hZCBzdGF0ZS4gV2UgY2FzdCBpdCBmb3IgY2xhcml0eVxuICAgICAgICB2YXIgcHJlbG9hZFN0YXRlID0gcmVzb3VyY2VTdGF0ZTtcblxuICAgICAgICBpZiAocHJlbG9hZFN0YXRlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGFkb3B0UHJlbG9hZENyZWRlbnRpYWxzKHByb3BzLCBwcmVsb2FkU3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZWxvYWRSZXNvdXJjZSA9IHJlbmRlclN0YXRlLnByZWxvYWRzLm1vZHVsZVNjcmlwdHMuZ2V0KGtleSk7XG5cbiAgICAgICAgaWYgKHByZWxvYWRSZXNvdXJjZSkge1xuICAgICAgICAgIC8vIHRoZSBwcmVsb2FkIHJlc291cmNlIGV4aXN0cyB3YXMgY3JlYXRlZCBpbiB0aGlzIHJlbmRlci4gTm93IHRoYXQgd2UgaGF2ZVxuICAgICAgICAgIC8vIGEgc2NyaXB0IHJlc291cmNlIHdoaWNoIHdpbGwgZW1pdCBlYXJsaWVyIHRoYW4gYSBwcmVsb2FkIHdvdWxkIGlmIGl0XG4gICAgICAgICAgLy8gaGFzbid0IGFscmVhZHkgZmx1c2hlZCB3ZSBwcmV2ZW50IGl0IGZyb20gZmx1c2hpbmcgYnkgemVyb2luZyB0aGUgbGVuZ3RoXG4gICAgICAgICAgcHJlbG9hZFJlc291cmNlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJlc291cmNlID0gW107IC8vIEFkZCB0byB0aGUgc2NyaXB0IGZsdXNoaW5nIHF1ZXVlXG5cbiAgICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHJlc291cmNlKTsgLy8gZW5jb2RlIHRoZSB0YWcgYXMgQ2h1bmtzXG5cbiAgICAgIHB1c2hTY3JpcHRJbXBsKHJlc291cmNlLCBwcm9wcyk7IC8vIE5vdGlmeSB0aGUgcmVxdWVzdCB0aGF0IHRoZXJlIGFyZSByZXNvdXJjZXMgdG8gZmx1c2ggZXZlbiBpZiBubyB3b3JrIGlzIGN1cnJlbnRseSBoYXBwZW5pbmdcblxuICAgICAgZmx1c2hSZXNvdXJjZXMocmVxdWVzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG59IC8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBzYWZlIHRvIGNhbGwgYXQgUmVxdWVzdCBzdGFydCB0aW1lIHNpbmNlIGl0IGFzc3VtZXNcbi8vIHRoYXQgZWFjaCBtb2R1bGUgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcHJlbG9hZGVkLiBJZiB3ZSBmaW5kIGEgbmVlZCB0byBwcmVsb2FkXG4vLyBzY3JpcHRzIGF0IGFueSBvdGhlciBwb2ludCBpbiB0aW1lIHdlIHdpbGwgbmVlZCB0byBjaGVjayB3aGV0aGVyIHRoZSBwcmVsb2FkXG4vLyBhbHJlYWR5IGV4aXN0cyBhbmQgbm90IGFzc3VtZSBpdFxuXG5cbmZ1bmN0aW9uIHByZWxvYWRCb290c3RyYXBTY3JpcHRPck1vZHVsZShyZXN1bWFibGVTdGF0ZSwgcmVuZGVyU3RhdGUsIGhyZWYsIHByb3BzKSB7XG5cbiAgdmFyIGtleSA9IGdldFJlc291cmNlS2V5KGhyZWYpO1xuXG4gIHtcbiAgICBpZiAocmVzdW1hYmxlU3RhdGUuc2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSkgfHwgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgY29kZWQgYXMgYSBSZWFjdCBlcnJvciBiZWNhdXNlIGl0IHNob3VsZCBiZSBpbXBvc3NpYmxlIGZvciBhIHVzZXJzcGFjZSBwcmVsb2FkIHRvIHByZWVtcHQgdGhpcyBjYWxsXG4gICAgICAvLyBJZiBhIHVzZXJzcGFjZSBwcmVsb2FkIGNhbiBwcmVlbXB0IGl0IHRoZW4gdGhpcyBhc3N1bXB0aW9uIGlzIGJyb2tlbiBhbmQgd2UgbmVlZCB0byByZWNvbnNpZGVyIHRoaXMgc3RyYXRlZ3lcbiAgICAgIC8vIHJhdGhlciB0aGFuIGluc3RydWN0IHRoZSB1c2VyIHRvIG5vdCBwcmVsb2FkIHRoZWlyIGJvb3RzdHJhcCBzY3JpcHRzIHRoZW1zZWx2ZXNcbiAgICAgIGVycm9yKCdJbnRlcm5hbCBSZWFjdCBFcnJvcjogUmVhY3QgZXhwZWN0ZWQgYm9vdHN0cmFwIHNjcmlwdCBvciBtb2R1bGUgd2l0aCBzcmMgXCIlc1wiIHRvIG5vdCBoYXZlIGJlZW4gcHJlbG9hZGVkIGFscmVhZHkuIHBsZWFzZSBmaWxlIGFuIGlzc3VlJywgaHJlZik7XG4gICAgfVxuICB9IC8vIFRoZSBocmVmIHVzZWQgZm9yIGJvb3RzdHJhcCBzY3JpcHRzIGFuZCBib290c3RyYXAgbW9kdWxlcyBzaG91bGQgbmV2ZXIgYmVcbiAgLy8gdXNlZCB0byBwcmVpbml0IHRoZSByZXNvdXJjZS4gSWYgYSBzY3JpcHQgY2FuIGJlIHByZWluaXRlZCB0aGVuIGl0IHNob3VsZG4ndFxuICAvLyBiZSBhIGJvb3RzdHJhcCBzY3JpcHQvbW9kdWxlIGFuZCBpZiBpdCBpcyBhIGJvb3RzdHJhcCBzY3JpcHQvbW9kdWxlIHRoZW4gaXRcbiAgLy8gbXVzdCBub3QgYmUgc2FmZSB0byBlbWl0IGVhcmx5LiBUbyBhdm9pZCBwb3NzaWJseSBhbGxvd2luZyBmb3IgcHJlaW5pdHMgb2ZcbiAgLy8gYm9vdHN0cmFwIHNjcmlwdHMvbW9kdWxlcyB3ZSBvY2NsdWRlIHRoZXNlIGtleXMuXG5cblxuICByZXN1bWFibGVTdGF0ZS5zY3JpcHRSZXNvdXJjZXNba2V5XSA9IEVYSVNUUztcbiAgcmVzdW1hYmxlU3RhdGUubW9kdWxlU2NyaXB0UmVzb3VyY2VzW2tleV0gPSBFWElTVFM7XG4gIHZhciByZXNvdXJjZSA9IFtdO1xuICBwdXNoTGlua0ltcGwocmVzb3VyY2UsIHByb3BzKTtcbiAgcmVuZGVyU3RhdGUuYm9vdHN0cmFwU2NyaXB0cy5hZGQocmVzb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBpbnRlcm5hbFByZWluaXRTY3JpcHQocmVzdW1hYmxlU3RhdGUsIHJlbmRlclN0YXRlLCBzcmMsIGNodW5rcykge1xuICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkoc3JjKTtcblxuICBpZiAoIXJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgdmFyIHJlc291cmNlID0gY2h1bmtzO1xuICAgIHJlc3VtYWJsZVN0YXRlLnNjcmlwdFJlc291cmNlc1trZXldID0gRVhJU1RTO1xuICAgIHJlbmRlclN0YXRlLnNjcmlwdHMuYWRkKHJlc291cmNlKTtcbiAgfVxuXG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gcHJlbG9hZEFzU3R5bGVQcm9wc0Zyb21Qcm9wcyhocmVmLCBwcm9wcykge1xuICByZXR1cm4ge1xuICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgIGFzOiAnc3R5bGUnLFxuICAgIGhyZWY6IGhyZWYsXG4gICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luLFxuICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgaW50ZWdyaXR5OiBwcm9wcy5pbnRlZ3JpdHksXG4gICAgbWVkaWE6IHByb3BzLm1lZGlhLFxuICAgIGhyZWZMYW5nOiBwcm9wcy5ocmVmTGFuZyxcbiAgICByZWZlcnJlclBvbGljeTogcHJvcHMucmVmZXJyZXJQb2xpY3lcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVzaGVldFByb3BzRnJvbVJhd1Byb3BzKHJhd1Byb3BzKSB7XG4gIHJldHVybiBhc3NpZ24oe30sIHJhd1Byb3BzLCB7XG4gICAgJ2RhdGEtcHJlY2VkZW5jZSc6IHJhd1Byb3BzLnByZWNlZGVuY2UsXG4gICAgcHJlY2VkZW5jZTogbnVsbFxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRvcHRQcmVsb2FkQ3JlZGVudGlhbHModGFyZ2V0LCBwcmVsb2FkU3RhdGUpIHtcbiAgaWYgKHRhcmdldC5jcm9zc09yaWdpbiA9PSBudWxsKSB0YXJnZXQuY3Jvc3NPcmlnaW4gPSBwcmVsb2FkU3RhdGVbMF07XG4gIGlmICh0YXJnZXQuaW50ZWdyaXR5ID09IG51bGwpIHRhcmdldC5pbnRlZ3JpdHkgPSBwcmVsb2FkU3RhdGVbMV07XG59XG5cbmZ1bmN0aW9uIGdldFByZWZldGNoRE5TQXNIZWFkZXIoaHJlZikge1xuICB2YXIgZXNjYXBlZEhyZWYgPSBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHQoaHJlZik7XG4gIHJldHVybiBcIjxcIiArIGVzY2FwZWRIcmVmICsgXCI+OyByZWw9ZG5zLXByZWZldGNoXCI7XG59XG5cbmZ1bmN0aW9uIGdldFByZWNvbm5lY3RBc0hlYWRlcihocmVmLCBjcm9zc09yaWdpbikge1xuICB2YXIgZXNjYXBlZEhyZWYgPSBlc2NhcGVIcmVmRm9yTGlua0hlYWRlclVSTENvbnRleHQoaHJlZik7XG4gIHZhciB2YWx1ZSA9IFwiPFwiICsgZXNjYXBlZEhyZWYgKyBcIj47IHJlbD1wcmVjb25uZWN0XCI7XG5cbiAgaWYgKHR5cGVvZiBjcm9zc09yaWdpbiA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgZXNjYXBlZENyb3NzT3JpZ2luID0gZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0KGNyb3NzT3JpZ2luLCAnY3Jvc3NPcmlnaW4nKTtcbiAgICB2YWx1ZSArPSBcIjsgY3Jvc3NvcmlnaW49XFxcIlwiICsgZXNjYXBlZENyb3NzT3JpZ2luICsgXCJcXFwiXCI7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldFByZWxvYWRBc0hlYWRlcihocmVmLCBhcywgcGFyYW1zKSB7XG4gIHZhciBlc2NhcGVkSHJlZiA9IGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dChocmVmKTtcbiAgdmFyIGVzY2FwZWRBcyA9IGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dChhcywgJ2FzJyk7XG4gIHZhciB2YWx1ZSA9IFwiPFwiICsgZXNjYXBlZEhyZWYgKyBcIj47IHJlbD1wcmVsb2FkOyBhcz1cXFwiXCIgKyBlc2NhcGVkQXMgKyBcIlxcXCJcIjtcblxuICBmb3IgKHZhciBwYXJhbU5hbWUgaW4gcGFyYW1zKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCBwYXJhbU5hbWUpKSB7XG4gICAgICB2YXIgcGFyYW1WYWx1ZSA9IHBhcmFtc1twYXJhbU5hbWVdO1xuXG4gICAgICBpZiAodHlwZW9mIHBhcmFtVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbHVlICs9IFwiOyBcIiArIHBhcmFtTmFtZS50b0xvd2VyQ2FzZSgpICsgXCI9XFxcIlwiICsgZXNjYXBlU3RyaW5nRm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0KHBhcmFtVmFsdWUsIHBhcmFtTmFtZSkgKyBcIlxcXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldFN0eWxlc2hlZXRQcmVsb2FkQXNIZWFkZXIoc3R5bGVzaGVldCkge1xuICB2YXIgcHJvcHMgPSBzdHlsZXNoZWV0LnByb3BzO1xuICB2YXIgcHJlbG9hZE9wdGlvbnMgPSB7XG4gICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luLFxuICAgIGludGVncml0eTogcHJvcHMuaW50ZWdyaXR5LFxuICAgIG5vbmNlOiBwcm9wcy5ub25jZSxcbiAgICB0eXBlOiBwcm9wcy50eXBlLFxuICAgIGZldGNoUHJpb3JpdHk6IHByb3BzLmZldGNoUHJpb3JpdHksXG4gICAgcmVmZXJyZXJQb2xpY3k6IHByb3BzLnJlZmVycmVyUG9saWN5LFxuICAgIG1lZGlhOiBwcm9wcy5tZWRpYVxuICB9O1xuICByZXR1cm4gZ2V0UHJlbG9hZEFzSGVhZGVyKHByb3BzLmhyZWYsICdzdHlsZScsIHByZWxvYWRPcHRpb25zKTtcbn0gLy8gVGhpcyBlc2NhcGluZyBmdW5jdGlvbiBpcyBvbmx5IHNhZmUgdG8gdXNlIGZvciBocmVmIHZhbHVlcyBiZWluZyB3cml0dGVuIGludG9cbi8vIGEgXCJMaW5rXCIgaGVhZGVyIGluIGJldHdlZW4gYDxgIGFuZCBgPmAgY2hhcmFjdGVycy4gVGhlIHByaW1hcnkgY29uY2VybiB3aXRoIHRoZSBocmVmIGlzXG4vLyB0byBlc2NhcGUgdGhlIGJvdW5kaW5nIGNoYXJhY3RlcnMgYXMgd2VsbCBhcyBuZXcgbGluZXMuIFRoaXMgaXMgdW5zYWZlIHRvIHVzZSBpbiBhbnkgb3RoZXJcbi8vIGNvbnRleHRcblxuXG52YXIgcmVnZXhGb3JIcmVmSW5MaW5rSGVhZGVyVVJMQ29udGV4dCA9IC9bPD5cXHJcXG5dL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dChocmVmSW5wdXQpIHtcbiAge1xuICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oaHJlZklucHV0LCAnaHJlZicpO1xuICB9XG5cbiAgdmFyIGNvZXJjZWRIcmVmID0gJycgKyBocmVmSW5wdXQ7XG4gIHJldHVybiBjb2VyY2VkSHJlZi5yZXBsYWNlKHJlZ2V4Rm9ySHJlZkluTGlua0hlYWRlclVSTENvbnRleHQsIGVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dFJlcGxhY2VyKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0UmVwbGFjZXIobWF0Y2gpIHtcbiAgc3dpdGNoIChtYXRjaCkge1xuICAgIGNhc2UgJzwnOlxuICAgICAgcmV0dXJuICclM0MnO1xuXG4gICAgY2FzZSAnPic6XG4gICAgICByZXR1cm4gJyUzRSc7XG5cbiAgICBjYXNlICdcXG4nOlxuICAgICAgcmV0dXJuICclMEEnO1xuXG4gICAgY2FzZSAnXFxyJzpcbiAgICAgIHJldHVybiAnJTBEJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXNjYXBlTGlua0hyZWZGb3JIZWFkZXJDb250ZXh0UmVwbGFjZXIgZW5jb3VudGVyZWQgYSBtYXRjaCBpdCBkb2VzIG5vdCBrbm93IGhvdyB0byByZXBsYWNlLiB0aGlzIG1lYW5zIHRoZSBtYXRjaCByZWdleCBhbmQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgYXJlIG5vIGxvbmdlciBpbiBzeW5jLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0Jyk7XG4gICAgICB9XG4gIH1cbn0gLy8gVGhpcyBlc2NhcGluZyBmdW5jdGlvbiBpcyBvbmx5IHNhZmUgdG8gdXNlIGZvciBxdW90ZWQgcGFyYW0gdmFsdWVzIGluIGFuIEhUVFAgaGVhZGVyLlxuLy8gSXQgaXMgdW5zYWZlIHRvIHVzZSBmb3IgYW55IHZhbHVlIG5vdCBpbnNpZGUgcXVvdGUgbWFya3MgaW4gcGFyYXRlciB2YWx1ZSBwb3NpdGlvbi5cblxuXG52YXIgcmVnZXhGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQgPSAvW1wiJzssXFxyXFxuXS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHQodmFsdWUsIG5hbWUpIHtcbiAge1xuICAgIGNoZWNrT3B0aW9uU3RyaW5nQ29lcmNpb24odmFsdWUsIG5hbWUpO1xuICB9XG5cbiAgdmFyIGNvZXJjZWQgPSAnJyArIHZhbHVlO1xuICByZXR1cm4gY29lcmNlZC5yZXBsYWNlKHJlZ2V4Rm9yTGlua0hlYWRlclF1b3RlZFBhcmFtVmFsdWVDb250ZXh0LCBlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHRSZXBsYWNlcik7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dFJlcGxhY2VyKG1hdGNoKSB7XG4gIHN3aXRjaCAobWF0Y2gpIHtcbiAgICBjYXNlICdcIic6XG4gICAgICByZXR1cm4gJyUyMic7XG5cbiAgICBjYXNlIFwiJ1wiOlxuICAgICAgcmV0dXJuICclMjcnO1xuXG4gICAgY2FzZSAnOyc6XG4gICAgICByZXR1cm4gJyUzQic7XG5cbiAgICBjYXNlICcsJzpcbiAgICAgIHJldHVybiAnJTJDJztcblxuICAgIGNhc2UgJ1xcbic6XG4gICAgICByZXR1cm4gJyUwQSc7XG5cbiAgICBjYXNlICdcXHInOlxuICAgICAgcmV0dXJuICclMEQnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHRSZXBsYWNlciBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QnKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBob2lzdFN0eWxlUXVldWVEZXBlbmRlbmN5KHN0eWxlUXVldWUpIHtcbiAgdGhpcy5zdHlsZXMuYWRkKHN0eWxlUXVldWUpO1xufVxuXG5mdW5jdGlvbiBob2lzdFN0eWxlc2hlZXREZXBlbmRlbmN5KHN0eWxlc2hlZXQpIHtcbiAgdGhpcy5zdHlsZXNoZWV0cy5hZGQoc3R5bGVzaGVldCk7XG59XG5cbmZ1bmN0aW9uIGhvaXN0UmVzb3VyY2VzKHJlbmRlclN0YXRlLCBzb3VyY2UpIHtcbiAgdmFyIGN1cnJlbnRCb3VuZGFyeVJlc291cmNlcyA9IHJlbmRlclN0YXRlLmJvdW5kYXJ5UmVzb3VyY2VzO1xuXG4gIGlmIChjdXJyZW50Qm91bmRhcnlSZXNvdXJjZXMpIHtcbiAgICBzb3VyY2Uuc3R5bGVzLmZvckVhY2goaG9pc3RTdHlsZVF1ZXVlRGVwZW5kZW5jeSwgY3VycmVudEJvdW5kYXJ5UmVzb3VyY2VzKTtcbiAgICBzb3VyY2Uuc3R5bGVzaGVldHMuZm9yRWFjaChob2lzdFN0eWxlc2hlZXREZXBlbmRlbmN5LCBjdXJyZW50Qm91bmRhcnlSZXNvdXJjZXMpO1xuICB9XG59IC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGF0IHZhcmlvdXMgdGltZXMgZGVwZW5kaW5nIG9uIHdoZXRoZXIgd2UgYXJlIHJlbmRlcmluZ1xuLy8gb3IgcHJlcmVuZGVyaW5nLiBJbiB0aGlzIGltcGxlbWVudGF0aW9uIHdlIG9ubHkgYWN0dWFsbHkgZW1pdCBoZWFkZXJzIG9uY2UgYW5kXG4vLyBzdWJzZXF1ZW50IGNhbGxzIGFyZSBpZ25vcmVkLiBXZSB0cmFjayB3aGV0aGVyIHRoZSByZXF1ZXN0IGhhcyBhIGNvbXBsZXRlZCBzaGVsbFxuLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2Ugd2lsbCBmb2xsb3cgaGVhZGVycyB3aXRoIGEgZmx1c2ggaW5jbHVkaW5nIHN0eWxlc2hlZXRzLlxuLy8gSW4gdGhlIGNvbnRleHQgb2YgcHJlcnJlbmRlciB3ZSBkb24ndCBoYXZlIGEgY29tcGxldGVkIHNoZWxsIHdoZW4gdGhlIHJlcXVlc3QgZmluaXNoZXNcbi8vIHdpdGggYSBwb3N0cG9uZSBpbiB0aGUgc2hlbGwuIEluIHRoZSBjb250ZXh0IG9mIGEgcmVuZGVyIHdlIGRvbid0IGhhdmUgYSBjb21wbGV0ZWQgc2hlbGxcbi8vIGlmIHRoaXMgaXMgY2FsbGVkIGJlZm9yZSB0aGUgc2hlbGwgZmluaXNoZXMgcmVuZGVyaW5nIHdoaWNoIHVzdWFsbHkgd2lsbCBoYXBwZW4gYW55dGltZVxuLy8gYW55dGhpbmcgc3VzcGVuZHMgaW4gdGhlIHNoZWxsLlxuXG5mdW5jdGlvbiBlbWl0RWFybHlQcmVsb2FkcyhyZW5kZXJTdGF0ZSwgcmVzdW1hYmxlU3RhdGUsIHNoZWxsQ29tcGxldGUpIHtcbiAgdmFyIG9uSGVhZGVycyA9IHJlbmRlclN0YXRlLm9uSGVhZGVycztcblxuICBpZiAob25IZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSByZW5kZXJTdGF0ZS5oZWFkZXJzO1xuXG4gICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgIC8vIEV2ZW4gaWYgb25IZWFkZXJzIHRocm93cyB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhpcyBhZ2FpbiBzb1xuICAgICAgLy8gd2UgZHJvcCB0aGUgaGVhZGVycyBzdGF0ZSBmcm9tIHRoaXMgcG9pbnQgb253YXJkcy5cbiAgICAgIHJlbmRlclN0YXRlLmhlYWRlcnMgPSBudWxsO1xuICAgICAgdmFyIGxpbmtIZWFkZXIgPSBoZWFkZXJzLnByZWNvbm5lY3RzO1xuXG4gICAgICBpZiAoaGVhZGVycy5mb250UHJlbG9hZHMpIHtcbiAgICAgICAgaWYgKGxpbmtIZWFkZXIpIHtcbiAgICAgICAgICBsaW5rSGVhZGVyICs9ICcsICc7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5rSGVhZGVyICs9IGhlYWRlcnMuZm9udFByZWxvYWRzO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2Fkcykge1xuICAgICAgICBpZiAobGlua0hlYWRlcikge1xuICAgICAgICAgIGxpbmtIZWFkZXIgKz0gJywgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmtIZWFkZXIgKz0gaGVhZGVycy5oaWdoSW1hZ2VQcmVsb2FkcztcbiAgICAgIH1cblxuICAgICAgaWYgKCFzaGVsbENvbXBsZXRlKSB7XG4gICAgICAgIC8vIFdlIHVzZSByYXcgaXRlcmF0b3JzIGJlY2F1c2Ugd2Ugd2FudCB0byBiZSBhYmxlIHRvIGhhbHQgaXRlcmF0aW9uXG4gICAgICAgIC8vIFdlIGNvdWxkIHJlZmFjdG9yIHJlbmRlclN0YXRlIHRvIHN0b3JlIHRoZXNlIGR1YWxseSBpbiBhcnJheXMgdG9cbiAgICAgICAgLy8gbWFrZSB0aGlzIG1vcmUgZWZmaWNpZW50IGF0IHRoZSBjb3N0IG9mIGFkZGl0aW9uYWwgbWVtb3J5IGFuZFxuICAgICAgICAvLyB3cml0ZSBvdmVyaGVhZC4gSG93ZXZlciB0aGlzIGNvZGUgb25seSBydW5zIG9uY2UgcGVyIHJlcXVlc3Qgc29cbiAgICAgICAgLy8gZm9yIG5vdyBJIGNvbnNpZGVyIHRoaXMgc3VmZmljaWVudC5cbiAgICAgICAgdmFyIHF1ZXVlSXRlciA9IHJlbmRlclN0YXRlLnN0eWxlcy52YWx1ZXMoKTtcblxuICAgICAgICBvdXRlcjogZm9yICh2YXIgcXVldWVTdGVwID0gcXVldWVJdGVyLm5leHQoKTsgaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSA+IDAgJiYgIXF1ZXVlU3RlcC5kb25lOyBxdWV1ZVN0ZXAgPSBxdWV1ZUl0ZXIubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIHNoZWV0cyA9IHF1ZXVlU3RlcC52YWx1ZS5zaGVldHM7XG4gICAgICAgICAgdmFyIHNoZWV0SXRlciA9IHNoZWV0cy52YWx1ZXMoKTtcblxuICAgICAgICAgIGZvciAodmFyIHNoZWV0U3RlcCA9IHNoZWV0SXRlci5uZXh0KCk7IGhlYWRlcnMucmVtYWluaW5nQ2FwYWNpdHkgPiAwICYmICFzaGVldFN0ZXAuZG9uZTsgc2hlZXRTdGVwID0gc2hlZXRJdGVyLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHNoZWV0ID0gc2hlZXRTdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHByb3BzID0gc2hlZXQucHJvcHM7XG4gICAgICAgICAgICB2YXIga2V5ID0gZ2V0UmVzb3VyY2VLZXkocHJvcHMuaHJlZik7XG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gZ2V0U3R5bGVzaGVldFByZWxvYWRBc0hlYWRlcihzaGVldCk7IC8vIFdlIG11dGF0ZSB0aGUgY2FwYWNpdHkgYi9jIHdlIGRvbid0IHdhbnQgdG8ga2VlcCBjaGVja2luZyBpZiBsYXRlciBoZWFkZXJzIHdpbGwgZml0LlxuICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IGEgcGFydGljdWxhcmx5IGxvbmcgaGVhZGVyIG1pZ2h0IGNsb3NlIG91dCB0aGUgaGVhZGVyIHF1ZXVlIHdoZXJlIGxhdGVyXG4gICAgICAgICAgICAvLyBoZWFkZXJzIGNvdWxkIHN0aWxsIGZpdC4gV2UgY291bGQgaW4gdGhlIGZ1dHVyZSBhbHRlciB0aGUgYmVoYXZpb3IgaGVyZSBiYXNlZCBvbiBwcmVyZW5kZXIgdnMgcmVuZGVyXG4gICAgICAgICAgICAvLyBzaW5jZSBkdXJpbmcgcHJlcmVuZGVyIHdlIGFyZW4ndCBhcyBjb25jZXJuZWQgd2l0aCBwdXJlIHJ1bnRpbWUgcGVyZm9ybWFuY2UuXG5cbiAgICAgICAgICAgIGlmICgoaGVhZGVycy5yZW1haW5pbmdDYXBhY2l0eSAtPSBoZWFkZXIubGVuZ3RoKSA+PSAyKSB7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnJlc2V0cy5zdHlsZVtrZXldID0gUFJFTE9BRF9OT19DUkVEUztcblxuICAgICAgICAgICAgICBpZiAobGlua0hlYWRlcikge1xuICAgICAgICAgICAgICAgIGxpbmtIZWFkZXIgKz0gJywgJztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxpbmtIZWFkZXIgKz0gaGVhZGVyOyAvLyBXZSBhbHJlYWR5IHRyYWNrIHRoYXQgdGhlIHJlc291cmNlIGV4aXN0cyBpbiByZXN1bWFibGVTdGF0ZSBob3dldmVyXG4gICAgICAgICAgICAgIC8vIGlmIHRoZSByZXN1bWFibGVTdGF0ZSByZXNldHMgYmVjYXVzZSB3ZSBwb3N0cG9uZWQgaW4gdGhlIHNoZWxsXG4gICAgICAgICAgICAgIC8vIHdoaWNoIGlzIHdoYXQgaXMgaGFwcGVuaW5nIGluIHRoaXMgYnJhbmNoIGlmIHdlIGFyZSBwcmVyZW5kZXJpbmdcbiAgICAgICAgICAgICAgLy8gdGhlbiB3ZSB3aWxsIGVuZCB1cCByZXNldHRpbmcgdGhlIHJlc3VtYWJsZVN0YXRlLiBXaGVuIGl0IHJlc2V0cyB3ZVxuICAgICAgICAgICAgICAvLyB3YW50IHRvIHJlY29yZCB0aGUgZmFjdCB0aGF0IHRoaXMgc3R5bGVzaGVldCB3YXMgYWxyZWFkeSBwcmVsb2FkZWRcblxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5yZXNldHMuc3R5bGVba2V5XSA9IHR5cGVvZiBwcm9wcy5jcm9zc09yaWdpbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmludGVncml0eSA9PT0gJ3N0cmluZycgPyBbcHJvcHMuY3Jvc3NPcmlnaW4sIHByb3BzLmludGVncml0eV0gOiBQUkVMT0FEX05PX0NSRURTO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW5rSGVhZGVyKSB7XG4gICAgICAgIG9uSGVhZGVycyh7XG4gICAgICAgICAgTGluazogbGlua0hlYWRlclxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIHN0aWxsIGNhbGwgdGhpcyB3aXRoIG5vIGhlYWRlcnMgYmVjYXVzZSBhIHVzZXIgbWF5IGJlIHVzaW5nIGl0IGFzIGEgc2lnbmFsIHRoYXRcbiAgICAgICAgLy8gaXQgUmVhY3Qgd2lsbCBub3QgcHJvdmlkZSBhbnkgaGVhZGVyc1xuICAgICAgICBvbkhlYWRlcnMoe30pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG52YXIgTm90UGVuZGluZ1RyYW5zaXRpb24gPSBOb3RQZW5kaW5nO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2VydmVyX2NvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKTtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbnZhciBSRUFDVF9DQUNIRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY2FjaGUnKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERUQgPSBTeW1ib2wuZm9yKCdyZWFjdC5kZWZhdWx0X3ZhbHVlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpOyAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICAvLyBUT0RPOiBDcmVhdGUgYSBjb252ZW50aW9uIGZvciBuYW1pbmcgY2xpZW50IHJlZmVyZW5jZXMgd2l0aCBkZWJ1ZyBpbmZvLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gICAgY2FzZSBSRUFDVF9DQUNIRV9UWVBFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gJ0NhY2hlJztcbiAgICAgIH1cblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuICAvKipcbiAgICogRmluZGluZyBhIGNvbW1vbiBzdGFjayBmcmFtZSBiZXR3ZWVuIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgY2FuIGJlXG4gICAqIHRyaWNreSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzIGFuZCBsZXZlbHMgb2Ygc3RhY2sgdHJhY2UgdHJ1bmNhdGlvbiBmcm9tXG4gICAqIGRpZmZlcmVudCBKUyBWTXMuIFNvIGluc3RlYWQgd2UnbGwgYXR0ZW1wdCB0byBjb250cm9sIHdoYXQgdGhhdCBjb21tb25cbiAgICogZnJhbWUgc2hvdWxkIGJlIHRocm91Z2ggdGhpcyBvYmplY3QgbWV0aG9kOlxuICAgKiBIYXZpbmcgYm90aCB0aGUgc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBiZSBpbiB0aGUgZnVuY3Rpb24gdW5kZXIgdGhlXG4gICAqIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgcHJvcGVydHksICsgc2V0dGluZyB0aGUgYG5hbWVgIGFuZFxuICAgKiBgZGlzcGxheU5hbWVgIHByb3BlcnRpZXMgb2YgdGhlIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCBhIHN0YWNrXG4gICAqIGZyYW1lIGV4aXN0cyB0aGF0IGhhcyB0aGUgbWV0aG9kIG5hbWUgYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBpblxuICAgKiBpdCBmb3IgYm90aCBjb250cm9sIGFuZCBzYW1wbGUgc3RhY2tzLlxuICAgKi9cblxuXG4gIHZhciBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb250cm9sO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICAgICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICB9IC8vIFRPRE8obHVuYSk6IFRoaXMgd2lsbCBjdXJyZW50bHkgb25seSB0aHJvdyBpZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIFJlYWN0L1JlYWN0RE9NL3Byb3BzLiBXZSBzaG91bGQgcHJvYmFibHkgbWFrZSB0aGlzIHRocm93XG4gICAgICAgICAgLy8gaW4gc2ltcGxlIGNvbXBvbmVudHMgdG9vXG5cblxuICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSBmbigpOyAvLyBJZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50IHJldHVybnMgYSBwcm9taXNlLCBpdCdzIGxpa2VseSBhbiBhc3luY1xuICAgICAgICAgIC8vIGNvbXBvbmVudCwgd2hpY2ggd2UgZG9uJ3QgeWV0IHN1cHBvcnQuIEF0dGFjaCBhIG5vb3AgY2F0Y2ggaGFuZGxlciB0b1xuICAgICAgICAgIC8vIHNpbGVuY2UgdGhlIGVycm9yLlxuICAgICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBjb21wb25lbnQgc3RhY2tzIGZvciBhc3luYyBjbGllbnQgY29tcG9uZW50cz9cblxuICAgICAgICAgIGlmIChtYXliZVByb21pc2UgJiYgdHlwZW9mIG1heWJlUHJvbWlzZS5jYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICB9XG4gIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG4gIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdC5kaXNwbGF5TmFtZSA9ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnO1xuICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsICduYW1lJyk7IC8vIEJlZm9yZSBFUzYsIHRoZSBgbmFtZWAgcHJvcGVydHkgd2FzIG5vdCBjb25maWd1cmFibGUuXG5cbiAgaWYgKG5hbWVQcm9wRGVzY3JpcHRvciAmJiBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgLy8gVjggdXRpbGl6ZXMgYSBmdW5jdGlvbidzIGBuYW1lYCBwcm9wZXJ0eSB3aGVuIGdlbmVyYXRpbmcgYSBzdGFjayB0cmFjZS5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAvLyBDb25maWd1cmFibGUgcHJvcGVydGllcyBjYW4gYmUgdXBkYXRlZCBldmVuIGlmIGl0cyB3cml0YWJsZSBkZXNjcmlwdG9yXG4gICAgLy8gaXMgc2V0IHRvIGBmYWxzZWAuXG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG4gICAgJ25hbWUnLCB7XG4gICAgICB2YWx1ZTogJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCdcbiAgICB9KTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpLFxuICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgY29udHJvbFN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzFdO1xuXG4gICAgaWYgKHNhbXBsZVN0YWNrICYmIGNvbnRyb2xTdGFjaykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IDA7XG4gICAgICB2YXIgYyA9IDA7XG5cbiAgICAgIHdoaWxlIChzIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmICFzYW1wbGVMaW5lc1tzXS5pbmNsdWRlcygnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JykpIHtcbiAgICAgICAgcysrO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoYyA8IGNvbnRyb2xMaW5lcy5sZW5ndGggJiYgIWNvbnRyb2xMaW5lc1tjXS5pbmNsdWRlcygnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JykpIHtcbiAgICAgICAgYysrO1xuICAgICAgfSAvLyBXZSBjb3VsZG4ndCBmaW5kIG91ciBpbnRlbnRpb25hbGx5IGluamVjdGVkIGNvbW1vbiByb290IGZyYW1lLCBhdHRlbXB0XG4gICAgICAvLyB0byBmaW5kIGFub3RoZXIgY29tbW9uIHJvb3QgZnJhbWUgYnkgc2VhcmNoIGZyb20gdGhlIGJvdHRvbSBvZiB0aGVcbiAgICAgIC8vIGNvbnRyb2wgc3RhY2suLi5cblxuXG4gICAgICBpZiAocyA9PT0gc2FtcGxlTGluZXMubGVuZ3RoIHx8IGMgPT09IGNvbnRyb2xMaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICAgIGMtLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZShjdG9yLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGN0b3IsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QkMShDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCQxKHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0O1xuXG57XG4gIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCA9IHt9O1xufVxuXG52YXIgZW1wdHlDb250ZXh0T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eUNvbnRleHRPYmplY3QpO1xufVxuXG5mdW5jdGlvbiBnZXRNYXNrZWRDb250ZXh0KHR5cGUsIHVubWFza2VkQ29udGV4dCkge1xuICB7XG4gICAgdmFyIGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuXG4gICAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICAgIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHQgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICAgIGNvbnRleHRba2V5XSA9IHVubWFza2VkQ29udGV4dFtrZXldO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdVbmtub3duJztcbiAgICAgIGNoZWNrUHJvcFR5cGVzKGNvbnRleHRUeXBlcywgY29udGV4dCwgJ2NvbnRleHQnLCBuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc0NoaWxkQ29udGV4dChpbnN0YW5jZSwgdHlwZSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAge1xuICAgIC8vIFRPRE8gKGJ2YXVnaG4pIFJlcGxhY2UgdGhpcyBiZWhhdmlvciB3aXRoIGFuIGludmFyaWFudCgpIGluIHRoZSBmdXR1cmUuXG4gICAgLy8gSXQgaGFzIG9ubHkgYmVlbiBhZGRlZCBpbiBGaWJlciB0byBtYXRjaCB0aGUgKHVuaW50ZW50aW9uYWwpIGJlaGF2aW9yIGluIFN0YWNrLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdVbmtub3duJztcblxuICAgICAgICBpZiAoIXdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignJXMuY2hpbGRDb250ZXh0VHlwZXMgaXMgc3BlY2lmaWVkIGJ1dCB0aGVyZSBpcyBubyBnZXRDaGlsZENvbnRleHQoKSBtZXRob2QgJyArICdvbiB0aGUgaW5zdGFuY2UuIFlvdSBjYW4gZWl0aGVyIGRlZmluZSBnZXRDaGlsZENvbnRleHQoKSBvbiAlcyBvciByZW1vdmUgJyArICdjaGlsZENvbnRleHRUeXBlcyBmcm9tIGl0LicsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJlbnRDb250ZXh0O1xuICAgIH1cblxuICAgIHZhciBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcblxuICAgIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgICBpZiAoIShjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dFR5cGVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnVW5rbm93bicpICsgXCIuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcXFwiXCIgKyBjb250ZXh0S2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnVW5rbm93bic7XG4gICAgICBjaGVja1Byb3BUeXBlcyhjaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGQgY29udGV4dCcsIG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBhc3NpZ24oe30sIHBhcmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG4gIH1cbn1cblxudmFyIHJlbmRlcmVyU2lnaWw7XG5cbntcbiAgLy8gVXNlIHRoaXMgdG8gZGV0ZWN0IG11bHRpcGxlIHJlbmRlcmVycyB1c2luZyB0aGUgc2FtZSBjb250ZXh0XG4gIHJlbmRlcmVyU2lnaWwgPSB7fTtcbn0gLy8gVXNlZCB0byBzdG9yZSB0aGUgcGFyZW50IHBhdGggb2YgYWxsIGNvbnRleHQgb3ZlcnJpZGVzIGluIGEgc2hhcmVkIGxpbmtlZCBsaXN0LlxuLy8gRm9ybWluZyBhIHJldmVyc2UgdHJlZS5cbi8vIFRoZSBzdHJ1Y3R1cmUgb2YgYSBjb250ZXh0IHNuYXBzaG90IGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZmlsZS5cbi8vIEN1cnJlbnRseSwgaXQncyBpbXBsZW1lbnRlZCBhcyB0cmFja2luZyB0aGUgY3VycmVudCBhY3RpdmUgbm9kZS5cblxuXG52YXIgcm9vdENvbnRleHRTbmFwc2hvdCA9IG51bGw7IC8vIFdlIGFzc3VtZSB0aGF0IHRoaXMgcnVudGltZSBvd25zIHRoZSBcImN1cnJlbnRcIiBmaWVsZCBvbiBhbGwgUmVhY3RDb250ZXh0IGluc3RhbmNlcy5cbi8vIFRoaXMgZ2xvYmFsIChhY3R1YWxseSB0aHJlYWQgbG9jYWwpIHN0YXRlIHJlcHJlc2VudHMgd2hhdCBzdGF0ZSBhbGwgdGhvc2UgXCJjdXJyZW50XCIsXG4vLyBmaWVsZHMgYXJlIGN1cnJlbnRseSBpbi5cblxudmFyIGN1cnJlbnRBY3RpdmVTbmFwc2hvdCA9IG51bGw7XG5cbmZ1bmN0aW9uIHBvcE5vZGUocHJldikge1xuICB7XG4gICAgcHJldi5jb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBwcmV2LnBhcmVudFZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hOb2RlKG5leHQpIHtcbiAge1xuICAgIG5leHQuY29udGV4dC5fY3VycmVudFZhbHVlID0gbmV4dC52YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwcmV2LCBuZXh0KSB7XG4gIGlmIChwcmV2ID09PSBuZXh0KSA7IGVsc2Uge1xuICAgIHBvcE5vZGUocHJldik7XG4gICAgdmFyIHBhcmVudFByZXYgPSBwcmV2LnBhcmVudDtcbiAgICB2YXIgcGFyZW50TmV4dCA9IG5leHQucGFyZW50O1xuXG4gICAgaWYgKHBhcmVudFByZXYgPT09IG51bGwpIHtcbiAgICAgIGlmIChwYXJlbnROZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN0YWNrcyBtdXN0IHJlYWNoIHRoZSByb290IGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXJlbnROZXh0ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN0YWNrcyBtdXN0IHJlYWNoIHRoZSByb290IGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHBhcmVudFByZXYsIHBhcmVudE5leHQpO1xuICAgIH0gLy8gT24gdGhlIHdheSBiYWNrLCB3ZSBwdXNoIHRoZSBuZXcgb25lcyB0aGF0IHdlcmVuJ3QgY29tbW9uLlxuXG5cbiAgICBwdXNoTm9kZShuZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BBbGxQcmV2aW91cyhwcmV2KSB7XG4gIHBvcE5vZGUocHJldik7XG4gIHZhciBwYXJlbnRQcmV2ID0gcHJldi5wYXJlbnQ7XG5cbiAgaWYgKHBhcmVudFByZXYgIT09IG51bGwpIHtcbiAgICBwb3BBbGxQcmV2aW91cyhwYXJlbnRQcmV2KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoQWxsTmV4dChuZXh0KSB7XG4gIHZhciBwYXJlbnROZXh0ID0gbmV4dC5wYXJlbnQ7XG5cbiAgaWYgKHBhcmVudE5leHQgIT09IG51bGwpIHtcbiAgICBwdXNoQWxsTmV4dChwYXJlbnROZXh0KTtcbiAgfVxuXG4gIHB1c2hOb2RlKG5leHQpO1xufVxuXG5mdW5jdGlvbiBwb3BQcmV2aW91c1RvQ29tbW9uTGV2ZWwocHJldiwgbmV4dCkge1xuICBwb3BOb2RlKHByZXYpO1xuICB2YXIgcGFyZW50UHJldiA9IHByZXYucGFyZW50O1xuXG4gIGlmIChwYXJlbnRQcmV2ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGVwdGggbXVzdCBlcXVhbCBhdCBsZWFzdCBhdCB6ZXJvIGJlZm9yZSByZWFjaGluZyB0aGUgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgfVxuXG4gIGlmIChwYXJlbnRQcmV2LmRlcHRoID09PSBuZXh0LmRlcHRoKSB7XG4gICAgLy8gV2UgZm91bmQgdGhlIHNhbWUgbGV2ZWwuIE5vdyB3ZSBqdXN0IG5lZWQgdG8gZmluZCBhIHNoYXJlZCBhbmNlc3Rvci5cbiAgICBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwYXJlbnRQcmV2LCBuZXh0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBtdXN0IHN0aWxsIGJlIGRlZXBlci5cbiAgICBwb3BQcmV2aW91c1RvQ29tbW9uTGV2ZWwocGFyZW50UHJldiwgbmV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wTmV4dFRvQ29tbW9uTGV2ZWwocHJldiwgbmV4dCkge1xuICB2YXIgcGFyZW50TmV4dCA9IG5leHQucGFyZW50O1xuXG4gIGlmIChwYXJlbnROZXh0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGVwdGggbXVzdCBlcXVhbCBhdCBsZWFzdCBhdCB6ZXJvIGJlZm9yZSByZWFjaGluZyB0aGUgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgfVxuXG4gIGlmIChwcmV2LmRlcHRoID09PSBwYXJlbnROZXh0LmRlcHRoKSB7XG4gICAgLy8gV2UgZm91bmQgdGhlIHNhbWUgbGV2ZWwuIE5vdyB3ZSBqdXN0IG5lZWQgdG8gZmluZCBhIHNoYXJlZCBhbmNlc3Rvci5cbiAgICBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwcmV2LCBwYXJlbnROZXh0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBtdXN0IHN0aWxsIGJlIGRlZXBlci5cbiAgICBwb3BOZXh0VG9Db21tb25MZXZlbChwcmV2LCBwYXJlbnROZXh0KTtcbiAgfVxuXG4gIHB1c2hOb2RlKG5leHQpO1xufSAvLyBQZXJmb3JtIGNvbnRleHQgc3dpdGNoaW5nIHRvIHRoZSBuZXcgc25hcHNob3QuXG4vLyBUbyBtYWtlIGl0IGNoZWFwIHRvIHJlYWQgbWFueSBjb250ZXh0cywgd2hpbGUgbm90IHN1c3BlbmRpbmcsIHdlIG1ha2UgdGhlIHN3aXRjaCBlYWdlcmx5IGJ5XG4vLyB1cGRhdGluZyBhbGwgdGhlIGNvbnRleHQncyBjdXJyZW50IHZhbHVlcy4gVGhhdCB3YXkgcmVhZHMsIGFsd2F5cyBqdXN0IHJlYWQgdGhlIGN1cnJlbnQgdmFsdWUuXG4vLyBBdCB0aGUgY29zdCBvZiB1cGRhdGluZyBjb250ZXh0cyBldmVuIGlmIHRoZXkncmUgbmV2ZXIgcmVhZCBieSB0aGlzIHN1YnRyZWUuXG5cblxuZnVuY3Rpb24gc3dpdGNoQ29udGV4dChuZXdTbmFwc2hvdCkge1xuICAvLyBUaGUgYmFzaWMgYWxnb3JpdGhtIHdlIG5lZWQgdG8gZG8gaXMgdG8gcG9wIGJhY2sgYW55IGNvbnRleHRzIHRoYXQgYXJlIG5vIGxvbmdlciBvbiB0aGUgc3RhY2suXG4gIC8vIFdlIGFsc28gbmVlZCB0byB1cGRhdGUgYW55IG5ldyBjb250ZXh0cyB0aGF0IGFyZSBub3cgb24gdGhlIHN0YWNrIHdpdGggdGhlIGRlZXBlc3QgdmFsdWUuXG4gIC8vIFRoZSBlYXNpZXN0IHdheSB0byB1cGRhdGUgbmV3IGNvbnRleHRzIGlzIHRvIGp1c3QgcmVhcHBseSB0aGVtIGluIHJldmVyc2Ugb3JkZXIgZnJvbSB0aGVcbiAgLy8gcGVyc3BlY3RpdmUgb2YgdGhlIGJhY2twb2ludGVycy4gVG8gYXZvaWQgYWxsb2NhdGluZyBhIGxvdCB3aGVuIHN3aXRjaGluZywgd2UgdXNlIHRoZSBzdGFja1xuICAvLyBmb3IgdGhhdC4gVGhlcmVmb3JlIHRoaXMgYWxnb3JpdGhtIGlzIHJlY3Vyc2l2ZS5cbiAgLy8gMSkgRmlyc3Qgd2UgcG9wIHdoaWNoIGV2ZXIgc25hcHNob3QgdHJlZSB3YXMgZGVlcGVzdC4gUG9wcGluZyBvbGQgY29udGV4dHMgYXMgd2UgZ28uXG4gIC8vIDIpIFRoZW4gd2UgZmluZCB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgZnJvbSB0aGVyZS4gUG9wcGluZyBvbGQgY29udGV4dHMgYXMgd2UgZ28uXG4gIC8vIDMpIFRoZW4gd2UgcmVhcHBseSBuZXcgY29udGV4dHMgb24gdGhlIHdheSBiYWNrIHVwIHRoZSBzdGFjay5cbiAgdmFyIHByZXYgPSBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG4gIHZhciBuZXh0ID0gbmV3U25hcHNob3Q7XG5cbiAgaWYgKHByZXYgIT09IG5leHQpIHtcbiAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IFRoaXMgaGFzIHRvIGJlIG5vbi1udWxsIHNpbmNlIGl0J3Mgbm90IGVxdWFsIHRvIHByZXYuXG4gICAgICBwdXNoQWxsTmV4dChuZXh0KTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgIHBvcEFsbFByZXZpb3VzKHByZXYpO1xuICAgIH0gZWxzZSBpZiAocHJldi5kZXB0aCA9PT0gbmV4dC5kZXB0aCkge1xuICAgICAgcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocHJldiwgbmV4dCk7XG4gICAgfSBlbHNlIGlmIChwcmV2LmRlcHRoID4gbmV4dC5kZXB0aCkge1xuICAgICAgcG9wUHJldmlvdXNUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3BOZXh0VG9Db21tb25MZXZlbChwcmV2LCBuZXh0KTtcbiAgICB9XG5cbiAgICBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBuZXh0O1xuICB9XG59XG5mdW5jdGlvbiBwdXNoUHJvdmlkZXIoY29udGV4dCwgbmV4dFZhbHVlKSB7XG4gIHZhciBwcmV2VmFsdWU7XG5cbiAge1xuICAgIHByZXZWYWx1ZSA9IGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBuZXh0VmFsdWU7XG5cbiAgICB7XG4gICAgICBpZiAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSB1bmRlZmluZWQgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSBudWxsICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gcmVuZGVyZXJTaWdpbCkge1xuICAgICAgICBlcnJvcignRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlICcgKyAnc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJldk5vZGUgPSBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG4gIHZhciBuZXdOb2RlID0ge1xuICAgIHBhcmVudDogcHJldk5vZGUsXG4gICAgZGVwdGg6IHByZXZOb2RlID09PSBudWxsID8gMCA6IHByZXZOb2RlLmRlcHRoICsgMSxcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIHBhcmVudFZhbHVlOiBwcmV2VmFsdWUsXG4gICAgdmFsdWU6IG5leHRWYWx1ZVxuICB9O1xuICBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBuZXdOb2RlO1xuICByZXR1cm4gbmV3Tm9kZTtcbn1cbmZ1bmN0aW9uIHBvcFByb3ZpZGVyKGNvbnRleHQpIHtcbiAgdmFyIHByZXZTbmFwc2hvdCA9IGN1cnJlbnRBY3RpdmVTbmFwc2hvdDtcblxuICBpZiAocHJldlNuYXBzaG90ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmllZCB0byBwb3AgYSBDb250ZXh0IGF0IHRoZSByb290IG9mIHRoZSBhcHAuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICB7XG4gICAgaWYgKHByZXZTbmFwc2hvdC5jb250ZXh0ICE9PSBjb250ZXh0KSB7XG4gICAgICBlcnJvcignVGhlIHBhcmVudCBjb250ZXh0IGlzIG5vdCB0aGUgZXhwZWN0ZWQgY29udGV4dC4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgdmFyIHZhbHVlID0gcHJldlNuYXBzaG90LnBhcmVudFZhbHVlO1xuXG4gICAgaWYgKHZhbHVlID09PSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERUQpIHtcbiAgICAgIHByZXZTbmFwc2hvdC5jb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBwcmV2U25hcHNob3QuY29udGV4dC5fZGVmYXVsdFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2U25hcHNob3QuY29udGV4dC5fY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gbnVsbCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IHJlbmRlcmVyU2lnaWwpIHtcbiAgICAgICAgZXJyb3IoJ0RldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSAnICsgJ3NhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IHJlbmRlcmVyU2lnaWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRBY3RpdmVTbmFwc2hvdCA9IHByZXZTbmFwc2hvdC5wYXJlbnQ7XG59XG5mdW5jdGlvbiBnZXRBY3RpdmVDb250ZXh0KCkge1xuICByZXR1cm4gY3VycmVudEFjdGl2ZVNuYXBzaG90O1xufVxuZnVuY3Rpb24gcmVhZENvbnRleHQkMShjb250ZXh0KSB7XG4gIHZhciB2YWx1ZSA9IGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBgUmVhY3RJbnN0YW5jZU1hcGAgbWFpbnRhaW5zIGEgbWFwcGluZyBmcm9tIGEgcHVibGljIGZhY2luZyBzdGF0ZWZ1bFxuICogaW5zdGFuY2UgKGtleSkgYW5kIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiAodmFsdWUpLiBUaGlzIGFsbG93cyBwdWJsaWNcbiAqIG1ldGhvZHMgdG8gYWNjZXB0IHRoZSB1c2VyIGZhY2luZyBpbnN0YW5jZSBhcyBhbiBhcmd1bWVudCBhbmQgbWFwIHRoZW0gYmFja1xuICogdG8gaW50ZXJuYWwgbWV0aG9kcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBtb2R1bGUgaXMgY3VycmVudGx5IHNoYXJlZCBhbmQgYXNzdW1lZCB0byBiZSBzdGF0ZWxlc3MuXG4gKiBJZiB0aGlzIGJlY29tZXMgYW4gYWN0dWFsIE1hcCwgdGhhdCB3aWxsIGJyZWFrLlxuICovXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxzO1xufVxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAga2V5Ll9yZWFjdEludGVybmFscyA9IHZhbHVlO1xufVxuXG52YXIgZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudCA9IHt9O1xudmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlO1xudmFyIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlO1xudmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzO1xudmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZTtcbnZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2s7XG5cbntcbiAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjayA9IG5ldyBTZXQoKTtcbn1cblxuZnVuY3Rpb24gd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IGNhbGxlck5hbWUgKyAnXycgKyBjYWxsYmFjaztcblxuICAgIGlmICghZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmhhcyhrZXkpKSB7XG4gICAgICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSk7XG5cbiAgICAgIGVycm9yKCclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUodHlwZSwgcGFydGlhbFN0YXRlKSB7XG4gIHtcbiAgICBpZiAocGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoX2NvbnN0cnVjdG9yKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgJy4nICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXJyb3IoJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG91dHNpZGUgY29tcG9uZW50V2lsbE1vdW50KCkgb24gdGhlIHNlcnZlci4gJyArICdUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cblxudmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlciA9IHtcbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBpbnRlcm5hbHMgPSBnZXQoaW5zdCk7XG5cbiAgICBpZiAoaW50ZXJuYWxzLnF1ZXVlID09PSBudWxsKSB7XG4gICAgICB3YXJuTm9vcChpbnN0LCAnc2V0U3RhdGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJuYWxzLnF1ZXVlLnB1c2gocGF5bG9hZCk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaW50ZXJuYWxzID0gZ2V0KGluc3QpO1xuICAgIGludGVybmFscy5yZXBsYWNlID0gdHJ1ZTtcbiAgICBpbnRlcm5hbHMucXVldWUgPSBbcGF5bG9hZF07XG5cbiAgICB7XG4gICAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChpbnN0LCBjYWxsYmFjaykge1xuICAgIHZhciBpbnRlcm5hbHMgPSBnZXQoaW5zdCk7XG5cbiAgICBpZiAoaW50ZXJuYWxzLnF1ZXVlID09PSBudWxsKSB7XG4gICAgICB3YXJuTm9vcChpbnN0LCAnZm9yY2VVcGRhdGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKGluc3RhbmNlLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIHByZXZTdGF0ZSwgbmV4dFByb3BzKSB7XG4gIHZhciBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuXG4gIHtcbiAgICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUoY3RvciwgcGFydGlhbFN0YXRlKTtcbiAgfSAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuXG5cbiAgdmFyIG5ld1N0YXRlID0gcGFydGlhbFN0YXRlID09PSBudWxsIHx8IHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkID8gcHJldlN0YXRlIDogYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0Q2xhc3NJbnN0YW5jZShjdG9yLCBwcm9wcywgbWFza2VkTGVnYWN5Q29udGV4dCkge1xuICB2YXIgY29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuICB7XG4gICAgaWYgKCdjb250ZXh0VHlwZScgaW4gY3Rvcikge1xuICAgICAgdmFyIGlzVmFsaWQgPSAvLyBBbGxvdyBudWxsIGZvciBjb25kaXRpb25hbCBkZWNsYXJhdGlvblxuICAgICAgY29udGV4dFR5cGUgPT09IG51bGwgfHwgY29udGV4dFR5cGUgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFICYmIGNvbnRleHRUeXBlLl9jb250ZXh0ID09PSB1bmRlZmluZWQ7IC8vIE5vdCBhIDxDb250ZXh0LkNvbnN1bWVyPlxuXG4gICAgICBpZiAoIWlzVmFsaWQgJiYgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZChjdG9yKTtcbiAgICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG5cbiAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gJyArICdUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiAnICsgJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcgKyAndHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHRUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSAnICsgdHlwZW9mIGNvbnRleHRUeXBlICsgJy4nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuUHJvdmlkZXIgaW5zdGVhZD8nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLl9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyA8Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY29udGV4dFR5cGUpLmpvaW4oJywgJykgKyAnfS4nO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3IoJyVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gJyArICdjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lcycsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JywgYWRkZW5kdW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgY29udGV4dCA9IHJlYWRDb250ZXh0JDEoY29udGV4dFR5cGUpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQgPSBtYXNrZWRMZWdhY3lDb250ZXh0O1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nICYmIChpbnN0YW5jZS5zdGF0ZSA9PT0gbnVsbCB8fCBpbnN0YW5jZS5zdGF0ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCdgJXNgIHVzZXMgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYnV0IGl0cyBpbml0aWFsIHN0YXRlIGlzICcgKyAnJXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkLiBJbnN0ZWFkLCBkZWZpbmUgdGhlIGluaXRpYWwgc3RhdGUgYnkgJyArICdhc3NpZ25pbmcgYW4gb2JqZWN0IHRvIGB0aGlzLnN0YXRlYCBpbiB0aGUgY29uc3RydWN0b3Igb2YgYCVzYC4gJyArICdUaGlzIGVuc3VyZXMgdGhhdCBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBhcmd1bWVudHMgaGF2ZSBhIGNvbnNpc3RlbnQgc2hhcGUuJywgY29tcG9uZW50TmFtZSwgaW5zdGFuY2Uuc3RhdGUgPT09IG51bGwgPyAnbnVsbCcgOiAndW5kZWZpbmVkJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfSAvLyBJZiBuZXcgY29tcG9uZW50IEFQSXMgYXJlIGRlZmluZWQsIFwidW5zYWZlXCIgbGlmZWN5Y2xlcyB3b24ndCBiZSBjYWxsZWQuXG4gICAgLy8gV2FybiBhYm91dCB0aGVzZSBsaWZlY3ljbGVzIGlmIHRoZXkgYXJlIHByZXNlbnQuXG4gICAgLy8gRG9uJ3Qgd2FybiBhYm91dCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIG1ldGhvZHMgdGhvdWdoLlxuXG5cbiAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGZvdW5kV2lsbE1vdW50TmFtZSA9IG51bGw7XG4gICAgICB2YXIgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9IG51bGw7XG4gICAgICB2YXIgZm91bmRXaWxsVXBkYXRlTmFtZSA9IG51bGw7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdjb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJztcbiAgICAgIH1cblxuICAgICAgaWYgKGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsIHx8IGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICAgIHZhciBuZXdBcGlOYW1lID0gdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nID8gJ2dldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpJyA6ICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpJztcblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuaGFzKF9jb21wb25lbnROYW1lKSkge1xuICAgICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuYWRkKF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICAgIGVycm9yKCdVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4nICsgJyVzIHVzZXMgJXMgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczolcyVzJXNcXG5cXG4nICsgJ1RoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbicgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcycsIF9jb21wb25lbnROYW1lLCBuZXdBcGlOYW1lLCBmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxNb3VudE5hbWUgOiAnJywgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgOiAnJywgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQ2xhc3NJbnN0YW5jZShpbnN0YW5jZSwgY3RvciwgbmV3UHJvcHMpIHtcbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuXG4gICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgdHlwZW9mIGN0b3IucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj8nLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlICYmICFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiYgIWluc3RhbmNlLnN0YXRlKSB7XG4gICAgICBlcnJvcignZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgJiYgIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wVHlwZXMpIHtcbiAgICAgIGVycm9yKCdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuY29udGV4dFR5cGUpIHtcbiAgICAgIGVycm9yKCdjb250ZXh0VHlwZSB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlcykge1xuICAgICAgICBlcnJvcignY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdG9yLmNvbnRleHRUeXBlICYmIGN0b3IuY29udGV4dFR5cGVzICYmICFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcy5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuYWRkKGN0b3IpO1xuXG4gICAgICAgIGVycm9yKCclcyBkZWNsYXJlcyBib3RoIGNvbnRleHRUeXBlcyBhbmQgY29udGV4dFR5cGUgc3RhdGljIHByb3BlcnRpZXMuICcgKyAnVGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmIHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdBIHB1cmUgY29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRSZWNlaXZlUHJvcHMoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgJyArICd1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciAnICsgJ3J1biBzaWRlLWVmZmVjdHMgb3IgbXV0YXRpb25zIGFmdGVyIFJlYWN0IGhhcyB1cGRhdGVkIHRoZSBVSSwgdXNlIGNvbXBvbmVudERpZFVwZGF0ZSgpLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IG5ld1Byb3BzO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSB1bmRlZmluZWQgJiYgaGFzTXV0YXRlZFByb3BzKSB7XG4gICAgICBlcnJvcignJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGVycm9yKCdTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuJyArICcgSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy4nLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgIT09ICdmdW5jdGlvbicgJiYgIWRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5oYXMoY3RvcikpIHtcbiAgICAgIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5hZGQoY3Rvcik7XG5cbiAgICAgIGVycm9yKCclczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBzaG91bGQgYmUgdXNlZCB3aXRoIGNvbXBvbmVudERpZFVwZGF0ZSgpLiAnICsgJ1RoaXMgY29tcG9uZW50IGRlZmluZXMgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBvbmx5LicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgICBpZiAoc3RhdGUgJiYgKHR5cGVvZiBzdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheShzdGF0ZSkpKSB7XG4gICAgICBlcnJvcignJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGN0b3IuY2hpbGRDb250ZXh0VHlwZXMgIT09ICdvYmplY3QnKSB7XG4gICAgICBlcnJvcignJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBuYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxNb3VudCh0eXBlLCBpbnN0YW5jZSkge1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIGlmIChpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybiggLy8ga2VlcCB0aGlzIHdhcm5pbmcgaW4gc3luYyB3aXRoIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmcuanNcbiAgICAgICAgICAnY29tcG9uZW50V2lsbE1vdW50IGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBjb2RlIGZyb20gY29tcG9uZW50V2lsbE1vdW50IHRvIGNvbXBvbmVudERpZE1vdW50IChwcmVmZXJyZWQgaW4gbW9zdCBjYXNlcykgJyArICdvciB0aGUgY29uc3RydWN0b3IuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cblxuICBpZiAob2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyAnICsgXCJkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ0NvbXBvbmVudCcpO1xuICAgIH1cblxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGludGVybmFsSW5zdGFuY2UsIGluc3QsIHByb3BzLCBtYXNrZWRMZWdhY3lDb250ZXh0KSB7XG4gIGlmIChpbnRlcm5hbEluc3RhbmNlLnF1ZXVlICE9PSBudWxsICYmIGludGVybmFsSW5zdGFuY2UucXVldWUubGVuZ3RoID4gMCkge1xuICAgIHZhciBvbGRRdWV1ZSA9IGludGVybmFsSW5zdGFuY2UucXVldWU7XG4gICAgdmFyIG9sZFJlcGxhY2UgPSBpbnRlcm5hbEluc3RhbmNlLnJlcGxhY2U7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSA9IG51bGw7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5yZXBsYWNlID0gZmFsc2U7XG5cbiAgICBpZiAob2xkUmVwbGFjZSAmJiBvbGRRdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGluc3Quc3RhdGUgPSBvbGRRdWV1ZVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRTdGF0ZSA9IG9sZFJlcGxhY2UgPyBvbGRRdWV1ZVswXSA6IGluc3Quc3RhdGU7XG4gICAgICB2YXIgZG9udE11dGF0ZSA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSBvbGRSZXBsYWNlID8gMSA6IDA7IGkgPCBvbGRRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFydGlhbCA9IG9sZFF1ZXVlW2ldO1xuICAgICAgICB2YXIgcGFydGlhbFN0YXRlID0gdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgPyBwYXJ0aWFsLmNhbGwoaW5zdCwgbmV4dFN0YXRlLCBwcm9wcywgbWFza2VkTGVnYWN5Q29udGV4dCkgOiBwYXJ0aWFsO1xuXG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChkb250TXV0YXRlKSB7XG4gICAgICAgICAgICBkb250TXV0YXRlID0gZmFsc2U7XG4gICAgICAgICAgICBuZXh0U3RhdGUgPSBhc3NpZ24oe30sIG5leHRTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXNzaWduKG5leHRTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSA9IG51bGw7XG4gIH1cbn0gLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuXG5cbmZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZShpbnN0YW5jZSwgY3RvciwgbmV3UHJvcHMsIG1hc2tlZExlZ2FjeUNvbnRleHQpIHtcbiAge1xuICAgIGNoZWNrQ2xhc3NJbnN0YW5jZShpbnN0YW5jZSwgY3RvciwgbmV3UHJvcHMpO1xuICB9XG5cbiAgdmFyIGluaXRpYWxTdGF0ZSA9IGluc3RhbmNlLnN0YXRlICE9PSB1bmRlZmluZWQgPyBpbnN0YW5jZS5zdGF0ZSA6IG51bGw7XG4gIGluc3RhbmNlLnVwZGF0ZXIgPSBjbGFzc0NvbXBvbmVudFVwZGF0ZXI7XG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gaW5pdGlhbFN0YXRlOyAvLyBXZSBkb24ndCBib3RoZXIgaW5pdGlhbGl6aW5nIHRoZSByZWZzIG9iamVjdCBvbiB0aGUgc2VydmVyLCBzaW5jZSB3ZSdyZSBub3QgZ29pbmcgdG8gcmVzb2x2ZSB0aGVtIGFueXdheS5cbiAgLy8gVGhlIGludGVybmFsIGluc3RhbmNlIHdpbGwgYmUgdXNlZCB0byBtYW5hZ2UgdXBkYXRlcyB0aGF0IGhhcHBlbiBkdXJpbmcgdGhpcyBtb3VudC5cblxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IHtcbiAgICBxdWV1ZTogW10sXG4gICAgcmVwbGFjZTogZmFsc2VcbiAgfTtcbiAgc2V0KGluc3RhbmNlLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSByZWFkQ29udGV4dCQxKGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gbWFza2VkTGVnYWN5Q29udGV4dDtcbiAgfVxuXG4gIHtcbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgPT09IG5ld1Byb3BzKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclczogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGFzc2lnbiBwcm9wcyBkaXJlY3RseSB0byBzdGF0ZSAnICsgXCJiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBcIiArICdJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHByb3BzIGRpcmVjdGx5LicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLnN0YXRlID0gYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMoaW5zdGFuY2UsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgaW5pdGlhbFN0YXRlLCBuZXdQcm9wcyk7XG4gIH0gLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cblxuICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KGN0b3IsIGluc3RhbmNlKTsgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgIC8vIHByb2Nlc3MgdGhlbSBub3cuXG5cbiAgICBwcm9jZXNzVXBkYXRlUXVldWUoaW50ZXJuYWxJbnN0YW5jZSwgaW5zdGFuY2UsIG5ld1Byb3BzLCBtYXNrZWRMZWdhY3lDb250ZXh0KTtcbiAgfVxufVxuXG4vLyBJZHMgYXJlIGJhc2UgMzIgc3RyaW5ncyB3aG9zZSBiaW5hcnkgcmVwcmVzZW50YXRpb24gY29ycmVzcG9uZHMgdG8gdGhlXG4vLyBwb3NpdGlvbiBvZiBhIG5vZGUgaW4gYSB0cmVlLlxuLy8gRXZlcnkgdGltZSB0aGUgdHJlZSBmb3JrcyBpbnRvIG11bHRpcGxlIGNoaWxkcmVuLCB3ZSBhZGQgYWRkaXRpb25hbCBiaXRzIHRvXG4vLyB0aGUgbGVmdCBvZiB0aGUgc2VxdWVuY2UgdGhhdCByZXByZXNlbnQgdGhlIHBvc2l0aW9uIG9mIHRoZSBjaGlsZCB3aXRoaW4gdGhlXG4vLyBjdXJyZW50IGxldmVsIG9mIGNoaWxkcmVuLlxuLy9cbi8vICAgICAgMDAxMDEgICAgICAgMDAwMTAwMDEwMTEwMTAxMDFcbi8vICAgICAg4pWw4pSA4pSs4pSA4pWvICAgICAgIOKVsOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKVr1xuLy8gICBGb3JrIDUgb2YgMjAgICAgICAgUGFyZW50IGlkXG4vL1xuLy8gVGhlIGxlYWRpbmcgMHMgYXJlIGltcG9ydGFudC4gSW4gdGhlIGFib3ZlIGV4YW1wbGUsIHlvdSBvbmx5IG5lZWQgMyBiaXRzIHRvXG4vLyByZXByZXNlbnQgc2xvdCA1LiBIb3dldmVyLCB5b3UgbmVlZCA1IGJpdHMgdG8gcmVwcmVzZW50IGFsbCB0aGUgZm9ya3MgYXRcbi8vIHRoZSBjdXJyZW50IGxldmVsLCBzbyB3ZSBtdXN0IGFjY291bnQgZm9yIHRoZSBlbXB0eSBiaXRzIGF0IHRoZSBlbmQuXG4vL1xuLy8gRm9yIHRoaXMgc2FtZSByZWFzb24sIHNsb3RzIGFyZSAxLWluZGV4ZWQgaW5zdGVhZCBvZiAwLWluZGV4ZWQuIE90aGVyd2lzZSxcbi8vIHRoZSB6ZXJvdGggaWQgYXQgYSBsZXZlbCB3b3VsZCBiZSBpbmRpc3Rpbmd1aXNoYWJsZSBmcm9tIGl0cyBwYXJlbnQuXG4vL1xuLy8gSWYgYSBub2RlIGhhcyBvbmx5IG9uZSBjaGlsZCwgYW5kIGRvZXMgbm90IG1hdGVyaWFsaXplIGFuIGlkIChpLmUuIGRvZXMgbm90XG4vLyBjb250YWluIGEgdXNlSWQgaG9vayksIHRoZW4gd2UgZG9uJ3QgbmVlZCB0byBhbGxvY2F0ZSBhbnkgc3BhY2UgaW4gdGhlXG4vLyBzZXF1ZW5jZS4gSXQncyB0cmVhdGVkIGFzIGEgdHJhbnNwYXJlbnQgaW5kaXJlY3Rpb24uIEZvciBleGFtcGxlLCB0aGVzZSB0d29cbi8vIHRyZWVzIHByb2R1Y2UgdGhlIHNhbWUgaWRzOlxuLy9cbi8vIDw+ICAgICAgICAgICAgICAgICAgICAgICAgICA8PlxuLy8gICA8SW5kaXJlY3Rpb24+ICAgICAgICAgICAgICAgPEEgLz5cbi8vICAgICA8QSAvPiAgICAgICAgICAgICAgICAgICAgIDxCIC8+XG4vLyAgIDwvSW5kaXJlY3Rpb24+ICAgICAgICAgICAgPC8+XG4vLyAgIDxCIC8+XG4vLyA8Lz5cbi8vXG4vLyBIb3dldmVyLCB3ZSBjYW5ub3Qgc2tpcCBhbnkgbm9kZSB0aGF0IG1hdGVyaWFsaXplcyBhbiBpZC4gT3RoZXJ3aXNlLCBhIHBhcmVudFxuLy8gaWQgdGhhdCBkb2VzIG5vdCBmb3JrIHdvdWxkIGJlIGluZGlzdGluZ3Vpc2hhYmxlIGZyb20gaXRzIGNoaWxkIGlkLiBGb3Jcbi8vIGV4YW1wbGUsIHRoaXMgdHJlZSBkb2VzIG5vdCBmb3JrLCBidXQgdGhlIHBhcmVudCBhbmQgY2hpbGQgbXVzdCBoYXZlXG4vLyBkaWZmZXJlbnQgaWRzLlxuLy9cbi8vIDxQYXJlbnQ+XG4vLyAgIDxDaGlsZCAvPlxuLy8gPC9QYXJlbnQ+XG4vL1xuLy8gVG8gaGFuZGxlIHRoaXMgc2NlbmFyaW8sIGV2ZXJ5IHRpbWUgd2UgbWF0ZXJpYWxpemUgYW4gaWQsIHdlIGFsbG9jYXRlIGFcbi8vIG5ldyBsZXZlbCB3aXRoIGEgc2luZ2xlIHNsb3QuIFlvdSBjYW4gdGhpbmsgb2YgdGhpcyBhcyBhIGZvcmsgd2l0aCBvbmx5IG9uZVxuLy8gcHJvbmcsIG9yIGFuIGFycmF5IG9mIGNoaWxkcmVuIHdpdGggbGVuZ3RoIDEuXG4vL1xuLy8gSXQncyBwb3NzaWJsZSBmb3IgdGhlIHNpemUgb2YgdGhlIHNlcXVlbmNlIHRvIGV4Y2VlZCAzMiBiaXRzLCB0aGUgbWF4XG4vLyBzaXplIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMuIFdoZW4gdGhpcyBoYXBwZW5zLCB3ZSBtYWtlIG1vcmUgcm9vbSBieVxuLy8gY29udmVydGluZyB0aGUgcmlnaHQgcGFydCBvZiB0aGUgaWQgdG8gYSBzdHJpbmcgYW5kIHN0b3JpbmcgaXQgaW4gYW4gb3ZlcmZsb3dcbi8vIHZhcmlhYmxlLiBXZSB1c2UgYSBiYXNlIDMyIHN0cmluZyByZXByZXNlbnRhdGlvbiwgYmVjYXVzZSAzMiBpcyB0aGUgbGFyZ2VzdFxuLy8gcG93ZXIgb2YgMiB0aGF0IGlzIHN1cHBvcnRlZCBieSB0b1N0cmluZygpLiBXZSB3YW50IHRoZSBiYXNlIHRvIGJlIGxhcmdlIHNvXG4vLyB0aGF0IHRoZSByZXN1bHRpbmcgaWRzIGFyZSBjb21wYWN0LCBhbmQgd2Ugd2FudCB0aGUgYmFzZSB0byBiZSBhIHBvd2VyIG9mIDJcbi8vIGJlY2F1c2UgZXZlcnkgbG9nMihiYXNlKSBiaXRzIGNvcnJlc3BvbmRzIHRvIGEgc2luZ2xlIGNoYXJhY3RlciwgaS5lLiBldmVyeVxuLy8gbG9nMigzMikgPSA1IGJpdHMuIFRoYXQgbWVhbnMgd2UgY2FuIGxvcCBiaXRzIG9mZiB0aGUgZW5kIDUgYXQgYSB0aW1lIHdpdGhvdXRcbi8vIGFmZmVjdGluZyB0aGUgZmluYWwgcmVzdWx0LlxudmFyIGVtcHR5VHJlZUNvbnRleHQgPSB7XG4gIGlkOiAxLFxuICBvdmVyZmxvdzogJydcbn07XG5mdW5jdGlvbiBnZXRUcmVlSWQoY29udGV4dCkge1xuICB2YXIgb3ZlcmZsb3cgPSBjb250ZXh0Lm92ZXJmbG93O1xuICB2YXIgaWRXaXRoTGVhZGluZ0JpdCA9IGNvbnRleHQuaWQ7XG4gIHZhciBpZCA9IGlkV2l0aExlYWRpbmdCaXQgJiB+Z2V0TGVhZGluZ0JpdChpZFdpdGhMZWFkaW5nQml0KTtcbiAgcmV0dXJuIGlkLnRvU3RyaW5nKDMyKSArIG92ZXJmbG93O1xufVxuZnVuY3Rpb24gcHVzaFRyZWVDb250ZXh0KGJhc2VDb250ZXh0LCB0b3RhbENoaWxkcmVuLCBpbmRleCkge1xuICB2YXIgYmFzZUlkV2l0aExlYWRpbmdCaXQgPSBiYXNlQ29udGV4dC5pZDtcbiAgdmFyIGJhc2VPdmVyZmxvdyA9IGJhc2VDb250ZXh0Lm92ZXJmbG93OyAvLyBUaGUgbGVmdG1vc3QgMSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZSwgbm9uLWluY2x1c2l2ZS4gSXQncyBub3QgcGFydFxuICAvLyBvZiB0aGUgaWQ7IHdlIHVzZSBpdCB0byBhY2NvdW50IGZvciBsZWFkaW5nIDBzLlxuXG4gIHZhciBiYXNlTGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKGJhc2VJZFdpdGhMZWFkaW5nQml0KSAtIDE7XG4gIHZhciBiYXNlSWQgPSBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmIH4oMSA8PCBiYXNlTGVuZ3RoKTtcbiAgdmFyIHNsb3QgPSBpbmRleCArIDE7XG4gIHZhciBsZW5ndGggPSBnZXRCaXRMZW5ndGgodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoOyAvLyAzMCBpcyB0aGUgbWF4IGxlbmd0aCB3ZSBjYW4gc3RvcmUgd2l0aG91dCBvdmVyZmxvd2luZywgdGFraW5nIGludG9cbiAgLy8gY29uc2lkZXJhdGlvbiB0aGUgbGVhZGluZyAxIHdlIHVzZSB0byBtYXJrIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLlxuXG4gIGlmIChsZW5ndGggPiAzMCkge1xuICAgIC8vIFdlIG92ZXJmbG93ZWQgdGhlIGJpdHdpc2Utc2FmZSByYW5nZS4gRmFsbCBiYWNrIHRvIHNsb3dlciBhbGdvcml0aG0uXG4gICAgLy8gVGhpcyBicmFuY2ggYXNzdW1lcyB0aGUgbGVuZ3RoIG9mIHRoZSBiYXNlIGlkIGlzIGdyZWF0ZXIgdGhhbiA1OyBpdCB3b24ndFxuICAgIC8vIHdvcmsgZm9yIHNtYWxsZXIgaWRzLCBiZWNhdXNlIHlvdSBuZWVkIDUgYml0cyBwZXIgY2hhcmFjdGVyLlxuICAgIC8vXG4gICAgLy8gV2UgZW5jb2RlIHRoZSBpZCBpbiBtdWx0aXBsZSBzdGVwczogZmlyc3QgdGhlIGJhc2UgaWQsIHRoZW4gdGhlXG4gICAgLy8gcmVtYWluaW5nIGRpZ2l0cy5cbiAgICAvL1xuICAgIC8vIEVhY2ggNSBiaXQgc2VxdWVuY2UgY29ycmVzcG9uZHMgdG8gYSBzaW5nbGUgYmFzZSAzMiBjaGFyYWN0ZXIuIFNvIGZvclxuICAgIC8vIGV4YW1wbGUsIGlmIHRoZSBjdXJyZW50IGlkIGlzIDIzIGJpdHMgbG9uZywgd2UgY2FuIGNvbnZlcnQgMjAgb2YgdGhvc2VcbiAgICAvLyBiaXRzIGludG8gYSBzdHJpbmcgb2YgNCBjaGFyYWN0ZXJzLCB3aXRoIDMgYml0cyBsZWZ0IG92ZXIuXG4gICAgLy9cbiAgICAvLyBGaXJzdCBjYWxjdWxhdGUgaG93IG1hbnkgYml0cyBpbiB0aGUgYmFzZSBpZCByZXByZXNlbnQgYSBjb21wbGV0ZVxuICAgIC8vIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMuXG4gICAgdmFyIG51bWJlck9mT3ZlcmZsb3dCaXRzID0gYmFzZUxlbmd0aCAtIGJhc2VMZW5ndGggJSA1OyAvLyBUaGVuIGNyZWF0ZSBhIGJpdG1hc2sgdGhhdCBzZWxlY3RzIG9ubHkgdGhvc2UgYml0cy5cblxuICAgIHZhciBuZXdPdmVyZmxvd0JpdHMgPSAoMSA8PCBudW1iZXJPZk92ZXJmbG93Qml0cykgLSAxOyAvLyBTZWxlY3QgdGhlIGJpdHMsIGFuZCBjb252ZXJ0IHRoZW0gdG8gYSBiYXNlIDMyIHN0cmluZy5cblxuICAgIHZhciBuZXdPdmVyZmxvdyA9IChiYXNlSWQgJiBuZXdPdmVyZmxvd0JpdHMpLnRvU3RyaW5nKDMyKTsgLy8gTm93IHdlIGNhbiByZW1vdmUgdGhvc2UgYml0cyBmcm9tIHRoZSBiYXNlIGlkLlxuXG4gICAgdmFyIHJlc3RPZkJhc2VJZCA9IGJhc2VJZCA+PiBudW1iZXJPZk92ZXJmbG93Qml0cztcbiAgICB2YXIgcmVzdE9mQmFzZUxlbmd0aCA9IGJhc2VMZW5ndGggLSBudW1iZXJPZk92ZXJmbG93Qml0czsgLy8gRmluYWxseSwgZW5jb2RlIHRoZSByZXN0IG9mIHRoZSBiaXRzIHVzaW5nIHRoZSBub3JtYWwgYWxnb3JpdGhtLiBCZWNhdXNlXG4gICAgLy8gd2UgbWFkZSBtb3JlIHJvb20sIHRoaXMgdGltZSBpdCB3b24ndCBvdmVyZmxvdy5cblxuICAgIHZhciByZXN0T2ZMZW5ndGggPSBnZXRCaXRMZW5ndGgodG90YWxDaGlsZHJlbikgKyByZXN0T2ZCYXNlTGVuZ3RoO1xuICAgIHZhciByZXN0T2ZOZXdCaXRzID0gc2xvdCA8PCByZXN0T2ZCYXNlTGVuZ3RoO1xuICAgIHZhciBpZCA9IHJlc3RPZk5ld0JpdHMgfCByZXN0T2ZCYXNlSWQ7XG4gICAgdmFyIG92ZXJmbG93ID0gbmV3T3ZlcmZsb3cgKyBiYXNlT3ZlcmZsb3c7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiAxIDw8IHJlc3RPZkxlbmd0aCB8IGlkLFxuICAgICAgb3ZlcmZsb3c6IG92ZXJmbG93XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBOb3JtYWwgcGF0aFxuICAgIHZhciBuZXdCaXRzID0gc2xvdCA8PCBiYXNlTGVuZ3RoO1xuXG4gICAgdmFyIF9pZCA9IG5ld0JpdHMgfCBiYXNlSWQ7XG5cbiAgICB2YXIgX292ZXJmbG93ID0gYmFzZU92ZXJmbG93O1xuICAgIHJldHVybiB7XG4gICAgICBpZDogMSA8PCBsZW5ndGggfCBfaWQsXG4gICAgICBvdmVyZmxvdzogX292ZXJmbG93XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaXRMZW5ndGgobnVtYmVyKSB7XG4gIHJldHVybiAzMiAtIGNsejMyKG51bWJlcik7XG59XG5cbmZ1bmN0aW9uIGdldExlYWRpbmdCaXQoaWQpIHtcbiAgcmV0dXJuIDEgPDwgZ2V0Qml0TGVuZ3RoKGlkKSAtIDE7XG59IC8vIFRPRE86IE1hdGguY2x6MzIgaXMgc3VwcG9ydGVkIGluIE5vZGUgMTIrLiBNYXliZSB3ZSBjYW4gZHJvcCB0aGUgZmFsbGJhY2suXG5cblxudmFyIGNsejMyID0gTWF0aC5jbHozMiA/IE1hdGguY2x6MzIgOiBjbHozMkZhbGxiYWNrOyAvLyBDb3VudCBsZWFkaW5nIHplcm9zLlxuLy8gQmFzZWQgb246XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2NsejMyXG5cbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBMTjIgPSBNYXRoLkxOMjtcblxuZnVuY3Rpb24gY2x6MzJGYWxsYmFjayh4KSB7XG4gIHZhciBhc1VpbnQgPSB4ID4+PiAwO1xuXG4gIGlmIChhc1VpbnQgPT09IDApIHtcbiAgICByZXR1cm4gMzI7XG4gIH1cblxuICByZXR1cm4gMzEgLSAobG9nKGFzVWludCkgLyBMTjIgfCAwKSB8IDA7XG59XG5cbi8vIENvcnJlc3BvbmRzIHRvIFJlYWN0RmliZXJXYWtlYWJsZSBhbmQgUmVhY3RGbGlnaHRXYWtlYWJsZSBtb2R1bGVzLiBHZW5lcmFsbHksXG4vLyBjaGFuZ2VzIHRvIG9uZSBtb2R1bGUgc2hvdWxkIGJlIHJlZmxlY3RlZCBpbiB0aGUgb3RoZXJzLlxuLy8gVE9ETzogUmVuYW1lIHRoaXMgbW9kdWxlIGFuZCB0aGUgY29ycmVzcG9uZGluZyBGaWJlciBvbmUgdG8gXCJUaGVuYWJsZVwiXG4vLyBpbnN0ZWFkIG9mIFwiV2FrZWFibGVcIi4gT3Igc29tZSBvdGhlciBtb3JlIGFwcHJvcHJpYXRlIG5hbWUuXG4vLyBBbiBlcnJvciB0aGF0IGlzIHRocm93biAoZS5nLiBieSBgdXNlYCkgdG8gdHJpZ2dlciBTdXNwZW5zZS4gSWYgd2Vcbi8vIGRldGVjdCB0aGlzIGlzIGNhdWdodCBieSB1c2Vyc3BhY2UsIHdlJ2xsIGxvZyBhIHdhcm5pbmcgaW4gZGV2ZWxvcG1lbnQuXG52YXIgU3VzcGVuc2VFeGNlcHRpb24gPSBuZXcgRXJyb3IoXCJTdXNwZW5zZSBFeGNlcHRpb246IFRoaXMgaXMgbm90IGEgcmVhbCBlcnJvciEgSXQncyBhbiBpbXBsZW1lbnRhdGlvbiBcIiArICdkZXRhaWwgb2YgYHVzZWAgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IHJlbmRlci4gWW91IG11c3QgZWl0aGVyICcgKyAncmV0aHJvdyBpdCBpbW1lZGlhdGVseSwgb3IgbW92ZSB0aGUgYHVzZWAgY2FsbCBvdXRzaWRlIG9mIHRoZSAnICsgJ2B0cnkvY2F0Y2hgIGJsb2NrLiBDYXB0dXJpbmcgd2l0aG91dCByZXRocm93aW5nIHdpbGwgbGVhZCB0byAnICsgJ3VuZXhwZWN0ZWQgYmVoYXZpb3IuXFxuXFxuJyArICdUbyBoYW5kbGUgYXN5bmMgZXJyb3JzLCB3cmFwIHlvdXIgY29tcG9uZW50IGluIGFuIGVycm9yIGJvdW5kYXJ5LCBvciAnICsgXCJjYWxsIHRoZSBwcm9taXNlJ3MgYC5jYXRjaGAgbWV0aG9kIGFuZCBwYXNzIHRoZSByZXN1bHQgdG8gYHVzZWBcIik7XG5mdW5jdGlvbiBjcmVhdGVUaGVuYWJsZVN0YXRlKCkge1xuICAvLyBUaGUgVGhlbmFibGVTdGF0ZSBpcyBjcmVhdGVkIHRoZSBmaXJzdCB0aW1lIGEgY29tcG9uZW50IHN1c3BlbmRzLiBJZiBpdFxuICAvLyBzdXNwZW5kcyBhZ2Fpbiwgd2UnbGwgcmV1c2UgdGhlIHNhbWUgc3RhdGUuXG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gbm9vcCQyKCkge31cblxuZnVuY3Rpb24gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KSB7XG4gIHZhciBwcmV2aW91cyA9IHRoZW5hYmxlU3RhdGVbaW5kZXhdO1xuXG4gIGlmIChwcmV2aW91cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhlbmFibGVTdGF0ZS5wdXNoKHRoZW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJldmlvdXMgIT09IHRoZW5hYmxlKSB7XG4gICAgICAvLyBSZXVzZSB0aGUgcHJldmlvdXMgdGhlbmFibGUsIGFuZCBkcm9wIHRoZSBuZXcgb25lLiBXZSBjYW4gYXNzdW1lXG4gICAgICAvLyB0aGV5IHJlcHJlc2VudCB0aGUgc2FtZSB2YWx1ZSwgYmVjYXVzZSBjb21wb25lbnRzIGFyZSBpZGVtcG90ZW50LlxuICAgICAgLy8gQXZvaWQgYW4gdW5oYW5kbGVkIHJlamVjdGlvbiBlcnJvcnMgZm9yIHRoZSBQcm9taXNlcyB0aGF0IHdlJ2xsXG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGlnbm9yZS5cbiAgICAgIHRoZW5hYmxlLnRoZW4obm9vcCQyLCBub29wJDIpO1xuICAgICAgdGhlbmFibGUgPSBwcmV2aW91cztcbiAgICB9XG4gIH0gLy8gV2UgdXNlIGFuIGV4cGFuZG8gdG8gdHJhY2sgdGhlIHN0YXR1cyBhbmQgcmVzdWx0IG9mIGEgdGhlbmFibGUgc28gdGhhdCB3ZVxuICAvLyBjYW4gc3luY2hyb25vdXNseSB1bndyYXAgdGhlIHZhbHVlLiBUaGluayBvZiB0aGlzIGFzIGFuIGV4dGVuc2lvbiBvZiB0aGVcbiAgLy8gUHJvbWlzZSBBUEksIG9yIGEgY3VzdG9tIGludGVyZmFjZSB0aGF0IGlzIGEgc3VwZXJzZXQgb2YgVGhlbmFibGUuXG4gIC8vXG4gIC8vIElmIHRoZSB0aGVuYWJsZSBkb2Vzbid0IGhhdmUgYSBzdGF0dXMsIHNldCBpdCB0byBcInBlbmRpbmdcIiBhbmQgYXR0YWNoXG4gIC8vIGEgbGlzdGVuZXIgdGhhdCB3aWxsIHVwZGF0ZSBpdHMgc3RhdHVzIGFuZCByZXN1bHQgd2hlbiBpdCByZXNvbHZlcy5cblxuXG4gIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgY2FzZSAnZnVsZmlsbGVkJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZ1bGZpbGxlZFZhbHVlID0gdGhlbmFibGUudmFsdWU7XG4gICAgICAgIHJldHVybiBmdWxmaWxsZWRWYWx1ZTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHJlamVjdGVkRXJyb3IgPSB0aGVuYWJsZS5yZWFzb247XG4gICAgICAgIHRocm93IHJlamVjdGVkRXJyb3I7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIHRoZW5hYmxlLnN0YXR1cyA9PT0gJ3N0cmluZycpIDsgZWxzZSB7XG4gICAgICAgICAgdmFyIHBlbmRpbmdUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgIHBlbmRpbmdUaGVuYWJsZS5zdGF0dXMgPSAncGVuZGluZyc7XG4gICAgICAgICAgcGVuZGluZ1RoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKGZ1bGZpbGxlZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhlbmFibGUuc3RhdHVzID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnN0YXR1cyA9ICdmdWxmaWxsZWQnO1xuICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS52YWx1ZSA9IGZ1bGZpbGxlZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHRoZW5hYmxlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUuc3RhdHVzID0gJ3JlamVjdGVkJztcbiAgICAgICAgICAgICAgcmVqZWN0ZWRUaGVuYWJsZS5yZWFzb24gPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTsgLy8gQ2hlY2sgb25lIG1vcmUgdGltZSBpbiBjYXNlIHRoZSB0aGVuYWJsZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG5cbiAgICAgICAgICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSAnZnVsZmlsbGVkJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBmdWxmaWxsZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWRUaGVuYWJsZS52YWx1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICAgIHRocm93IHJlamVjdGVkVGhlbmFibGUucmVhc29uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFN1c3BlbmQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRocm93aW5nIGhlcmUgaXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIHRoYXQgYWxsb3dzIHVzIHRvIHVud2luZCB0aGVcbiAgICAgICAgLy8gY2FsbCBzdGFjay4gQnV0IHdlIHNob3VsZG4ndCBhbGxvdyBpdCB0byBsZWFrIGludG8gdXNlcnNwYWNlLiBUaHJvdyBhblxuICAgICAgICAvLyBvcGFxdWUgcGxhY2Vob2xkZXIgdmFsdWUgaW5zdGVhZCBvZiB0aGUgYWN0dWFsIHRoZW5hYmxlLiBJZiBpdCBkb2Vzbid0XG4gICAgICAgIC8vIGdldCBjYXB0dXJlZCBieSB0aGUgd29yayBsb29wLCBsb2cgYSB3YXJuaW5nLCBiZWNhdXNlIHRoYXQgbWVhbnNcbiAgICAgICAgLy8gc29tZXRoaW5nIGluIHVzZXJzcGFjZSBtdXN0IGhhdmUgY2F1Z2h0IGl0LlxuXG5cbiAgICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgdGhyb3cgU3VzcGVuc2VFeGNlcHRpb247XG4gICAgICB9XG4gIH1cbn0gLy8gVGhpcyBpcyB1c2VkIHRvIHRyYWNrIHRoZSBhY3R1YWwgdGhlbmFibGUgdGhhdCBzdXNwZW5kZWQgc28gaXQgY2FuIGJlXG4vLyBwYXNzZWQgdG8gdGhlIHJlc3Qgb2YgdGhlIFN1c3BlbnNlIGltcGxlbWVudGF0aW9uIOKAlCB3aGljaCwgZm9yIGhpc3RvcmljYWxcbi8vIHJlYXNvbnMsIGV4cGVjdHMgdG8gcmVjZWl2ZSBhIHRoZW5hYmxlLlxuXG52YXIgc3VzcGVuZGVkVGhlbmFibGUgPSBudWxsO1xuZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSB7XG4gIC8vIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIGB1c2VgIHN1c3BlbmRzIGJ5IHRocm93aW5nIGFuIGV4Y2VwdGlvbi4gYHVzZWBcbiAgLy8gdGhyb3dzIGFuIG9wYXF1ZSB2YWx1ZSBpbnN0ZWFkIG9mIHRoZSB0aGVuYWJsZSBpdHNlbGYgc28gdGhhdCBpdCBjYW4ndCBiZVxuICAvLyBjYXVnaHQgaW4gdXNlcnNwYWNlLiBUaGVuIHRoZSB3b3JrIGxvb3AgYWNjZXNzZXMgdGhlIGFjdHVhbCB0aGVuYWJsZSB1c2luZ1xuICAvLyB0aGlzIGZ1bmN0aW9uLlxuICBpZiAoc3VzcGVuZGVkVGhlbmFibGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgc3VzcGVuZGVkIHRoZW5hYmxlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSAnICsgJ2FuIGlzc3VlLicpO1xuICB9XG5cbiAgdmFyIHRoZW5hYmxlID0gc3VzcGVuZGVkVGhlbmFibGU7XG4gIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbiAgcmV0dXJuIHRoZW5hYmxlO1xufVxuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIDtcbn1cblxudmFyIG9iamVjdElzID0gLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxudHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGlzO1xuXG52YXIgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gbnVsbDtcbnZhciBjdXJyZW50bHlSZW5kZXJpbmdUYXNrID0gbnVsbDtcbnZhciBjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0ID0gbnVsbDtcbnZhciBjdXJyZW50bHlSZW5kZXJpbmdLZXlQYXRoID0gbnVsbDtcbnZhciBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG52YXIgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDsgLy8gV2hldGhlciB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rIGlzIGEgcmUtcmVuZGVyZWQgaG9va1xuXG52YXIgaXNSZVJlbmRlciA9IGZhbHNlOyAvLyBXaGV0aGVyIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGR1cmluZyB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyByZW5kZXIgcGFzcy5cblxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTsgLy8gQ291bnRzIHRoZSBudW1iZXIgb2YgdXNlSWQgaG9va3MgaW4gdGhpcyBjb21wb25lbnRcblxudmFyIGxvY2FsSWRDb3VudGVyID0gMDsgLy8gQ2h1bmtzIHRoYXQgc2hvdWxkIGJlIHB1c2hlZCB0byB0aGUgc3RyZWFtIG9uY2UgdGhlIGNvbXBvbmVudFxuLy8gZmluaXNoZXMgcmVuZGVyaW5nLlxuLy8gQ291bnRzIHRoZSBudW1iZXIgb2YgdXNlRm9ybVN0YXRlIGNhbGxzIGluIHRoaXMgY29tcG9uZW50XG5cbnZhciBmb3JtU3RhdGVDb3VudGVyID0gMDsgLy8gVGhlIGluZGV4IG9mIHRoZSB1c2VGb3JtU3RhdGUgaG9vayB0aGF0IG1hdGNoZXMgdGhlIG9uZSBwYXNzZWQgaW4gYXQgdGhlXG4vLyByb290IGR1cmluZyBhbiBNUEEgbmF2aWdhdGlvbiwgaWYgYW55LlxuXG52YXIgZm9ybVN0YXRlTWF0Y2hpbmdJbmRleCA9IC0xOyAvLyBDb3VudHMgdGhlIG51bWJlciBvZiB1c2UodGhlbmFibGUpIGNhbGxzIGluIHRoaXMgY29tcG9uZW50XG5cbnZhciB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG52YXIgdGhlbmFibGVTdGF0ZSA9IG51bGw7IC8vIExhemlseSBjcmVhdGVkIG1hcCBvZiByZW5kZXItcGhhc2UgdXBkYXRlc1xuXG52YXIgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDsgLy8gQ291bnRlciB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlxuXG52YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xudmFyIFJFX1JFTkRFUl9MSU1JVCA9IDI1O1xudmFyIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlOyAvLyBJbiBERVYsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcHJpbWl0aXZlIGhvb2tcblxudmFyIGN1cnJlbnRIb29rTmFtZUluRGV2O1xuXG5mdW5jdGlvbiByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCkge1xuICBpZiAoY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yJyArICcgb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4nICsgJzEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbicgKyAnMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbicgKyAnMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcbicgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uJyk7XG4gIH1cblxuICB7XG4gICAgaWYgKGlzSW5Ib29rVXNlckNvZGVJbkRldikge1xuICAgICAgZXJyb3IoJ0RvIG5vdCBjYWxsIEhvb2tzIGluc2lkZSB1c2VFZmZlY3QoLi4uKSwgdXNlTWVtbyguLi4pLCBvciBvdGhlciBidWlsdC1pbiBIb29rcy4gJyArICdZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQ7XG59XG5cbmZ1bmN0aW9uIGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpIHtcbiAgaWYgKHByZXZEZXBzID09PSBudWxsKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyAnICsgJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJyArICdpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy4nLCBjdXJyZW50SG9va05hbWVJbkRldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcgbGVuZ3RocyBpbiBwcm9kIGJlY2F1c2UgdGhlc2UgYXJyYXlzIHNob3VsZCBiZVxuICAgIC8vIHBhc3NlZCBpbmxpbmUuXG4gICAgaWYgKG5leHREZXBzLmxlbmd0aCAhPT0gcHJldkRlcHMubGVuZ3RoKSB7XG4gICAgICBlcnJvcignVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgJyArICdvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcbicgKyAnUHJldmlvdXM6ICVzXFxuJyArICdJbmNvbWluZzogJXMnLCBjdXJyZW50SG9va05hbWVJbkRldiwgXCJbXCIgKyBuZXh0RGVwcy5qb2luKCcsICcpICsgXCJdXCIsIFwiW1wiICsgcHJldkRlcHMuam9pbignLCAnKSArIFwiXVwiKTtcbiAgICB9XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICBpZiAob2JqZWN0SXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhvb2soKSB7XG4gIGlmIChudW1iZXJPZlJlUmVuZGVycyA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlcicpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIHF1ZXVlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgaG9vayBpbiB0aGUgbGlzdFxuICAgIGlmIChmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgICAgaXNSZVJlbmRlciA9IGZhbHNlO1xuICAgICAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVIb29rKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgICAgaXNSZVJlbmRlciA9IHRydWU7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBmaXJzdFdvcmtJblByb2dyZXNzSG9vaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID09PSBudWxsKSB7XG4gICAgICBpc1JlUmVuZGVyID0gZmFsc2U7IC8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0XG5cbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gY3JlYXRlSG9vaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSB3b3JrLWluLXByb2dyZXNzLiBSZXVzZSBpdC5cbiAgICAgIGlzUmVSZW5kZXIgPSB0cnVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvVXNlSG9va3MocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgY29tcG9uZW50SWRlbnRpdHksIHByZXZUaGVuYWJsZVN0YXRlKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IGNvbXBvbmVudElkZW50aXR5O1xuICBjdXJyZW50bHlSZW5kZXJpbmdUYXNrID0gdGFzaztcbiAgY3VycmVudGx5UmVuZGVyaW5nUmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0tleVBhdGggPSBrZXlQYXRoO1xuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfSAvLyBUaGUgZm9sbG93aW5nIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiByZXNldFxuICAvLyBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIC8vIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgLy8gbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICAvLyByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuICAvLyB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuXG5cbiAgbG9jYWxJZENvdW50ZXIgPSAwO1xuICBmb3JtU3RhdGVDb3VudGVyID0gMDtcbiAgZm9ybVN0YXRlTWF0Y2hpbmdJbmRleCA9IC0xO1xuICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gIHRoZW5hYmxlU3RhdGUgPSBwcmV2VGhlbmFibGVTdGF0ZTtcbn1cbmZ1bmN0aW9uIGZpbmlzaEhvb2tzKENvbXBvbmVudCwgcHJvcHMsIGNoaWxkcmVuLCByZWZPckNvbnRleHQpIHtcbiAgLy8gVGhpcyBtdXN0IGJlIGNhbGxlZCBhZnRlciBldmVyeSBmdW5jdGlvbiBjb21wb25lbnQgdG8gcHJldmVudCBob29rcyBmcm9tXG4gIC8vIGJlaW5nIHVzZWQgaW4gY2xhc3Nlcy5cbiAgd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAvLyBVcGRhdGVzIHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLiBUaGV5IGFyZSBzdG9yZWQgaW5cbiAgICAvLyB0aGUgYHJlbmRlclBoYXNlVXBkYXRlc2AgbWFwLiBDYWxsIHRoZSBjb21wb25lbnQgYWdhaW4sIHJldXNpbmcgdGhlXG4gICAgLy8gd29yay1pbi1wcm9ncmVzcyBob29rcyBhbmQgYXBwbHlpbmcgdGhlIGFkZGl0aW9uYWwgdXBkYXRlcyBvbiB0b3AuIEtlZXBcbiAgICAvLyByZXN0YXJ0aW5nIHVudGlsIG5vIG1vcmUgdXBkYXRlcyBhcmUgc2NoZWR1bGVkLlxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgICBsb2NhbElkQ291bnRlciA9IDA7XG4gICAgZm9ybVN0YXRlQ291bnRlciA9IDA7XG4gICAgZm9ybVN0YXRlTWF0Y2hpbmdJbmRleCA9IC0xO1xuICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxOyAvLyBTdGFydCBvdmVyIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgICBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgcmVmT3JDb250ZXh0KTtcbiAgfVxuXG4gIHJlc2V0SG9va3NTdGF0ZSgpO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5mdW5jdGlvbiBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCkge1xuICB2YXIgc3RhdGUgPSB0aGVuYWJsZVN0YXRlO1xuICB0aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gY2hlY2tEaWRSZW5kZXJJZEhvb2soKSB7XG4gIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBldmVyeSBmaW5pc2hIb29rcyBjYWxsLlxuICAvLyBDb25jZXB0dWFsbHksIGl0J3MgcGFydCBvZiB0aGUgcmV0dXJuIHZhbHVlIG9mIGZpbmlzaEhvb2tzOyBpdCdzIG9ubHkgYVxuICAvLyBzZXBhcmF0ZSBmdW5jdGlvbiB0byBhdm9pZCB1c2luZyBhbiBhcnJheSB0dXBsZS5cbiAgdmFyIGRpZFJlbmRlcklkSG9vayA9IGxvY2FsSWRDb3VudGVyICE9PSAwO1xuICByZXR1cm4gZGlkUmVuZGVySWRIb29rO1xufVxuZnVuY3Rpb24gZ2V0Rm9ybVN0YXRlQ291bnQoKSB7XG4gIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBldmVyeSBmaW5pc2hIb29rcyBjYWxsLlxuICAvLyBDb25jZXB0dWFsbHksIGl0J3MgcGFydCBvZiB0aGUgcmV0dXJuIHZhbHVlIG9mIGZpbmlzaEhvb2tzOyBpdCdzIG9ubHkgYVxuICAvLyBzZXBhcmF0ZSBmdW5jdGlvbiB0byBhdm9pZCB1c2luZyBhbiBhcnJheSB0dXBsZS5cbiAgcmV0dXJuIGZvcm1TdGF0ZUNvdW50ZXI7XG59XG5mdW5jdGlvbiBnZXRGb3JtU3RhdGVNYXRjaGluZ0luZGV4KCkge1xuICAvLyBUaGlzIHNob3VsZCBiZSBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgZXZlcnkgZmluaXNoSG9va3MgY2FsbC5cbiAgLy8gQ29uY2VwdHVhbGx5LCBpdCdzIHBhcnQgb2YgdGhlIHJldHVybiB2YWx1ZSBvZiBmaW5pc2hIb29rczsgaXQncyBvbmx5IGFcbiAgLy8gc2VwYXJhdGUgZnVuY3Rpb24gdG8gYXZvaWQgdXNpbmcgYW4gYXJyYXkgdHVwbGUuXG4gIHJldHVybiBmb3JtU3RhdGVNYXRjaGluZ0luZGV4O1xufSAvLyBSZXNldCB0aGUgaW50ZXJuYWwgaG9va3Mgc3RhdGUgaWYgYW4gZXJyb3Igb2NjdXJzIHdoaWxlIHJlbmRlcmluZyBhIGNvbXBvbmVudFxuXG5mdW5jdGlvbiByZXNldEhvb2tzU3RhdGUoKSB7XG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfVxuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IG51bGw7XG4gIGN1cnJlbnRseVJlbmRlcmluZ1Rhc2sgPSBudWxsO1xuICBjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aCA9IG51bGw7XG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQpIHtcbiAge1xuICAgIGlmIChpc0luSG9va1VzZXJDb2RlSW5EZXYpIHtcbiAgICAgIGVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZENvbnRleHQkMShjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gdXNlQ29udGV4dChjb250ZXh0KSB7XG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgfVxuXG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgcmV0dXJuIHJlYWRDb250ZXh0JDEoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIGJhc2ljU3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXTogRmxvdyBkb2Vzbid0IGxpa2UgbWl4ZWQgdHlwZXNcbiAgcmV0dXJuIHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicgPyBhY3Rpb24oc3RhdGUpIDogYWN0aW9uO1xufVxuXG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAge1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgfVxuXG4gIHJldHVybiB1c2VSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyLCAvLyB1c2VSZWR1Y2VyIGhhcyBhIHNwZWNpYWwgY2FzZSB0byBzdXBwb3J0IGxhenkgdXNlU3RhdGUgaW5pdGlhbGl6ZXJzXG4gIGluaXRpYWxTdGF0ZSk7XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAge1xuICAgIGlmIChyZWR1Y2VyICE9PSBiYXNpY1N0YXRlUmVkdWNlcikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgfVxuICB9XG5cbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuICBpZiAoaXNSZVJlbmRlcikge1xuICAgIC8vIFRoaXMgaXMgYSByZS1yZW5kZXIuIEFwcGx5IHRoZSBuZXcgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG8gdGhlIHByZXZpb3VzXG4gICAgLy8gY3VycmVudCBob29rLlxuICAgIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZTtcbiAgICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcblxuICAgIGlmIChyZW5kZXJQaGFzZVVwZGF0ZXMgIT09IG51bGwpIHtcbiAgICAgIC8vIFJlbmRlciBwaGFzZSB1cGRhdGVzIGFyZSBzdG9yZWQgaW4gYSBtYXAgb2YgcXVldWUgLT4gbGlua2VkIGxpc3RcbiAgICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSk7XG5cbiAgICAgIGlmIChmaXJzdFJlbmRlclBoYXNlVXBkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5kZWxldGUocXVldWUpOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuICAgICAgICB2YXIgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGU7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8vIFByb2Nlc3MgdGhpcyByZW5kZXIgcGhhc2UgdXBkYXRlLiBXZSBkb24ndCBoYXZlIHRvIGNoZWNrIHRoZVxuICAgICAgICAgIC8vIHByaW9yaXR5IGJlY2F1c2UgaXQgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnRcbiAgICAgICAgICAvLyByZW5kZXIncy5cbiAgICAgICAgICB2YXIgYWN0aW9uID0gdXBkYXRlLmFjdGlvbjtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSB3ZSBiYWlsIG91dCB3aGVuIHdlIGdldCBhIG51bGxcblxuXG4gICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCk7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgcmV0dXJuIFtuZXdTdGF0ZSwgZGlzcGF0Y2hdO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgIHJldHVybiBbd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsU3RhdGU7XG5cbiAgICBpZiAocmVkdWNlciA9PT0gYmFzaWNTdGF0ZVJlZHVjZXIpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYHVzZVN0YXRlYC5cbiAgICAgIGluaXRpYWxTdGF0ZSA9IHR5cGVvZiBpbml0aWFsQXJnID09PSAnZnVuY3Rpb24nID8gaW5pdGlhbEFyZygpIDogaW5pdGlhbEFyZztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbFN0YXRlID0gaW5pdCAhPT0gdW5kZWZpbmVkID8gaW5pdChpbml0aWFsQXJnKSA6IGluaXRpYWxBcmc7XG4gICAgfVxuXG4gICAge1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsU3RhdGU7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG4gICAgdmFyIF9xdWV1ZSA9IHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZSA9IHtcbiAgICAgIGxhc3Q6IG51bGwsXG4gICAgICBkaXNwYXRjaDogbnVsbFxuICAgIH07XG5cbiAgICB2YXIgX2Rpc3BhdGNoID0gX3F1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2hBY3Rpb24uYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQsIF9xdWV1ZSk7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBfZGlzcGF0Y2hdO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcblxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuICAgICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IHRydWU7XG4gIH1cblxuICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBwcmV2aW91c1JlZiA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChwcmV2aW91c1JlZiA9PT0gbnVsbCkge1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiBpbml0aWFsVmFsdWVcbiAgICB9O1xuXG4gICAge1xuICAgICAgT2JqZWN0LnNlYWwocmVmKTtcbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IHJlZjtcbiAgICByZXR1cm4gcmVmO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmV2aW91c1JlZjtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihjb21wb25lbnRJZGVudGl0eSwgcXVldWUsIGFjdGlvbikge1xuICBpZiAobnVtYmVyT2ZSZVJlbmRlcnMgPj0gUkVfUkVOREVSX0xJTUlUKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgJyArICdhbiBpbmZpbml0ZSBsb29wLicpO1xuICB9XG5cbiAgaWYgKGNvbXBvbmVudElkZW50aXR5ID09PSBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gU3Rhc2ggaXQgaW4gYSBsYXppbHktY3JlYXRlZCBtYXAgb2ZcbiAgICAvLyBxdWV1ZSAtPiBsaW5rZWQgbGlzdCBvZiB1cGRhdGVzLiBBZnRlciB0aGlzIHJlbmRlciBwYXNzLCB3ZSdsbCByZXN0YXJ0XG4gICAgLy8gYW5kIGFwcGx5IHRoZSBzdGFzaGVkIHVwZGF0ZXMgb24gdG9wIG9mIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IHRydWU7XG4gICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KHF1ZXVlKTtcblxuICAgIGlmIChmaXJzdFJlbmRlclBoYXNlVXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLnNldChxdWV1ZSwgdXBkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgIHZhciBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgICB3aGlsZSAobGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICByZXR1cm4gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9LCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgaWYgKGdldFNlcnZlclNuYXBzaG90ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZ2V0U2VydmVyU25hcHNob3QsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciAnICsgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBXaWxsIHJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLicpO1xuICB9XG5cbiAgcmV0dXJuIGdldFNlcnZlclNuYXBzaG90KCk7XG59XG5cbmZ1bmN0aW9uIHVzZURlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG5cbiAge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN1cHBvcnRlZFN0YXJ0VHJhbnNpdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdzdGFydFRyYW5zaXRpb24gY2Fubm90IGJlIGNhbGxlZCBkdXJpbmcgc2VydmVyIHJlbmRlcmluZy4nKTtcbn1cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbigpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICByZXR1cm4gW2ZhbHNlLCB1bnN1cHBvcnRlZFN0YXJ0VHJhbnNpdGlvbl07XG59XG5cbmZ1bmN0aW9uIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzKCkge1xuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHJldHVybiBOb3RQZW5kaW5nVHJhbnNpdGlvbjtcbn1cblxuZnVuY3Rpb24gdW5zdXBwb3J0ZWRTZXRPcHRpbWlzdGljU3RhdGUoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVwZGF0ZSBvcHRpbWlzdGljIHN0YXRlIHdoaWxlIHJlbmRlcmluZy4nKTtcbn1cblxuZnVuY3Rpb24gdXNlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHJldHVybiBbcGFzc3Rocm91Z2gsIHVuc3VwcG9ydGVkU2V0T3B0aW1pc3RpY1N0YXRlXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9zdGJhY2tGb3JtU3RhdGVLZXkocGVybWFsaW5rLCBjb21wb25lbnRLZXlQYXRoLCBob29rSW5kZXgpIHtcbiAgaWYgKHBlcm1hbGluayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gRG9uJ3QgYm90aGVyIHRvIGhhc2ggYSBwZXJtYWxpbmstYmFzZWQga2V5IHNpbmNlIGl0J3MgYWxyZWFkeSBzaG9ydC5cbiAgICByZXR1cm4gJ3AnICsgcGVybWFsaW5rO1xuICB9IGVsc2Uge1xuICAgIC8vIEFwcGVuZCBhIG5vZGUgdG8gdGhlIGtleSBwYXRoIHRoYXQgcmVwcmVzZW50cyB0aGUgZm9ybSBzdGF0ZSBob29rLlxuICAgIHZhciBrZXlQYXRoID0gW2NvbXBvbmVudEtleVBhdGgsIG51bGwsIGhvb2tJbmRleF07IC8vIEtleSBwYXRocyBhcmUgaGFzaGVkIHRvIHJlZHVjZSB0aGUgc2l6ZS4gSXQgZG9lcyBub3QgbmVlZCB0byBiZSBzZWN1cmUsXG4gICAgLy8gYW5kIGl0J3MgbW9yZSBpbXBvcnRhbnQgdGhhdCBpdCdzIGZhc3QgdGhhbiB0aGF0IGl0J3MgY29tcGxldGVseVxuICAgIC8vIGNvbGxpc2lvbi1mcmVlLlxuXG4gICAgdmFyIGtleVBhdGhIYXNoID0gY3JlYXRlRmFzdEhhc2hKUyhKU09OLnN0cmluZ2lmeShrZXlQYXRoKSk7XG4gICAgcmV0dXJuICdrJyArIGtleVBhdGhIYXNoO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUZvcm1TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTsgLy8gQ291bnQgdGhlIG51bWJlciBvZiB1c2VGb3JtU3RhdGUgaG9va3MgcGVyIGNvbXBvbmVudC4gV2UgYWxzbyB1c2UgdGhpcyB0b1xuICAvLyB0cmFjayB0aGUgcG9zaXRpb24gb2YgdGhpcyB1c2VGb3JtU3RhdGUgaG9vayByZWxhdGl2ZSB0byB0aGUgb3RoZXIgb25lcyBpblxuICAvLyB0aGlzIGNvbXBvbmVudCwgc28gd2UgY2FuIGdlbmVyYXRlIGEgdW5pcXVlIGtleSBmb3IgZWFjaCBvbmUuXG5cbiAgdmFyIGZvcm1TdGF0ZUhvb2tJbmRleCA9IGZvcm1TdGF0ZUNvdW50ZXIrKztcbiAgdmFyIHJlcXVlc3QgPSBjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0OyAvLyAkRmxvd0lnbm9yZVtwcm9wLW1pc3NpbmddXG5cbiAgdmFyIGZvcm1BY3Rpb24gPSBhY3Rpb24uJCRGT1JNX0FDVElPTjtcblxuICBpZiAodHlwZW9mIGZvcm1BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUaGlzIGlzIGEgc2VydmVyIGFjdGlvbi4gVGhlc2UgaGF2ZSBhZGRpdGlvbmFsIGZlYXR1cmVzIHRvIGVuYWJsZVxuICAgIC8vIE1QQS1zdHlsZSBmb3JtIHN1Ym1pc3Npb25zIHdpdGggcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQuXG4gICAgLy8gVE9ETzogSWYgdGhlIHNhbWUgcGVybWFsaW5rIGlzIHBhc3NlZCB0byBtdWx0aXBsZSB1c2VGb3JtU3RhdGVzLCBhbmRcbiAgICAvLyB0aGV5IGFsbCBoYXZlIHRoZSBzYW1lIGFjdGlvbiBzaWduYXR1cmUsIEZpenogd2lsbCBwYXNzIHRoZSBwb3N0YmFja1xuICAgIC8vIHN0YXRlIHRvIGFsbCBvZiB0aGVtLiBXZSBzaG91bGQgcHJvYmFibHkgb25seSBwYXNzIGl0IHRvIHRoZSBmaXJzdCBvbmUsXG4gICAgLy8gYW5kL29yIHdhcm4uXG4gICAgLy8gVGhlIGtleSBpcyBsYXppbHkgZ2VuZXJhdGVkIGFuZCBkZWR1cGVkIHNvIHRoZSB0aGF0IHRoZSBrZXlwYXRoIGRvZXNuJ3RcbiAgICAvLyBnZXQgSlNPTi5zdHJpbmdpZnktZWQgdW5uZWNlc3NhcmlseSwgYW5kIGF0IG1vc3Qgb25jZS5cbiAgICB2YXIgbmV4dFBvc3RiYWNrU3RhdGVLZXkgPSBudWxsOyAvLyBEZXRlcm1pbmUgdGhlIGN1cnJlbnQgZm9ybSBzdGF0ZS4gSWYgd2UgcmVjZWl2ZWQgc3RhdGUgZHVyaW5nIGFuIE1QQSBmb3JtXG4gICAgLy8gc3VibWlzc2lvbiwgdGhlbiB3ZSB3aWxsIHJldXNlIHRoYXQsIGlmIHRoZSBhY3Rpb24gaWRlbnRpdHkgbWF0Y2hlcy5cbiAgICAvLyBPdGhlcndpc2Ugd2UnbGwgdXNlIHRoZSBpbml0aWFsIHN0YXRlIGFyZ3VtZW50LiBXZSB3aWxsIGVtaXQgYSBjb21tZW50XG4gICAgLy8gbWFya2VyIGludG8gdGhlIHN0cmVhbSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBzdGF0ZSB3YXMgcmV1c2VkLlxuXG4gICAgdmFyIHN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIHZhciBjb21wb25lbnRLZXlQYXRoID0gY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aDtcbiAgICB2YXIgcG9zdGJhY2tGb3JtU3RhdGUgPSBnZXRGb3JtU3RhdGUocmVxdWVzdCk7IC8vICRGbG93SWdub3JlW3Byb3AtbWlzc2luZ11cblxuICAgIHZhciBpc1NpZ25hdHVyZUVxdWFsID0gYWN0aW9uLiQkSVNfU0lHTkFUVVJFX0VRVUFMO1xuXG4gICAgaWYgKHBvc3RiYWNrRm9ybVN0YXRlICE9PSBudWxsICYmIHR5cGVvZiBpc1NpZ25hdHVyZUVxdWFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgcG9zdGJhY2tLZXkgPSBwb3N0YmFja0Zvcm1TdGF0ZVsxXTtcbiAgICAgIHZhciBwb3N0YmFja1JlZmVyZW5jZUlkID0gcG9zdGJhY2tGb3JtU3RhdGVbMl07XG4gICAgICB2YXIgcG9zdGJhY2tCb3VuZEFyaXR5ID0gcG9zdGJhY2tGb3JtU3RhdGVbM107XG5cbiAgICAgIGlmIChpc1NpZ25hdHVyZUVxdWFsLmNhbGwoYWN0aW9uLCBwb3N0YmFja1JlZmVyZW5jZUlkLCBwb3N0YmFja0JvdW5kQXJpdHkpKSB7XG4gICAgICAgIG5leHRQb3N0YmFja1N0YXRlS2V5ID0gY3JlYXRlUG9zdGJhY2tGb3JtU3RhdGVLZXkocGVybWFsaW5rLCBjb21wb25lbnRLZXlQYXRoLCBmb3JtU3RhdGVIb29rSW5kZXgpO1xuXG4gICAgICAgIGlmIChwb3N0YmFja0tleSA9PT0gbmV4dFBvc3RiYWNrU3RhdGVLZXkpIHtcbiAgICAgICAgICAvLyBUaGlzIHdhcyBhIG1hdGNoXG4gICAgICAgICAgZm9ybVN0YXRlTWF0Y2hpbmdJbmRleCA9IGZvcm1TdGF0ZUhvb2tJbmRleDsgLy8gUmV1c2UgdGhlIHN0YXRlIHRoYXQgd2FzIHN1Ym1pdHRlZCBieSB0aGUgZm9ybS5cblxuICAgICAgICAgIHN0YXRlID0gcG9zdGJhY2tGb3JtU3RhdGVbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEJpbmQgdGhlIHN0YXRlIHRvIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgYWN0aW9uLlxuXG5cbiAgICB2YXIgYm91bmRBY3Rpb24gPSBhY3Rpb24uYmluZChudWxsLCBzdGF0ZSk7IC8vIFdyYXAgdGhlIGFjdGlvbiBzbyB0aGUgcmV0dXJuIHZhbHVlIGlzIHZvaWQuXG5cbiAgICB2YXIgZGlzcGF0Y2ggPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgYm91bmRBY3Rpb24ocGF5bG9hZCk7XG4gICAgfTsgLy8gJEZsb3dJZ25vcmVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICBpZiAodHlwZW9mIGJvdW5kQWN0aW9uLiQkRk9STV9BQ1RJT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vICRGbG93SWdub3JlW3Byb3AtbWlzc2luZ11cbiAgICAgIGRpc3BhdGNoLiQkRk9STV9BQ1RJT04gPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IGJvdW5kQWN0aW9uLiQkRk9STV9BQ1RJT04ocHJlZml4KTsgLy8gT3ZlcnJpZGUgdGhlIGFjdGlvbiBVUkxcblxuICAgICAgICBpZiAocGVybWFsaW5rICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHBlcm1hbGluaywgJ3RhcmdldCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBlcm1hbGluayArPSAnJztcbiAgICAgICAgICBtZXRhZGF0YS5hY3Rpb24gPSBwZXJtYWxpbms7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZm9ybURhdGEgPSBtZXRhZGF0YS5kYXRhO1xuXG4gICAgICAgIGlmIChmb3JtRGF0YSkge1xuICAgICAgICAgIGlmIChuZXh0UG9zdGJhY2tTdGF0ZUtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbmV4dFBvc3RiYWNrU3RhdGVLZXkgPSBjcmVhdGVQb3N0YmFja0Zvcm1TdGF0ZUtleShwZXJtYWxpbmssIGNvbXBvbmVudEtleVBhdGgsIGZvcm1TdGF0ZUhvb2tJbmRleCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKCckQUNUSU9OX0tFWScsIG5leHRQb3N0YmFja1N0YXRlS2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtzdGF0ZSwgZGlzcGF0Y2hdO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgbm90IGEgc2VydmVyIGFjdGlvbiwgc28gdGhlIGltcGxlbWVudGF0aW9uIGlzIG11Y2ggc2ltcGxlci5cbiAgICAvLyBCaW5kIHRoZSBzdGF0ZSB0byB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGFjdGlvbi5cbiAgICB2YXIgX2JvdW5kQWN0aW9uID0gYWN0aW9uLmJpbmQobnVsbCwgaW5pdGlhbFN0YXRlKTsgLy8gV3JhcCB0aGUgYWN0aW9uIHNvIHRoZSByZXR1cm4gdmFsdWUgaXMgdm9pZC5cblxuXG4gICAgdmFyIF9kaXNwYXRjaDIgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgX2JvdW5kQWN0aW9uKHBheWxvYWQpO1xuICAgIH07XG5cbiAgICByZXR1cm4gW2luaXRpYWxTdGF0ZSwgX2Rpc3BhdGNoMl07XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlSWQoKSB7XG4gIHZhciB0YXNrID0gY3VycmVudGx5UmVuZGVyaW5nVGFzaztcbiAgdmFyIHRyZWVJZCA9IGdldFRyZWVJZCh0YXNrLnRyZWVDb250ZXh0KTtcbiAgdmFyIHJlc3VtYWJsZVN0YXRlID0gY3VycmVudFJlc3VtYWJsZVN0YXRlO1xuXG4gIGlmIChyZXN1bWFibGVTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuJyk7XG4gIH1cblxuICB2YXIgbG9jYWxJZCA9IGxvY2FsSWRDb3VudGVyKys7XG4gIHJldHVybiBtYWtlSWQocmVzdW1hYmxlU3RhdGUsIHRyZWVJZCwgbG9jYWxJZCk7XG59XG5cbmZ1bmN0aW9uIHVzZSh1c2FibGUpIHtcbiAgaWYgKHVzYWJsZSAhPT0gbnVsbCAmJiB0eXBlb2YgdXNhYmxlID09PSAnb2JqZWN0Jykge1xuICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICBpZiAodHlwZW9mIHVzYWJsZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdGhlbmFibGUuXG4gICAgICB2YXIgdGhlbmFibGUgPSB1c2FibGU7XG4gICAgICByZXR1cm4gdW53cmFwVGhlbmFibGUodGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAodXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHVzYWJsZTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0FuIHVuc3VwcG9ydGVkIHR5cGUgd2FzIHBhc3NlZCB0byB1c2UoKTogJyArIFN0cmluZyh1c2FibGUpKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwVGhlbmFibGUodGhlbmFibGUpIHtcbiAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXI7XG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyICs9IDE7XG5cbiAgaWYgKHRoZW5hYmxlU3RhdGUgPT09IG51bGwpIHtcbiAgICB0aGVuYWJsZVN0YXRlID0gY3JlYXRlVGhlbmFibGVTdGF0ZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCk7XG59XG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkUmVmcmVzaCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDYWNoZSBjYW5ub3QgYmUgcmVmcmVzaGVkIGR1cmluZyBzZXJ2ZXIgcmVuZGVyaW5nLicpO1xufVxuXG5mdW5jdGlvbiB1c2VDYWNoZVJlZnJlc2goKSB7XG4gIHJldHVybiB1bnN1cHBvcnRlZFJlZnJlc2g7XG59XG5cbmZ1bmN0aW9uIG5vb3AkMSgpIHt9XG5cbnZhciBIb29rc0Rpc3BhdGNoZXIgPSB7XG4gIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgdXNlOiB1c2UsXG4gIHVzZUNvbnRleHQ6IHVzZUNvbnRleHQsXG4gIHVzZU1lbW86IHVzZU1lbW8sXG4gIHVzZVJlZHVjZXI6IHVzZVJlZHVjZXIsXG4gIHVzZVJlZjogdXNlUmVmLFxuICB1c2VTdGF0ZTogdXNlU3RhdGUsXG4gIHVzZUluc2VydGlvbkVmZmVjdDogbm9vcCQxLFxuICB1c2VMYXlvdXRFZmZlY3Q6IG5vb3AkMSxcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrLFxuICAvLyB1c2VJbXBlcmF0aXZlSGFuZGxlIGlzIG5vdCBydW4gaW4gdGhlIHNlcnZlciBlbnZpcm9ubWVudFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBub29wJDEsXG4gIC8vIEVmZmVjdHMgYXJlIG5vdCBydW4gaW4gdGhlIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgdXNlRWZmZWN0OiBub29wJDEsXG4gIC8vIERlYnVnZ2luZyBlZmZlY3RcbiAgdXNlRGVidWdWYWx1ZTogbm9vcCQxLFxuICB1c2VEZWZlcnJlZFZhbHVlOiB1c2VEZWZlcnJlZFZhbHVlLFxuICB1c2VUcmFuc2l0aW9uOiB1c2VUcmFuc2l0aW9uLFxuICB1c2VJZDogdXNlSWQsXG4gIC8vIFN1YnNjcmlwdGlvbnMgYXJlIG5vdCBzZXR1cCBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgdXNlU3luY0V4dGVybmFsU3RvcmU6IHVzZVN5bmNFeHRlcm5hbFN0b3JlXG59O1xuXG57XG4gIEhvb2tzRGlzcGF0Y2hlci51c2VDYWNoZVJlZnJlc2ggPSB1c2VDYWNoZVJlZnJlc2g7XG59XG5cbntcbiAgSG9va3NEaXNwYXRjaGVyLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG59XG5cbntcbiAgSG9va3NEaXNwYXRjaGVyLnVzZU9wdGltaXN0aWMgPSB1c2VPcHRpbWlzdGljO1xuICBIb29rc0Rpc3BhdGNoZXIudXNlRm9ybVN0YXRlID0gdXNlRm9ybVN0YXRlO1xufVxuXG52YXIgY3VycmVudFJlc3VtYWJsZVN0YXRlID0gbnVsbDtcbmZ1bmN0aW9uIHNldEN1cnJlbnRSZXN1bWFibGVTdGF0ZShyZXN1bWFibGVTdGF0ZSkge1xuICBjdXJyZW50UmVzdW1hYmxlU3RhdGUgPSByZXN1bWFibGVTdGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2FjaGVTaWduYWwoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLicpO1xufVxuXG5mdW5jdGlvbiBnZXRDYWNoZUZvclR5cGUocmVzb3VyY2VUeXBlKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLicpO1xufVxuXG52YXIgRGVmYXVsdENhY2hlRGlzcGF0Y2hlciA9IHtcbiAgZ2V0Q2FjaGVTaWduYWw6IGdldENhY2hlU2lnbmFsLFxuICBnZXRDYWNoZUZvclR5cGU6IGdldENhY2hlRm9yVHlwZVxufTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tCeUNvbXBvbmVudFN0YWNrTm9kZShjb21wb25lbnRTdGFjaykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgdmFyIG5vZGUgPSBjb21wb25lbnRTdGFjaztcblxuICAgIGRvIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGluZm8gKz0gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobm9kZS50eXBlLCBudWxsLCBudWxsKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaW5mbyArPSBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUobm9kZS50eXBlLCBudWxsLCBudWxsKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaW5mbyArPSBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUobm9kZS50eXBlLCBudWxsLCBudWxsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gd2UgYmFpbCBvdXQgd2hlbiB3ZSBnZXQgYSBudWxsXG5cblxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH0gd2hpbGUgKG5vZGUpO1xuXG4gICAgcmV0dXJuIGluZm87XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICByZXR1cm4gJ1xcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6ICcgKyB4Lm1lc3NhZ2UgKyAnXFxuJyArIHguc3RhY2s7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIFJlYWN0Q3VycmVudENhY2hlID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50Q2FjaGU7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7IC8vIExpbmtlZCBsaXN0IHJlcHJlc2VudGluZyB0aGUgaWRlbnRpdHkgb2YgYSBjb21wb25lbnQgZ2l2ZW4gdGhlIGNvbXBvbmVudC90YWcgbmFtZSBhbmQga2V5LlxuLy8gVGhlIG5hbWUgbWlnaHQgYmUgbWluaWZpZWQgYnV0IHdlIGFzc3VtZSB0aGF0IGl0J3MgZ29pbmcgdG8gYmUgdGhlIHNhbWUgZ2VuZXJhdGVkIG5hbWUuIFR5cGljYWxseVxuLy8gYmVjYXVzZSBpdCdzIGp1c3QgdGhlIHNhbWUgY29tcGlsZWQgb3V0cHV0IGluIHByYWN0aWNlLlxuLy8gcmVzdW1lIHdpdGggc2VnbWVudElEIGF0IHRoZSBpbmRleFxuXG52YXIgQ0xJRU5UX1JFTkRFUkVEID0gNDsgLy8gaWYgaXQgZXJyb3JzIG9yIGluZmluaXRlbHkgc3VzcGVuZHNcblxudmFyIFBFTkRJTkcgPSAwO1xudmFyIENPTVBMRVRFRCA9IDE7XG52YXIgRkxVU0hFRCA9IDI7XG52YXIgQUJPUlRFRCA9IDM7XG52YXIgRVJST1JFRCA9IDQ7XG52YXIgUE9TVFBPTkVEID0gNTtcbnZhciBPUEVOID0gMDtcbnZhciBDTE9TSU5HID0gMTtcbnZhciBDTE9TRUQgPSAyOyAvLyBUaGlzIGlzIGEgZGVmYXVsdCBoZXVyaXN0aWMgZm9yIGhvdyB0byBzcGxpdCB1cCB0aGUgSFRNTCBjb250ZW50IGludG8gcHJvZ3Jlc3NpdmVcbi8vIGxvYWRpbmcuIE91ciBnb2FsIGlzIHRvIGJlIGFibGUgdG8gZGlzcGxheSBhZGRpdGlvbmFsIG5ldyBjb250ZW50IGFib3V0IGV2ZXJ5IDUwMG1zLlxuLy8gRmFzdGVyIHRoYW4gdGhhdCBpcyB1bm5lY2Vzc2FyeSBhbmQgc2hvdWxkIGJlIHRocm90dGxlZCBvbiB0aGUgY2xpZW50LiBJdCBhbHNvXG4vLyBhZGRzIHVubmVjZXNzYXJ5IG92ZXJoZWFkIHRvIGRvIG1vcmUgc3BsaXRzLiBXZSBkb24ndCBrbm93IGlmIGl0J3MgYSBoaWdoZXIgb3IgbG93ZXJcbi8vIGVuZCBkZXZpY2UgYnV0IGhpZ2hlciBlbmQgc3VmZmVyIGxlc3MgZnJvbSB0aGUgb3ZlcmhlYWQgdGhhbiBsb3dlciBlbmQgZG9lcyBmcm9tXG4vLyBub3QgZ2V0dGluZyBzbWFsbCBlbm91Z2ggcGllY2VzLiBXZSBlcnJvciBvbiB0aGUgc2lkZSBvZiBsb3cgZW5kLlxuLy8gV2UgYmFzZSB0aGlzIG9uIGxvdyBlbmQgM0cgc3BlZWRzIHdoaWNoIGlzIGFib3V0IDUwMGtiaXRzIHBlciBzZWNvbmQuIFdlIGFzc3VtZVxuLy8gdGhhdCB0aGVyZSBjYW4gYmUgYSByZWFzb25hYmxlIGRyb3Agb2ZmIGZyb20gbWF4IGJhbmR3aWR0aCB3aGljaCBsZWF2ZXMgeW91IHdpdGhcbi8vIGFzIGxpdHRsZSBhcyA4MCUuIFdlIGNhbiByZWNlaXZlIGhhbGYgb2YgdGhhdCBlYWNoIDUwMG1zIC0gYXQgYmVzdC4gSW4gcHJhY3RpY2UsXG4vLyBhIGxpdHRsZSBiYW5kd2lkdGggaXMgbG9zdCB0byBwcm9jZXNzaW5nIGFuZCBjb250ZW50aW9uIC0gZS5nLiBDU1MgYW5kIGltYWdlcyB0aGF0XG4vLyBhcmUgZG93bmxvYWRlZCBhbG9uZyB3aXRoIHRoZSBtYWluIGNvbnRlbnQuIFNvIHdlIGVzdGltYXRlIGFib3V0IGhhbGYgb2YgdGhhdCB0byBiZVxuLy8gdGhlIGxvd2VyIGVuZCB0aHJvdWdocHV0LiBJbiBvdGhlciB3b3Jkcywgd2UgZXhwZWN0IHRoYXQgeW91IGNhbiBhdCBsZWFzdCBzaG93XG4vLyBhYm91dCAxMi41a2Igb2YgY29udGVudCBwZXIgNTAwbXMuIE5vdCBjb3VudGluZyBzdGFydGluZyBsYXRlbmN5IGZvciB0aGUgZmlyc3Rcbi8vIHBhaW50LlxuLy8gNTAwICogMTAyNCAvIDggKiAuOCAqIDAuNSAvIDJcblxudmFyIERFRkFVTFRfUFJPR1JFU1NJVkVfQ0hVTktfU0laRSA9IDEyODAwO1xuXG5mdW5jdGlvbiBkZWZhdWx0RXJyb3JIYW5kbGVyKGVycm9yKSB7XG4gIGNvbnNvbGVbJ2Vycm9yJ10oZXJyb3IpOyAvLyBEb24ndCB0cmFuc2Zvcm0gdG8gb3VyIHdyYXBwZXJcblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3QoY2hpbGRyZW4sIHJlc3VtYWJsZVN0YXRlLCByZW5kZXJTdGF0ZSwgcm9vdEZvcm1hdENvbnRleHQsIHByb2dyZXNzaXZlQ2h1bmtTaXplLCBvbkVycm9yLCBvbkFsbFJlYWR5LCBvblNoZWxsUmVhZHksIG9uU2hlbGxFcnJvciwgb25GYXRhbEVycm9yLCBvblBvc3Rwb25lLCBmb3JtU3RhdGUpIHtcbiAgcHJlcGFyZUhvc3REaXNwYXRjaGVyKCk7XG4gIHZhciBwaW5nZWRUYXNrcyA9IFtdO1xuICB2YXIgYWJvcnRTZXQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXF1ZXN0ID0ge1xuICAgIGRlc3RpbmF0aW9uOiBudWxsLFxuICAgIGZsdXNoU2NoZWR1bGVkOiBmYWxzZSxcbiAgICByZXN1bWFibGVTdGF0ZTogcmVzdW1hYmxlU3RhdGUsXG4gICAgcmVuZGVyU3RhdGU6IHJlbmRlclN0YXRlLFxuICAgIHJvb3RGb3JtYXRDb250ZXh0OiByb290Rm9ybWF0Q29udGV4dCxcbiAgICBwcm9ncmVzc2l2ZUNodW5rU2l6ZTogcHJvZ3Jlc3NpdmVDaHVua1NpemUgPT09IHVuZGVmaW5lZCA/IERFRkFVTFRfUFJPR1JFU1NJVkVfQ0hVTktfU0laRSA6IHByb2dyZXNzaXZlQ2h1bmtTaXplLFxuICAgIHN0YXR1czogT1BFTixcbiAgICBmYXRhbEVycm9yOiBudWxsLFxuICAgIG5leHRTZWdtZW50SWQ6IDAsXG4gICAgYWxsUGVuZGluZ1Rhc2tzOiAwLFxuICAgIHBlbmRpbmdSb290VGFza3M6IDAsXG4gICAgY29tcGxldGVkUm9vdFNlZ21lbnQ6IG51bGwsXG4gICAgYWJvcnRhYmxlVGFza3M6IGFib3J0U2V0LFxuICAgIHBpbmdlZFRhc2tzOiBwaW5nZWRUYXNrcyxcbiAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXM6IFtdLFxuICAgIGNvbXBsZXRlZEJvdW5kYXJpZXM6IFtdLFxuICAgIHBhcnRpYWxCb3VuZGFyaWVzOiBbXSxcbiAgICB0cmFja2VkUG9zdHBvbmVzOiBudWxsLFxuICAgIG9uRXJyb3I6IG9uRXJyb3IgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRFcnJvckhhbmRsZXIgOiBvbkVycm9yLFxuICAgIG9uUG9zdHBvbmU6IG9uUG9zdHBvbmUgPT09IHVuZGVmaW5lZCA/IG5vb3AgOiBvblBvc3Rwb25lLFxuICAgIG9uQWxsUmVhZHk6IG9uQWxsUmVhZHkgPT09IHVuZGVmaW5lZCA/IG5vb3AgOiBvbkFsbFJlYWR5LFxuICAgIG9uU2hlbGxSZWFkeTogb25TaGVsbFJlYWR5ID09PSB1bmRlZmluZWQgPyBub29wIDogb25TaGVsbFJlYWR5LFxuICAgIG9uU2hlbGxFcnJvcjogb25TaGVsbEVycm9yID09PSB1bmRlZmluZWQgPyBub29wIDogb25TaGVsbEVycm9yLFxuICAgIG9uRmF0YWxFcnJvcjogb25GYXRhbEVycm9yID09PSB1bmRlZmluZWQgPyBub29wIDogb25GYXRhbEVycm9yLFxuICAgIGZvcm1TdGF0ZTogZm9ybVN0YXRlID09PSB1bmRlZmluZWQgPyBudWxsIDogZm9ybVN0YXRlXG4gIH07IC8vIFRoaXMgc2VnbWVudCByZXByZXNlbnRzIHRoZSByb290IGZhbGxiYWNrLlxuXG4gIHZhciByb290U2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KHJlcXVlc3QsIDAsIG51bGwsIHJvb3RGb3JtYXRDb250ZXh0LCAvLyBSb290IHNlZ21lbnRzIGFyZSBuZXZlciBlbWJlZGRlZCBpbiBUZXh0IG9uIGVpdGhlciBlZGdlXG4gIGZhbHNlLCBmYWxzZSk7IC8vIFRoZXJlIGlzIG5vIHBhcmVudCBzbyBjb25jZXB0dWFsbHksIHdlJ3JlIHVuYmxvY2tlZCB0byBmbHVzaCB0aGlzIHNlZ21lbnQuXG5cbiAgcm9vdFNlZ21lbnQucGFyZW50Rmx1c2hlZCA9IHRydWU7XG4gIHZhciByb290VGFzayA9IGNyZWF0ZVJlbmRlclRhc2socmVxdWVzdCwgbnVsbCwgY2hpbGRyZW4sIC0xLCBudWxsLCByb290U2VnbWVudCwgYWJvcnRTZXQsIG51bGwsIHJvb3RGb3JtYXRDb250ZXh0LCBlbXB0eUNvbnRleHRPYmplY3QsIHJvb3RDb250ZXh0U25hcHNob3QsIGVtcHR5VHJlZUNvbnRleHQsIG51bGwpO1xuICBwaW5nZWRUYXNrcy5wdXNoKHJvb3RUYXNrKTtcbiAgcmV0dXJuIHJlcXVlc3Q7XG59XG52YXIgY3VycmVudFJlcXVlc3QgPSBudWxsO1xuZnVuY3Rpb24gcmVzb2x2ZVJlcXVlc3QoKSB7XG4gIGlmIChjdXJyZW50UmVxdWVzdCkgcmV0dXJuIGN1cnJlbnRSZXF1ZXN0O1xuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwaW5nVGFzayhyZXF1ZXN0LCB0YXNrKSB7XG4gIHZhciBwaW5nZWRUYXNrcyA9IHJlcXVlc3QucGluZ2VkVGFza3M7XG4gIHBpbmdlZFRhc2tzLnB1c2godGFzayk7XG5cbiAgaWYgKHJlcXVlc3QucGluZ2VkVGFza3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9IHJlcXVlc3QuZGVzdGluYXRpb24gIT09IG51bGw7XG4gICAgc2NoZWR1bGVXb3JrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtV29yayhyZXF1ZXN0KTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHJlcXVlc3QsIGZhbGxiYWNrQWJvcnRhYmxlVGFza3MpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6IFBFTkRJTkcsXG4gICAgcm9vdFNlZ21lbnRJRDogLTEsXG4gICAgcGFyZW50Rmx1c2hlZDogZmFsc2UsXG4gICAgcGVuZGluZ1Rhc2tzOiAwLFxuICAgIGNvbXBsZXRlZFNlZ21lbnRzOiBbXSxcbiAgICBieXRlU2l6ZTogMCxcbiAgICBmYWxsYmFja0Fib3J0YWJsZVRhc2tzOiBmYWxsYmFja0Fib3J0YWJsZVRhc2tzLFxuICAgIGVycm9yRGlnZXN0OiBudWxsLFxuICAgIHJlc291cmNlczogY3JlYXRlQm91bmRhcnlSZXNvdXJjZXMoKSxcbiAgICB0cmFja2VkQ29udGVudEtleVBhdGg6IG51bGwsXG4gICAgdHJhY2tlZEZhbGxiYWNrTm9kZTogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJUYXNrKHJlcXVlc3QsIHRoZW5hYmxlU3RhdGUsIG5vZGUsIGNoaWxkSW5kZXgsIGJsb2NrZWRCb3VuZGFyeSwgYmxvY2tlZFNlZ21lbnQsIGFib3J0U2V0LCBrZXlQYXRoLCBmb3JtYXRDb250ZXh0LCBsZWdhY3lDb250ZXh0LCBjb250ZXh0LCB0cmVlQ29udGV4dCwgY29tcG9uZW50U3RhY2spIHtcbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MrKztcblxuICBpZiAoYmxvY2tlZEJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKys7XG4gIH0gZWxzZSB7XG4gICAgYmxvY2tlZEJvdW5kYXJ5LnBlbmRpbmdUYXNrcysrO1xuICB9XG5cbiAgdmFyIHRhc2sgPSB7XG4gICAgcmVwbGF5OiBudWxsLFxuICAgIG5vZGU6IG5vZGUsXG4gICAgY2hpbGRJbmRleDogY2hpbGRJbmRleCxcbiAgICBwaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGluZ1Rhc2socmVxdWVzdCwgdGFzayk7XG4gICAgfSxcbiAgICBibG9ja2VkQm91bmRhcnk6IGJsb2NrZWRCb3VuZGFyeSxcbiAgICBibG9ja2VkU2VnbWVudDogYmxvY2tlZFNlZ21lbnQsXG4gICAgYWJvcnRTZXQ6IGFib3J0U2V0LFxuICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgZm9ybWF0Q29udGV4dDogZm9ybWF0Q29udGV4dCxcbiAgICBsZWdhY3lDb250ZXh0OiBsZWdhY3lDb250ZXh0LFxuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgdHJlZUNvbnRleHQ6IHRyZWVDb250ZXh0LFxuICAgIGNvbXBvbmVudFN0YWNrOiBjb21wb25lbnRTdGFjayxcbiAgICB0aGVuYWJsZVN0YXRlOiB0aGVuYWJsZVN0YXRlXG4gIH07XG4gIGFib3J0U2V0LmFkZCh0YXNrKTtcbiAgcmV0dXJuIHRhc2s7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcGxheVRhc2socmVxdWVzdCwgdGhlbmFibGVTdGF0ZSwgcmVwbGF5LCBub2RlLCBjaGlsZEluZGV4LCBibG9ja2VkQm91bmRhcnksIGFib3J0U2V0LCBrZXlQYXRoLCBmb3JtYXRDb250ZXh0LCBsZWdhY3lDb250ZXh0LCBjb250ZXh0LCB0cmVlQ29udGV4dCwgY29tcG9uZW50U3RhY2spIHtcbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MrKztcblxuICBpZiAoYmxvY2tlZEJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKys7XG4gIH0gZWxzZSB7XG4gICAgYmxvY2tlZEJvdW5kYXJ5LnBlbmRpbmdUYXNrcysrO1xuICB9XG5cbiAgcmVwbGF5LnBlbmRpbmdUYXNrcysrO1xuICB2YXIgdGFzayA9IHtcbiAgICByZXBsYXk6IHJlcGxheSxcbiAgICBub2RlOiBub2RlLFxuICAgIGNoaWxkSW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgcGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBpbmdUYXNrKHJlcXVlc3QsIHRhc2spO1xuICAgIH0sXG4gICAgYmxvY2tlZEJvdW5kYXJ5OiBibG9ja2VkQm91bmRhcnksXG4gICAgYmxvY2tlZFNlZ21lbnQ6IG51bGwsXG4gICAgYWJvcnRTZXQ6IGFib3J0U2V0LFxuICAgIGtleVBhdGg6IGtleVBhdGgsXG4gICAgZm9ybWF0Q29udGV4dDogZm9ybWF0Q29udGV4dCxcbiAgICBsZWdhY3lDb250ZXh0OiBsZWdhY3lDb250ZXh0LFxuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgdHJlZUNvbnRleHQ6IHRyZWVDb250ZXh0LFxuICAgIGNvbXBvbmVudFN0YWNrOiBjb21wb25lbnRTdGFjayxcbiAgICB0aGVuYWJsZVN0YXRlOiB0aGVuYWJsZVN0YXRlXG4gIH07XG4gIGFib3J0U2V0LmFkZCh0YXNrKTtcbiAgcmV0dXJuIHRhc2s7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBlbmRpbmdTZWdtZW50KHJlcXVlc3QsIGluZGV4LCBib3VuZGFyeSwgcGFyZW50Rm9ybWF0Q29udGV4dCwgbGFzdFB1c2hlZFRleHQsIHRleHRFbWJlZGRlZCkge1xuICByZXR1cm4ge1xuICAgIHN0YXR1czogUEVORElORyxcbiAgICBpZDogLTEsXG4gICAgLy8gbGF6aWx5IGFzc2lnbmVkIGxhdGVyXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIHBhcmVudEZsdXNoZWQ6IGZhbHNlLFxuICAgIGNodW5rczogW10sXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIHBhcmVudEZvcm1hdENvbnRleHQ6IHBhcmVudEZvcm1hdENvbnRleHQsXG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIGxhc3RQdXNoZWRUZXh0OiBsYXN0UHVzaGVkVGV4dCxcbiAgICB0ZXh0RW1iZWRkZWQ6IHRleHRFbWJlZGRlZFxuICB9O1xufSAvLyBERVYtb25seSBnbG9iYWwgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHRhc2tcblxuXG52YXIgY3VycmVudFRhc2tJbkRFViA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRTdGFja0luREVWKCkge1xuICB7XG4gICAgaWYgKGN1cnJlbnRUYXNrSW5ERVYgPT09IG51bGwgfHwgY3VycmVudFRhc2tJbkRFVi5jb21wb25lbnRTdGFjayA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRTdGFja0J5Q29tcG9uZW50U3RhY2tOb2RlKGN1cnJlbnRUYXNrSW5ERVYuY29tcG9uZW50U3RhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrRnJvbU5vZGUoc3RhY2tOb2RlKSB7XG4gIHJldHVybiBnZXRTdGFja0J5Q29tcG9uZW50U3RhY2tOb2RlKHN0YWNrTm9kZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1aWx0SW5Db21wb25lbnRTdGFjayh0YXNrLCB0eXBlKSB7XG4gIHJldHVybiB7XG4gICAgdGFnOiAwLFxuICAgIHBhcmVudDogdGFzay5jb21wb25lbnRTdGFjayxcbiAgICB0eXBlOiB0eXBlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50U3RhY2sodGFzaywgdHlwZSkge1xuICByZXR1cm4ge1xuICAgIHRhZzogMSxcbiAgICBwYXJlbnQ6IHRhc2suY29tcG9uZW50U3RhY2ssXG4gICAgdHlwZTogdHlwZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc0NvbXBvbmVudFN0YWNrKHRhc2ssIHR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0YWc6IDIsXG4gICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgIHR5cGU6IHR5cGVcbiAgfTtcbn0gLy8gV2hpbGUgd2UgdHJhY2sgY29tcG9uZW50IHN0YWNrcyBpbiBwcm9kIGFsbCB0aGUgdGltZSB3ZSBvbmx5IHByb2R1Y2UgYSByZWlmaWVkIHN0YWNrIGluIGRldiBhbmRcbi8vIGR1cmluZyBwcmVyZW5kZXIgaW4gUHJvZC4gVGhlIHJlYXNvbiBmb3IgdGhpcyBpcyB0aGF0IHRoZSBzdGFjayBpcyB1c2VmdWwgZm9yIHByZXJlbmRlciB3aGVyZSB0aGUgdGltZWxpbmVzc1xuLy8gb2YgdGhlIHJlcXVlc3QgaXMgbGVzcyBjcml0aWNhbCB0aGFuIHRoZSBvYnNlcnZhYmlsaXR5IG9mIHRoZSBleGVjdXRpb24uIEZvciByZW5kZXJzIGFuZCByZXN1bWVzIGhvd2V2ZXIgd2Vcbi8vIHByaW9yaXRpemUgc3BlZWQgb2YgdGhlIHJlcXVlc3QuXG5cblxuZnVuY3Rpb24gZ2V0VGhyb3duSW5mbyhyZXF1ZXN0LCBub2RlKSB7XG4gIGlmIChub2RlICYmICggLy8gQWx3YXlzIHByb2R1Y2UgYSBzdGFjayBpbiBkZXZcbiAgdHJ1ZSApKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBvbmVudFN0YWNrOiBnZXRTdGFja0Zyb21Ob2RlKG5vZGUpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShib3VuZGFyeSwgZGlnZXN0LCBlcnJvciwgdGhyb3duSW5mbykge1xuICBib3VuZGFyeS5lcnJvckRpZ2VzdCA9IGRpZ2VzdDtcblxuICB7XG4gICAgLy8gSW4gZGV2IHdlIGFkZGl0aW9uYWxseSBlbmNvZGUgdGhlIGVycm9yIG1lc3NhZ2UgYW5kIGNvbXBvbmVudCBzdGFjayBvbiB0aGUgYm91bmRhcnlcbiAgICB2YXIgZXJyb3JNZXNzYWdlO1xuXG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yO1xuICAgIH0gZWxzZSBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgIGVycm9yTWVzc2FnZSA9IFN0cmluZyhlcnJvcik7XG4gICAgfVxuXG4gICAgYm91bmRhcnkuZXJyb3JNZXNzYWdlID0gZXJyb3JNZXNzYWdlO1xuICAgIGJvdW5kYXJ5LmVycm9yQ29tcG9uZW50U3RhY2sgPSB0aHJvd25JbmZvLmNvbXBvbmVudFN0YWNrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IkMSwgZXJyb3JJbmZvKSB7XG4gIC8vIElmIHRoaXMgY2FsbGJhY2sgZXJyb3JzLCB3ZSBpbnRlbnRpb25hbGx5IGxldCB0aGF0IGVycm9yIGJ1YmJsZSB1cCB0byBiZWNvbWUgYSBmYXRhbCBlcnJvclxuICAvLyBzbyB0aGF0IHNvbWVvbmUgZml4ZXMgdGhlIGVycm9yIHJlcG9ydGluZyBpbnN0ZWFkIG9mIGhpZGluZyBpdC5cbiAgdmFyIGVycm9yRGlnZXN0ID0gcmVxdWVzdC5vbkVycm9yKGVycm9yJDEsIGVycm9ySW5mbyk7XG5cbiAgaWYgKGVycm9yRGlnZXN0ICE9IG51bGwgJiYgdHlwZW9mIGVycm9yRGlnZXN0ICE9PSAnc3RyaW5nJykge1xuICAgIC8vIFdlIHVzZWQgdG8gdGhyb3cgaGVyZSBidXQgc2luY2UgdGhpcyBnZXRzIGNhbGxlZCBmcm9tIGEgdmFyaWV0eSBvZiB1bnByb3RlY3RlZCBwbGFjZXMgaXRcbiAgICAvLyBzZWVtcyBiZXR0ZXIgdG8ganVzdCB3YXJuIGFuZCBkaXNjYXJkIHRoZSByZXR1cm5lZCB2YWx1ZS5cbiAgICB7XG4gICAgICBlcnJvcignb25FcnJvciByZXR1cm5lZCBzb21ldGhpbmcgd2l0aCBhIHR5cGUgb3RoZXIgdGhhbiBcInN0cmluZ1wiLiBvbkVycm9yIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgYW5kIG1heSByZXR1cm4gbnVsbCBvciB1bmRlZmluZWQgYnV0IG11c3Qgbm90IHJldHVybiBhbnl0aGluZyBlbHNlLiBJdCByZWNlaXZlZCBzb21ldGhpbmcgb2YgdHlwZSBcIiVzXCIgaW5zdGVhZCcsIHR5cGVvZiBlcnJvckRpZ2VzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGVycm9yRGlnZXN0O1xufVxuXG5mdW5jdGlvbiBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yKSB7XG4gIC8vIFRoaXMgaXMgY2FsbGVkIG91dHNpZGUgZXJyb3IgaGFuZGxpbmcgY29kZSBzdWNoIGFzIGlmIHRoZSByb290IGVycm9ycyBvdXRzaWRlXG4gIC8vIGEgc3VzcGVuc2UgYm91bmRhcnkgb3IgaWYgdGhlIHJvb3Qgc3VzcGVuc2UgYm91bmRhcnkncyBmYWxsYmFjayBlcnJvcnMuXG4gIC8vIEl0J3MgYWxzbyBjYWxsZWQgaWYgUmVhY3QgaXRzZWxmIG9yIGl0cyBob3N0IGNvbmZpZ3MgZXJyb3JzLlxuICB2YXIgb25TaGVsbEVycm9yID0gcmVxdWVzdC5vblNoZWxsRXJyb3I7XG4gIG9uU2hlbGxFcnJvcihlcnJvcik7XG4gIHZhciBvbkZhdGFsRXJyb3IgPSByZXF1ZXN0Lm9uRmF0YWxFcnJvcjtcbiAgb25GYXRhbEVycm9yKGVycm9yKTtcblxuICBpZiAocmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbCkge1xuICAgIHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEO1xuICAgIGNsb3NlV2l0aEVycm9yKHJlcXVlc3QuZGVzdGluYXRpb24sIGVycm9yKTtcbiAgfSBlbHNlIHtcbiAgICByZXF1ZXN0LnN0YXR1cyA9IENMT1NJTkc7XG4gICAgcmVxdWVzdC5mYXRhbEVycm9yID0gZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyU3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCBzb21lVGFzaywga2V5UGF0aCwgcHJvcHMpIHtcbiAgaWYgKHNvbWVUYXNrLnJlcGxheSAhPT0gbnVsbCkge1xuICAgIC8vIElmIHdlJ3JlIHJlcGxheWluZyB0aHJvdWdoIHRoaXMgcGFzcywgaXQgbWVhbnMgd2UncmUgcmVwbGF5aW5nIHRocm91Z2hcbiAgICAvLyBhbiBhbHJlYWR5IGNvbXBsZXRlZCBTdXNwZW5zZSBib3VuZGFyeS4gSXQncyB0b28gbGF0ZSB0byBkbyBhbnl0aGluZyBhYm91dCBpdFxuICAgIC8vIHNvIHdlIGNhbiBqdXN0IHJlbmRlciB0aHJvdWdoIGl0LlxuICAgIHZhciBfcHJldktleVBhdGggPSBzb21lVGFzay5rZXlQYXRoO1xuICAgIHNvbWVUYXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgIHZhciBfY29udGVudCA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlbmRlck5vZGUocmVxdWVzdCwgc29tZVRhc2ssIF9jb250ZW50LCAtMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNvbWVUYXNrLmtleVBhdGggPSBfcHJldktleVBhdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9IC8vICRGbG93Rml4TWU6IFJlZmluZWQuXG5cblxuICB2YXIgdGFzayA9IHNvbWVUYXNrO1xuICB2YXIgcHJldmlvdXNDb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2s7IC8vIElmIHdlIGVuZCB1cCBjcmVhdGluZyB0aGUgZmFsbGJhY2sgdGFzayB3ZSBuZWVkIGl0IHRvIGhhdmUgdGhlIGNvcnJlY3Qgc3RhY2sgd2hpY2ggaXNcbiAgLy8gdGhlIHN0YWNrIGZvciB0aGUgYm91bmRhcnkgaXRzZWxmLiBXZSBzdGFzaCBpdCBoZXJlIHNvIHdlIGNhbiB1c2UgaXQgaWYgbmVlZGVkIGxhdGVyXG5cbiAgdmFyIHN1c3BlbnNlQ29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrID0gY3JlYXRlQnVpbHRJbkNvbXBvbmVudFN0YWNrKHRhc2ssICdTdXNwZW5zZScpO1xuICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG4gIHZhciBwYXJlbnRCb3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICB2YXIgcGFyZW50U2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7IC8vIEVhY2ggdGltZSB3ZSBlbnRlciBhIHN1c3BlbnNlIGJvdW5kYXJ5LCB3ZSBzcGxpdCBvdXQgaW50byBhIG5ldyBzZWdtZW50IGZvclxuICAvLyB0aGUgZmFsbGJhY2sgc28gdGhhdCB3ZSBjYW4gbGF0ZXIgcmVwbGFjZSB0aGF0IHNlZ21lbnQgd2l0aCB0aGUgY29udGVudC5cbiAgLy8gVGhpcyBhbHNvIGxldHMgdXMgc3BsaXQgb3V0IHRoZSBtYWluIGNvbnRlbnQgZXZlbiBpZiBpdCBkb2Vzbid0IHN1c3BlbmQsXG4gIC8vIGluIGNhc2UgaXQgZW5kcyB1cCBnZW5lcmF0aW5nIGEgbGFyZ2Ugc3VidHJlZSBvZiBjb250ZW50LlxuXG4gIHZhciBmYWxsYmFjayA9IHByb3BzLmZhbGxiYWNrO1xuICB2YXIgY29udGVudCA9IHByb3BzLmNoaWxkcmVuO1xuICB2YXIgZmFsbGJhY2tBYm9ydFNldCA9IG5ldyBTZXQoKTtcbiAgdmFyIG5ld0JvdW5kYXJ5ID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCBmYWxsYmFja0Fib3J0U2V0KTtcblxuICBpZiAocmVxdWVzdC50cmFja2VkUG9zdHBvbmVzICE9PSBudWxsKSB7XG4gICAgbmV3Qm91bmRhcnkudHJhY2tlZENvbnRlbnRLZXlQYXRoID0ga2V5UGF0aDtcbiAgfVxuXG4gIHZhciBpbnNlcnRpb25JbmRleCA9IHBhcmVudFNlZ21lbnQuY2h1bmtzLmxlbmd0aDsgLy8gVGhlIGNoaWxkcmVuIG9mIHRoZSBib3VuZGFyeSBzZWdtZW50IGlzIGFjdHVhbGx5IHRoZSBmYWxsYmFjay5cblxuICB2YXIgYm91bmRhcnlTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQocmVxdWVzdCwgaW5zZXJ0aW9uSW5kZXgsIG5ld0JvdW5kYXJ5LCB0YXNrLmZvcm1hdENvbnRleHQsIC8vIGJvdW5kYXJpZXMgbmV2ZXIgcmVxdWlyZSB0ZXh0IGVtYmVkZGluZyBhdCB0aGVpciBlZGdlcyBiZWNhdXNlIGNvbW1lbnQgbm9kZXMgYm91bmQgdGhlbVxuICBmYWxzZSwgZmFsc2UpO1xuICBwYXJlbnRTZWdtZW50LmNoaWxkcmVuLnB1c2goYm91bmRhcnlTZWdtZW50KTsgLy8gVGhlIHBhcmVudFNlZ21lbnQgaGFzIGEgY2hpbGQgU2VnbWVudCBhdCB0aGlzIGluZGV4IHNvIHdlIHJlc2V0IHRoZSBsYXN0UHVzaGVkVGV4dCBtYXJrZXIgb24gdGhlIHBhcmVudFxuXG4gIHBhcmVudFNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBmYWxzZTsgLy8gVGhpcyBzZWdtZW50IGlzIHRoZSBhY3R1YWwgY2hpbGQgY29udGVudC4gV2UgY2FuIHN0YXJ0IHJlbmRlcmluZyB0aGF0IGltbWVkaWF0ZWx5LlxuXG4gIHZhciBjb250ZW50Um9vdFNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChyZXF1ZXN0LCAwLCBudWxsLCB0YXNrLmZvcm1hdENvbnRleHQsIC8vIGJvdW5kYXJpZXMgbmV2ZXIgcmVxdWlyZSB0ZXh0IGVtYmVkZGluZyBhdCB0aGVpciBlZGdlcyBiZWNhdXNlIGNvbW1lbnQgbm9kZXMgYm91bmQgdGhlbVxuICBmYWxzZSwgZmFsc2UpOyAvLyBXZSBtYXJrIHRoZSByb290IHNlZ21lbnQgYXMgaGF2aW5nIGl0cyBwYXJlbnQgZmx1c2hlZC4gSXQncyBub3QgcmVhbGx5IGZsdXNoZWQgYnV0IHRoZXJlIGlzXG4gIC8vIG5vIHBhcmVudCBzZWdtZW50IHNvIHRoZXJlJ3Mgbm90aGluZyB0byB3YWl0IG9uLlxuXG4gIGNvbnRlbnRSb290U2VnbWVudC5wYXJlbnRGbHVzaGVkID0gdHJ1ZTsgLy8gQ3VycmVudGx5IHRoaXMgaXMgcnVubmluZyBzeW5jaHJvbm91c2x5LiBXZSBjb3VsZCBpbnN0ZWFkIHNjaGVkdWxlIHRoaXMgdG8gcGluZ2VkVGFza3MuXG4gIC8vIEkgc3VzcGVjdCB0aGF0IHRoZXJlIG1pZ2h0IGJlIHNvbWUgZWZmaWNpZW5jeSBiZW5lZml0cyBmcm9tIG5vdCBjcmVhdGluZyB0aGUgc3VzcGVuZGVkIHRhc2tcbiAgLy8gYW5kIGluc3RlYWQganVzdCB1c2luZyB0aGUgc3RhY2sgaWYgcG9zc2libGUuXG4gIC8vIFRPRE86IENhbGwgdGhpcyBkaXJlY3RseSBpbnN0ZWFkIG9mIG1lc3Npbmcgd2l0aCBzYXZpbmcgYW5kIHJlc3RvcmluZyBjb250ZXh0cy5cbiAgLy8gV2UgY2FuIHJldXNlIHRoZSBjdXJyZW50IGNvbnRleHQgYW5kIHRhc2sgdG8gcmVuZGVyIHRoZSBjb250ZW50IGltbWVkaWF0ZWx5IHdpdGhvdXRcbiAgLy8gY29udGV4dCBzd2l0Y2hpbmcuIFdlIGp1c3QgbmVlZCB0byB0ZW1wb3JhcmlseSBzd2l0Y2ggd2hpY2ggYm91bmRhcnkgYW5kIHdoaWNoIHNlZ21lbnRcbiAgLy8gd2UncmUgd3JpdGluZyB0by4gSWYgc29tZXRoaW5nIHN1c3BlbmRzLCBpdCdsbCBzcGF3biBuZXcgc3VzcGVuZGVkIHRhc2sgd2l0aCB0aGF0IGNvbnRleHQuXG5cbiAgdGFzay5ibG9ja2VkQm91bmRhcnkgPSBuZXdCb3VuZGFyeTtcbiAgdGFzay5ibG9ja2VkU2VnbWVudCA9IGNvbnRlbnRSb290U2VnbWVudDtcblxuICB7XG4gICAgc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVxdWVzdC5yZW5kZXJTdGF0ZSwgbmV3Qm91bmRhcnkucmVzb3VyY2VzKTtcbiAgfVxuXG4gIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7XG5cbiAgdHJ5IHtcbiAgICAvLyBXZSB1c2UgdGhlIHNhZmUgZm9ybSBiZWNhdXNlIHdlIGRvbid0IGhhbmRsZSBzdXNwZW5kaW5nIGhlcmUuIE9ubHkgZXJyb3IgaGFuZGxpbmcuXG4gICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjb250ZW50LCAtMSk7XG4gICAgcHVzaFNlZ21lbnRGaW5hbGUoY29udGVudFJvb3RTZWdtZW50LmNodW5rcywgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgY29udGVudFJvb3RTZWdtZW50Lmxhc3RQdXNoZWRUZXh0LCBjb250ZW50Um9vdFNlZ21lbnQudGV4dEVtYmVkZGVkKTtcbiAgICBjb250ZW50Um9vdFNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgIHF1ZXVlQ29tcGxldGVkU2VnbWVudChuZXdCb3VuZGFyeSwgY29udGVudFJvb3RTZWdtZW50KTtcblxuICAgIGlmIChuZXdCb3VuZGFyeS5wZW5kaW5nVGFza3MgPT09IDAgJiYgbmV3Qm91bmRhcnkuc3RhdHVzID09PSBQRU5ESU5HKSB7XG4gICAgICAvLyBUaGlzIG11c3QgaGF2ZSBiZWVuIHRoZSBsYXN0IHNlZ21lbnQgd2Ugd2VyZSB3YWl0aW5nIG9uLiBUaGlzIGJvdW5kYXJ5IGlzIG5vdyBjb21wbGV0ZS5cbiAgICAgIC8vIFRoZXJlZm9yZSB3ZSB3b24ndCBuZWVkIHRoZSBmYWxsYmFjay4gV2UgZWFybHkgcmV0dXJuIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjcmVhdGVcbiAgICAgIC8vIHRoZSBmYWxsYmFjay5cbiAgICAgIG5ld0JvdW5kYXJ5LnN0YXR1cyA9IENPTVBMRVRFRDsgLy8gV2UgYXJlIHJldHVybmluZyBlYXJseSBzbyB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlXG5cbiAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb250ZW50Um9vdFNlZ21lbnQuc3RhdHVzID0gRVJST1JFRDtcbiAgICBuZXdCb3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQ7XG4gICAgdmFyIHRocm93bkluZm8gPSBnZXRUaHJvd25JbmZvKHJlcXVlc3QsIHRhc2suY29tcG9uZW50U3RhY2spO1xuICAgIHZhciBlcnJvckRpZ2VzdDtcblxuICAgIHtcbiAgICAgIGVycm9yRGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgdGhyb3duSW5mbyk7XG4gICAgfVxuXG4gICAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShuZXdCb3VuZGFyeSwgZXJyb3JEaWdlc3QsIGVycm9yLCB0aHJvd25JbmZvKTtcbiAgICB1bnRyYWNrQm91bmRhcnkocmVxdWVzdCwgbmV3Qm91bmRhcnkpOyAvLyBXZSBkb24ndCBuZWVkIHRvIGRlY3JlbWVudCBhbnkgdGFzayBudW1iZXJzIGJlY2F1c2Ugd2UgZGlkbid0IHNwYXduIGFueSBuZXcgdGFzay5cbiAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHNjaGVkdWxlIGFueSB0YXNrIGJlY2F1c2Ugd2Uga25vdyB0aGUgcGFyZW50IGhhcyB3cml0dGVuIHlldC5cbiAgICAvLyBXZSBkbyBuZWVkIHRvIGZhbGx0aHJvdWdoIHRvIGNyZWF0ZSB0aGUgZmFsbGJhY2sgdGhvdWdoLlxuICB9IGZpbmFsbHkge1xuICAgIHtcbiAgICAgIHNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0KHJlcXVlc3QucmVuZGVyU3RhdGUsIHBhcmVudEJvdW5kYXJ5ID8gcGFyZW50Qm91bmRhcnkucmVzb3VyY2VzIDogbnVsbCk7XG4gICAgfVxuXG4gICAgdGFzay5ibG9ja2VkQm91bmRhcnkgPSBwYXJlbnRCb3VuZGFyeTtcbiAgICB0YXNrLmJsb2NrZWRTZWdtZW50ID0gcGFyZW50U2VnbWVudDtcbiAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgfVxuXG4gIHZhciBmYWxsYmFja0tleVBhdGggPSBba2V5UGF0aFswXSwgJ1N1c3BlbnNlIEZhbGxiYWNrJywga2V5UGF0aFsyXV07XG4gIHZhciB0cmFja2VkUG9zdHBvbmVzID0gcmVxdWVzdC50cmFja2VkUG9zdHBvbmVzO1xuXG4gIGlmICh0cmFja2VkUG9zdHBvbmVzICE9PSBudWxsKSB7XG4gICAgLy8gV2UgY3JlYXRlIGEgZGV0YWNoZWQgcmVwbGF5IG5vZGUgdG8gdHJhY2sgYW55IHBvc3Rwb25lcyBpbnNpZGUgdGhlIGZhbGxiYWNrLlxuICAgIHZhciBmYWxsYmFja1JlcGxheU5vZGUgPSBbZmFsbGJhY2tLZXlQYXRoWzFdLCBmYWxsYmFja0tleVBhdGhbMl0sIFtdLCBudWxsXTtcbiAgICB0cmFja2VkUG9zdHBvbmVzLndvcmtpbmdNYXAuc2V0KGZhbGxiYWNrS2V5UGF0aCwgZmFsbGJhY2tSZXBsYXlOb2RlKTtcblxuICAgIGlmIChuZXdCb3VuZGFyeS5zdGF0dXMgPT09IFBPU1RQT05FRCkge1xuICAgICAgLy8gVGhpcyBtdXN0IGV4aXN0IG5vdy5cbiAgICAgIHZhciBib3VuZGFyeVJlcGxheU5vZGUgPSB0cmFja2VkUG9zdHBvbmVzLndvcmtpbmdNYXAuZ2V0KGtleVBhdGgpO1xuICAgICAgYm91bmRhcnlSZXBsYXlOb2RlWzRdID0gZmFsbGJhY2tSZXBsYXlOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBtaWdodCBub3QgaW5qZWN0IGl0IGludG8gdGhlIHBvc3Rwb25lZCB0cmVlLCB1bmxlc3MgdGhlIGNvbnRlbnQgYWN0dWFsbHlcbiAgICAgIC8vIHBvc3Rwb25lcyB0b28uIFdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBpdCB1bnRpbCB0aGF0IGhhcHBwZW5zLlxuICAgICAgbmV3Qm91bmRhcnkudHJhY2tlZEZhbGxiYWNrTm9kZSA9IGZhbGxiYWNrUmVwbGF5Tm9kZTtcbiAgICB9XG4gIH0gLy8gV2UgY3JlYXRlIHN1c3BlbmRlZCB0YXNrIGZvciB0aGUgZmFsbGJhY2sgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGFjdHVhbGx5IHdvcmtcbiAgLy8gb24gaXQgeWV0IGluIGNhc2Ugd2UgZmluaXNoIHRoZSBtYWluIGNvbnRlbnQsIHNvIHdlIHF1ZXVlIGZvciBsYXRlci5cblxuXG4gIHZhciBzdXNwZW5kZWRGYWxsYmFja1Rhc2sgPSBjcmVhdGVSZW5kZXJUYXNrKHJlcXVlc3QsIG51bGwsIGZhbGxiYWNrLCAtMSwgcGFyZW50Qm91bmRhcnksIGJvdW5kYXJ5U2VnbWVudCwgZmFsbGJhY2tBYm9ydFNldCwgZmFsbGJhY2tLZXlQYXRoLCB0YXNrLmZvcm1hdENvbnRleHQsIHRhc2subGVnYWN5Q29udGV4dCwgdGFzay5jb250ZXh0LCB0YXNrLnRyZWVDb250ZXh0LCAvLyBUaGlzIHN0YWNrIHNob3VsZCBiZSB0aGUgU3VzcGVuc2UgYm91bmRhcnkgc3RhY2sgYmVjYXVzZSB3aGlsZSB0aGUgZmFsbGJhY2sgaXMgYWN0dWFsbHkgYSBjaGlsZCBzZWdtZW50XG4gIC8vIG9mIHRoZSBwYXJlbnQgYm91bmRhcnkgZnJvbSBhIGNvbXBvbmVudCBzdGFuZHBvaW50IHRoZSBmYWxsYmFjayBpcyBhIGNoaWxkIG9mIHRoZSBTdXNwZW5zZSBib3VuZGFyeSBpdHNlbGZcbiAgc3VzcGVuc2VDb21wb25lbnRTdGFjayk7IC8vIFRPRE86IFRoaXMgc2hvdWxkIGJlIHF1ZXVlZCBhdCBhIHNlcGFyYXRlIGxvd2VyIHByaW9yaXR5IHF1ZXVlIHNvIHRoYXQgd2Ugb25seSB3b3JrXG4gIC8vIG9uIHByZXBhcmluZyBmYWxsYmFja3MgaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBtYWluIGNvbnRlbnQgdG8gdGFzayBvbi5cblxuICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2goc3VzcGVuZGVkRmFsbGJhY2tUYXNrKTtcbn1cblxuZnVuY3Rpb24gcmVwbGF5U3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcm9wcywgaWQsIGNoaWxkTm9kZXMsIGNoaWxkU2xvdHMsIGZhbGxiYWNrTm9kZXMsIGZhbGxiYWNrU2xvdHMpIHtcbiAgdmFyIHByZXZpb3VzQ29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrOyAvLyBJZiB3ZSBlbmQgdXAgY3JlYXRpbmcgdGhlIGZhbGxiYWNrIHRhc2sgd2UgbmVlZCBpdCB0byBoYXZlIHRoZSBjb3JyZWN0IHN0YWNrIHdoaWNoIGlzXG4gIC8vIHRoZSBzdGFjayBmb3IgdGhlIGJvdW5kYXJ5IGl0c2VsZi4gV2Ugc3Rhc2ggaXQgaGVyZSBzbyB3ZSBjYW4gdXNlIGl0IGlmIG5lZWRlZCBsYXRlclxuXG4gIHZhciBzdXNwZW5zZUNvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjayA9IGNyZWF0ZUJ1aWx0SW5Db21wb25lbnRTdGFjayh0YXNrLCAnU3VzcGVuc2UnKTtcbiAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICB2YXIgcHJldmlvdXNSZXBsYXlTZXQgPSB0YXNrLnJlcGxheTtcbiAgdmFyIHBhcmVudEJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnk7XG4gIHZhciBjb250ZW50ID0gcHJvcHMuY2hpbGRyZW47XG4gIHZhciBmYWxsYmFjayA9IHByb3BzLmZhbGxiYWNrO1xuICB2YXIgZmFsbGJhY2tBYm9ydFNldCA9IG5ldyBTZXQoKTtcbiAgdmFyIHJlc3VtZWRCb3VuZGFyeSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgZmFsbGJhY2tBYm9ydFNldCk7XG4gIHJlc3VtZWRCb3VuZGFyeS5wYXJlbnRGbHVzaGVkID0gdHJ1ZTsgLy8gV2UgcmVzdG9yZSB0aGUgc2FtZSBpZCBvZiB0aGlzIGJvdW5kYXJ5IGFzIHdhcyB1c2VkIGR1cmluZyBwcmVyZW5kZXIuXG5cbiAgcmVzdW1lZEJvdW5kYXJ5LnJvb3RTZWdtZW50SUQgPSBpZDsgLy8gV2UgY2FuIHJldXNlIHRoZSBjdXJyZW50IGNvbnRleHQgYW5kIHRhc2sgdG8gcmVuZGVyIHRoZSBjb250ZW50IGltbWVkaWF0ZWx5IHdpdGhvdXRcbiAgLy8gY29udGV4dCBzd2l0Y2hpbmcuIFdlIGp1c3QgbmVlZCB0byB0ZW1wb3JhcmlseSBzd2l0Y2ggd2hpY2ggYm91bmRhcnkgYW5kIHJlcGxheSBub2RlXG4gIC8vIHdlJ3JlIHdyaXRpbmcgdG8uIElmIHNvbWV0aGluZyBzdXNwZW5kcywgaXQnbGwgc3Bhd24gbmV3IHN1c3BlbmRlZCB0YXNrIHdpdGggdGhhdCBjb250ZXh0LlxuXG4gIHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gcmVzdW1lZEJvdW5kYXJ5O1xuICB0YXNrLnJlcGxheSA9IHtcbiAgICBub2RlczogY2hpbGROb2RlcyxcbiAgICBzbG90czogY2hpbGRTbG90cyxcbiAgICBwZW5kaW5nVGFza3M6IDFcbiAgfTtcblxuICB7XG4gICAgc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVxdWVzdC5yZW5kZXJTdGF0ZSwgcmVzdW1lZEJvdW5kYXJ5LnJlc291cmNlcyk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFdlIHVzZSB0aGUgc2FmZSBmb3JtIGJlY2F1c2Ugd2UgZG9uJ3QgaGFuZGxlIHN1c3BlbmRpbmcgaGVyZS4gT25seSBlcnJvciBoYW5kbGluZy5cbiAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNvbnRlbnQsIC0xKTtcblxuICAgIGlmICh0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MgPT09IDEgJiYgdGFzay5yZXBsYXkubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBcIiArIFwiVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCIpO1xuICAgIH1cblxuICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuXG4gICAgaWYgKHJlc3VtZWRCb3VuZGFyeS5wZW5kaW5nVGFza3MgPT09IDAgJiYgcmVzdW1lZEJvdW5kYXJ5LnN0YXR1cyA9PT0gUEVORElORykge1xuICAgICAgLy8gVGhpcyBtdXN0IGhhdmUgYmVlbiB0aGUgbGFzdCBzZWdtZW50IHdlIHdlcmUgd2FpdGluZyBvbi4gVGhpcyBib3VuZGFyeSBpcyBub3cgY29tcGxldGUuXG4gICAgICAvLyBUaGVyZWZvcmUgd2Ugd29uJ3QgbmVlZCB0aGUgZmFsbGJhY2suIFdlIGVhcmx5IHJldHVybiBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY3JlYXRlXG4gICAgICAvLyB0aGUgZmFsbGJhY2suXG4gICAgICByZXN1bWVkQm91bmRhcnkuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2gocmVzdW1lZEJvdW5kYXJ5KTsgLy8gV2UgcmVzdG9yZSB0aGUgcGFyZW50IGNvbXBvbmVudFN0YWNrLiBTZW1hbnRpY2FsbHkgdGhpcyBpcyB0aGUgc2FtZSBhc1xuICAgICAgLy8gcG9wQ29tcG9uZW50U3RhY2sodGFzaykgYnV0IHdlIGRvIHRoaXMgaW5zdGVhZCBiZWNhdXNlIGl0IHNob3VsZCBiZSBzbGlnaHRseVxuICAgICAgLy8gZmFzdGVyXG5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVzdW1lZEJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDtcbiAgICB2YXIgdGhyb3duSW5mbyA9IGdldFRocm93bkluZm8ocmVxdWVzdCwgdGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgdmFyIGVycm9yRGlnZXN0O1xuXG4gICAge1xuICAgICAgZXJyb3JEaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCB0aHJvd25JbmZvKTtcbiAgICB9XG5cbiAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KHJlc3VtZWRCb3VuZGFyeSwgZXJyb3JEaWdlc3QsIGVycm9yLCB0aHJvd25JbmZvKTtcbiAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTsgLy8gVGhlIHBhcmVudCBhbHJlYWR5IGZsdXNoZWQgaW4gdGhlIHByZXJlbmRlciBzbyB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoaXMgdG8gYmUgZW1pdHRlZC5cblxuICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2gocmVzdW1lZEJvdW5kYXJ5KTsgLy8gV2UgZG9uJ3QgbmVlZCB0byBkZWNyZW1lbnQgYW55IHRhc2sgbnVtYmVycyBiZWNhdXNlIHdlIGRpZG4ndCBzcGF3biBhbnkgbmV3IHRhc2suXG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBzY2hlZHVsZSBhbnkgdGFzayBiZWNhdXNlIHdlIGtub3cgdGhlIHBhcmVudCBoYXMgd3JpdHRlbiB5ZXQuXG4gICAgLy8gV2UgZG8gbmVlZCB0byBmYWxsdGhyb3VnaCB0byBjcmVhdGUgdGhlIGZhbGxiYWNrIHRob3VnaC5cbiAgfSBmaW5hbGx5IHtcbiAgICB7XG4gICAgICBzZXRDdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeVJlc291cmNlc1RhcmdldChyZXF1ZXN0LnJlbmRlclN0YXRlLCBwYXJlbnRCb3VuZGFyeSA/IHBhcmVudEJvdW5kYXJ5LnJlc291cmNlcyA6IG51bGwpO1xuICAgIH1cblxuICAgIHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gcGFyZW50Qm91bmRhcnk7XG4gICAgdGFzay5yZXBsYXkgPSBwcmV2aW91c1JlcGxheVNldDtcbiAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgfVxuXG4gIHZhciBmYWxsYmFja0tleVBhdGggPSBba2V5UGF0aFswXSwgJ1N1c3BlbnNlIEZhbGxiYWNrJywga2V5UGF0aFsyXV07IC8vIFdlIGNyZWF0ZSBzdXNwZW5kZWQgdGFzayBmb3IgdGhlIGZhbGxiYWNrIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBhY3R1YWxseSB3b3JrXG4gIC8vIG9uIGl0IHlldCBpbiBjYXNlIHdlIGZpbmlzaCB0aGUgbWFpbiBjb250ZW50LCBzbyB3ZSBxdWV1ZSBmb3IgbGF0ZXIuXG5cbiAgdmFyIGZhbGxiYWNrUmVwbGF5ID0ge1xuICAgIG5vZGVzOiBmYWxsYmFja05vZGVzLFxuICAgIHNsb3RzOiBmYWxsYmFja1Nsb3RzLFxuICAgIHBlbmRpbmdUYXNrczogMFxuICB9O1xuICB2YXIgc3VzcGVuZGVkRmFsbGJhY2tUYXNrID0gY3JlYXRlUmVwbGF5VGFzayhyZXF1ZXN0LCBudWxsLCBmYWxsYmFja1JlcGxheSwgZmFsbGJhY2ssIC0xLCBwYXJlbnRCb3VuZGFyeSwgZmFsbGJhY2tBYm9ydFNldCwgZmFsbGJhY2tLZXlQYXRoLCB0YXNrLmZvcm1hdENvbnRleHQsIHRhc2subGVnYWN5Q29udGV4dCwgdGFzay5jb250ZXh0LCB0YXNrLnRyZWVDb250ZXh0LCAvLyBUaGlzIHN0YWNrIHNob3VsZCBiZSB0aGUgU3VzcGVuc2UgYm91bmRhcnkgc3RhY2sgYmVjYXVzZSB3aGlsZSB0aGUgZmFsbGJhY2sgaXMgYWN0dWFsbHkgYSBjaGlsZCBzZWdtZW50XG4gIC8vIG9mIHRoZSBwYXJlbnQgYm91bmRhcnkgZnJvbSBhIGNvbXBvbmVudCBzdGFuZHBvaW50IHRoZSBmYWxsYmFjayBpcyBhIGNoaWxkIG9mIHRoZSBTdXNwZW5zZSBib3VuZGFyeSBpdHNlbGZcbiAgc3VzcGVuc2VDb21wb25lbnRTdGFjayk7IC8vIFRPRE86IFRoaXMgc2hvdWxkIGJlIHF1ZXVlZCBhdCBhIHNlcGFyYXRlIGxvd2VyIHByaW9yaXR5IHF1ZXVlIHNvIHRoYXQgd2Ugb25seSB3b3JrXG4gIC8vIG9uIHByZXBhcmluZyBmYWxsYmFja3MgaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBtYWluIGNvbnRlbnQgdG8gdGFzayBvbi5cblxuICByZXF1ZXN0LnBpbmdlZFRhc2tzLnB1c2goc3VzcGVuZGVkRmFsbGJhY2tUYXNrKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVySG9zdEVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgdHlwZSwgcHJvcHMpIHtcbiAgdmFyIHByZXZpb3VzQ29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrO1xuICB0YXNrLmNvbXBvbmVudFN0YWNrID0gY3JlYXRlQnVpbHRJbkNvbXBvbmVudFN0YWNrKHRhc2ssIHR5cGUpO1xuICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG5cbiAgaWYgKHNlZ21lbnQgPT09IG51bGwpIHtcbiAgICAvLyBSZXBsYXlcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjsgLy8gVE9ETzogTWFrZSB0aGlzIGEgQ29uZmlnIGZvciByZXBsYXlpbmcuXG5cbiAgICB2YXIgcHJldkNvbnRleHQgPSB0YXNrLmZvcm1hdENvbnRleHQ7XG4gICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IGdldENoaWxkRm9ybWF0Q29udGV4dChwcmV2Q29udGV4dCwgdHlwZSwgcHJvcHMpO1xuICAgIHRhc2sua2V5UGF0aCA9IGtleVBhdGg7IC8vIFdlIHVzZSB0aGUgbm9uLWRlc3RydWN0aXZlIGZvcm0gYmVjYXVzZSBpZiBzb21ldGhpbmcgc3VzcGVuZHMsIHdlIHN0aWxsXG4gICAgLy8gbmVlZCB0byBwb3AgYmFjayB1cCBhbmQgZmluaXNoIHRoaXMgc3VidHJlZSBvZiBIVE1MLlxuXG4gICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpOyAvLyBXZSBleHBlY3QgdGhhdCBlcnJvcnMgd2lsbCBmYXRhbCB0aGUgd2hvbGUgdGFzayBhbmQgdGhhdCB3ZSBkb24ndCBuZWVkXG4gICAgLy8gdGhlIGNvcnJlY3QgY29udGV4dC4gVGhlcmVmb3JlIHRoaXMgaXMgbm90IGluIGEgZmluYWxseS5cblxuICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZDb250ZXh0O1xuICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICB9IGVsc2Uge1xuICAgIC8vIFJlbmRlclxuICAgIHZhciBfY2hpbGRyZW4gPSBwdXNoU3RhcnRJbnN0YW5jZShzZWdtZW50LmNodW5rcywgdHlwZSwgcHJvcHMsIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsIHJlcXVlc3QucmVuZGVyU3RhdGUsIHRhc2suZm9ybWF0Q29udGV4dCwgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCk7XG5cbiAgICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gZmFsc2U7XG4gICAgdmFyIF9wcmV2Q29udGV4dCA9IHRhc2suZm9ybWF0Q29udGV4dDtcbiAgICB2YXIgX3ByZXZLZXlQYXRoMiA9IHRhc2sua2V5UGF0aDtcbiAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBnZXRDaGlsZEZvcm1hdENvbnRleHQoX3ByZXZDb250ZXh0LCB0eXBlLCBwcm9wcyk7XG4gICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDsgLy8gV2UgdXNlIHRoZSBub24tZGVzdHJ1Y3RpdmUgZm9ybSBiZWNhdXNlIGlmIHNvbWV0aGluZyBzdXNwZW5kcywgd2Ugc3RpbGxcbiAgICAvLyBuZWVkIHRvIHBvcCBiYWNrIHVwIGFuZCBmaW5pc2ggdGhpcyBzdWJ0cmVlIG9mIEhUTUwuXG5cbiAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIF9jaGlsZHJlbiwgLTEpOyAvLyBXZSBleHBlY3QgdGhhdCBlcnJvcnMgd2lsbCBmYXRhbCB0aGUgd2hvbGUgdGFzayBhbmQgdGhhdCB3ZSBkb24ndCBuZWVkXG4gICAgLy8gdGhlIGNvcnJlY3QgY29udGV4dC4gVGhlcmVmb3JlIHRoaXMgaXMgbm90IGluIGEgZmluYWxseS5cblxuICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IF9wcmV2Q29udGV4dDtcbiAgICB0YXNrLmtleVBhdGggPSBfcHJldktleVBhdGgyO1xuICAgIHB1c2hFbmRJbnN0YW5jZShzZWdtZW50LmNodW5rcywgdHlwZSwgcHJvcHMsIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsIF9wcmV2Q29udGV4dCk7XG4gICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9IGZhbHNlO1xuICB9XG5cbiAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgcmV0dXJuIENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiByZW5kZXJXaXRoSG9va3MocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICB2YXIgY29tcG9uZW50SWRlbnRpdHkgPSB7fTtcbiAgcHJlcGFyZVRvVXNlSG9va3MocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgY29tcG9uZW50SWRlbnRpdHksIHByZXZUaGVuYWJsZVN0YXRlKTtcbiAgdmFyIHJlc3VsdCA9IENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTtcbiAgcmV0dXJuIGZpbmlzaEhvb2tzKENvbXBvbmVudCwgcHJvcHMsIHJlc3VsdCwgc2Vjb25kQXJnKTtcbn1cblxuZnVuY3Rpb24gZmluaXNoQ2xhc3NDb21wb25lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgaW5zdGFuY2UsIENvbXBvbmVudCwgcHJvcHMpIHtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IGluc3RhbmNlLnJlbmRlcigpO1xuXG4gIHtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IHByb3BzKSB7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgZXJyb3IoJ0l0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiAnICsgJ1RoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ2EgY29tcG9uZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgICBpZiAoY2hpbGRDb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHByZXZpb3VzQ29udGV4dCA9IHRhc2subGVnYWN5Q29udGV4dDtcbiAgICAgIHZhciBtZXJnZWRDb250ZXh0ID0gcHJvY2Vzc0NoaWxkQ29udGV4dChpbnN0YW5jZSwgQ29tcG9uZW50LCBwcmV2aW91c0NvbnRleHQsIGNoaWxkQ29udGV4dFR5cGVzKTtcbiAgICAgIHRhc2subGVnYWN5Q29udGV4dCA9IG1lcmdlZENvbnRleHQ7XG4gICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgbmV4dENoaWxkcmVuLCAtMSk7XG4gICAgICB0YXNrLmxlZ2FjeUNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgbmV4dENoaWxkcmVuLCAtMSk7XG4gIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzc0NvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBDb21wb25lbnQsIHByb3BzKSB7XG4gIHZhciBwcmV2aW91c0NvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgdGFzay5jb21wb25lbnRTdGFjayA9IGNyZWF0ZUNsYXNzQ29tcG9uZW50U3RhY2sodGFzaywgQ29tcG9uZW50KTtcbiAgdmFyIG1hc2tlZENvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KENvbXBvbmVudCwgdGFzay5sZWdhY3lDb250ZXh0KSA7XG4gIHZhciBpbnN0YW5jZSA9IGNvbnN0cnVjdENsYXNzSW5zdGFuY2UoQ29tcG9uZW50LCBwcm9wcywgbWFza2VkQ29udGV4dCk7XG4gIG1vdW50Q2xhc3NJbnN0YW5jZShpbnN0YW5jZSwgQ29tcG9uZW50LCBwcm9wcywgbWFza2VkQ29udGV4dCk7XG4gIGZpbmlzaENsYXNzQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIGluc3RhbmNlLCBDb21wb25lbnQsIHByb3BzKTtcbiAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG59XG5cbnZhciBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xudmFyIGRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9IGZhbHNlO1xudmFyIGRpZFdhcm5BYm91dERlZmF1bHRQcm9wc09uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xudmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IGZhbHNlOyAvLyBUaGlzIHdvdWxkIHR5cGljYWxseSBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCBidXQgd2Ugc3RpbGwgc3VwcG9ydCBtb2R1bGUgcGF0dGVyblxuLy8gY29tcG9uZW50cyBmb3Igc29tZSByZWFzb24uXG5cbmZ1bmN0aW9uIHJlbmRlckluZGV0ZXJtaW5hdGVDb21wb25lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIENvbXBvbmVudCwgcHJvcHMpIHtcbiAgdmFyIGxlZ2FjeUNvbnRleHQ7XG5cbiAge1xuICAgIGxlZ2FjeUNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KENvbXBvbmVudCwgdGFzay5sZWdhY3lDb250ZXh0KTtcbiAgfVxuXG4gIHZhciBwcmV2aW91c0NvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgdGFzay5jb21wb25lbnRTdGFjayA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50U3RhY2sodGFzaywgQ29tcG9uZW50KTtcblxuICB7XG4gICAgaWYgKENvbXBvbmVudC5wcm90b3R5cGUgJiYgdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcihcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFwiICsgJ1RoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCBDb21wb25lbnQsIHByb3BzLCBsZWdhY3lDb250ZXh0KTtcbiAgdmFyIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgdmFyIGZvcm1TdGF0ZUNvdW50ID0gZ2V0Rm9ybVN0YXRlQ291bnQoKTtcbiAgdmFyIGZvcm1TdGF0ZU1hdGNoaW5nSW5kZXggPSBnZXRGb3JtU3RhdGVNYXRjaGluZ0luZGV4KCk7XG5cbiAge1xuICAgIC8vIFN1cHBvcnQgZm9yIG1vZHVsZSBjb21wb25lbnRzIGlzIGRlcHJlY2F0ZWQgYW5kIGlzIHJlbW92ZWQgYmVoaW5kIGEgZmxhZy5cbiAgICAvLyBXaGV0aGVyIG9yIG5vdCBpdCB3b3VsZCBjcmFzaCBsYXRlciwgd2Ugd2FudCB0byBzaG93IGEgZ29vZCBtZXNzYWdlIGluIERFViBmaXJzdC5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZS4gJyArICdDaGFuZ2UgJXMgdG8gYSBjbGFzcyB0aGF0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuICcgKyBcIklmIHlvdSBjYW4ndCB1c2UgYSBjbGFzcyB0cnkgYXNzaWduaW5nIHRoZSBwcm90b3R5cGUgb24gdGhlIGZ1bmN0aW9uIGFzIGEgd29ya2Fyb3VuZC4gXCIgKyBcImAlcy5wcm90b3R5cGUgPSBSZWFjdC5Db21wb25lbnQucHJvdG90eXBlYC4gRG9uJ3QgdXNlIGFuIGFycm93IGZ1bmN0aW9uIHNpbmNlIGl0IFwiICsgJ2Nhbm5vdCBiZSBjYWxsZWQgd2l0aCBgbmV3YCBieSBSZWFjdC4nLCBfY29tcG9uZW50TmFtZSwgX2NvbXBvbmVudE5hbWUsIF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCAvLyBSdW4gdGhlc2UgY2hlY2tzIGluIHByb2R1Y3Rpb24gb25seSBpZiB0aGUgZmxhZyBpcyBvZmYuXG4gIC8vIEV2ZW50dWFsbHkgd2UnbGwgZGVsZXRlIHRoaXMgYnJhbmNoIGFsdG9nZXRoZXIuXG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lMiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIsIF9jb21wb25lbnROYW1lMik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb3VudENsYXNzSW5zdGFuY2UodmFsdWUsIENvbXBvbmVudCwgcHJvcHMsIGxlZ2FjeUNvbnRleHQpO1xuICAgIGZpbmlzaENsYXNzQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHZhbHVlLCBDb21wb25lbnQsIHByb3BzKTtcbiAgfSBlbHNlIHtcblxuICAgIHtcbiAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldihDb21wb25lbnQpO1xuICAgIH1cblxuICAgIGZpbmlzaEZ1bmN0aW9uQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHZhbHVlLCBoYXNJZCwgZm9ybVN0YXRlQ291bnQsIGZvcm1TdGF0ZU1hdGNoaW5nSW5kZXgpO1xuICB9XG5cbiAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaEZ1bmN0aW9uQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIGNoaWxkcmVuLCBoYXNJZCwgZm9ybVN0YXRlQ291bnQsIGZvcm1TdGF0ZU1hdGNoaW5nSW5kZXgpIHtcbiAgdmFyIGRpZEVtaXRGb3JtU3RhdGVNYXJrZXJzID0gZmFsc2U7XG5cbiAgaWYgKGZvcm1TdGF0ZUNvdW50ICE9PSAwICYmIHJlcXVlc3QuZm9ybVN0YXRlICE9PSBudWxsKSB7XG4gICAgLy8gRm9yIGVhY2ggdXNlRm9ybVN0YXRlIGhvb2ssIGVtaXQgYSBtYXJrZXIgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB3ZVxuICAgIC8vIHJlbmRlcmVkIHVzaW5nIHRoZSBmb3JtIHN0YXRlIHBhc3NlZCBhdCB0aGUgcm9vdC4gV2Ugb25seSBlbWl0IHRoZXNlXG4gICAgLy8gbWFya2VycyBpZiBmb3JtIHN0YXRlIGlzIHBhc3NlZCBhdCB0aGUgcm9vdC5cbiAgICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG5cbiAgICBpZiAoc2VnbWVudCA9PT0gbnVsbCkgOyBlbHNlIHtcbiAgICAgIGRpZEVtaXRGb3JtU3RhdGVNYXJrZXJzID0gdHJ1ZTtcbiAgICAgIHZhciB0YXJnZXQgPSBzZWdtZW50LmNodW5rcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JtU3RhdGVDb3VudDsgaSsrKSB7XG4gICAgICAgIGlmIChpID09PSBmb3JtU3RhdGVNYXRjaGluZ0luZGV4KSB7XG4gICAgICAgICAgcHVzaEZvcm1TdGF0ZU1hcmtlcklzTWF0Y2hpbmcodGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoRm9ybVN0YXRlTWFya2VySXNOb3RNYXRjaGluZyh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuXG4gIGlmIChoYXNJZCkge1xuICAgIC8vIFRoaXMgY29tcG9uZW50IG1hdGVyaWFsaXplZCBhbiBpZC4gV2UgdHJlYXQgdGhpcyBhcyBpdHMgb3duIGxldmVsLCB3aXRoXG4gICAgLy8gYSBzaW5nbGUgXCJjaGlsZFwiIHNsb3QuXG4gICAgdmFyIHByZXZUcmVlQ29udGV4dCA9IHRhc2sudHJlZUNvbnRleHQ7XG4gICAgdmFyIHRvdGFsQ2hpbGRyZW4gPSAxO1xuICAgIHZhciBpbmRleCA9IDA7IC8vIE1vZGlmeSB0aGUgaWQgY29udGV4dC4gQmVjYXVzZSB3ZSdsbCBuZWVkIHRvIHJlc2V0IHRoaXMgaWYgc29tZXRoaW5nXG4gICAgLy8gc3VzcGVuZHMgb3IgZXJyb3JzLCB3ZSdsbCB1c2UgdGhlIG5vbi1kZXN0cnVjdGl2ZSByZW5kZXIgcGF0aC5cblxuICAgIHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQocHJldlRyZWVDb250ZXh0LCB0b3RhbENoaWxkcmVuLCBpbmRleCk7XG4gICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgLTEpOyAvLyBMaWtlIHRoZSBvdGhlciBjb250ZXh0cywgdGhpcyBkb2VzIG5vdCBuZWVkIHRvIGJlIGluIGEgZmluYWxseSBibG9ja1xuICAgIC8vIGJlY2F1c2UgcmVuZGVyTm9kZSB0YWtlcyBjYXJlIG9mIHVud2luZGluZyB0aGUgc3RhY2suXG5cbiAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldlRyZWVDb250ZXh0O1xuICB9IGVsc2UgaWYgKGRpZEVtaXRGb3JtU3RhdGVNYXJrZXJzKSB7XG4gICAgLy8gSWYgdGhlcmUgd2VyZSBmb3JtU3RhdGUgaG9va3MsIHdlIG11c3QgdXNlIHRoZSBub24tZGVzdHJ1Y3RpdmUgcGF0aFxuICAgIC8vIGJlY2F1c2UgdGhpcyBjb21wb25lbnQgaXMgbm90IGEgcHVyZSBpbmRpcmVjdGlvbjsgd2UgZW1pdHRlZCBtYXJrZXJzXG4gICAgLy8gdG8gdGhlIHN0cmVhbS5cbiAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UncmUgbm93IHN1Y2Nlc3NmdWxseSBwYXN0IHRoaXMgdGFzaywgYW5kIHdlIGhhdmVuJ3QgbW9kaWZpZWQgdGhlXG4gICAgLy8gY29udGV4dCBzdGFjay4gV2UgZG9uJ3QgaGF2ZSB0byBwb3AgYmFjayB0byB0aGUgcHJldmlvdXMgdGFzayBldmVyeVxuICAgIC8vIGFnYWluLCBzbyB3ZSBjYW4gdXNlIHRoZSBkZXN0cnVjdGl2ZSByZWN1cnNpdmUgZm9ybS5cbiAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgY2hpbGRyZW4sIC0xKTtcbiAgfVxuXG4gIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYoQ29tcG9uZW50KSB7XG4gIHtcbiAgICBpZiAoQ29tcG9uZW50KSB7XG4gICAgICBpZiAoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChDb21wb25lbnQuZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dERlZmF1bHRQcm9wc09uRnVuY3Rpb25Db21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBTdXBwb3J0IGZvciBkZWZhdWx0UHJvcHMgd2lsbCBiZSByZW1vdmVkIGZyb20gZnVuY3Rpb24gY29tcG9uZW50cyAnICsgJ2luIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIFVzZSBKYXZhU2NyaXB0IGRlZmF1bHQgcGFyYW1ldGVycyBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dERlZmF1bHRQcm9wc09uRnVuY3Rpb25Db21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lMyA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4nLCBfY29tcG9uZW50TmFtZTMpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQuY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIENvbXBvbmVudC5jb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lNCA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWU0XSkge1xuICAgICAgICBlcnJvcignJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgY29udGV4dFR5cGUuJywgX2NvbXBvbmVudE5hbWU0KTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWU0XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEZWZhdWx0UHJvcHMoQ29tcG9uZW50LCBiYXNlUHJvcHMpIHtcbiAgaWYgKENvbXBvbmVudCAmJiBDb21wb25lbnQuZGVmYXVsdFByb3BzKSB7XG4gICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzLiBUYWtlbiBmcm9tIFJlYWN0RWxlbWVudFxuICAgIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgYmFzZVByb3BzKTtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gQ29tcG9uZW50LmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG5cbiAgcmV0dXJuIGJhc2VQcm9wcztcbn1cblxuZnVuY3Rpb24gcmVuZGVyRm9yd2FyZFJlZihyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZikge1xuICB2YXIgcHJldmlvdXNDb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2s7XG4gIHRhc2suY29tcG9uZW50U3RhY2sgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFN0YWNrKHRhc2ssIHR5cGUucmVuZGVyKTtcbiAgdmFyIGNoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCB0eXBlLnJlbmRlciwgcHJvcHMsIHJlZik7XG4gIHZhciBoYXNJZCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gIHZhciBmb3JtU3RhdGVDb3VudCA9IGdldEZvcm1TdGF0ZUNvdW50KCk7XG4gIHZhciBmb3JtU3RhdGVNYXRjaGluZ0luZGV4ID0gZ2V0Rm9ybVN0YXRlTWF0Y2hpbmdJbmRleCgpO1xuICBmaW5pc2hGdW5jdGlvbkNvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBjaGlsZHJlbiwgaGFzSWQsIGZvcm1TdGF0ZUNvdW50LCBmb3JtU3RhdGVNYXRjaGluZ0luZGV4KTtcbiAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1lbW8ocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIHR5cGUsIHByb3BzLCByZWYpIHtcbiAgdmFyIGlubmVyVHlwZSA9IHR5cGUudHlwZTtcbiAgdmFyIHJlc29sdmVkUHJvcHMgPSByZXNvbHZlRGVmYXVsdFByb3BzKGlubmVyVHlwZSwgcHJvcHMpO1xuICByZW5kZXJFbGVtZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCBpbm5lclR5cGUsIHJlc29sdmVkUHJvcHMsIHJlZik7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNvbnRleHRDb25zdW1lcihyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBjb250ZXh0LCBwcm9wcykge1xuICAvLyBUaGUgbG9naWMgYmVsb3cgZm9yIENvbnRleHQgZGlmZmVycyBkZXBlbmRpbmcgb24gUFJPRCBvciBERVYgbW9kZS4gSW5cbiAgLy8gREVWIG1vZGUsIHdlIGNyZWF0ZSBhIHNlcGFyYXRlIG9iamVjdCBmb3IgQ29udGV4dC5Db25zdW1lciB0aGF0IGFjdHNcbiAgLy8gbGlrZSBhIHByb3h5IHRvIENvbnRleHQuIFRoaXMgcHJveHkgb2JqZWN0IGFkZHMgdW5uZWNlc3NhcnkgY29kZSBpbiBQUk9EXG4gIC8vIHNvIHdlIHVzZSB0aGUgb2xkIGJlaGF2aW91ciAoQ29udGV4dC5Db25zdW1lciByZWZlcmVuY2VzIENvbnRleHQpIHRvXG4gIC8vIHJlZHVjZSBzaXplIGFuZCBvdmVyaGVhZC4gVGhlIHNlcGFyYXRlIG9iamVjdCByZWZlcmVuY2VzIGNvbnRleHQgdmlhXG4gIC8vIGEgcHJvcGVydHkgY2FsbGVkIFwiX2NvbnRleHRcIiwgd2hpY2ggYWxzbyBnaXZlcyB1cyB0aGUgYWJpbGl0eSB0byBjaGVja1xuICAvLyBpbiBERVYgbW9kZSBpZiB0aGlzIHByb3BlcnR5IGV4aXN0cyBvciBub3QgYW5kIHdhcm4gaWYgaXQgZG9lcyBub3QuXG4gIHtcbiAgICBpZiAoY29udGV4dC5fY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGlzIG1heSBiZSBiZWNhdXNlIGl0J3MgYSBDb250ZXh0IChyYXRoZXIgdGhhbiBhIENvbnN1bWVyKS5cbiAgICAgIC8vIE9yIGl0IG1heSBiZSBiZWNhdXNlIGl0J3Mgb2xkZXIgUmVhY3Qgd2hlcmUgdGhleSdyZSB0aGUgc2FtZSB0aGluZy5cbiAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB3YXJuIGlmIHdlJ3JlIHN1cmUgaXQncyBhIG5ldyBSZWFjdC5cbiAgICAgIGlmIChjb250ZXh0ICE9PSBjb250ZXh0LkNvbnN1bWVyKSB7XG4gICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyKSB7XG4gICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQ+IGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IGNvbnRleHQuX2NvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlbmRlciA9IHByb3BzLmNoaWxkcmVuO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0EgY29udGV4dCBjb25zdW1lciB3YXMgcmVuZGVyZWQgd2l0aCBtdWx0aXBsZSBjaGlsZHJlbiwgb3IgYSBjaGlsZCAnICsgXCJ0aGF0IGlzbid0IGEgZnVuY3Rpb24uIEEgY29udGV4dCBjb25zdW1lciBleHBlY3RzIGEgc2luZ2xlIGNoaWxkIFwiICsgJ3RoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSAnICsgJ2lzIG5vIHRyYWlsaW5nIG9yIGxlYWRpbmcgd2hpdGVzcGFjZSBhcm91bmQgaXQuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld1ZhbHVlID0gcmVhZENvbnRleHQkMShjb250ZXh0KTtcbiAgdmFyIG5ld0NoaWxkcmVuID0gcmVuZGVyKG5ld1ZhbHVlKTtcbiAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgbmV3Q2hpbGRyZW4sIC0xKTtcbiAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNvbnRleHRQcm92aWRlcihyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBwcm9wcykge1xuICB2YXIgY29udGV4dCA9IHR5cGUuX2NvbnRleHQ7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgdmFyIHByZXZTbmFwc2hvdDtcblxuICB7XG4gICAgcHJldlNuYXBzaG90ID0gdGFzay5jb250ZXh0O1xuICB9XG5cbiAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICB0YXNrLmNvbnRleHQgPSBwdXNoUHJvdmlkZXIoY29udGV4dCwgdmFsdWUpO1xuICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgY2hpbGRyZW4sIC0xKTtcbiAgdGFzay5jb250ZXh0ID0gcG9wUHJvdmlkZXIoY29udGV4dCk7XG4gIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuXG4gIHtcbiAgICBpZiAocHJldlNuYXBzaG90ICE9PSB0YXNrLmNvbnRleHQpIHtcbiAgICAgIGVycm9yKCdQb3BwaW5nIHRoZSBjb250ZXh0IHByb3ZpZGVyIGRpZCBub3QgcmV0dXJuIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHNuYXBzaG90LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJMYXp5Q29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCBsYXp5Q29tcG9uZW50LCBwcm9wcywgcmVmKSB7XG4gIHZhciBwcmV2aW91c0NvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgdGFzay5jb21wb25lbnRTdGFjayA9IGNyZWF0ZUJ1aWx0SW5Db21wb25lbnRTdGFjayh0YXNrLCAnTGF6eScpO1xuICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgdmFyIENvbXBvbmVudCA9IGluaXQocGF5bG9hZCk7XG4gIHZhciByZXNvbHZlZFByb3BzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQsIHByb3BzKTtcbiAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZWYpO1xuICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbn1cblxuZnVuY3Rpb24gcmVuZGVyT2Zmc2NyZWVuKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByb3BzKSB7XG4gIHZhciBtb2RlID0gcHJvcHMubW9kZTtcblxuICBpZiAobW9kZSA9PT0gJ2hpZGRlbicpIDsgZWxzZSB7XG4gICAgLy8gQSB2aXNpYmxlIE9mZnNjcmVlbiBib3VuZGFyeSBpcyB0cmVhdGVkIGV4YWN0bHkgbGlrZSBhIGZyYWdtZW50OiBhXG4gICAgLy8gcHVyZSBpbmRpcmVjdGlvbi5cbiAgICB2YXIgcHJldktleVBhdGggPSB0YXNrLmtleVBhdGg7XG4gICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgcHJvcHMuY2hpbGRyZW4sIC0xKTtcbiAgICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJFbGVtZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCB0eXBlLCBwcm9wcywgcmVmKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChzaG91bGRDb25zdHJ1Y3QodHlwZSkpIHtcbiAgICAgIHJlbmRlckNsYXNzQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHR5cGUsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVySW5kZXRlcm1pbmF0ZUNvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZW5kZXJIb3N0RWxlbWVudChyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBwcm9wcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgLy8gTGVnYWN5SGlkZGVuIGFjdHMgdGhlIHNhbWUgYXMgYSBmcmFnbWVudC4gVGhpcyBvbmx5IHdvcmtzIGJlY2F1c2Ugd2VcbiAgICAvLyBjdXJyZW50bHkgYXNzdW1lIHRoYXQgZXZlcnkgaW5zdGFuY2Ugb2YgTGVnYWN5SGlkZGVuIGlzIGFjY29tcGFuaWVkIGJ5IGFcbiAgICAvLyBob3N0IGNvbXBvbmVudCB3cmFwcGVyLiBJbiB0aGUgaGlkZGVuIG1vZGUsIHRoZSBob3N0IGNvbXBvbmVudCBpcyBnaXZlbiBhXG4gICAgLy8gYGhpZGRlbmAgYXR0cmlidXRlLCB3aGljaCBlbnN1cmVzIHRoYXQgdGhlIGluaXRpYWwgSFRNTCBpcyBub3QgdmlzaWJsZS5cbiAgICAvLyBUbyBzdXBwb3J0IHRoZSB1c2Ugb2YgTGVnYWN5SGlkZGVuIGFzIGEgdHJ1ZSBmcmFnbWVudCwgd2l0aG91dCBhbiBleHRyYVxuICAgIC8vIERPTSBub2RlLCB3ZSB3b3VsZCBoYXZlIHRvIGhpZGUgdGhlIGluaXRpYWwgSFRNTCBpbiBzb21lIG90aGVyIHdheS5cbiAgICAvLyBUT0RPOiBEZWxldGUgaW4gTGVnYWN5SGlkZGVuLiBJdCdzIGFuIHVuc3RhYmxlIEFQSSBvbmx5IHVzZWQgaW4gdGhlXG4gICAgLy8gd3d3IGJ1aWxkLiBBcyBhIG1pZ3JhdGlvbiBzdGVwLCB3ZSBjb3VsZCBhZGQgYSBzcGVjaWFsIHByb3AgdG8gT2Zmc2NyZWVuXG4gICAgLy8gdGhhdCBzaW11bGF0ZXMgdGhlIG9sZCBiZWhhdmlvciAobm8gaGlkaW5nLCBubyBjaGFuZ2UgdG8gZWZmZWN0cykuXG4gICAgY2FzZSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEU6XG4gICAgY2FzZSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRTpcbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoO1xuICAgICAgICB0YXNrLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgcHJvcHMuY2hpbGRyZW4sIC0xKTtcbiAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJlbmRlck9mZnNjcmVlbihyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcm9wcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAge1xuICAgICAgICB2YXIgcHJlaW91c0NvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IGNyZWF0ZUJ1aWx0SW5Db21wb25lbnRTdGFjayh0YXNrLCAnU3VzcGVuc2VMaXN0Jyk7IC8vIFRPRE86IFN1c3BlbnNlTGlzdCBzaG91bGQgY29udHJvbCB0aGUgYm91bmRhcmllcy5cblxuICAgICAgICB2YXIgX3ByZXZLZXlQYXRoMyA9IHRhc2sua2V5UGF0aDtcbiAgICAgICAgdGFzay5rZXlQYXRoID0ga2V5UGF0aDtcbiAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIHByb3BzLmNoaWxkcmVuLCAtMSk7XG4gICAgICAgIHRhc2sua2V5UGF0aCA9IF9wcmV2S2V5UGF0aDM7XG4gICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmVpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgUkVBQ1RfU0NPUEVfVFlQRTpcbiAgICAgIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0RE9NU2VydmVyIGRvZXMgbm90IHlldCBzdXBwb3J0IHNjb3BlIGNvbXBvbmVudHMuJyk7XG4gICAgICB9XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJTdXNwZW5zZUJvdW5kYXJ5KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmVuZGVyRm9yd2FyZFJlZihyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmVuZGVyTWVtbyhyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcmV2VGhlbmFibGVTdGF0ZSwgdHlwZSwgcHJvcHMsIHJlZik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHJlbmRlckNvbnRleHRQcm92aWRlcihyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmVuZGVyQ29udGV4dENvbnN1bWVyKHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJMYXp5Q29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGluZm8gPSAnJztcblxuICB7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIFwiICsgJ25hbWVkIGltcG9ydHMuJztcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluICcgKyAnY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSAnICsgKFwiYnV0IGdvdDogXCIgKyAodHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlKSArIFwiLlwiICsgaW5mbykpO1xufVxuXG5mdW5jdGlvbiByZXN1bWVOb2RlKHJlcXVlc3QsIHRhc2ssIHNlZ21lbnRJZCwgbm9kZSwgY2hpbGRJbmRleCkge1xuICB2YXIgcHJldlJlcGxheSA9IHRhc2sucmVwbGF5O1xuICB2YXIgYmxvY2tlZEJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnk7XG4gIHZhciByZXN1bWVkU2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KHJlcXVlc3QsIDAsIG51bGwsIHRhc2suZm9ybWF0Q29udGV4dCwgZmFsc2UsIGZhbHNlKTtcbiAgcmVzdW1lZFNlZ21lbnQuaWQgPSBzZWdtZW50SWQ7XG4gIHJlc3VtZWRTZWdtZW50LnBhcmVudEZsdXNoZWQgPSB0cnVlO1xuXG4gIHRyeSB7XG4gICAgLy8gQ29udmVydCB0aGUgY3VycmVudCBSZXBsYXlUYXNrIHRvIGEgUmVuZGVyVGFzay5cbiAgICB2YXIgcmVuZGVyVGFzayA9IHRhc2s7XG4gICAgcmVuZGVyVGFzay5yZXBsYXkgPSBudWxsO1xuICAgIHJlbmRlclRhc2suYmxvY2tlZFNlZ21lbnQgPSByZXN1bWVkU2VnbWVudDtcbiAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgIHJlc3VtZWRTZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRDtcblxuICAgIGlmIChibG9ja2VkQm91bmRhcnkgPT09IG51bGwpIHtcbiAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQgPSByZXN1bWVkU2VnbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJsb2NrZWRCb3VuZGFyeSwgcmVzdW1lZFNlZ21lbnQpO1xuXG4gICAgICBpZiAoYmxvY2tlZEJvdW5kYXJ5LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcy5wdXNoKGJsb2NrZWRCb3VuZGFyeSk7XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIC8vIFJlc3RvcmUgdG8gYSBSZXBsYXlUYXNrLlxuICAgIHRhc2sucmVwbGF5ID0gcHJldlJlcGxheTtcbiAgICB0YXNrLmJsb2NrZWRTZWdtZW50ID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYXlFbGVtZW50KHJlcXVlc3QsIHRhc2ssIGtleVBhdGgsIHByZXZUaGVuYWJsZVN0YXRlLCBuYW1lLCBrZXlPckluZGV4LCBjaGlsZEluZGV4LCB0eXBlLCBwcm9wcywgcmVmLCByZXBsYXkpIHtcbiAgLy8gV2UncmUgcmVwbGF5aW5nLiBGaW5kIHRoZSBwYXRoIHRvIGZvbGxvdy5cbiAgdmFyIHJlcGxheU5vZGVzID0gcmVwbGF5Lm5vZGVzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwbGF5Tm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCByZWZpbmVtZW50IG9uIHR1cGxlcyBzbyB3ZSBkbyBpdCBtYW51YWxseSBoZXJlLlxuICAgIHZhciBub2RlID0gcmVwbGF5Tm9kZXNbaV07XG5cbiAgICBpZiAoa2V5T3JJbmRleCAhPT0gbm9kZVsxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUubGVuZ3RoID09PSA0KSB7XG4gICAgICAvLyBNYXRjaGVkIGEgcmVwbGF5YWJsZSBwYXRoLlxuICAgICAgLy8gTGV0J3MgZG91YmxlIGNoZWNrIHRoYXQgdGhlIGNvbXBvbmVudCBuYW1lIG1hdGNoZXMgYXMgYSBwcmVjYXV0aW9uLlxuICAgICAgaWYgKG5hbWUgIT09IG51bGwgJiYgbmFtZSAhPT0gbm9kZVswXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSByZXN1bWUgdG8gcmVuZGVyIDwnICsgbm9kZVswXSArICc+IGluIHRoaXMgc2xvdCBidXQgaW5zdGVhZCBpdCByZW5kZXJlZCA8JyArIG5hbWUgKyAnPi4gJyArIFwiVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGROb2RlcyA9IG5vZGVbMl07XG4gICAgICB2YXIgY2hpbGRTbG90cyA9IG5vZGVbM107XG4gICAgICB2YXIgY3VycmVudE5vZGUgPSB0YXNrLm5vZGU7XG4gICAgICB0YXNrLnJlcGxheSA9IHtcbiAgICAgICAgbm9kZXM6IGNoaWxkTm9kZXMsXG4gICAgICAgIHNsb3RzOiBjaGlsZFNsb3RzLFxuICAgICAgICBwZW5kaW5nVGFza3M6IDFcbiAgICAgIH07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIHR5cGUsIHByb3BzLCByZWYpO1xuXG4gICAgICAgIGlmICh0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MgPT09IDEgJiYgdGFzay5yZXBsYXkubm9kZXMubGVuZ3RoID4gMCAvLyBUT0RPIGNoZWNrIHJlbWFpbmluZyBzbG90c1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYWxsIHJlc3VtYWJsZSBzbG90cyBieSBrZXkvaW5kZXggZHVyaW5nIHJlcGxheWluZy4gXCIgKyBcIlRoZSB0cmVlIGRvZXNuJ3QgbWF0Y2ggc28gUmVhY3Qgd2lsbCBmYWxsYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCAmJiAoeCA9PT0gU3VzcGVuc2VFeGNlcHRpb24gfHwgdHlwZW9mIHgudGhlbiA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAvLyBTdXNwZW5kXG4gICAgICAgICAgaWYgKHRhc2subm9kZSA9PT0gY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgc2FtZSBlbGVtZW50IHN1c3BlbmRlZCBzbyB3ZSBuZWVkIHRvIHBvcCB0aGUgcmVwbGF5IHdlIGp1c3QgYWRkZWQuXG4gICAgICAgICAgICB0YXNrLnJlcGxheSA9IHJlcGxheTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyB4O1xuICAgICAgICB9XG5cbiAgICAgICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07IC8vIFVubGlrZSByZWd1bGFyIHJlbmRlciwgd2UgZG9uJ3QgdGVybWluYXRlIHRoZSBzaWJsaW5ncyBpZiB3ZSBlcnJvclxuICAgICAgICAvLyBkdXJpbmcgYSByZXBsYXkuIFRoYXQncyBiZWNhdXNlIHRoaXMgY29tcG9uZW50IGRpZG4ndCBhY3R1YWxseSBlcnJvclxuICAgICAgICAvLyBpbiB0aGUgb3JpZ2luYWwgcHJlcmVuZGVyLiBXaGF0J3MgdW5hYmxlIHRvIGNvbXBsZXRlIGlzIHRoZSBjaGlsZFxuICAgICAgICAvLyByZXBsYXkgbm9kZXMgd2hpY2ggbWlnaHQgYmUgU3VzcGVuc2UgYm91bmRhcmllcyB3aGljaCBhcmUgYWJsZSB0b1xuICAgICAgICAvLyBhYnNvcmIgdGhlIGVycm9yIGFuZCB3ZSBjYW4gc3RpbGwgY29udGludWUgd2l0aCBzaWJsaW5ncy5cblxuICAgICAgICB2YXIgdGhyb3duSW5mbyA9IGdldFRocm93bkluZm8ocmVxdWVzdCwgdGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgICAgIGVycm9yZWRSZXBsYXkocmVxdWVzdCwgdGFzay5ibG9ja2VkQm91bmRhcnksIHgsIHRocm93bkluZm8sIGNoaWxkTm9kZXMsIGNoaWxkU2xvdHMpO1xuICAgICAgfVxuXG4gICAgICB0YXNrLnJlcGxheSA9IHJlcGxheTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGV0J3MgZG91YmxlIGNoZWNrIHRoYXQgdGhlIGNvbXBvbmVudCB0eXBlIG1hdGNoZXMuXG4gICAgICBpZiAodHlwZSAhPT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRUeXBlID0gJ1N1c3BlbnNlJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgcmVzdW1lIHRvIHJlbmRlciA8JyArIGV4cGVjdGVkVHlwZSArICc+IGluIHRoaXMgc2xvdCBidXQgaW5zdGVhZCBpdCByZW5kZXJlZCA8JyArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nKSArICc+LiAnICsgXCJUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIik7XG4gICAgICB9IC8vIE1hdGNoZWQgYSByZXBsYXlhYmxlIHBhdGguXG5cblxuICAgICAgcmVwbGF5U3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCB0YXNrLCBrZXlQYXRoLCBwcm9wcywgbm9kZVs1XSwgbm9kZVsyXSwgbm9kZVszXSwgbm9kZVs0XSA9PT0gbnVsbCA/IFtdIDogbm9kZVs0XVsyXSwgbm9kZVs0XSA9PT0gbnVsbCA/IG51bGwgOiBub2RlWzRdWzNdKTtcbiAgICB9IC8vIFdlIGZpbmlzaGVkIHJlbmRlcmluZyB0aGlzIG5vZGUsIHNvIG5vdyB3ZSBjYW4gY29uc3VtZSB0aGlzXG4gICAgLy8gc2xvdC4gVGhpcyBtdXN0IGhhcHBlbiBhZnRlciBpbiBjYXNlIHdlIHJlcmVuZGVyIHRoaXMgdGFzay5cblxuXG4gICAgcmVwbGF5Tm9kZXMuc3BsaWNlKGksIDEpO1xuICAgIHJldHVybjtcbiAgfSAvLyBXZSBkaWRuJ3QgZmluZCBhbnkgbWF0Y2hpbmcgbm9kZXMuIFdlIGFzc3VtZSB0aGF0IHRoaXMgZWxlbWVudCB3YXMgYWxyZWFkeVxuICAvLyByZW5kZXJlZCBpbiB0aGUgcHJlbHVkZSBhbmQgc2tpcCBpdC5cblxufSAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVJdGVyYWJsZShpdGVyYWJsZSwgaXRlcmF0b3JGbikge1xuICB7XG4gICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCByZW5kZXJpbmcgR2VuZXJhdG9ycyBiZWNhdXNlIGl0J3MgYSBtdXRhdGlvbi5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjk5NVxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIGl0ZXJhYmxlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdHZW5lcmF0b3InKSB7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEdlbmVyYXRvcnMpIHtcbiAgICAgICAgZXJyb3IoJ1VzaW5nIEdlbmVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gJyArICdZb3UgbWF5IGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBgQXJyYXkuZnJvbSgpYCBvciB0aGUgJyArICdgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIEtlZXAgaW4gbWluZCAnICsgJ3lvdSBtaWdodCBuZWVkIHRvIHBvbHlmaWxsIHRoZXNlIGZlYXR1cmVzIGZvciBvbGRlciBicm93c2Vycy4nKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IHRydWU7XG4gICAgfSAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cblxuXG4gICAgaWYgKGl0ZXJhYmxlLmVudHJpZXMgPT09IGl0ZXJhdG9yRm4pIHtcbiAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICBlcnJvcignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgIH1cbiAgfVxufSAvLyBUaGlzIGZ1bmN0aW9uIGJ5IGl0IHNlbGYgcmVuZGVycyBhIG5vZGUgYW5kIGNvbnN1bWVzIHRoZSB0YXNrIGJ5IG11dGF0aW5nIGl0XG4vLyB0byB1cGRhdGUgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIHN0YXRlLlxuXG5cbmZ1bmN0aW9uIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCAvLyBUaGUgdGhlbmFibGUgc3RhdGUgcmV1c2VkIGZyb20gdGhlIHByZXZpb3VzIGF0dGVtcHQsIGlmIGFueS4gVGhpcyBpcyBhbG1vc3Rcbi8vIGFsd2F5cyBudWxsLCBleGNlcHQgd2hlbiBjYWxsZWQgYnkgcmV0cnlUYXNrLlxucHJldlRoZW5hYmxlU3RhdGUsIG5vZGUsIGNoaWxkSW5kZXgpIHtcbiAgaWYgKHRhc2sucmVwbGF5ICE9PSBudWxsICYmIHR5cGVvZiB0YXNrLnJlcGxheS5zbG90cyA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IGEgY2hlYXBlciBwbGFjZSB0aGFuIHRoaXMgaG90IHBhdGggdG8gZG8gdGhpcyBjaGVjay5cbiAgICB2YXIgcmVzdW1lU2VnbWVudElEID0gdGFzay5yZXBsYXkuc2xvdHM7XG4gICAgcmVzdW1lTm9kZShyZXF1ZXN0LCB0YXNrLCByZXN1bWVTZWdtZW50SUQsIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgIHJldHVybjtcbiAgfSAvLyBTdGFzaCB0aGUgbm9kZSB3ZSdyZSB3b3JraW5nIG9uLiBXZSdsbCBwaWNrIHVwIGZyb20gdGhpcyB0YXNrIGluIGNhc2VcbiAgLy8gc29tZXRoaW5nIHN1c3BlbmRzLlxuXG5cbiAgdGFzay5ub2RlID0gbm9kZTtcbiAgdGFzay5jaGlsZEluZGV4ID0gY2hpbGRJbmRleDsgLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuXG4gIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZSAhPT0gbnVsbCkge1xuICAgIHN3aXRjaCAobm9kZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IG5vZGU7XG4gICAgICAgICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgICAgICAgIHZhciBwcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gICAgICAgICAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAgICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICAgIHZhciBrZXlPckluZGV4ID0ga2V5ID09IG51bGwgPyBjaGlsZEluZGV4ID09PSAtMSA/IDAgOiBjaGlsZEluZGV4IDoga2V5O1xuICAgICAgICAgIHZhciBrZXlQYXRoID0gW3Rhc2sua2V5UGF0aCwgbmFtZSwga2V5T3JJbmRleF07XG5cbiAgICAgICAgICBpZiAodGFzay5yZXBsYXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlcGxheUVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIG5hbWUsIGtleU9ySW5kZXgsIGNoaWxkSW5kZXgsIHR5cGUsIHByb3BzLCByZWYsIHRhc2sucmVwbGF5KTsgLy8gTm8gbWF0Y2hlcyBmb3VuZCBmb3IgdGhpcyBub2RlLiBXZSBhc3N1bWUgaXQncyBhbHJlYWR5IGVtaXR0ZWQgaW4gdGhlXG4gICAgICAgICAgICAvLyBwcmVsdWRlIGFuZCBza2lwIGl0IGR1cmluZyB0aGUgcmVwbGF5LlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBkb2luZyBhIHBsYWluIHJlbmRlci5cbiAgICAgICAgICAgIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywga2V5UGF0aCwgcHJldlRoZW5hYmxlU3RhdGUsIHR5cGUsIHByb3BzLCByZWYpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnRhbHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHRoZSBzZXJ2ZXIgcmVuZGVyZXIuICcgKyAnUmVuZGVyIHRoZW0gY29uZGl0aW9uYWxseSBzbyB0aGF0IHRoZXkgb25seSBhcHBlYXIgb24gdGhlIGNsaWVudCByZW5kZXIuJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzQ29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrO1xuICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBjcmVhdGVCdWlsdEluQ29tcG9uZW50U3RhY2sodGFzaywgJ0xhenknKTtcbiAgICAgICAgICB2YXIgbGF6eU5vZGUgPSBub2RlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eU5vZGUuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Tm9kZS5faW5pdDtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWROb2RlID0gaW5pdChwYXlsb2FkKTsgLy8gV2UgcmVzdG9yZSB0aGUgc3RhY2sgYmVmb3JlIHJlbmRlcmluZyB0aGUgcmVzb2x2ZWQgbm9kZSBiZWNhdXNlIG9uY2UgdGhlIExhenlcbiAgICAgICAgICAvLyBoYXMgcmVzb2x2ZWQgYW55IGZ1dHVyZSBlcnJvcnNcblxuICAgICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrOyAvLyBOb3cgd2UgcmVuZGVyIHRoZSByZXNvbHZlZCBub2RlXG5cbiAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbnVsbCwgcmVzb2x2ZWROb2RlLCBjaGlsZEluZGV4KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAge1xuICAgICAgICB2YWxpZGF0ZUl0ZXJhYmxlKG5vZGUsIGl0ZXJhdG9yRm4pO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG5cbiAgICAgIGlmIChpdGVyYXRvcikge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGtub3cgaG93IG1hbnkgdG90YWwgY2hpbGRyZW4gYXJlIGluIHRoaXMgc2V0LCBzbyB0aGF0IHdlXG4gICAgICAgIC8vIGNhbiBhbGxvY2F0ZSBlbm91Z2ggaWQgc2xvdHMgdG8gYWNvbW1vZGF0ZSB0aGVtLiBTbyB3ZSBtdXN0IGV4aGF1c3RcbiAgICAgICAgLy8gdGhlIGl0ZXJhdG9yIGJlZm9yZSB3ZSBzdGFydCByZWN1cnNpdmVseSByZW5kZXJpbmcgdGhlIGNoaWxkcmVuLlxuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIG5vdCBncmVhdCBidXQgSSB0aGluayBpdCdzIGluaGVyZW50IHRvIHRoZSBpZFxuICAgICAgICAvLyBnZW5lcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7IC8vIElmIHRoZXJlIGFyZSBub3QgZW50cmllcywgd2UgbmVlZCB0byBwdXNoIGFuIGVtcHR5IHNvIHdlIHN0YXJ0IGJ5IGNoZWNraW5nIHRoYXQuXG5cbiAgICAgICAgaWYgKCFzdGVwLmRvbmUpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICAgICAgICBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIH0gd2hpbGUgKCFzdGVwLmRvbmUpO1xuXG4gICAgICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgY2hpbGRJbmRleCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gLy8gVXNhYmxlcyBhcmUgYSB2YWxpZCBSZWFjdCBub2RlIHR5cGUuIFdoZW4gUmVhY3QgZW5jb3VudGVycyBhIFVzYWJsZSBpblxuICAgIC8vIGEgY2hpbGQgcG9zaXRpb24sIGl0IHVud3JhcHMgaXQgdXNpbmcgdGhlIHNhbWUgYWxnb3JpdGhtIGFzIGB1c2VgLiBGb3JcbiAgICAvLyBleGFtcGxlLCBmb3IgcHJvbWlzZXMsIFJlYWN0IHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIHRvIHVud2luZCB0aGVcbiAgICAvLyBzdGFjaywgdGhlbiByZXBsYXkgdGhlIGNvbXBvbmVudCBvbmNlIHRoZSBwcm9taXNlIHJlc29sdmVzLlxuICAgIC8vXG4gICAgLy8gQSBkaWZmZXJlbmNlIGZyb20gYHVzZWAgaXMgdGhhdCBSZWFjdCB3aWxsIGtlZXAgdW53cmFwcGluZyB0aGUgdmFsdWVcbiAgICAvLyB1bnRpbCBpdCByZWFjaGVzIGEgbm9uLVVzYWJsZSB0eXBlLlxuICAgIC8vXG4gICAgLy8gZS5nLiBVc2FibGU8VXNhYmxlPFVzYWJsZTxUPj4+IHNob3VsZCByZXNvbHZlIHRvIFRcblxuXG4gICAgdmFyIG1heWJlVXNhYmxlID0gbm9kZTtcblxuICAgIGlmICh0eXBlb2YgbWF5YmVVc2FibGUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRoZW5hYmxlID0gbWF5YmVVc2FibGU7XG4gICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIHVud3JhcFRoZW5hYmxlKHRoZW5hYmxlKSwgY2hpbGRJbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKG1heWJlVXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgbWF5YmVVc2FibGUuJCR0eXBlb2YgPT09IFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gbWF5YmVVc2FibGU7XG4gICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIHJlYWRDb250ZXh0JDEoY29udGV4dCksIGNoaWxkSW5kZXgpO1xuICAgIH0gLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuXG5cbiAgICB2YXIgY2hpbGRTdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobm9kZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZFN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5vZGUpLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZFN0cmluZykgKyBcIikuIFwiICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcblxuICAgIGlmIChzZWdtZW50ID09PSBudWxsKSA7IGVsc2Uge1xuICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9IHB1c2hUZXh0SW5zdGFuY2Uoc2VnbWVudC5jaHVua3MsIG5vZGUsIHJlcXVlc3QucmVuZGVyU3RhdGUsIHNlZ21lbnQubGFzdFB1c2hlZFRleHQpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgX3NlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuXG4gICAgaWYgKF9zZWdtZW50ID09PSBudWxsKSA7IGVsc2Uge1xuICAgICAgX3NlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBwdXNoVGV4dEluc3RhbmNlKF9zZWdtZW50LmNodW5rcywgJycgKyBub2RlLCByZXF1ZXN0LnJlbmRlclN0YXRlLCBfc2VnbWVudC5sYXN0UHVzaGVkVGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LicpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYXlGcmFnbWVudChyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgY2hpbGRJbmRleCkge1xuICAvLyBJZiB3ZSdyZSBzdXBwb3NlZCBmb2xsb3cgdGhpcyBhcnJheSwgd2UnZCBleHBlY3QgdG8gc2VlIGEgUmVwbGF5Tm9kZSBtYXRjaGluZ1xuICAvLyB0aGlzIGZyYWdtZW50LlxuICB2YXIgcmVwbGF5ID0gdGFzay5yZXBsYXk7XG4gIHZhciByZXBsYXlOb2RlcyA9IHJlcGxheS5ub2RlcztcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IHJlcGxheU5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIG5vZGUgPSByZXBsYXlOb2Rlc1tqXTtcblxuICAgIGlmIChub2RlWzFdICE9PSBjaGlsZEluZGV4KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIE1hdGNoZWQgYSByZXBsYXlhYmxlIHBhdGguXG5cblxuICAgIHZhciBjaGlsZE5vZGVzID0gbm9kZVsyXTtcbiAgICB2YXIgY2hpbGRTbG90cyA9IG5vZGVbM107XG4gICAgdGFzay5yZXBsYXkgPSB7XG4gICAgICBub2RlczogY2hpbGROb2RlcyxcbiAgICAgIHNsb3RzOiBjaGlsZFNsb3RzLFxuICAgICAgcGVuZGluZ1Rhc2tzOiAxXG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICByZW5kZXJDaGlsZHJlbkFycmF5KHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCAtMSk7XG5cbiAgICAgIGlmICh0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MgPT09IDEgJiYgdGFzay5yZXBsYXkubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGFsbCByZXN1bWFibGUgc2xvdHMgYnkga2V5L2luZGV4IGR1cmluZyByZXBsYXlpbmcuIFwiICsgXCJUaGUgdHJlZSBkb2Vzbid0IG1hdGNoIHNvIFJlYWN0IHdpbGwgZmFsbGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cIik7XG4gICAgICB9XG5cbiAgICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCAmJiAoeCA9PT0gU3VzcGVuc2VFeGNlcHRpb24gfHwgdHlwZW9mIHgudGhlbiA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgLy8gU3VzcGVuZFxuICAgICAgICB0aHJvdyB4O1xuICAgICAgfVxuXG4gICAgICB0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MtLTsgLy8gVW5saWtlIHJlZ3VsYXIgcmVuZGVyLCB3ZSBkb24ndCB0ZXJtaW5hdGUgdGhlIHNpYmxpbmdzIGlmIHdlIGVycm9yXG4gICAgICAvLyBkdXJpbmcgYSByZXBsYXkuIFRoYXQncyBiZWNhdXNlIHRoaXMgY29tcG9uZW50IGRpZG4ndCBhY3R1YWxseSBlcnJvclxuICAgICAgLy8gaW4gdGhlIG9yaWdpbmFsIHByZXJlbmRlci4gV2hhdCdzIHVuYWJsZSB0byBjb21wbGV0ZSBpcyB0aGUgY2hpbGRcbiAgICAgIC8vIHJlcGxheSBub2RlcyB3aGljaCBtaWdodCBiZSBTdXNwZW5zZSBib3VuZGFyaWVzIHdoaWNoIGFyZSBhYmxlIHRvXG4gICAgICAvLyBhYnNvcmIgdGhlIGVycm9yIGFuZCB3ZSBjYW4gc3RpbGwgY29udGludWUgd2l0aCBzaWJsaW5ncy5cbiAgICAgIC8vIFRoaXMgaXMgYW4gZXJyb3IsIHN0YXNoIHRoZSBjb21wb25lbnQgc3RhY2sgaWYgaXQgaXMgbnVsbC5cblxuICAgICAgdmFyIHRocm93bkluZm8gPSBnZXRUaHJvd25JbmZvKHJlcXVlc3QsIHRhc2suY29tcG9uZW50U3RhY2spO1xuICAgICAgZXJyb3JlZFJlcGxheShyZXF1ZXN0LCB0YXNrLmJsb2NrZWRCb3VuZGFyeSwgeCwgdGhyb3duSW5mbywgY2hpbGROb2RlcywgY2hpbGRTbG90cyk7XG4gICAgfVxuXG4gICAgdGFzay5yZXBsYXkgPSByZXBsYXk7IC8vIFdlIGZpbmlzaGVkIHJlbmRlcmluZyB0aGlzIG5vZGUsIHNvIG5vdyB3ZSBjYW4gY29uc3VtZSB0aGlzXG4gICAgLy8gc2xvdC4gVGhpcyBtdXN0IGhhcHBlbiBhZnRlciBpbiBjYXNlIHdlIHJlcmVuZGVyIHRoaXMgdGFzay5cblxuICAgIHJlcGxheU5vZGVzLnNwbGljZShqLCAxKTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDaGlsZHJlbkFycmF5KHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCBjaGlsZEluZGV4KSB7XG4gIHZhciBwcmV2S2V5UGF0aCA9IHRhc2sua2V5UGF0aDtcblxuICBpZiAoY2hpbGRJbmRleCAhPT0gLTEpIHtcbiAgICB0YXNrLmtleVBhdGggPSBbdGFzay5rZXlQYXRoLCAnRnJhZ21lbnQnLCBjaGlsZEluZGV4XTtcblxuICAgIGlmICh0YXNrLnJlcGxheSAhPT0gbnVsbCkge1xuICAgICAgcmVwbGF5RnJhZ21lbnQocmVxdWVzdCwgLy8gJEZsb3dGaXhNZTogUmVmaW5lZC5cbiAgICAgIHRhc2ssIGNoaWxkcmVuLCBjaGlsZEluZGV4KTtcbiAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZLZXlQYXRoO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcmV2VHJlZUNvbnRleHQgPSB0YXNrLnRyZWVDb250ZXh0O1xuICB2YXIgdG90YWxDaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICBpZiAodGFzay5yZXBsYXkgIT09IG51bGwpIHtcbiAgICAvLyBSZXBsYXlcbiAgICAvLyBGaXJzdCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGhhdmUgYW55IHJlc3VtZSBzbG90cyBhdCB0aGlzIGxldmVsLlxuICAgIHZhciByZXN1bWVTbG90cyA9IHRhc2sucmVwbGF5LnNsb3RzO1xuXG4gICAgaWYgKHJlc3VtZVNsb3RzICE9PSBudWxsICYmIHR5cGVvZiByZXN1bWVTbG90cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxDaGlsZHJlbjsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gY2hpbGRyZW5baV07XG4gICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQocHJldlRyZWVDb250ZXh0LCB0b3RhbENoaWxkcmVuLCBpKTsgLy8gV2UgbmVlZCB0byB1c2UgdGhlIG5vbi1kZXN0cnVjdGl2ZSBmb3JtIHNvIHRoYXQgd2UgY2FuIHNhZmVseSBwb3AgYmFja1xuICAgICAgICAvLyB1cCBhbmQgcmVuZGVyIHRoZSBzaWJsaW5nIGlmIHNvbWV0aGluZyBzdXNwZW5kcy5cblxuICAgICAgICB2YXIgcmVzdW1lU2VnbWVudElEID0gcmVzdW1lU2xvdHNbaV07IC8vIFRPRE86IElmIHRoaXMgZXJyb3JzIHdlIHNob3VsZCBzdGlsbCBjb250aW51ZSB3aXRoIHRoZSBuZXh0IHNpYmxpbmcuXG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bWVTZWdtZW50SUQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmVzdW1lTm9kZShyZXF1ZXN0LCB0YXNrLCByZXN1bWVTZWdtZW50SUQsIG5vZGUsIGkpOyAvLyBXZSBmaW5pc2hlZCByZW5kZXJpbmcgdGhpcyBub2RlLCBzbyBub3cgd2UgY2FuIGNvbnN1bWUgdGhpc1xuICAgICAgICAgIC8vIHNsb3QuIFRoaXMgbXVzdCBoYXBwZW4gYWZ0ZXIgaW4gY2FzZSB3ZSByZXJlbmRlciB0aGlzIHRhc2suXG5cbiAgICAgICAgICBkZWxldGUgcmVzdW1lU2xvdHNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldlRyZWVDb250ZXh0O1xuICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRvdGFsQ2hpbGRyZW47IF9pKyspIHtcbiAgICB2YXIgX25vZGUgPSBjaGlsZHJlbltfaV07XG4gICAgdGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChwcmV2VHJlZUNvbnRleHQsIHRvdGFsQ2hpbGRyZW4sIF9pKTsgLy8gV2UgbmVlZCB0byB1c2UgdGhlIG5vbi1kZXN0cnVjdGl2ZSBmb3JtIHNvIHRoYXQgd2UgY2FuIHNhZmVseSBwb3AgYmFja1xuICAgIC8vIHVwIGFuZCByZW5kZXIgdGhlIHNpYmxpbmcgaWYgc29tZXRoaW5nIHN1c3BlbmRzLlxuXG4gICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBfbm9kZSwgX2kpO1xuICB9IC8vIEJlY2F1c2UgdGhpcyBjb250ZXh0IGlzIGFsd2F5cyBzZXQgcmlnaHQgYmVmb3JlIHJlbmRlcmluZyBldmVyeSBjaGlsZCwgd2VcbiAgLy8gb25seSBuZWVkIHRvIHJlc2V0IGl0IHRvIHRoZSBwcmV2aW91cyB2YWx1ZSBhdCB0aGUgdmVyeSBlbmQuXG5cblxuICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldlRyZWVDb250ZXh0O1xuICB0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aDtcbn1cbi8vIHJlc3VtZSBpdC5cblxuXG5mdW5jdGlvbiB1bnRyYWNrQm91bmRhcnkocmVxdWVzdCwgYm91bmRhcnkpIHtcbiAgdmFyIHRyYWNrZWRQb3N0cG9uZXMgPSByZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXM7XG5cbiAgaWYgKHRyYWNrZWRQb3N0cG9uZXMgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYm91bmRhcnlLZXlQYXRoID0gYm91bmRhcnkudHJhY2tlZENvbnRlbnRLZXlQYXRoO1xuXG4gIGlmIChib3VuZGFyeUtleVBhdGggPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYm91bmRhcnlOb2RlID0gdHJhY2tlZFBvc3Rwb25lcy53b3JraW5nTWFwLmdldChib3VuZGFyeUtleVBhdGgpO1xuXG4gIGlmIChib3VuZGFyeU5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBEb3duZ3JhZGUgdG8gcGxhaW4gUmVwbGF5Tm9kZSBzaW5jZSB3ZSB3b24ndCByZXBsYXkgdGhyb3VnaCBpdC5cbiAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdOiBXZSBpbnRlbnRpb25hbGx5IGRvd25ncmFkZSB0aGlzIHRvIHRoZSBvdGhlciB0dXBsZS5cblxuXG4gIGJvdW5kYXJ5Tm9kZS5sZW5ndGggPSA0OyAvLyBSZW1vdmUgYW55IHJlc3VtYWJsZSBzbG90cy5cblxuICBib3VuZGFyeU5vZGVbMl0gPSBbXTtcbiAgYm91bmRhcnlOb2RlWzNdID0gbnVsbDsgLy8gVE9ETzogV2Ugc2hvdWxkIHJlYWxseSBqdXN0IHJlbW92ZSB0aGUgYm91bmRhcnkgZnJvbSBhbGwgcGFyZW50IHBhdGhzIHRvbyBzb1xuICAvLyB3ZSBkb24ndCByZXBsYXkgdGhlIHBhdGggdG8gaXQuXG59XG5cbmZ1bmN0aW9uIHNwYXduTmV3U3VzcGVuZGVkUmVwbGF5VGFzayhyZXF1ZXN0LCB0YXNrLCB0aGVuYWJsZVN0YXRlLCB4KSB7XG4gIHZhciBuZXdUYXNrID0gY3JlYXRlUmVwbGF5VGFzayhyZXF1ZXN0LCB0aGVuYWJsZVN0YXRlLCB0YXNrLnJlcGxheSwgdGFzay5ub2RlLCB0YXNrLmNoaWxkSW5kZXgsIHRhc2suYmxvY2tlZEJvdW5kYXJ5LCB0YXNrLmFib3J0U2V0LCB0YXNrLmtleVBhdGgsIHRhc2suZm9ybWF0Q29udGV4dCwgdGFzay5sZWdhY3lDb250ZXh0LCB0YXNrLmNvbnRleHQsIHRhc2sudHJlZUNvbnRleHQsIC8vIFdlIHBvcCBvbmUgdGFzayBvZmYgdGhlIHN0YWNrIGJlY2F1c2UgdGhlIG5vZGUgdGhhdCBzdXNwZW5kZWQgd2lsbCBiZSB0cmllZCBhZ2FpbixcbiAgLy8gd2hpY2ggd2lsbCBhZGQgaXQgYmFjayBvbnRvIHRoZSBzdGFjay5cbiAgdGFzay5jb21wb25lbnRTdGFjayAhPT0gbnVsbCA/IHRhc2suY29tcG9uZW50U3RhY2sucGFyZW50IDogbnVsbCk7XG4gIHZhciBwaW5nID0gbmV3VGFzay5waW5nO1xuICB4LnRoZW4ocGluZywgcGluZyk7XG59XG5cbmZ1bmN0aW9uIHNwYXduTmV3U3VzcGVuZGVkUmVuZGVyVGFzayhyZXF1ZXN0LCB0YXNrLCB0aGVuYWJsZVN0YXRlLCB4KSB7XG4gIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQsIHdlJ2xsIG5lZWQgdG8gY3JlYXRlIGEgbmV3IHNlZ21lbnQgYW5kIHJlc29sdmUgaXQgbGF0ZXIuXG4gIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgdmFyIGluc2VydGlvbkluZGV4ID0gc2VnbWVudC5jaHVua3MubGVuZ3RoO1xuICB2YXIgbmV3U2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KHJlcXVlc3QsIGluc2VydGlvbkluZGV4LCBudWxsLCB0YXNrLmZvcm1hdENvbnRleHQsIC8vIEFkb3B0IHRoZSBwYXJlbnQgc2VnbWVudCdzIGxlYWRpbmcgdGV4dCBlbWJlZFxuICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0LCAvLyBBc3N1bWUgd2UgYXJlIHRleHQgZW1iZWRkZWQgYXQgdGhlIHRyYWlsaW5nIGVkZ2VcbiAgdHJ1ZSk7XG4gIHNlZ21lbnQuY2hpbGRyZW4ucHVzaChuZXdTZWdtZW50KTsgLy8gUmVzZXQgbGFzdFB1c2hlZFRleHQgZm9yIGN1cnJlbnQgU2VnbWVudCBzaW5jZSB0aGUgbmV3IFNlZ21lbnQgXCJjb25zdW1lZFwiIGl0XG5cbiAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9IGZhbHNlO1xuICB2YXIgbmV3VGFzayA9IGNyZWF0ZVJlbmRlclRhc2socmVxdWVzdCwgdGhlbmFibGVTdGF0ZSwgdGFzay5ub2RlLCB0YXNrLmNoaWxkSW5kZXgsIHRhc2suYmxvY2tlZEJvdW5kYXJ5LCBuZXdTZWdtZW50LCB0YXNrLmFib3J0U2V0LCB0YXNrLmtleVBhdGgsIHRhc2suZm9ybWF0Q29udGV4dCwgdGFzay5sZWdhY3lDb250ZXh0LCB0YXNrLmNvbnRleHQsIHRhc2sudHJlZUNvbnRleHQsIC8vIFdlIHBvcCBvbmUgdGFzayBvZmYgdGhlIHN0YWNrIGJlY2F1c2UgdGhlIG5vZGUgdGhhdCBzdXNwZW5kZWQgd2lsbCBiZSB0cmllZCBhZ2FpbixcbiAgLy8gd2hpY2ggd2lsbCBhZGQgaXQgYmFjayBvbnRvIHRoZSBzdGFjay5cbiAgdGFzay5jb21wb25lbnRTdGFjayAhPT0gbnVsbCA/IHRhc2suY29tcG9uZW50U3RhY2sucGFyZW50IDogbnVsbCk7XG4gIHZhciBwaW5nID0gbmV3VGFzay5waW5nO1xuICB4LnRoZW4ocGluZywgcGluZyk7XG59IC8vIFRoaXMgaXMgYSBub24tZGVzdHJ1Y3RpdmUgZm9ybSBvZiByZW5kZXJpbmcgYSBub2RlLiBJZiBpdCBzdXNwZW5kcyBpdCBzcGF3bnNcbi8vIGEgbmV3IHRhc2sgYW5kIHJlc3RvcmVzIHRoZSBjb250ZXh0IG9mIHRoaXMgdGFzayB0byB3aGF0IGl0IHdhcyBiZWZvcmUuXG5cblxuZnVuY3Rpb24gcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlLCBjaGlsZEluZGV4KSB7XG4gIC8vIFNuYXBzaG90IHRoZSBjdXJyZW50IGNvbnRleHQgaW4gY2FzZSBzb21ldGhpbmcgdGhyb3dzIHRvIGludGVycnVwdCB0aGVcbiAgLy8gcHJvY2Vzcy5cbiAgdmFyIHByZXZpb3VzRm9ybWF0Q29udGV4dCA9IHRhc2suZm9ybWF0Q29udGV4dDtcbiAgdmFyIHByZXZpb3VzTGVnYWN5Q29udGV4dCA9IHRhc2subGVnYWN5Q29udGV4dDtcbiAgdmFyIHByZXZpb3VzQ29udGV4dCA9IHRhc2suY29udGV4dDtcbiAgdmFyIHByZXZpb3VzS2V5UGF0aCA9IHRhc2sua2V5UGF0aDtcbiAgdmFyIHByZXZpb3VzVHJlZUNvbnRleHQgPSB0YXNrLnRyZWVDb250ZXh0O1xuICB2YXIgcHJldmlvdXNDb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2s7XG4gIHZhciB4OyAvLyBTdG9yZSBob3cgbXVjaCB3ZSd2ZSBwdXNoZWQgYXQgdGhpcyBwb2ludCBzbyB3ZSBjYW4gcmVzZXQgaXQgaW4gY2FzZSBzb21ldGhpbmdcbiAgLy8gc3VzcGVuZGVkIHBhcnRpYWxseSB0aHJvdWdoIHdyaXRpbmcgc29tZXRoaW5nLlxuXG4gIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcblxuICBpZiAoc2VnbWVudCA9PT0gbnVsbCkge1xuICAgIC8vIFJlcGxheVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICByZXNldEhvb2tzU3RhdGUoKTtcbiAgICAgIHggPSB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24gPyAvLyBUaGlzIGlzIGEgc3BlY2lhbCB0eXBlIG9mIGV4Y2VwdGlvbiB1c2VkIGZvciBTdXNwZW5zZS4gRm9yIGhpc3RvcmljYWxcbiAgICAgIC8vIHJlYXNvbnMsIHRoZSByZXN0IG9mIHRoZSBTdXNwZW5zZSBpbXBsZW1lbnRhdGlvbiBleHBlY3RzIHRoZSB0aHJvd25cbiAgICAgIC8vIHZhbHVlIHRvIGJlIGEgdGhlbmFibGUsIGJlY2F1c2UgYmVmb3JlIGB1c2VgIGV4aXN0ZWQgdGhhdCB3YXMgdGhlXG4gICAgICAvLyAodW5zdGFibGUpIEFQSSBmb3Igc3VzcGVuZGluZy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgY2FuIGNoYW5nZVxuICAgICAgLy8gbGF0ZXIsIG9uY2Ugd2UgZGVwcmVjYXRlIHRoZSBvbGQgQVBJIGluIGZhdm9yIG9mIGB1c2VgLlxuICAgICAgZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSA6IHRocm93blZhbHVlO1xuXG4gICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgICAgICBpZiAodHlwZW9mIHgudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB3YWtlYWJsZSA9IHg7XG4gICAgICAgICAgdmFyIHRoZW5hYmxlU3RhdGUgPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgICAgc3Bhd25OZXdTdXNwZW5kZWRSZXBsYXlUYXNrKHJlcXVlc3QsIC8vICRGbG93Rml4TWU6IFJlZmluZWQuXG4gICAgICAgICAgdGFzaywgdGhlbmFibGVTdGF0ZSwgd2FrZWFibGUpOyAvLyBSZXN0b3JlIHRoZSBjb250ZXh0LiBXZSBhc3N1bWUgdGhhdCB0aGlzIHdpbGwgYmUgcmVzdG9yZWQgYnkgdGhlIGlubmVyXG4gICAgICAgICAgLy8gZnVuY3Rpb25zIGluIGNhc2Ugbm90aGluZyB0aHJvd3Mgc28gd2UgZG9uJ3QgdXNlIFwiZmluYWxseVwiIGhlcmUuXG5cbiAgICAgICAgICB0YXNrLmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICAgICAgdGFzay5sZWdhY3lDb250ZXh0ID0gcHJldmlvdXNMZWdhY3lDb250ZXh0O1xuICAgICAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBwcmV2aW91c0tleVBhdGg7XG4gICAgICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZpb3VzVHJlZUNvbnRleHQ7XG4gICAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7IC8vIFJlc3RvcmUgYWxsIGFjdGl2ZSBSZWFjdENvbnRleHRzIHRvIHdoYXQgdGhleSB3ZXJlIGJlZm9yZS5cblxuICAgICAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVE9ETzogQWJvcnQgYW55IHVuZGlzY292ZXJlZCBTdXNwZW5zZSBib3VuZGFyaWVzIGluIHRoZSBSZXBsYXlOb2RlLlxuXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJlbmRlclxuICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHZhciBjaHVua0xlbmd0aCA9IHNlZ21lbnQuY2h1bmtzLmxlbmd0aDtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG51bGwsIG5vZGUsIGNoaWxkSW5kZXgpO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICByZXNldEhvb2tzU3RhdGUoKTsgLy8gUmVzZXQgdGhlIHdyaXRlIHBvaW50ZXJzIHRvIHdoZXJlIHdlIHN0YXJ0ZWQuXG5cbiAgICAgIHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoID0gY2hpbGRyZW5MZW5ndGg7XG4gICAgICBzZWdtZW50LmNodW5rcy5sZW5ndGggPSBjaHVua0xlbmd0aDtcbiAgICAgIHggPSB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24gPyAvLyBUaGlzIGlzIGEgc3BlY2lhbCB0eXBlIG9mIGV4Y2VwdGlvbiB1c2VkIGZvciBTdXNwZW5zZS4gRm9yIGhpc3RvcmljYWxcbiAgICAgIC8vIHJlYXNvbnMsIHRoZSByZXN0IG9mIHRoZSBTdXNwZW5zZSBpbXBsZW1lbnRhdGlvbiBleHBlY3RzIHRoZSB0aHJvd25cbiAgICAgIC8vIHZhbHVlIHRvIGJlIGEgdGhlbmFibGUsIGJlY2F1c2UgYmVmb3JlIGB1c2VgIGV4aXN0ZWQgdGhhdCB3YXMgdGhlXG4gICAgICAvLyAodW5zdGFibGUpIEFQSSBmb3Igc3VzcGVuZGluZy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgY2FuIGNoYW5nZVxuICAgICAgLy8gbGF0ZXIsIG9uY2Ugd2UgZGVwcmVjYXRlIHRoZSBvbGQgQVBJIGluIGZhdm9yIG9mIGB1c2VgLlxuICAgICAgZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSA6IHRocm93blZhbHVlO1xuXG4gICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgICAgICBpZiAodHlwZW9mIHgudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBfd2FrZWFibGUgPSB4O1xuXG4gICAgICAgICAgdmFyIF90aGVuYWJsZVN0YXRlID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuXG4gICAgICAgICAgc3Bhd25OZXdTdXNwZW5kZWRSZW5kZXJUYXNrKHJlcXVlc3QsIC8vICRGbG93Rml4TWU6IFJlZmluZWQuXG4gICAgICAgICAgdGFzaywgX3RoZW5hYmxlU3RhdGUsIF93YWtlYWJsZSk7IC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuIFdlIGFzc3VtZSB0aGF0IHRoaXMgd2lsbCBiZSByZXN0b3JlZCBieSB0aGUgaW5uZXJcbiAgICAgICAgICAvLyBmdW5jdGlvbnMgaW4gY2FzZSBub3RoaW5nIHRocm93cyBzbyB3ZSBkb24ndCB1c2UgXCJmaW5hbGx5XCIgaGVyZS5cblxuICAgICAgICAgIHRhc2suZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgICAgICB0YXNrLmxlZ2FjeUNvbnRleHQgPSBwcmV2aW91c0xlZ2FjeUNvbnRleHQ7XG4gICAgICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICAgIHRhc2sua2V5UGF0aCA9IHByZXZpb3VzS2V5UGF0aDtcbiAgICAgICAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDtcbiAgICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjazsgLy8gUmVzdG9yZSBhbGwgYWN0aXZlIFJlYWN0Q29udGV4dHMgdG8gd2hhdCB0aGV5IHdlcmUgYmVmb3JlLlxuXG4gICAgICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZXN0b3JlIHRoZSBjb250ZXh0LiBXZSBhc3N1bWUgdGhhdCB0aGlzIHdpbGwgYmUgcmVzdG9yZWQgYnkgdGhlIGlubmVyXG4gIC8vIGZ1bmN0aW9ucyBpbiBjYXNlIG5vdGhpbmcgdGhyb3dzIHNvIHdlIGRvbid0IHVzZSBcImZpbmFsbHlcIiBoZXJlLlxuXG5cbiAgdGFzay5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICB0YXNrLmxlZ2FjeUNvbnRleHQgPSBwcmV2aW91c0xlZ2FjeUNvbnRleHQ7XG4gIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgdGFzay5rZXlQYXRoID0gcHJldmlvdXNLZXlQYXRoO1xuICB0YXNrLnRyZWVDb250ZXh0ID0gcHJldmlvdXNUcmVlQ29udGV4dDsgLy8gV2UgaW50ZW50aW9uYWxseSBkbyBub3QgcmVzdG9yZSB0aGUgY29tcG9uZW50IHN0YWNrIG9uIHRoZSBlcnJvciBwYXRod2F5XG4gIC8vIFdoYXRldmVyIGhhbmRsZXMgdGhlIGVycm9yIG5lZWRzIHRvIHVzZSB0aGlzIHN0YWNrIHdoaWNoIGlzIHRoZSBsb2NhdGlvbiBvZiB0aGVcbiAgLy8gZXJyb3IuIFdlIG11c3QgcmVzdG9yZSB0aGUgc3RhY2sgd2hlcmV2ZXIgd2UgaGFuZGxlIHRoaXNcbiAgLy8gUmVzdG9yZSBhbGwgYWN0aXZlIFJlYWN0Q29udGV4dHMgdG8gd2hhdCB0aGV5IHdlcmUgYmVmb3JlLlxuXG4gIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgdGhyb3cgeDtcbn1cblxuZnVuY3Rpb24gZXJyb3JlZFJlcGxheShyZXF1ZXN0LCBib3VuZGFyeSwgZXJyb3IsIGVycm9ySW5mbywgcmVwbGF5Tm9kZXMsIHJlc3VtZVNsb3RzKSB7XG4gIC8vIEVycm9yaW5nIGR1cmluZyBhIHJlcGxheSBkb2Vzbid0IGFjdHVhbGx5IGNhdXNlIGFuIGVycm9yIGJ5IGl0c2VsZiBiZWNhdXNlXG4gIC8vIHRoYXQgY29tcG9uZW50IGhhcyBhbHJlYWR5IHJlbmRlcmVkLiBXaGF0IGNhdXNlcyB0aGUgZXJyb3IgaXMgdGhlIHJlc3VtYWJsZVxuICAvLyBwb2ludHMgdGhhdCB3ZSBkaWQgbm90IHlldCBmaW5pc2ggd2hpY2ggd2lsbCBiZSBiZWxvdyB0aGUgcG9pbnQgb2YgdGhlIHJlc2V0LlxuICAvLyBGb3IgZXhhbXBsZSwgaWYgd2UncmUgcmVwbGF5aW5nIGEgcGF0aCB0byBhIFN1c3BlbnNlIGJvdW5kYXJ5IHRoYXQgaXMgbm90IGRvbmVcbiAgLy8gdGhhdCBkb2Vzbid0IGVycm9yIHRoZSBwYXJlbnQgU3VzcGVuc2UgYm91bmRhcnkuXG4gIC8vIFRoaXMgbWlnaHQgYmUgYSBiaXQgc3RyYW5nZSB0aGF0IHRoZSBlcnJvciBpbiBhIHBhcmVudCBnZXRzIHRocm93biBhdCBhIGNoaWxkLlxuICAvLyBXZSBsb2cgaXQgb25seSBvbmNlIGFuZCByZXVzZSB0aGUgZGlnZXN0LlxuICB2YXIgZXJyb3JEaWdlc3Q7XG5cbiAge1xuICAgIGVycm9yRGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgZXJyb3JJbmZvKTtcbiAgfVxuXG4gIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMocmVxdWVzdCwgYm91bmRhcnksIHJlcGxheU5vZGVzLCByZXN1bWVTbG90cywgZXJyb3IsIGVycm9yRGlnZXN0LCBlcnJvckluZm8pO1xufVxuXG5mdW5jdGlvbiBlcnJvcmVkVGFzayhyZXF1ZXN0LCBib3VuZGFyeSwgZXJyb3IsIGVycm9ySW5mbykge1xuICAvLyBSZXBvcnQgdGhlIGVycm9yIHRvIGEgZ2xvYmFsIGhhbmRsZXIuXG4gIHZhciBlcnJvckRpZ2VzdDtcblxuICB7XG4gICAgZXJyb3JEaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBlcnJvckluZm8pO1xuICB9XG5cbiAgaWYgKGJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS07XG5cbiAgICBpZiAoYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQpIHtcbiAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDtcbiAgICAgIGVuY29kZUVycm9yRm9yQm91bmRhcnkoYm91bmRhcnksIGVycm9yRGlnZXN0LCBlcnJvciwgZXJyb3JJbmZvKTtcbiAgICAgIHVudHJhY2tCb3VuZGFyeShyZXF1ZXN0LCBib3VuZGFyeSk7IC8vIFJlZ2FyZGxlc3Mgb2Ygd2hhdCBoYXBwZW5zIG5leHQsIHRoaXMgYm91bmRhcnkgd29uJ3QgYmUgZGlzcGxheWVkLFxuICAgICAgLy8gc28gd2UgY2FuIGZsdXNoIGl0LCBpZiB0aGUgcGFyZW50IGFscmVhZHkgZmx1c2hlZC5cblxuICAgICAgaWYgKGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBhIHByZWZlcmVuY2Ugd2hlcmUgaW4gdGhlIHF1ZXVlIHRoaXMgZ29lcyBzaW5jZSBpdCdzIGxpa2VseVxuICAgICAgICAvLyB0byBlcnJvciBvbiB0aGUgY2xpZW50IGFueXdheS4gSG93ZXZlciwgaW50ZW50aW9uYWxseSBjbGllbnQtcmVuZGVyZWRcbiAgICAgICAgLy8gYm91bmRhcmllcyBzaG91bGQgYmUgZmx1c2hlZCBlYXJsaWVyIHNvIHRoYXQgdGhleSBjYW4gc3RhcnQgb24gdGhlIGNsaWVudC5cbiAgICAgICAgLy8gV2UgcmV1c2UgdGhlIHNhbWUgcXVldWUgZm9yIGVycm9ycy5cbiAgICAgICAgcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcblxuICBpZiAocmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICBjb21wbGV0ZUFsbChyZXF1ZXN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhYm9ydFRhc2tTb2Z0KHRhc2spIHtcbiAgLy8gVGhpcyBhYm9ydHMgdGFzayB3aXRob3V0IGFib3J0aW5nIHRoZSBwYXJlbnQgYm91bmRhcnkgdGhhdCBpdCBibG9ja3MuXG4gIC8vIEl0J3MgdXNlZCBmb3Igd2hlbiB3ZSBkaWRuJ3QgbmVlZCB0aGlzIHRhc2sgdG8gY29tcGxldGUgdGhlIHRyZWUuXG4gIC8vIElmIHRhc2sgd2FzIG5lZWRlZCwgdGhlbiBpdCBzaG91bGQgdXNlIGFib3J0VGFzayBpbnN0ZWFkLlxuICB2YXIgcmVxdWVzdCA9IHRoaXM7XG4gIHZhciBib3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG5cbiAgaWYgKHNlZ21lbnQgIT09IG51bGwpIHtcbiAgICBzZWdtZW50LnN0YXR1cyA9IEFCT1JURUQ7XG4gICAgZmluaXNoZWRUYXNrKHJlcXVlc3QsIGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhYm9ydFJlbWFpbmluZ1N1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgcm9vdFNlZ21lbnRJRCwgZXJyb3IsIGVycm9yRGlnZXN0LCBlcnJvckluZm8pIHtcbiAgdmFyIHJlc3VtZWRCb3VuZGFyeSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgbmV3IFNldCgpKTtcbiAgcmVzdW1lZEJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgPSB0cnVlOyAvLyBXZSByZXN0b3JlIHRoZSBzYW1lIGlkIG9mIHRoaXMgYm91bmRhcnkgYXMgd2FzIHVzZWQgZHVyaW5nIHByZXJlbmRlci5cblxuICByZXN1bWVkQm91bmRhcnkucm9vdFNlZ21lbnRJRCA9IHJvb3RTZWdtZW50SUQ7XG4gIHJlc3VtZWRCb3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQ7XG4gIHZhciBlcnJvck1lc3NhZ2UgPSBlcnJvcjtcblxuICB7XG4gICAgdmFyIGVycm9yUHJlZml4ID0gJ1RoZSBzZXJ2ZXIgZGlkIG5vdCBmaW5pc2ggdGhpcyBTdXNwZW5zZSBib3VuZGFyeTogJztcblxuICAgIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yUHJlZml4ICsgZXJyb3IubWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvclByZWZpeCArIFN0cmluZyhlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgZW5jb2RlRXJyb3JGb3JCb3VuZGFyeShyZXN1bWVkQm91bmRhcnksIGVycm9yRGlnZXN0LCBlcnJvck1lc3NhZ2UsIGVycm9ySW5mbyk7XG5cbiAgaWYgKHJlc3VtZWRCb3VuZGFyeS5wYXJlbnRGbHVzaGVkKSB7XG4gICAgcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucHVzaChyZXN1bWVkQm91bmRhcnkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMocmVxdWVzdCwgYm91bmRhcnksIG5vZGVzLCBzbG90cywgZXJyb3IsIGVycm9yRGlnZXN0LCBlcnJvckluZm8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAobm9kZS5sZW5ndGggPT09IDQpIHtcbiAgICAgIGFib3J0UmVtYWluaW5nUmVwbGF5Tm9kZXMocmVxdWVzdCwgYm91bmRhcnksIG5vZGVbMl0sIG5vZGVbM10sIGVycm9yLCBlcnJvckRpZ2VzdCwgZXJyb3JJbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJvdW5kYXJ5Tm9kZSA9IG5vZGU7XG4gICAgICB2YXIgcm9vdFNlZ21lbnRJRCA9IGJvdW5kYXJ5Tm9kZVs1XTtcbiAgICAgIGFib3J0UmVtYWluaW5nU3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCByb290U2VnbWVudElELCBlcnJvciwgZXJyb3JEaWdlc3QsIGVycm9ySW5mbyk7XG4gICAgfVxuICB9IC8vIEVtcHR5IHRoZSBzZXQsIHNpbmNlIHdlJ3ZlIGNsZWFyZWQgaXQgbm93LlxuXG5cbiAgbm9kZXMubGVuZ3RoID0gMDtcblxuICBpZiAoc2xvdHMgIT09IG51bGwpIHtcbiAgICAvLyBXZSBoYWQgc29tZXRoaW5nIHN0aWxsIHRvIHJlc3VtZSBpbiB0aGUgcGFyZW50IGJvdW5kYXJ5LiBXZSBtdXN0IHRyaWdnZXJcbiAgICAvLyB0aGUgZXJyb3Igb24gdGhlIHBhcmVudCBib3VuZGFyeSBzaW5jZSBpdCdzIG5vdCBhYmxlIHRvIGNvbXBsZXRlLlxuICAgIGlmIChib3VuZGFyeSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZSBzaG91bGQgbm90IGhhdmUgYW55IHJlc3VtYWJsZSBub2RlcyBpbiB0aGUgc2hlbGwuICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9IGVsc2UgaWYgKGJvdW5kYXJ5LnN0YXR1cyAhPT0gQ0xJRU5UX1JFTkRFUkVEKSB7XG4gICAgICBib3VuZGFyeS5zdGF0dXMgPSBDTElFTlRfUkVOREVSRUQ7XG4gICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KGJvdW5kYXJ5LCBlcnJvckRpZ2VzdCwgZXJyb3IsIGVycm9ySW5mbyk7XG5cbiAgICAgIGlmIChib3VuZGFyeS5wYXJlbnRGbHVzaGVkKSB7XG4gICAgICAgIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpO1xuICAgICAgfVxuICAgIH0gLy8gRW1wdHkgdGhlIHNldFxuXG5cbiAgICBpZiAodHlwZW9mIHNsb3RzID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIgaW5kZXggaW4gc2xvdHMpIHtcbiAgICAgICAgZGVsZXRlIHNsb3RzW2luZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWJvcnRUYXNrKHRhc2ssIHJlcXVlc3QsIGVycm9yKSB7XG4gIC8vIFRoaXMgYWJvcnRzIHRoZSB0YXNrIGFuZCBhYm9ydHMgdGhlIHBhcmVudCB0aGF0IGl0IGJsb2NrcywgcHV0dGluZyBpdCBpbnRvXG4gIC8vIGNsaWVudCByZW5kZXJlZCBtb2RlLlxuICB2YXIgYm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuXG4gIGlmIChzZWdtZW50ICE9PSBudWxsKSB7XG4gICAgc2VnbWVudC5zdGF0dXMgPSBBQk9SVEVEO1xuICB9XG5cbiAgaWYgKGJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgdmFyIGVycm9ySW5mbyA9IHt9O1xuXG4gICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSBDTE9TSU5HICYmIHJlcXVlc3Quc3RhdHVzICE9PSBDTE9TRUQpIHtcbiAgICAgIHZhciByZXBsYXkgPSB0YXNrLnJlcGxheTtcblxuICAgICAgaWYgKHJlcGxheSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBkaWRuJ3QgY29tcGxldGUgdGhlIHJvb3Qgc28gd2UgaGF2ZSBub3RoaW5nIHRvIHNob3cuIFdlIGNhbiBjbG9zZVxuICAgICAgICAvLyB0aGUgcmVxdWVzdDtcbiAgICAgICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgZXJyb3JJbmZvKTtcbiAgICAgICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSBzaGVsbCBhYm9ydHMgZHVyaW5nIGEgcmVwbGF5LCB0aGF0J3Mgbm90IGEgZmF0YWwgZXJyb3IuIEluc3RlYWRcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVjb3ZlciBieSBjbGllbnQgcmVuZGVyaW5nIGFsbCB0aGUgcm9vdCBib3VuZGFyaWVzIGluXG4gICAgICAgIC8vIHRoZSBSZXBsYXlTZXQuXG4gICAgICAgIHJlcGxheS5wZW5kaW5nVGFza3MtLTtcblxuICAgICAgICBpZiAocmVwbGF5LnBlbmRpbmdUYXNrcyA9PT0gMCAmJiByZXBsYXkubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBlcnJvckRpZ2VzdCA9IGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIGVycm9ySW5mbyk7XG4gICAgICAgICAgYWJvcnRSZW1haW5pbmdSZXBsYXlOb2RlcyhyZXF1ZXN0LCBudWxsLCByZXBsYXkubm9kZXMsIHJlcGxheS5zbG90cywgZXJyb3IsIGVycm9yRGlnZXN0LCBlcnJvckluZm8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzLS07XG5cbiAgICAgICAgaWYgKHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyA9PT0gMCkge1xuICAgICAgICAgIGNvbXBsZXRlU2hlbGwocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS07XG5cbiAgICBpZiAoYm91bmRhcnkuc3RhdHVzICE9PSBDTElFTlRfUkVOREVSRUQpIHtcbiAgICAgIGJvdW5kYXJ5LnN0YXR1cyA9IENMSUVOVF9SRU5ERVJFRDsgLy8gV2UgY29uc3RydWN0IGFuIGVycm9ySW5mbyBmcm9tIHRoZSBib3VuZGFyeSdzIGNvbXBvbmVudFN0YWNrIHNvIHRoZSBlcnJvciBpbiBkZXYgd2lsbCBpbmRpY2F0ZSB3aGljaFxuICAgICAgLy8gYm91bmRhcnkgdGhlIG1lc3NhZ2UgaXMgcmVmZXJyaW5nIHRvXG5cbiAgICAgIHZhciBfZXJyb3JJbmZvID0gZ2V0VGhyb3duSW5mbyhyZXF1ZXN0LCB0YXNrLmNvbXBvbmVudFN0YWNrKTtcblxuICAgICAgdmFyIF9lcnJvckRpZ2VzdCA9IGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIF9lcnJvckluZm8pO1xuXG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZXJyb3I7XG5cbiAgICAgIHtcbiAgICAgICAgdmFyIGVycm9yUHJlZml4ID0gJ1RoZSBzZXJ2ZXIgZGlkIG5vdCBmaW5pc2ggdGhpcyBTdXNwZW5zZSBib3VuZGFyeTogJztcblxuICAgICAgICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JQcmVmaXggKyBlcnJvci5tZXNzYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yUHJlZml4ICsgU3RyaW5nKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbmNvZGVFcnJvckZvckJvdW5kYXJ5KGJvdW5kYXJ5LCBfZXJyb3JEaWdlc3QsIGVycm9yTWVzc2FnZSwgX2Vycm9ySW5mbyk7XG4gICAgICB1bnRyYWNrQm91bmRhcnkocmVxdWVzdCwgYm91bmRhcnkpO1xuXG4gICAgICBpZiAoYm91bmRhcnkucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KTtcbiAgICAgIH1cbiAgICB9IC8vIElmIHRoaXMgYm91bmRhcnkgd2FzIHN0aWxsIHBlbmRpbmcgdGhlbiB3ZSBoYXZlbid0IGFscmVhZHkgY2FuY2VsbGVkIGl0cyBmYWxsYmFja3MuXG4gICAgLy8gV2UnbGwgbmVlZCB0byBhYm9ydCB0aGUgZmFsbGJhY2tzLCB3aGljaCB3aWxsIGFsc28gZXJyb3IgdGhhdCBwYXJlbnQgYm91bmRhcnkuXG5cblxuICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAoZmFsbGJhY2tUYXNrKSB7XG4gICAgICByZXR1cm4gYWJvcnRUYXNrKGZhbGxiYWNrVGFzaywgcmVxdWVzdCwgZXJyb3IpO1xuICAgIH0pO1xuICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuY2xlYXIoKTtcbiAgfVxuXG4gIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzLS07XG5cbiAgaWYgKHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzID09PSAwKSB7XG4gICAgY29tcGxldGVBbGwocmVxdWVzdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgc2hlbGxDb21wbGV0ZSkge1xuICB0cnkge1xuICAgIGVtaXRFYXJseVByZWxvYWRzKHJlcXVlc3QucmVuZGVyU3RhdGUsIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsIHNoZWxsQ29tcGxldGUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFdlIGFzc3VtZSBwcmVsb2FkcyBhcmUgb3B0aW1pc3RpYyBhbmQgdGh1cyBub24tZmF0YWwgaWYgZXJyb3JlZC5cbiAgICB2YXIgZXJyb3JJbmZvID0ge307XG4gICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgZXJyb3JJbmZvKTtcbiAgfVxufSAvLyBJIGV4dHJhY3RlZCB0aGlzIGZ1bmN0aW9uIG91dCBiZWNhdXNlIHdlIHdhbnQgdG8gZW5zdXJlIHdlIGNvbnNpc3RlbnRseSBlbWl0IHByZWxvYWRzIGJlZm9yZVxuLy8gdHJhbnNpdGlvbmluZyB0byB0aGUgbmV4dCByZXF1ZXN0IHN0YWdlIGFuZCB0aGlzIHRyYW5zaXRpb24gY2FuIGhhcHBlbiBpbiBtdWx0aXBsZSBwbGFjZXMgaW4gdGhpc1xuLy8gaW1wbGVtZW50YXRpb24uXG5cblxuZnVuY3Rpb24gY29tcGxldGVTaGVsbChyZXF1ZXN0KSB7XG4gIGlmIChyZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgPT09IG51bGwpIHtcbiAgICAvLyBXZSBvbmx5IGVtaXQgZWFybHkgcHJlbG9hZHMgb24gc2hlbGwgY29tcGxldGlvbiBmb3IgcmVuZGVycy4gRm9yIHByZXJlbmRlcnNcbiAgICAvLyB3ZSB3YWl0IGZvciB0aGUgZW50aXJlIFJlcXVlc3QgdG8gZmluaXNoIGJlY2F1c2Ugd2UgYXJlIG5vdCByZXNwb25kaW5nIHRvIGFcbiAgICAvLyBsaXZlIHJlcXVlc3QgYW5kIGNhbiB3YWl0IGZvciBhcyBtdWNoIGRhdGEgYXMgcG9zc2libGUuXG4gICAgLy8gd2Ugc2hvdWxkIG9ubHkgYmUgY2FsbGluZyBjb21wbGV0ZVNoZWxsIHdoZW4gdGhlIHNoZWxsIGlzIGNvbXBsZXRlIHNvIHdlXG4gICAgLy8ganVzdCB1c2UgYSBsaXRlcmFsIGhlcmVcbiAgICB2YXIgc2hlbGxDb21wbGV0ZSA9IHRydWU7XG4gICAgc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgc2hlbGxDb21wbGV0ZSk7XG4gIH0gLy8gV2UgaGF2ZSBjb21wbGV0ZWQgdGhlIHNoZWxsIHNvIHRoZSBzaGVsbCBjYW4ndCBlcnJvciBhbnltb3JlLlxuXG5cbiAgcmVxdWVzdC5vblNoZWxsRXJyb3IgPSBub29wO1xuICB2YXIgb25TaGVsbFJlYWR5ID0gcmVxdWVzdC5vblNoZWxsUmVhZHk7XG4gIG9uU2hlbGxSZWFkeSgpO1xufSAvLyBJIGV4dHJhY3RlZCB0aGlzIGZ1bmN0aW9uIG91dCBiZWNhdXNlIHdlIHdhbnQgdG8gZW5zdXJlIHdlIGNvbnNpc3RlbnRseSBlbWl0IHByZWxvYWRzIGJlZm9yZVxuLy8gdHJhbnNpdGlvbmluZyB0byB0aGUgbmV4dCByZXF1ZXN0IHN0YWdlIGFuZCB0aGlzIHRyYW5zaXRpb24gY2FuIGhhcHBlbiBpbiBtdWx0aXBsZSBwbGFjZXMgaW4gdGhpc1xuLy8gaW1wbGVtZW50YXRpb24uXG5cblxuZnVuY3Rpb24gY29tcGxldGVBbGwocmVxdWVzdCkge1xuICAvLyBEdXJpbmcgYSByZW5kZXIgdGhlIHNoZWxsIG11c3QgYmUgY29tcGxldGUgaWYgdGhlIGVudGlyZSByZXF1ZXN0IGlzIGZpbmlzaGVkXG4gIC8vIGhvd2V2ZXIgZHVyaW5nIGEgUHJlcmVuZGVyIGl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIHNoZWxsIGlzIGluY29tcGxldGUgYmVjYXVzZVxuICAvLyBpdCBwb3N0cG9uZWQuIFdlIGNhbm5vdCB1c2Ugcm9vdFBlbmRpbmdUYXNrcyBpbiB0aGUgcHJlcmVuZGVyIGNhc2UgYmVjYXVzZVxuICAvLyB0aG9zZSBoaXQgemVybyBldmVuIHdoZW4gdGhlIHNoZWxsIHBvc3Rwb25lcy4gSW5zdGVhZCB3ZSBsb29rIGF0IHRoZSBjb21wbGV0ZWRSb290U2VnbWVudFxuICB2YXIgc2hlbGxDb21wbGV0ZSA9IHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyA9PT0gbnVsbCA/IC8vIFJlbmRlciwgd2UgYXNzdW1lIGl0IGlzIGNvbXBsZXRlZFxuICB0cnVlIDogLy8gUHJlcmVuZGVyIFJlcXVlc3QsIHdlIHVzZSB0aGUgc3RhdGUgb2YgdGhlIHJvb3Qgc2VnbWVudFxuICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ID09PSBudWxsIHx8IHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQuc3RhdHVzICE9PSBQT1NUUE9ORUQ7XG4gIHNhZmVseUVtaXRFYXJseVByZWxvYWRzKHJlcXVlc3QsIHNoZWxsQ29tcGxldGUpO1xuICB2YXIgb25BbGxSZWFkeSA9IHJlcXVlc3Qub25BbGxSZWFkeTtcbiAgb25BbGxSZWFkeSgpO1xufVxuXG5mdW5jdGlvbiBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYm91bmRhcnksIHNlZ21lbnQpIHtcbiAgaWYgKHNlZ21lbnQuY2h1bmtzLmxlbmd0aCA9PT0gMCAmJiBzZWdtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBzZWdtZW50LmNoaWxkcmVuWzBdLmJvdW5kYXJ5ID09PSBudWxsICYmIHNlZ21lbnQuY2hpbGRyZW5bMF0uaWQgPT09IC0xKSB7XG4gICAgLy8gVGhpcyBpcyBhbiBlbXB0eSBzZWdtZW50LiBUaGVyZSdzIG5vdGhpbmcgdG8gd3JpdGUsIHNvIHdlIGNhbiBpbnN0ZWFkIHRyYW5zZmVyIHRoZSBJRFxuICAgIC8vIHRvIHRoZSBjaGlsZC4gVGhhdCB3YXkgYW55IGV4aXN0aW5nIHJlZmVyZW5jZXMgcG9pbnQgdG8gdGhlIGNoaWxkLlxuICAgIHZhciBjaGlsZFNlZ21lbnQgPSBzZWdtZW50LmNoaWxkcmVuWzBdO1xuICAgIGNoaWxkU2VnbWVudC5pZCA9IHNlZ21lbnQuaWQ7XG4gICAgY2hpbGRTZWdtZW50LnBhcmVudEZsdXNoZWQgPSB0cnVlO1xuXG4gICAgaWYgKGNoaWxkU2VnbWVudC5zdGF0dXMgPT09IENPTVBMRVRFRCkge1xuICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBjaGlsZFNlZ21lbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcbiAgICBjb21wbGV0ZWRTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaGVkVGFzayhyZXF1ZXN0LCBib3VuZGFyeSwgc2VnbWVudCkge1xuICBpZiAoYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICBpZiAoc2VnbWVudCAhPT0gbnVsbCAmJiBzZWdtZW50LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgIGlmIChyZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgY2FuIG9ubHkgYmUgb25lIHJvb3Qgc2VnbWVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzLS07XG5cbiAgICBpZiAocmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzID09PSAwKSB7XG4gICAgICBjb21wbGV0ZVNoZWxsKHJlcXVlc3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBib3VuZGFyeS5wZW5kaW5nVGFza3MtLTtcblxuICAgIGlmIChib3VuZGFyeS5zdGF0dXMgPT09IENMSUVOVF9SRU5ERVJFRCkgOyBlbHNlIGlmIChib3VuZGFyeS5wZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICAgIGlmIChib3VuZGFyeS5zdGF0dXMgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgYm91bmRhcnkuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgICAgfSAvLyBUaGlzIG11c3QgaGF2ZSBiZWVuIHRoZSBsYXN0IHNlZ21lbnQgd2Ugd2VyZSB3YWl0aW5nIG9uLiBUaGlzIGJvdW5kYXJ5IGlzIG5vdyBjb21wbGV0ZS5cblxuXG4gICAgICBpZiAoc2VnbWVudCAhPT0gbnVsbCAmJiBzZWdtZW50LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgLy8gT3VyIHBhcmVudCBzZWdtZW50IGFscmVhZHkgZmx1c2hlZCwgc28gd2UgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHNlZ21lbnQgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBzZWdtZW50IHRoYXQgd2FzIGFib3J0ZWQsIHdlJ2xsIHdyaXRlIG90aGVyIGNvbnRlbnQgaW5zdGVhZCBzbyB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vIHRvIGVtaXQgaXQuXG4gICAgICAgIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEKSB7XG4gICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRhcnkucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAvLyBUaGUgc2VnbWVudCBtaWdodCBiZSBwYXJ0IG9mIGEgc2VnbWVudCB0aGF0IGRpZG4ndCBmbHVzaCB5ZXQsIGJ1dCBpZiB0aGUgYm91bmRhcnknc1xuICAgICAgICAvLyBwYXJlbnQgZmx1c2hlZCwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgYm91bmRhcnkgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpO1xuICAgICAgfSAvLyBXZSBjYW4gbm93IGNhbmNlbCBhbnkgcGVuZGluZyB0YXNrIG9uIHRoZSBmYWxsYmFjayBzaW5jZSB3ZSB3b24ndCBuZWVkIHRvIHNob3cgaXQgYW55bW9yZS5cbiAgICAgIC8vIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHdlIHJlYWQgdGhlIHBhcmVudEZsdXNoZWQgZmxhZ3MgYmVjYXVzZSBhYm9ydGluZyBjYW4gZmluaXNoXG4gICAgICAvLyB3b3JrIHdoaWNoIGNhbiB0cmlnZ2VyIHVzZXIgY29kZSwgd2hpY2ggY2FuIHN0YXJ0IGZsdXNoaW5nLCB3aGljaCBjYW4gY2hhbmdlIHRob3NlIGZsYWdzLlxuICAgICAgLy8gSWYgdGhlIGJvdW5kYXJ5IHdhcyBQT1NUUE9ORUQsIHdlIHN0aWxsIG5lZWQgdG8gZmluaXNoIHRoZSBmYWxsYmFjayBmaXJzdC5cblxuXG4gICAgICBpZiAoYm91bmRhcnkuc3RhdHVzID09PSBDT01QTEVURUQpIHtcbiAgICAgICAgYm91bmRhcnkuZmFsbGJhY2tBYm9ydGFibGVUYXNrcy5mb3JFYWNoKGFib3J0VGFza1NvZnQsIHJlcXVlc3QpO1xuICAgICAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzZWdtZW50ICE9PSBudWxsICYmIHNlZ21lbnQucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAvLyBPdXIgcGFyZW50IGFscmVhZHkgZmx1c2hlZCwgc28gd2UgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHNlZ21lbnQgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBzZWdtZW50IHRoYXQgd2FzIGFib3J0ZWQsIHdlJ2xsIHdyaXRlIG90aGVyIGNvbnRlbnQgaW5zdGVhZCBzbyB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vIHRvIGVtaXQgaXQuXG4gICAgICAgIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEKSB7XG4gICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgICAgICAgICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcblxuICAgICAgICAgIGlmIChjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgc2luY2Ugd2UgbGFzdCBmbHVzaGVkIHRoYXQgd2UgY29tcGxldGVkIGFueXRoaW5nLlxuICAgICAgICAgICAgLy8gV2UgY2FuIHNjaGVkdWxlIHRoaXMgYm91bmRhcnkgdG8gZW1pdCBpdHMgcGFydGlhbGx5IGNvbXBsZXRlZCBzZWdtZW50cyBlYXJseVxuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gZmx1c2hlZC5cbiAgICAgICAgICAgIGlmIChib3VuZGFyeS5wYXJlbnRGbHVzaGVkKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcblxuICBpZiAocmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICBjb21wbGV0ZUFsbChyZXF1ZXN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyeVRhc2socmVxdWVzdCwgdGFzaykge1xuICB7XG4gICAgdmFyIGJsb2NrZWRCb3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICAgIHNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0KHJlcXVlc3QucmVuZGVyU3RhdGUsIGJsb2NrZWRCb3VuZGFyeSA/IGJsb2NrZWRCb3VuZGFyeS5yZXNvdXJjZXMgOiBudWxsKTtcbiAgfVxuXG4gIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcblxuICBpZiAoc2VnbWVudCA9PT0gbnVsbCkge1xuICAgIHJldHJ5UmVwbGF5VGFzayhyZXF1ZXN0LCAvLyAkRmxvd0ZpeE1lOiBSZWZpbmVkLlxuICAgIHRhc2spO1xuICB9IGVsc2Uge1xuICAgIHJldHJ5UmVuZGVyVGFzayhyZXF1ZXN0LCAvLyAkRmxvd0ZpeE1lOiBSZWZpbmVkLlxuICAgIHRhc2ssIHNlZ21lbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJldHJ5UmVuZGVyVGFzayhyZXF1ZXN0LCB0YXNrLCBzZWdtZW50KSB7XG4gIGlmIChzZWdtZW50LnN0YXR1cyAhPT0gUEVORElORykge1xuICAgIC8vIFdlIGNvbXBsZXRlZCB0aGlzIGJ5IG90aGVyIG1lYW5zIGJlZm9yZSB3ZSBoYWQgYSBjaGFuY2UgdG8gcmV0cnkgaXQuXG4gICAgcmV0dXJuO1xuICB9IC8vIFdlIHJlc3RvcmUgdGhlIGNvbnRleHQgdG8gd2hhdCBpdCB3YXMgd2hlbiB3ZSBzdXNwZW5kZWQuXG4gIC8vIFdlIGRvbid0IHJlc3RvcmUgaXQgYWZ0ZXIgd2UgbGVhdmUgYmVjYXVzZSBpdCdzIGxpa2VseSB0aGF0IHdlJ2xsIGVuZCB1cFxuICAvLyBuZWVkaW5nIGEgdmVyeSBzaW1pbGFyIGNvbnRleHQgc29vbiBhZ2Fpbi5cblxuXG4gIHN3aXRjaENvbnRleHQodGFzay5jb250ZXh0KTtcbiAgdmFyIHByZXZUYXNrSW5ERVYgPSBudWxsO1xuXG4gIHtcbiAgICBwcmV2VGFza0luREVWID0gY3VycmVudFRhc2tJbkRFVjtcbiAgICBjdXJyZW50VGFza0luREVWID0gdGFzaztcbiAgfVxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICB2YXIgY2h1bmtMZW5ndGggPSBzZWdtZW50LmNodW5rcy5sZW5ndGg7XG5cbiAgdHJ5IHtcbiAgICAvLyBXZSBjYWxsIHRoZSBkZXN0cnVjdGl2ZSBmb3JtIHRoYXQgbXV0YXRlcyB0aGlzIHRhc2suIFRoYXQgd2F5IGlmIHNvbWV0aGluZ1xuICAgIC8vIHN1c3BlbmRzIGFnYWluLCB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdGFzayBpbnN0ZWFkIG9mIHNwYXduaW5nIGEgbmV3IG9uZS5cbiAgICAvLyBSZXNldCB0aGUgdGFzaydzIHRoZW5hYmxlIHN0YXRlIGJlZm9yZSBjb250aW51aW5nLCBzbyB0aGF0IGlmIGEgbGF0ZXJcbiAgICAvLyBjb21wb25lbnQgc3VzcGVuZHMgd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRhc2sgb2JqZWN0LiBJZiB0aGUgc2FtZVxuICAgIC8vIGNvbXBvbmVudCBzdXNwZW5kcyBhZ2FpbiwgdGhlIHRoZW5hYmxlIHN0YXRlIHdpbGwgYmUgcmVzdG9yZWQuXG4gICAgdmFyIHByZXZUaGVuYWJsZVN0YXRlID0gdGFzay50aGVuYWJsZVN0YXRlO1xuICAgIHRhc2sudGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByZXZUaGVuYWJsZVN0YXRlLCB0YXNrLm5vZGUsIHRhc2suY2hpbGRJbmRleCk7XG4gICAgcHVzaFNlZ21lbnRGaW5hbGUoc2VnbWVudC5jaHVua3MsIHJlcXVlc3QucmVuZGVyU3RhdGUsIHNlZ21lbnQubGFzdFB1c2hlZFRleHQsIHNlZ21lbnQudGV4dEVtYmVkZGVkKTtcbiAgICB0YXNrLmFib3J0U2V0LmRlbGV0ZSh0YXNrKTtcbiAgICBzZWdtZW50LnN0YXR1cyA9IENPTVBMRVRFRDtcbiAgICBmaW5pc2hlZFRhc2socmVxdWVzdCwgdGFzay5ibG9ja2VkQm91bmRhcnksIHNlZ21lbnQpO1xuICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgIHJlc2V0SG9va3NTdGF0ZSgpOyAvLyBSZXNldCB0aGUgd3JpdGUgcG9pbnRlcnMgdG8gd2hlcmUgd2Ugc3RhcnRlZC5cblxuICAgIHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoID0gY2hpbGRyZW5MZW5ndGg7XG4gICAgc2VnbWVudC5jaHVua3MubGVuZ3RoID0gY2h1bmtMZW5ndGg7XG4gICAgdmFyIHggPSB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24gPyAvLyBUaGlzIGlzIGEgc3BlY2lhbCB0eXBlIG9mIGV4Y2VwdGlvbiB1c2VkIGZvciBTdXNwZW5zZS4gRm9yIGhpc3RvcmljYWxcbiAgICAvLyByZWFzb25zLCB0aGUgcmVzdCBvZiB0aGUgU3VzcGVuc2UgaW1wbGVtZW50YXRpb24gZXhwZWN0cyB0aGUgdGhyb3duXG4gICAgLy8gdmFsdWUgdG8gYmUgYSB0aGVuYWJsZSwgYmVjYXVzZSBiZWZvcmUgYHVzZWAgZXhpc3RlZCB0aGF0IHdhcyB0aGVcbiAgICAvLyAodW5zdGFibGUpIEFQSSBmb3Igc3VzcGVuZGluZy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgY2FuIGNoYW5nZVxuICAgIC8vIGxhdGVyLCBvbmNlIHdlIGRlcHJlY2F0ZSB0aGUgb2xkIEFQSSBpbiBmYXZvciBvZiBgdXNlYC5cbiAgICBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpIDogdGhyb3duVmFsdWU7XG5cbiAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICAgIGlmICh0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQgYWdhaW4sIGxldCdzIHBpY2sgaXQgYmFjayB1cCBsYXRlci5cbiAgICAgICAgdmFyIHBpbmcgPSB0YXNrLnBpbmc7XG4gICAgICAgIHgudGhlbihwaW5nLCBwaW5nKTtcbiAgICAgICAgdGFzay50aGVuYWJsZVN0YXRlID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVycm9ySW5mbyA9IGdldFRocm93bkluZm8ocmVxdWVzdCwgdGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgdGFzay5hYm9ydFNldC5kZWxldGUodGFzayk7XG4gICAgc2VnbWVudC5zdGF0dXMgPSBFUlJPUkVEO1xuICAgIGVycm9yZWRUYXNrKHJlcXVlc3QsIHRhc2suYmxvY2tlZEJvdW5kYXJ5LCB4LCBlcnJvckluZm8pO1xuICAgIHJldHVybjtcbiAgfSBmaW5hbGx5IHtcbiAgICB7XG4gICAgICBzZXRDdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeVJlc291cmNlc1RhcmdldChyZXF1ZXN0LnJlbmRlclN0YXRlLCBudWxsKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBjdXJyZW50VGFza0luREVWID0gcHJldlRhc2tJbkRFVjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cnlSZXBsYXlUYXNrKHJlcXVlc3QsIHRhc2spIHtcbiAgaWYgKHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcyA9PT0gMCkge1xuICAgIC8vIFRoZXJlIGFyZSBubyBwZW5kaW5nIHRhc2tzIHdvcmtpbmcgb24gdGhpcyBzZXQsIHNvIHdlIG11c3QgaGF2ZSBhYm9ydGVkLlxuICAgIHJldHVybjtcbiAgfSAvLyBXZSByZXN0b3JlIHRoZSBjb250ZXh0IHRvIHdoYXQgaXQgd2FzIHdoZW4gd2Ugc3VzcGVuZGVkLlxuICAvLyBXZSBkb24ndCByZXN0b3JlIGl0IGFmdGVyIHdlIGxlYXZlIGJlY2F1c2UgaXQncyBsaWtlbHkgdGhhdCB3ZSdsbCBlbmQgdXBcbiAgLy8gbmVlZGluZyBhIHZlcnkgc2ltaWxhciBjb250ZXh0IHNvb24gYWdhaW4uXG5cblxuICBzd2l0Y2hDb250ZXh0KHRhc2suY29udGV4dCk7XG4gIHZhciBwcmV2VGFza0luREVWID0gbnVsbDtcblxuICB7XG4gICAgcHJldlRhc2tJbkRFViA9IGN1cnJlbnRUYXNrSW5ERVY7XG4gICAgY3VycmVudFRhc2tJbkRFViA9IHRhc2s7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFdlIGNhbGwgdGhlIGRlc3RydWN0aXZlIGZvcm0gdGhhdCBtdXRhdGVzIHRoaXMgdGFzay4gVGhhdCB3YXkgaWYgc29tZXRoaW5nXG4gICAgLy8gc3VzcGVuZHMgYWdhaW4sIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0YXNrIGluc3RlYWQgb2Ygc3Bhd25pbmcgYSBuZXcgb25lLlxuICAgIC8vIFJlc2V0IHRoZSB0YXNrJ3MgdGhlbmFibGUgc3RhdGUgYmVmb3JlIGNvbnRpbnVpbmcsIHNvIHRoYXQgaWYgYSBsYXRlclxuICAgIC8vIGNvbXBvbmVudCBzdXNwZW5kcyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdGFzayBvYmplY3QuIElmIHRoZSBzYW1lXG4gICAgLy8gY29tcG9uZW50IHN1c3BlbmRzIGFnYWluLCB0aGUgdGhlbmFibGUgc3RhdGUgd2lsbCBiZSByZXN0b3JlZC5cbiAgICB2YXIgcHJldlRoZW5hYmxlU3RhdGUgPSB0YXNrLnRoZW5hYmxlU3RhdGU7XG4gICAgdGFzay50aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgcHJldlRoZW5hYmxlU3RhdGUsIHRhc2subm9kZSwgdGFzay5jaGlsZEluZGV4KTtcblxuICAgIGlmICh0YXNrLnJlcGxheS5wZW5kaW5nVGFza3MgPT09IDEgJiYgdGFzay5yZXBsYXkubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhbGwgcmVzdW1hYmxlIHNsb3RzIGJ5IGtleS9pbmRleCBkdXJpbmcgcmVwbGF5aW5nLiBcIiArIFwiVGhlIHRyZWUgZG9lc24ndCBtYXRjaCBzbyBSZWFjdCB3aWxsIGZhbGxiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXCIpO1xuICAgIH1cblxuICAgIHRhc2sucmVwbGF5LnBlbmRpbmdUYXNrcy0tO1xuICAgIHRhc2suYWJvcnRTZXQuZGVsZXRlKHRhc2spO1xuICAgIGZpbmlzaGVkVGFzayhyZXF1ZXN0LCB0YXNrLmJsb2NrZWRCb3VuZGFyeSwgbnVsbCk7XG4gIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgcmVzZXRIb29rc1N0YXRlKCk7XG4gICAgdmFyIHggPSB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24gPyAvLyBUaGlzIGlzIGEgc3BlY2lhbCB0eXBlIG9mIGV4Y2VwdGlvbiB1c2VkIGZvciBTdXNwZW5zZS4gRm9yIGhpc3RvcmljYWxcbiAgICAvLyByZWFzb25zLCB0aGUgcmVzdCBvZiB0aGUgU3VzcGVuc2UgaW1wbGVtZW50YXRpb24gZXhwZWN0cyB0aGUgdGhyb3duXG4gICAgLy8gdmFsdWUgdG8gYmUgYSB0aGVuYWJsZSwgYmVjYXVzZSBiZWZvcmUgYHVzZWAgZXhpc3RlZCB0aGF0IHdhcyB0aGVcbiAgICAvLyAodW5zdGFibGUpIEFQSSBmb3Igc3VzcGVuZGluZy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgY2FuIGNoYW5nZVxuICAgIC8vIGxhdGVyLCBvbmNlIHdlIGRlcHJlY2F0ZSB0aGUgb2xkIEFQSSBpbiBmYXZvciBvZiBgdXNlYC5cbiAgICBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpIDogdGhyb3duVmFsdWU7XG5cbiAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICAgIGlmICh0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQgYWdhaW4sIGxldCdzIHBpY2sgaXQgYmFjayB1cCBsYXRlci5cbiAgICAgICAgdmFyIHBpbmcgPSB0YXNrLnBpbmc7XG4gICAgICAgIHgudGhlbihwaW5nLCBwaW5nKTtcbiAgICAgICAgdGFzay50aGVuYWJsZVN0YXRlID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGFzay5yZXBsYXkucGVuZGluZ1Rhc2tzLS07XG4gICAgdGFzay5hYm9ydFNldC5kZWxldGUodGFzayk7XG4gICAgdmFyIGVycm9ySW5mbyA9IGdldFRocm93bkluZm8ocmVxdWVzdCwgdGFzay5jb21wb25lbnRTdGFjayk7XG4gICAgZXJyb3JlZFJlcGxheShyZXF1ZXN0LCB0YXNrLmJsb2NrZWRCb3VuZGFyeSwgeCwgZXJyb3JJbmZvLCB0YXNrLnJlcGxheS5ub2RlcywgdGFzay5yZXBsYXkuc2xvdHMpO1xuICAgIHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcy0tO1xuXG4gICAgaWYgKHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyA9PT0gMCkge1xuICAgICAgY29tcGxldGVTaGVsbChyZXF1ZXN0KTtcbiAgICB9XG5cbiAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcy0tO1xuXG4gICAgaWYgKHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzID09PSAwKSB7XG4gICAgICBjb21wbGV0ZUFsbChyZXF1ZXN0KTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0gZmluYWxseSB7XG4gICAge1xuICAgICAgc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVxdWVzdC5yZW5kZXJTdGF0ZSwgbnVsbCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgY3VycmVudFRhc2tJbkRFViA9IHByZXZUYXNrSW5ERVY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Xb3JrKHJlcXVlc3QpIHtcbiAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSBDTE9TRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcHJldkNvbnRleHQgPSBnZXRBY3RpdmVDb250ZXh0KCk7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gSG9va3NEaXNwYXRjaGVyO1xuICB2YXIgcHJldkNhY2hlRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldkNhY2hlRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudENhY2hlLmN1cnJlbnQ7XG4gICAgUmVhY3RDdXJyZW50Q2FjaGUuY3VycmVudCA9IERlZmF1bHRDYWNoZURpc3BhdGNoZXI7XG4gIH1cblxuICB2YXIgcHJldlJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdDtcbiAgY3VycmVudFJlcXVlc3QgPSByZXF1ZXN0O1xuICB2YXIgcHJldkdldEN1cnJlbnRTdGFja0ltcGw7XG5cbiAge1xuICAgIHByZXZHZXRDdXJyZW50U3RhY2tJbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50U3RhY2tJbkRFVjtcbiAgfVxuXG4gIHZhciBwcmV2UmVzdW1hYmxlU3RhdGUgPSBjdXJyZW50UmVzdW1hYmxlU3RhdGU7XG4gIHNldEN1cnJlbnRSZXN1bWFibGVTdGF0ZShyZXF1ZXN0LnJlc3VtYWJsZVN0YXRlKTtcblxuICB0cnkge1xuICAgIHZhciBwaW5nZWRUYXNrcyA9IHJlcXVlc3QucGluZ2VkVGFza3M7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcGluZ2VkVGFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0YXNrID0gcGluZ2VkVGFza3NbaV07XG4gICAgICByZXRyeVRhc2socmVxdWVzdCwgdGFzayk7XG4gICAgfVxuXG4gICAgcGluZ2VkVGFza3Muc3BsaWNlKDAsIGkpO1xuXG4gICAgaWYgKHJlcXVlc3QuZGVzdGluYXRpb24gIT09IG51bGwpIHtcbiAgICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIHJlcXVlc3QuZGVzdGluYXRpb24pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB2YXIgZXJyb3JJbmZvID0ge307XG4gICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgZXJyb3JJbmZvKTtcbiAgICBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50UmVzdW1hYmxlU3RhdGUocHJldlJlc3VtYWJsZVN0YXRlKTtcbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudENhY2hlLmN1cnJlbnQgPSBwcmV2Q2FjaGVEaXNwYXRjaGVyO1xuICAgIH1cblxuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFja0ltcGw7XG4gICAgfVxuXG4gICAgaWYgKHByZXZEaXNwYXRjaGVyID09PSBIb29rc0Rpc3BhdGNoZXIpIHtcbiAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB3ZSB3ZXJlIGluIGEgcmVlbnRyYW50IHdvcmsgbG9vcC4gVGhpcyBjb3VsZCBoYXBwZW5cbiAgICAgIC8vIGluIGEgcmVuZGVyZXIgdGhhdCBzdXBwb3J0cyBzeW5jaHJvbm91cyB3b3JrIGxpa2UgcmVuZGVyVG9TdHJpbmcsXG4gICAgICAvLyB3aGVuIGl0J3MgY2FsbGVkIGZyb20gd2l0aGluIGFub3RoZXIgcmVuZGVyZXIuXG4gICAgICAvLyBOb3JtYWxseSB3ZSBkb24ndCBib3RoZXIgc3dpdGNoaW5nIHRoZSBjb250ZXh0cyB0byB0aGVpciByb290L2RlZmF1bHRcbiAgICAgIC8vIHZhbHVlcyB3aGVuIGxlYXZpbmcgYmVjYXVzZSB3ZSdsbCBsaWtlbHkgbmVlZCB0aGUgc2FtZSBvciBzaW1pbGFyXG4gICAgICAvLyBjb250ZXh0IGFnYWluLiBIb3dldmVyLCB3aGVuIHdlJ3JlIGluc2lkZSBhIHN5bmNocm9ub3VzIGxvb3AgbGlrZSB0aGlzXG4gICAgICAvLyB3ZSdsbCB0byByZXN0b3JlIHRoZSBjb250ZXh0IHRvIHdoYXQgaXQgd2FzIGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICBzd2l0Y2hDb250ZXh0KHByZXZDb250ZXh0KTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVxdWVzdCA9IHByZXZSZXF1ZXN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCkge1xuICBzZWdtZW50LnBhcmVudEZsdXNoZWQgPSB0cnVlO1xuXG4gIHN3aXRjaCAoc2VnbWVudC5zdGF0dXMpIHtcbiAgICBjYXNlIFBFTkRJTkc6XG4gICAgICB7XG4gICAgICAgIC8vIFdlJ3JlIGVtaXR0aW5nIGEgcGxhY2Vob2xkZXIgZm9yIHRoaXMgc2VnbWVudCB0byBiZSBmaWxsZWQgaW4gbGF0ZXIuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSdsbCBuZWVkIHRvIGFzc2lnbiBpdCBhbiBJRCAtIHRvIHJlZmVyIHRvIGl0IGJ5LlxuICAgICAgICBzZWdtZW50LmlkID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKys7IC8vIEZhbGx0aHJvdWdoXG4gICAgICB9XG5cbiAgICBjYXNlIFBPU1RQT05FRDpcbiAgICAgIHtcbiAgICAgICAgdmFyIHNlZ21lbnRJRCA9IHNlZ21lbnQuaWQ7IC8vIFdoZW4gdGhpcyBzZWdtZW50IGZpbmFsbHkgY29tcGxldGVzIGl0IHdvbid0IGJlIGVtYmVkZGVkIGluIHRleHQgc2luY2UgaXQgd2lsbCBmbHVzaCBzZXBhcmF0ZWx5XG5cbiAgICAgICAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9IGZhbHNlO1xuICAgICAgICBzZWdtZW50LnRleHRFbWJlZGRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gd3JpdGVQbGFjZWhvbGRlcihkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgc2VnbWVudElEKTtcbiAgICAgIH1cblxuICAgIGNhc2UgQ09NUExFVEVEOlxuICAgICAge1xuICAgICAgICBzZWdtZW50LnN0YXR1cyA9IEZMVVNIRUQ7XG4gICAgICAgIHZhciByID0gdHJ1ZTtcbiAgICAgICAgdmFyIGNodW5rcyA9IHNlZ21lbnQuY2h1bmtzO1xuICAgICAgICB2YXIgY2h1bmtJZHggPSAwO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBzZWdtZW50LmNoaWxkcmVuO1xuXG4gICAgICAgIGZvciAodmFyIGNoaWxkSWR4ID0gMDsgY2hpbGRJZHggPCBjaGlsZHJlbi5sZW5ndGg7IGNoaWxkSWR4KyspIHtcbiAgICAgICAgICB2YXIgbmV4dENoaWxkID0gY2hpbGRyZW5bY2hpbGRJZHhdOyAvLyBXcml0ZSBhbGwgdGhlIGNodW5rcyB1cCB1bnRpbCB0aGUgbmV4dCBjaGlsZC5cblxuICAgICAgICAgIGZvciAoOyBjaHVua0lkeCA8IG5leHRDaGlsZC5pbmRleDsgY2h1bmtJZHgrKykge1xuICAgICAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmtzW2NodW5rSWR4XSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgciA9IGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgbmV4dENoaWxkKTtcbiAgICAgICAgfSAvLyBGaW5hbGx5IGp1c3Qgd3JpdGUgYWxsIHRoZSByZW1haW5pbmcgY2h1bmtzXG5cblxuICAgICAgICBmb3IgKDsgY2h1bmtJZHggPCBjaHVua3MubGVuZ3RoIC0gMTsgY2h1bmtJZHgrKykge1xuICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNodW5rc1tjaHVua0lkeF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNodW5rSWR4IDwgY2h1bmtzLmxlbmd0aCkge1xuICAgICAgICAgIHIgPSB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjaHVua3NbY2h1bmtJZHhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGVkLCBlcnJvcmVkIG9yIGFscmVhZHkgZmx1c2hlZCBib3VuZGFyaWVzIHNob3VsZCBub3QgYmUgZmx1c2hlZCBhZ2Fpbi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpIHtcbiAgdmFyIGJvdW5kYXJ5ID0gc2VnbWVudC5ib3VuZGFyeTtcblxuICBpZiAoYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICAvLyBOb3QgYSBzdXNwZW5zZSBib3VuZGFyeS5cbiAgICByZXR1cm4gZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgfVxuXG4gIGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQgPSB0cnVlOyAvLyBUaGlzIHNlZ21lbnQgaXMgYSBTdXNwZW5zZSBib3VuZGFyeS4gV2UgbmVlZCB0byBkZWNpZGUgd2hldGhlciB0b1xuICAvLyBlbWl0IHRoZSBjb250ZW50IG9yIHRoZSBmYWxsYmFjayBub3cuXG5cbiAgaWYgKGJvdW5kYXJ5LnN0YXR1cyA9PT0gQ0xJRU5UX1JFTkRFUkVEKSB7XG4gICAgLy8gRW1pdCBhIGNsaWVudCByZW5kZXJlZCBzdXNwZW5zZSBib3VuZGFyeSB3cmFwcGVyLlxuICAgIC8vIFdlIG5ldmVyIHF1ZXVlIHRoZSBpbm5lciBib3VuZGFyeSBzbyB3ZSdsbCBuZXZlciBlbWl0IGl0cyBjb250ZW50IG9yIHBhcnRpYWwgc2VnbWVudHMuXG4gICAgd3JpdGVTdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgYm91bmRhcnkuZXJyb3JEaWdlc3QsIGJvdW5kYXJ5LmVycm9yTWVzc2FnZSwgYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjayk7IC8vIEZsdXNoIHRoZSBmYWxsYmFjay5cblxuICAgIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlRW5kQ2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uKTtcbiAgfSBlbHNlIGlmIChib3VuZGFyeS5zdGF0dXMgIT09IENPTVBMRVRFRCkge1xuICAgIGlmIChib3VuZGFyeS5zdGF0dXMgPT09IFBFTkRJTkcpIHtcbiAgICAgIC8vIEZvciBwZW5kaW5nIGJvdW5kYXJpZXMgd2UgbGF6aWx5IGFzc2lnbiBhbiBJRCB0byB0aGUgYm91bmRhcnlcbiAgICAgIC8vIGFuZCByb290IHNlZ21lbnQuXG4gICAgICBib3VuZGFyeS5yb290U2VnbWVudElEID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKys7XG4gICAgfVxuXG4gICAgaWYgKGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYXQgbGVhc3QgcGFydGlhbGx5IGNvbXBsZXRlLCB3ZSBjYW4gcXVldWUgaXQgdG8gYmUgcGFydGlhbGx5IGVtaXR0ZWQgZWFybHkuXG4gICAgICByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpO1xuICAgIH0gLy8gVGhpcyBib3VuZGFyeSBpcyBzdGlsbCBsb2FkaW5nLiBFbWl0IGEgcGVuZGluZyBzdXNwZW5zZSBib3VuZGFyeSB3cmFwcGVyLlxuXG5cbiAgICB2YXIgaWQgPSBib3VuZGFyeS5yb290U2VnbWVudElEO1xuICAgIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgaWQpOyAvLyBGbHVzaCB0aGUgZmFsbGJhY2suXG5cbiAgICBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpO1xuICAgIHJldHVybiB3cml0ZUVuZFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uKTtcbiAgfSBlbHNlIGlmIChib3VuZGFyeS5ieXRlU2l6ZSA+IHJlcXVlc3QucHJvZ3Jlc3NpdmVDaHVua1NpemUpIHtcbiAgICAvLyBUaGlzIGJvdW5kYXJ5IGlzIGxhcmdlIGFuZCB3aWxsIGJlIGVtaXR0ZWQgc2VwYXJhdGVseSBzbyB0aGF0IHdlIGNhbiBwcm9ncmVzc2l2ZWx5IHNob3dcbiAgICAvLyBvdGhlciBjb250ZW50LiBXZSBhZGQgaXQgdG8gdGhlIHF1ZXVlIGR1cmluZyB0aGUgZmx1c2ggYmVjYXVzZSB3ZSBoYXZlIHRvIGVuc3VyZSB0aGF0XG4gICAgLy8gdGhlIHBhcmVudCBmbHVzaGVzIGZpcnN0IHNvIHRoYXQgdGhlcmUncyBzb21ldGhpbmcgdG8gaW5qZWN0IGl0IGludG8uXG4gICAgLy8gV2UgYWxzbyBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3MgZW1pdHRlZCBpbnRvIHRoZSBxdWV1ZSBpbiBhIGRldGVybWluaXN0aWMgc2xvdC5cbiAgICAvLyBJLmUuIHdlIGNhbid0IGluc2VydCBpdCBoZXJlIHdoZW4gaXQgY29tcGxldGVzLlxuICAgIC8vIEFzc2lnbiBhbiBJRCB0byByZWZlciB0byB0aGUgZnV0dXJlIGNvbnRlbnQgYnkuXG4gICAgYm91bmRhcnkucm9vdFNlZ21lbnRJRCA9IHJlcXVlc3QubmV4dFNlZ21lbnRJZCsrO1xuICAgIHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KTsgLy8gRW1pdCBhIHBlbmRpbmcgcmVuZGVyZWQgc3VzcGVuc2UgYm91bmRhcnkgd3JhcHBlci5cblxuICAgIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgYm91bmRhcnkucm9vdFNlZ21lbnRJRCk7IC8vIEZsdXNoIHRoZSBmYWxsYmFjay5cblxuICAgIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlRW5kUGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24pO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGhvaXN0UmVzb3VyY2VzKHJlcXVlc3QucmVuZGVyU3RhdGUsIGJvdW5kYXJ5LnJlc291cmNlcyk7XG4gICAgfSAvLyBXZSBjYW4gaW5saW5lIHRoaXMgYm91bmRhcnkncyBjb250ZW50IGFzIGEgY29tcGxldGUgYm91bmRhcnkuXG5cblxuICAgIHdyaXRlU3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uKTtcbiAgICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcblxuICAgIGlmIChjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSBwcmV2aW91c2x5IHVudmlzaXRlZCBib3VuZGFyeSBtdXN0IGhhdmUgZXhhY3RseSBvbmUgcm9vdCBzZWdtZW50LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cblxuICAgIHZhciBjb250ZW50U2VnbWVudCA9IGNvbXBsZXRlZFNlZ21lbnRzWzBdO1xuICAgIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgY29udGVudFNlZ21lbnQpO1xuICAgIHJldHVybiB3cml0ZUVuZENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoQ2xpZW50UmVuZGVyZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnkpIHtcbiAgcmV0dXJuIHdyaXRlQ2xpZW50UmVuZGVyQm91bmRhcnlJbnN0cnVjdGlvbihkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgYm91bmRhcnkucm9vdFNlZ21lbnRJRCwgYm91bmRhcnkuZXJyb3JEaWdlc3QsIGJvdW5kYXJ5LmVycm9yTWVzc2FnZSwgYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjayk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoU2VnbWVudENvbnRhaW5lcihyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCkge1xuICB3cml0ZVN0YXJ0U2VnbWVudChkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgc2VnbWVudC5wYXJlbnRGb3JtYXRDb250ZXh0LCBzZWdtZW50LmlkKTtcbiAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgcmV0dXJuIHdyaXRlRW5kU2VnbWVudChkZXN0aW5hdGlvbiwgc2VnbWVudC5wYXJlbnRGb3JtYXRDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnkpIHtcbiAge1xuICAgIHNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0KHJlcXVlc3QucmVuZGVyU3RhdGUsIGJvdW5kYXJ5LnJlc291cmNlcyk7XG4gIH1cblxuICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgY29tcGxldGVkU2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IGNvbXBsZXRlZFNlZ21lbnRzW2ldO1xuICAgIGZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnksIHNlZ21lbnQpO1xuICB9XG5cbiAgY29tcGxldGVkU2VnbWVudHMubGVuZ3RoID0gMDtcblxuICB7XG4gICAgd3JpdGVSZXNvdXJjZXNGb3JCb3VuZGFyeShkZXN0aW5hdGlvbiwgYm91bmRhcnkucmVzb3VyY2VzLCByZXF1ZXN0LnJlbmRlclN0YXRlKTtcbiAgfVxuXG4gIHJldHVybiB3cml0ZUNvbXBsZXRlZEJvdW5kYXJ5SW5zdHJ1Y3Rpb24oZGVzdGluYXRpb24sIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsIHJlcXVlc3QucmVuZGVyU3RhdGUsIGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQsIGJvdW5kYXJ5LnJlc291cmNlcyk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFydGlhbEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSkge1xuICB7XG4gICAgc2V0Q3VycmVudGx5UmVuZGVyaW5nQm91bmRhcnlSZXNvdXJjZXNUYXJnZXQocmVxdWVzdC5yZW5kZXJTdGF0ZSwgYm91bmRhcnkucmVzb3VyY2VzKTtcbiAgfVxuXG4gIHZhciBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzO1xuICB2YXIgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gY29tcGxldGVkU2VnbWVudHNbaV07XG5cbiAgICBpZiAoIWZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnksIHNlZ21lbnQpKSB7XG4gICAgICBpKys7XG4gICAgICBjb21wbGV0ZWRTZWdtZW50cy5zcGxpY2UoMCwgaSk7IC8vIE9ubHkgd3JpdGUgYXMgbXVjaCBhcyB0aGUgYnVmZmVyIHdhbnRzLiBTb21ldGhpbmcgaGlnaGVyIHByaW9yaXR5XG4gICAgICAvLyBtaWdodCB3YW50IHRvIHdyaXRlIGxhdGVyLlxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgY29tcGxldGVkU2VnbWVudHMuc3BsaWNlKDAsIGkpO1xuXG4gIHtcbiAgICAvLyBUaGUgd2F5IHRoaXMgaXMgc3RydWN0dXJlZCB3ZSBvbmx5IHdyaXRlIHJlc291cmNlcyBmb3IgcGFydGlhbCBib3VuZGFyaWVzXG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gYmFja3ByZXNzdXJlLiBMYXRlciBiZWZvcmUgd2UgY29tcGxldGUgdGhlIGJvdW5kYXJ5IHdlXG4gICAgLy8gd2lsbCB3cml0ZSByZXNvdXJjZXMgcmVnYXJkbGVzcyBvZiBiYWNrcHJlc3N1cmUgYmVmb3JlIHdlIGVtaXQgdGhlXG4gICAgLy8gY29tcGxldGlvbiBpbnN0cnVjdGlvblxuICAgIHJldHVybiB3cml0ZVJlc291cmNlc0ZvckJvdW5kYXJ5KGRlc3RpbmF0aW9uLCBib3VuZGFyeS5yZXNvdXJjZXMsIHJlcXVlc3QucmVuZGVyU3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnksIHNlZ21lbnQpIHtcbiAgaWYgKHNlZ21lbnQuc3RhdHVzID09PSBGTFVTSEVEKSB7XG4gICAgLy8gV2UndmUgYWxyZWFkeSBmbHVzaGVkIHRoaXMgaW5saW5lLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHNlZ21lbnRJRCA9IHNlZ21lbnQuaWQ7XG5cbiAgaWYgKHNlZ21lbnRJRCA9PT0gLTEpIHtcbiAgICAvLyBUaGlzIHNlZ21lbnQgd2Fzbid0IHByZXZpb3VzbHkgcmVmZXJyZWQgdG8uIFRoaXMgaGFwcGVucyBhdCB0aGUgcm9vdCBvZlxuICAgIC8vIGEgYm91bmRhcnkuIFdlIG1ha2Uga2luZCBvZiBhIGxlYXAgaGVyZSBhbmQgYXNzdW1lIHRoaXMgaXMgdGhlIHJvb3QuXG4gICAgdmFyIHJvb3RTZWdtZW50SUQgPSBzZWdtZW50LmlkID0gYm91bmRhcnkucm9vdFNlZ21lbnRJRDtcblxuICAgIGlmIChyb290U2VnbWVudElEID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHJvb3Qgc2VnbWVudCBJRCBtdXN0IGhhdmUgYmVlbiBhc3NpZ25lZCBieSBub3cuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZsdXNoU2VnbWVudENvbnRhaW5lcihyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gIH0gZWxzZSBpZiAoc2VnbWVudElEID09PSBib3VuZGFyeS5yb290U2VnbWVudElEKSB7XG4gICAgLy8gV2hlbiB3ZSBlbWl0IHBvc3Rwb25lZCBib3VuZGFyaWVzLCB3ZSBtaWdodCBoYXZlIGFzc2lnbmVkIHRoZSBJRCBhbHJlYWR5XG4gICAgLy8gYnV0IGl0J3Mgc3RpbGwgdGhlIHJvb3Qgc2VnbWVudCBzbyB3ZSBjYW4ndCBpbmplY3QgaXQgaW50byB0aGUgcGFyZW50IHlldC5cbiAgICByZXR1cm4gZmx1c2hTZWdtZW50Q29udGFpbmVyKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBmbHVzaFNlZ21lbnRDb250YWluZXIocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpO1xuICAgIHJldHVybiB3cml0ZUNvbXBsZXRlZFNlZ21lbnRJbnN0cnVjdGlvbihkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXN1bWFibGVTdGF0ZSwgcmVxdWVzdC5yZW5kZXJTdGF0ZSwgc2VnbWVudElEKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbikge1xuICBiZWdpbldyaXRpbmcoKTtcblxuICB0cnkge1xuICAgIC8vIFRoZSBzdHJ1Y3R1cmUgb2YgdGhpcyBpcyB0byBnbyB0aHJvdWdoIGVhY2ggcXVldWUgb25lIGJ5IG9uZSBhbmQgd3JpdGVcbiAgICAvLyB1bnRpbCB0aGUgc2luayB0ZWxscyB1cyB0byBzdG9wLiBXaGVuIHdlIHNob3VsZCBzdG9wLCB3ZSBzdGlsbCBmaW5pc2ggd3JpdGluZ1xuICAgIC8vIHRoYXQgaXRlbSBmdWxseSBhbmQgdGhlbiB5aWVsZC4gQXQgdGhhdCBwb2ludCB3ZSByZW1vdmUgdGhlIGFscmVhZHkgY29tcGxldGVkXG4gICAgLy8gaXRlbXMgdXAgdW50aWwgdGhlIHBvaW50IHdlIGNvbXBsZXRlZCB0aGVtLlxuICAgIHZhciBpO1xuICAgIHZhciBjb21wbGV0ZWRSb290U2VnbWVudCA9IHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQ7XG5cbiAgICBpZiAoY29tcGxldGVkUm9vdFNlZ21lbnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChjb21wbGV0ZWRSb290U2VnbWVudC5zdGF0dXMgPT09IFBPU1RQT05FRCkge1xuICAgICAgICAvLyBXZSBwb3N0cG9uZWQgdGhlIHJvb3QsIHNvIHdlIHdyaXRlIG5vdGhpbmcuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAocmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzID09PSAwKSB7XG4gICAgICAgIGlmIChlbmFibGVGbG9hdCkge1xuICAgICAgICAgIHdyaXRlUHJlYW1ibGUoZGVzdGluYXRpb24sIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsIHJlcXVlc3QucmVuZGVyU3RhdGUsIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzID09PSAwICYmIHJlcXVlc3QudHJhY2tlZFBvc3Rwb25lcyA9PT0gbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIGNvbXBsZXRlZFJvb3RTZWdtZW50KTtcbiAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IG51bGw7XG4gICAgICAgIHdyaXRlQ29tcGxldGVkUm9vdChkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZW5kZXJTdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBoYXZlbid0IGZsdXNoZWQgdGhlIHJvb3QgeWV0IHNvIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgYW55IG90aGVyIGJyYW5jaGVzIGZ1cnRoZXIgZG93blxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVuYWJsZUZsb2F0KSB7XG4gICAgICB3cml0ZUhvaXN0YWJsZXMoZGVzdGluYXRpb24sIHJlcXVlc3QucmVzdW1hYmxlU3RhdGUsIHJlcXVlc3QucmVuZGVyU3RhdGUpO1xuICAgIH0gLy8gV2UgZW1pdCBjbGllbnQgcmVuZGVyaW5nIGluc3RydWN0aW9ucyBmb3IgYWxyZWFkeSBlbWl0dGVkIGJvdW5kYXJpZXMgZmlyc3QuXG4gICAgLy8gVGhpcyBpcyBzbyB0aGF0IHdlIGNhbiBzaWduYWwgdG8gdGhlIGNsaWVudCB0byBzdGFydCBjbGllbnQgcmVuZGVyaW5nIHRoZW0gYXNcbiAgICAvLyBzb29uIGFzIHBvc3NpYmxlLlxuXG5cbiAgICB2YXIgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzID0gcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYm91bmRhcnkgPSBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXNbaV07XG5cbiAgICAgIGlmICghZmx1c2hDbGllbnRSZW5kZXJlZEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSkpIHtcbiAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgIGkrKztcbiAgICAgICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7IC8vIE5leHQgd2UgZW1pdCBhbnkgY29tcGxldGUgYm91bmRhcmllcy4gSXQncyBiZXR0ZXIgdG8gZmF2b3IgYm91bmRhcmllc1xuICAgIC8vIHRoYXQgYXJlIGNvbXBsZXRlbHkgZG9uZSBzaW5jZSB3ZSBjYW4gYWN0dWFsbHkgc2hvdyB0aGVtLCB0aGFuIGl0IGlzIHRvIGVtaXRcbiAgICAvLyBhbnkgaW5kaXZpZHVhbCBzZWdtZW50cyBmcm9tIGEgcGFydGlhbGx5IGNvbXBsZXRlIGJvdW5kYXJ5LlxuXG4gICAgdmFyIGNvbXBsZXRlZEJvdW5kYXJpZXMgPSByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY29tcGxldGVkQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9ib3VuZGFyeSA9IGNvbXBsZXRlZEJvdW5kYXJpZXNbaV07XG5cbiAgICAgIGlmICghZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgX2JvdW5kYXJ5KSkge1xuICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgaSsrO1xuICAgICAgICBjb21wbGV0ZWRCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBsZXRlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpOyAvLyBBbGxvdyBhbnl0aGluZyB3cml0dGVuIHNvIGZhciB0byBmbHVzaCB0byB0aGUgdW5kZXJseWluZyBzaW5rIGJlZm9yZVxuICAgIC8vIHdlIGNvbnRpbnVlIHdpdGggbG93ZXIgcHJpb3JpdGllcy5cblxuICAgIGNvbXBsZXRlV3JpdGluZyhkZXN0aW5hdGlvbik7XG4gICAgYmVnaW5Xcml0aW5nKGRlc3RpbmF0aW9uKTsgLy8gVE9ETzogSGVyZSB3ZSdsbCBlbWl0IGRhdGEgdXNlZCBieSBoeWRyYXRpb24uXG4gICAgLy8gTmV4dCB3ZSBlbWl0IGFueSBzZWdtZW50cyBvZiBhbnkgYm91bmRhcmllcyB0aGF0IGFyZSBwYXJ0aWFsbHkgY29tcGxldGVcbiAgICAvLyBidXQgbm90IGRlZXBseSBjb21wbGV0ZS5cblxuICAgIHZhciBwYXJ0aWFsQm91bmRhcmllcyA9IHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcGFydGlhbEJvdW5kYXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfYm91bmRhcnkyID0gcGFydGlhbEJvdW5kYXJpZXNbaV07XG5cbiAgICAgIGlmICghZmx1c2hQYXJ0aWFsQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIF9ib3VuZGFyeTIpKSB7XG4gICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICBpKys7XG4gICAgICAgIHBhcnRpYWxCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcnRpYWxCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTsgLy8gTmV4dCB3ZSBjaGVjayB0aGUgY29tcGxldGVkIGJvdW5kYXJpZXMgYWdhaW4uIFRoaXMgbWF5IGhhdmUgaGFkXG4gICAgLy8gYm91bmRhcmllcyBhZGRlZCB0byBpdCBpbiBjYXNlIHRoZXkgd2VyZSB0b28gbGFyZ2VkIHRvIGJlIGlubGluZWQuXG4gICAgLy8gTmV3IG9uZXMgbWlnaHQgYmUgYWRkZWQgaW4gdGhpcyBsb29wLlxuXG4gICAgdmFyIGxhcmdlQm91bmRhcmllcyA9IHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsYXJnZUJvdW5kYXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfYm91bmRhcnkzID0gbGFyZ2VCb3VuZGFyaWVzW2ldO1xuXG4gICAgICBpZiAoIWZsdXNoQ29tcGxldGVkQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIF9ib3VuZGFyeTMpKSB7XG4gICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICBpKys7XG4gICAgICAgIGxhcmdlQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXJnZUJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChyZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyA9PT0gMCAmJiByZXF1ZXN0LnBpbmdlZFRhc2tzLmxlbmd0aCA9PT0gMCAmJiByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5sZW5ndGggPT09IDAgJiYgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLmxlbmd0aCA9PT0gMCAvLyBXZSBkb24ndCBuZWVkIHRvIGNoZWNrIGFueSBwYXJ0aWFsbHkgY29tcGxldGVkIHNlZ21lbnRzIGJlY2F1c2VcbiAgICAvLyBlaXRoZXIgdGhleSBoYXZlIHBlbmRpbmcgdGFzayBvciB0aGV5J3JlIGNvbXBsZXRlLlxuICAgICkge1xuICAgICAgICByZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIHdyaXRlIHRoZSB0cmFpbGluZyB0YWdzIGJ1dCBvbmx5IGlmIGRvbid0IGhhdmUgYW55IGRhdGEgdG8gcmVzdW1lLlxuICAgICAgICAgIC8vIElmIHdlIG5lZWQgdG8gcmVzdW1lIHdlJ2xsIHdyaXRlIHRoZSBwb3N0YW1ibGUgaW4gdGhlIHJlc3VtZSBpbnN0ZWFkLlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHdyaXRlUG9zdGFtYmxlKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3VtYWJsZVN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb21wbGV0ZVdyaXRpbmcoZGVzdGluYXRpb24pO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAocmVxdWVzdC5hYm9ydGFibGVUYXNrcy5zaXplICE9PSAwKSB7XG4gICAgICAgICAgICBlcnJvcignVGhlcmUgd2FzIHN0aWxsIGFib3J0YWJsZSB0YXNrIGF0IHRoZSByb290IHdoZW4gd2UgY2xvc2VkLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBXZSdyZSBkb25lLlxuXG5cbiAgICAgICAgY2xvc2UoZGVzdGluYXRpb24pOyAvLyBXZSBuZWVkIHRvIHN0b3AgZmxvd2luZyBub3cgYmVjYXVzZSB3ZSBkbyBub3Qgd2FudCBhbnkgYXN5bmMgY29udGV4dHMgd2hpY2ggbWlnaHQgY2FsbFxuICAgICAgICAvLyBmbG9hdCBtZXRob2RzIHRvIGluaXRpYXRlIGFueSBmbHVzaGVzIGFmdGVyIHRoaXMgcG9pbnRcblxuICAgICAgICBzdG9wRmxvd2luZyhyZXF1ZXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICBjb21wbGV0ZVdyaXRpbmcoZGVzdGluYXRpb24pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFdvcmsocmVxdWVzdCkge1xuICByZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gcmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbDtcblxuICB7XG4gICAgc2NoZWR1bGVXb3JrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtV29yayhyZXF1ZXN0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LnRyYWNrZWRQb3N0cG9uZXMgPT09IG51bGwpIHtcbiAgICAvLyB0aGlzIGlzIGVpdGhlciBhIHJlZ3VsYXIgcmVuZGVyIG9yIGEgcmVzdW1lLiBGb3IgcmVndWxhciByZW5kZXIgd2Ugd2FudFxuICAgIC8vIHRvIGNhbGwgZW1pdEVhcmx5UHJlbG9hZHMgYWZ0ZXIgdGhlIGZpcnN0IHBlcmZvcm1Xb3JrIGJlY2F1c2Ugd2Ugd2FudFxuICAgIC8vIGFyZSByZXNwb25kaW5nIHRvIGEgbGl2ZSByZXF1ZXN0IGFuZCBuZWVkIHRvIGJhbGFuY2Ugc2VuZGluZyBzb21ldGhpbmcgZWFybHlcbiAgICAvLyAoaS5lLiBkb24ndCB3YW50IGZvciB0aGUgc2hlbGwgdG8gZmluaXNoKSBidXQgd2UgbmVlZCBzb21ldGhpbmcgdG8gc2VuZC5cbiAgICAvLyBUaGUgb25seSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGlzIGZvciBET00gYXQgdGhlIG1vbWVudCBhbmQgZHVyaW5nIHJlc3VtZXMgbm90aGluZ1xuICAgIC8vIGFjdHVhbGx5IGVtaXRzIGJ1dCB0aGUgY29kZSBwYXRocyBoZXJlIGFyZSB0aGUgc2FtZS5cbiAgICAvLyBEdXJpbmcgYSBwcmVyZW5kZXIgd2UgZG9uJ3Qgd2FudCB0byBiZSB0b28gYWdncmVzc2l2ZSBpbiBlbWl0dGluZyBlYXJseSBwcmVsb2Fkc1xuICAgIC8vIGJlY2F1c2Ugd2UgYXJlbid0IHJlc3BvbmRpbmcgdG8gYSBsaXZlIHJlcXVlc3QgYW5kIHdlIGNhbiB3YWl0IGZvciB0aGUgcHJlcmVuZGVyIHRvXG4gICAgLy8gcG9zdHBvbmUgYmVmb3JlIHdlIGVtaXQgYW55dGhpbmcuXG4gICAge1xuICAgICAgc2NoZWR1bGVXb3JrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVucXVldWVFYXJseVByZWxvYWRzQWZ0ZXJJbml0aWFsV29yayhyZXF1ZXN0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlbnF1ZXVlRWFybHlQcmVsb2Fkc0FmdGVySW5pdGlhbFdvcmsocmVxdWVzdCkge1xuICB2YXIgc2hlbGxDb21wbGV0ZSA9IHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyA9PT0gMDtcbiAgc2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMocmVxdWVzdCwgc2hlbGxDb21wbGV0ZSk7XG59XG5cbmZ1bmN0aW9uIGVucXVldWVGbHVzaChyZXF1ZXN0KSB7XG4gIGlmIChyZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID09PSBmYWxzZSAmJiAvLyBJZiB0aGVyZSBhcmUgcGluZ2VkIHRhc2tzIHdlIGFyZSBnb2luZyB0byBmbHVzaCBhbnl3YXkgYWZ0ZXIgd29yayBjb21wbGV0ZXNcbiAgcmVxdWVzdC5waW5nZWRUYXNrcy5sZW5ndGggPT09IDAgJiYgLy8gSWYgdGhlcmUgaXMgbm8gZGVzdGluYXRpb24gdGhlcmUgaXMgbm90aGluZyB3ZSBjYW4gZmx1c2ggdG8uIEEgZmx1c2ggd2lsbFxuICAvLyBoYXBwZW4gd2hlbiB3ZSBzdGFydCBmbG93aW5nIGFnYWluXG4gIHJlcXVlc3QuZGVzdGluYXRpb24gIT09IG51bGwpIHtcbiAgICByZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBzY2hlZHVsZVdvcmsoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBleGlzdGVuY2UgY2hlY2sgZGVzdGluYXRpb24gYWdhaW4gaGVyZSBiZWNhdXNlIGl0IG1pZ2h0IGdvIGF3YXlcbiAgICAgIC8vIGluIGJldHdlZW4gdGhlIGVucXVldWVGbHVzaCBjYWxsIGFuZCB0aGUgd29yayBleGVjdXRpb25cbiAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHJlcXVlc3QuZGVzdGluYXRpb247XG5cbiAgICAgIGlmIChkZXN0aW5hdGlvbikge1xuICAgICAgICBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBpbnRlbnRlZCB0byBvbmx5IGJlIGNhbGxlZCBkdXJpbmcgdGhlIHBpcGUgZnVuY3Rpb24gZm9yIHRoZSBOb2RlIGJ1aWxkcy5cbmZ1bmN0aW9uIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBkZXN0aW5hdGlvbikge1xuICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IENMT1NJTkcpIHtcbiAgICByZXF1ZXN0LnN0YXR1cyA9IENMT1NFRDtcbiAgICBjbG9zZVdpdGhFcnJvcihkZXN0aW5hdGlvbiwgcmVxdWVzdC5mYXRhbEVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IENMT1NFRCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsKSB7XG4gICAgLy8gV2UncmUgYWxyZWFkeSBmbG93aW5nLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlcXVlc3QuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcblxuICB0cnkge1xuICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB2YXIgZXJyb3JJbmZvID0ge307XG4gICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgZXJyb3JJbmZvKTtcbiAgICBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gc3RvcEZsb3dpbmcocmVxdWVzdCkge1xuICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbn0gLy8gVGhpcyBpcyBjYWxsZWQgdG8gZWFybHkgdGVybWluYXRlIGEgcmVxdWVzdC4gSXQgcHV0cyBhbGwgcGVuZGluZyBib3VuZGFyaWVzIGluIGNsaWVudCByZW5kZXJlZCBzdGF0ZS5cblxuZnVuY3Rpb24gYWJvcnQocmVxdWVzdCwgcmVhc29uKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFib3J0YWJsZVRhc2tzID0gcmVxdWVzdC5hYm9ydGFibGVUYXNrcztcblxuICAgIGlmIChhYm9ydGFibGVUYXNrcy5zaXplID4gMCkge1xuICAgICAgdmFyIGVycm9yID0gcmVhc29uID09PSB1bmRlZmluZWQgPyBuZXcgRXJyb3IoJ1RoZSByZW5kZXIgd2FzIGFib3J0ZWQgYnkgdGhlIHNlcnZlciB3aXRob3V0IGEgcmVhc29uLicpIDogcmVhc29uO1xuICAgICAgYWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAodGFzaykge1xuICAgICAgICByZXR1cm4gYWJvcnRUYXNrKHRhc2ssIHJlcXVlc3QsIGVycm9yKTtcbiAgICAgIH0pO1xuICAgICAgYWJvcnRhYmxlVGFza3MuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbCkge1xuICAgICAgZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgcmVxdWVzdC5kZXN0aW5hdGlvbik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHZhciBlcnJvckluZm8gPSB7fTtcbiAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBlcnJvckluZm8pO1xuICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaFJlc291cmNlcyhyZXF1ZXN0KSB7XG4gIGVucXVldWVGbHVzaChyZXF1ZXN0KTtcbn1cbmZ1bmN0aW9uIGdldEZvcm1TdGF0ZShyZXF1ZXN0KSB7XG4gIHJldHVybiByZXF1ZXN0LmZvcm1TdGF0ZTtcbn1cbmZ1bmN0aW9uIGdldFJlc3VtYWJsZVN0YXRlKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHJlcXVlc3QucmVzdW1hYmxlU3RhdGU7XG59XG5mdW5jdGlvbiBnZXRSZW5kZXJTdGF0ZShyZXF1ZXN0KSB7XG4gIHJldHVybiByZXF1ZXN0LnJlbmRlclN0YXRlO1xufVxuXG5mdW5jdGlvbiByZW5kZXJUb1JlYWRhYmxlU3RyZWFtKGNoaWxkcmVuLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIG9uRmF0YWxFcnJvcjtcbiAgICB2YXIgb25BbGxSZWFkeTtcbiAgICB2YXIgYWxsUmVhZHkgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcbiAgICAgIG9uQWxsUmVhZHkgPSByZXM7XG4gICAgICBvbkZhdGFsRXJyb3IgPSByZWo7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBvblNoZWxsUmVhZHkoKSB7XG4gICAgICB2YXIgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgdHlwZTogJ2J5dGVzJyxcbiAgICAgICAgcHVsbDogZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBzdGFydEZsb3dpbmcocmVxdWVzdCwgY29udHJvbGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIHN0b3BGbG93aW5nKHJlcXVlc3QpO1xuICAgICAgICAgIGFib3J0KHJlcXVlc3QsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgIH0sIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBzaXplKCkgbWV0aG9kcyBhcmUgbm90IGFsbG93ZWQgb24gYnl0ZSBzdHJlYW1zLlxuICAgICAge1xuICAgICAgICBoaWdoV2F0ZXJNYXJrOiAwXG4gICAgICB9KTsgLy8gVE9ETzogTW92ZSB0byBzdWItY2xhc3NpbmcgUmVhZGFibGVTdHJlYW0uXG5cbiAgICAgIHN0cmVhbS5hbGxSZWFkeSA9IGFsbFJlYWR5O1xuICAgICAgcmVzb2x2ZShzdHJlYW0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uU2hlbGxFcnJvcihlcnJvcikge1xuICAgICAgLy8gSWYgdGhlIHNoZWxsIGVycm9ycyB0aGUgY2FsbGVyIG9mIGByZW5kZXJUb1JlYWRhYmxlU3RyZWFtYCB3b24ndCBoYXZlIGFjY2VzcyB0byBgYWxsUmVhZHlgLlxuICAgICAgLy8gSG93ZXZlciwgYGFsbFJlYWR5YCB3aWxsIGJlIHJlamVjdGVkIGJ5IGBvbkZhdGFsRXJyb3JgIGFzIHdlbGwuXG4gICAgICAvLyBTbyB3ZSBuZWVkIHRvIGNhdGNoIHRoZSBkdXBsaWNhdGUsIHVuY2F0Y2hhYmxlIGZhdGFsIGVycm9yIGluIGBhbGxSZWFkeWAgdG8gcHJldmVudCBhIGBVbmhhbmRsZWRQcm9taXNlUmVqZWN0aW9uYC5cbiAgICAgIGFsbFJlYWR5LmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgdmFyIG9uSGVhZGVycyA9IG9wdGlvbnMgPyBvcHRpb25zLm9uSGVhZGVycyA6IHVuZGVmaW5lZDtcbiAgICB2YXIgb25IZWFkZXJzSW1wbDtcblxuICAgIGlmIChvbkhlYWRlcnMpIHtcbiAgICAgIG9uSGVhZGVyc0ltcGwgPSBmdW5jdGlvbiAoaGVhZGVyc0Rlc2NyaXB0b3IpIHtcbiAgICAgICAgb25IZWFkZXJzKG5ldyBIZWFkZXJzKGhlYWRlcnNEZXNjcmlwdG9yKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciByZXN1bWFibGVTdGF0ZSA9IGNyZWF0ZVJlc3VtYWJsZVN0YXRlKG9wdGlvbnMgPyBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXggOiB1bmRlZmluZWQsIG9wdGlvbnMgPyBvcHRpb25zLnVuc3RhYmxlX2V4dGVybmFsUnVudGltZVNyYyA6IHVuZGVmaW5lZCwgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwU2NyaXB0Q29udGVudCA6IHVuZGVmaW5lZCwgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwU2NyaXB0cyA6IHVuZGVmaW5lZCwgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwTW9kdWxlcyA6IHVuZGVmaW5lZCk7XG4gICAgdmFyIHJlcXVlc3QgPSBjcmVhdGVSZXF1ZXN0KGNoaWxkcmVuLCByZXN1bWFibGVTdGF0ZSwgY3JlYXRlUmVuZGVyU3RhdGUocmVzdW1hYmxlU3RhdGUsIG9wdGlvbnMgPyBvcHRpb25zLm5vbmNlIDogdW5kZWZpbmVkLCBvcHRpb25zID8gb3B0aW9ucy51bnN0YWJsZV9leHRlcm5hbFJ1bnRpbWVTcmMgOiB1bmRlZmluZWQsIG9wdGlvbnMgPyBvcHRpb25zLmltcG9ydE1hcCA6IHVuZGVmaW5lZCwgb25IZWFkZXJzSW1wbCwgb3B0aW9ucyA/IG9wdGlvbnMubWF4SGVhZGVyc0xlbmd0aCA6IHVuZGVmaW5lZCksIGNyZWF0ZVJvb3RGb3JtYXRDb250ZXh0KG9wdGlvbnMgPyBvcHRpb25zLm5hbWVzcGFjZVVSSSA6IHVuZGVmaW5lZCksIG9wdGlvbnMgPyBvcHRpb25zLnByb2dyZXNzaXZlQ2h1bmtTaXplIDogdW5kZWZpbmVkLCBvcHRpb25zID8gb3B0aW9ucy5vbkVycm9yIDogdW5kZWZpbmVkLCBvbkFsbFJlYWR5LCBvblNoZWxsUmVhZHksIG9uU2hlbGxFcnJvciwgb25GYXRhbEVycm9yLCBvcHRpb25zID8gb3B0aW9ucy5vblBvc3Rwb25lIDogdW5kZWZpbmVkLCBvcHRpb25zID8gb3B0aW9ucy5mb3JtU3RhdGUgOiB1bmRlZmluZWQpO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaWduYWwpIHtcbiAgICAgIHZhciBzaWduYWwgPSBvcHRpb25zLnNpZ25hbDtcblxuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIGFib3J0KHJlcXVlc3QsIHNpZ25hbC5yZWFzb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGFib3J0KHJlcXVlc3QsIHNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhcnRXb3JrKHJlcXVlc3QpO1xuICB9KTtcbn1cblxuZXhwb3J0cy5yZW5kZXJUb1JlYWRhYmxlU3RyZWFtID0gcmVuZGVyVG9SZWFkYWJsZVN0cmVhbTtcbmV4cG9ydHMudmVyc2lvbiA9IFJlYWN0VmVyc2lvbjtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiUmVhY3QiLCJyZXF1aXJlIiwiUmVhY3RET00iLCJSZWFjdFZlcnNpb24iLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwid2FybiIsImZvcm1hdCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwicHJpbnRXYXJuaW5nIiwiZXJyb3IiLCJfbGVuMiIsIl9rZXkyIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImNyZWF0ZUZhc3RIYXNoSlMiLCJrZXkiLCJtdXJtdXJoYXNoM18zMl9nYyIsInNlZWQiLCJyZW1haW5kZXIiLCJieXRlcyIsImgxIiwiaDFiIiwiYzEiLCJjMiIsImsxIiwiaSIsImNoYXJDb2RlQXQiLCJzY2hlZHVsZVdvcmsiLCJjYWxsYmFjayIsIlZJRVdfU0laRSIsImN1cnJlbnRWaWV3Iiwid3JpdHRlbkJ5dGVzIiwiYmVnaW5Xcml0aW5nIiwiZGVzdGluYXRpb24iLCJVaW50OEFycmF5Iiwid3JpdGVDaHVuayIsImNodW5rIiwiYnl0ZUxlbmd0aCIsInByZWNvbXB1dGVkQ2h1bmtTZXQiLCJoYXMiLCJlbnF1ZXVlIiwiYnVmZmVyIiwiYnl0ZXNUb1dyaXRlIiwiYWxsb3dhYmxlQnl0ZXMiLCJzZXQiLCJzdWJhcnJheSIsIndyaXRlQ2h1bmtBbmRSZXR1cm4iLCJjb21wbGV0ZVdyaXRpbmciLCJjbG9zZSIsInRleHRFbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJzdHJpbmdUb0NodW5rIiwiY29udGVudCIsImVuY29kZSIsIlNldCIsInN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayIsInByZWNvbXB1dGVkQ2h1bmsiLCJhZGQiLCJjbG9uZVByZWNvbXB1dGVkQ2h1bmsiLCJzbGljZSIsImNsb3NlV2l0aEVycm9yIiwiYXNzaWduIiwiT2JqZWN0IiwidHlwZU5hbWUiLCJ2YWx1ZSIsImhhc1RvU3RyaW5nVGFnIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ0eXBlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwid2lsbENvZXJjaW9uVGhyb3ciLCJ0ZXN0U3RyaW5nQ29lcmNpb24iLCJlIiwiY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbiIsImF0dHJpYnV0ZU5hbWUiLCJjaGVja09wdGlvblN0cmluZ0NvZXJjaW9uIiwicHJvcE5hbWUiLCJjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24iLCJjaGVja0h0bWxTdHJpbmdDb2VyY2lvbiIsImVuYWJsZUZsb2F0IiwiaGFzT3duUHJvcGVydHkiLCJBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSIiwiQVRUUklCVVRFX05BTUVfQ0hBUiIsIlZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYIiwiUmVnRXhwIiwiaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSIsInZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSIsImlzQXR0cmlidXRlTmFtZVNhZmUiLCJ0ZXN0IiwidW5pdGxlc3NOdW1iZXJzIiwiaXNVbml0bGVzc051bWJlciIsImFsaWFzZXMiLCJNYXAiLCJnZXRBdHRyaWJ1dGVBbGlhcyIsImdldCIsImhhc1JlYWRPbmx5VmFsdWUiLCJidXR0b24iLCJjaGVja2JveCIsImltYWdlIiwiaGlkZGVuIiwicmFkaW8iLCJyZXNldCIsInN1Ym1pdCIsImNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMiLCJ0YWdOYW1lIiwicHJvcHMiLCJvbkNoYW5nZSIsIm9uSW5wdXQiLCJyZWFkT25seSIsImRpc2FibGVkIiwiY2hlY2tlZCIsImFyaWFQcm9wZXJ0aWVzIiwid2FybmVkUHJvcGVydGllcyQxIiwickFSSUEkMSIsInJBUklBQ2FtZWwkMSIsInZhbGlkYXRlUHJvcGVydHkkMSIsImFyaWFOYW1lIiwidG9Mb3dlckNhc2UiLCJjb3JyZWN0TmFtZSIsImxvd2VyQ2FzZWROYW1lIiwic3RhbmRhcmROYW1lIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDIiLCJpbnZhbGlkUHJvcHMiLCJpc1ZhbGlkIiwicHVzaCIsInVua25vd25Qcm9wU3RyaW5nIiwicHJvcCIsImpvaW4iLCJkaWRXYXJuVmFsdWVOdWxsIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDEiLCJtdWx0aXBsZSIsImlzQ3VzdG9tRWxlbWVudCIsImluZGV4T2YiLCJwb3NzaWJsZVN0YW5kYXJkTmFtZXMiLCJhY2NlcHQiLCJhY2NlcHRjaGFyc2V0IiwiYWNjZXNza2V5IiwiYWN0aW9uIiwiYWxsb3dmdWxsc2NyZWVuIiwiYWx0IiwiYXMiLCJhc3luYyIsImF1dG9jYXBpdGFsaXplIiwiYXV0b2NvbXBsZXRlIiwiYXV0b2NvcnJlY3QiLCJhdXRvZm9jdXMiLCJhdXRvcGxheSIsImF1dG9zYXZlIiwiY2FwdHVyZSIsImNlbGxwYWRkaW5nIiwiY2VsbHNwYWNpbmciLCJjaGFsbGVuZ2UiLCJjaGFyc2V0IiwiY2hpbGRyZW4iLCJjaXRlIiwiY2xhc3MiLCJjbGFzc2lkIiwiY2xhc3NuYW1lIiwiY29scyIsImNvbHNwYW4iLCJjb250ZW50ZWRpdGFibGUiLCJjb250ZXh0bWVudSIsImNvbnRyb2xzIiwiY29udHJvbHNsaXN0IiwiY29vcmRzIiwiY3Jvc3NvcmlnaW4iLCJkYW5nZXJvdXNseXNldGlubmVyaHRtbCIsImRhdGEiLCJkYXRldGltZSIsImRlZmF1bHQiLCJkZWZhdWx0Y2hlY2tlZCIsImRlZmF1bHR2YWx1ZSIsImRlZmVyIiwiZGlyIiwiZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmUiLCJkaXNhYmxlcmVtb3RlcGxheWJhY2siLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImVuY3R5cGUiLCJlbnRlcmtleWhpbnQiLCJmZXRjaHByaW9yaXR5IiwiZm9yIiwiZm9ybSIsImZvcm1tZXRob2QiLCJmb3JtYWN0aW9uIiwiZm9ybWVuY3R5cGUiLCJmb3Jtbm92YWxpZGF0ZSIsImZvcm10YXJnZXQiLCJmcmFtZWJvcmRlciIsImhlYWRlcnMiLCJoZWlnaHQiLCJoaWdoIiwiaHJlZiIsImhyZWZsYW5nIiwiaHRtbGZvciIsImh0dHBlcXVpdiIsImljb24iLCJpZCIsImltYWdlc2l6ZXMiLCJpbWFnZXNyY3NldCIsImlubmVyaHRtbCIsImlucHV0bW9kZSIsImludGVncml0eSIsImlzIiwiaXRlbWlkIiwiaXRlbXByb3AiLCJpdGVtcmVmIiwiaXRlbXNjb3BlIiwiaXRlbXR5cGUiLCJrZXlwYXJhbXMiLCJrZXl0eXBlIiwia2luZCIsImxhYmVsIiwibGFuZyIsImxpc3QiLCJsb29wIiwibG93IiwibWFuaWZlc3QiLCJtYXJnaW53aWR0aCIsIm1hcmdpbmhlaWdodCIsIm1heCIsIm1heGxlbmd0aCIsIm1lZGlhIiwibWVkaWFncm91cCIsIm1ldGhvZCIsIm1pbiIsIm1pbmxlbmd0aCIsIm11dGVkIiwibm9tb2R1bGUiLCJub25jZSIsIm5vdmFsaWRhdGUiLCJvcGVuIiwib3B0aW11bSIsInBhdHRlcm4iLCJwbGFjZWhvbGRlciIsInBsYXlzaW5saW5lIiwicG9zdGVyIiwicHJlbG9hZCIsInByb2ZpbGUiLCJyYWRpb2dyb3VwIiwicmVhZG9ubHkiLCJyZWZlcnJlcnBvbGljeSIsInJlbCIsInJlcXVpcmVkIiwicmV2ZXJzZWQiLCJyb2xlIiwicm93cyIsInJvd3NwYW4iLCJzYW5kYm94Iiwic2NvcGUiLCJzY29wZWQiLCJzY3JvbGxpbmciLCJzZWFtbGVzcyIsInNlbGVjdGVkIiwic2hhcGUiLCJzaXplIiwic2l6ZXMiLCJzcGFuIiwic3BlbGxjaGVjayIsInNyYyIsInNyY2RvYyIsInNyY2xhbmciLCJzcmNzZXQiLCJzdGFydCIsInN0ZXAiLCJzdHlsZSIsInN1bW1hcnkiLCJ0YWJpbmRleCIsInRhcmdldCIsInRpdGxlIiwidXNlbWFwIiwid2lkdGgiLCJ3bW9kZSIsIndyYXAiLCJhYm91dCIsImFjY2VudGhlaWdodCIsImFjY3VtdWxhdGUiLCJhZGRpdGl2ZSIsImFsaWdubWVudGJhc2VsaW5lIiwiYWxsb3dyZW9yZGVyIiwiYWxwaGFiZXRpYyIsImFtcGxpdHVkZSIsImFyYWJpY2Zvcm0iLCJhc2NlbnQiLCJhdHRyaWJ1dGVuYW1lIiwiYXR0cmlidXRldHlwZSIsImF1dG9yZXZlcnNlIiwiYXppbXV0aCIsImJhc2VmcmVxdWVuY3kiLCJiYXNlbGluZXNoaWZ0IiwiYmFzZXByb2ZpbGUiLCJiYm94IiwiYmVnaW4iLCJiaWFzIiwiYnkiLCJjYWxjbW9kZSIsImNhcGhlaWdodCIsImNsaXAiLCJjbGlwcGF0aCIsImNsaXBwYXRodW5pdHMiLCJjbGlwcnVsZSIsImNvbG9yIiwiY29sb3JpbnRlcnBvbGF0aW9uIiwiY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVycyIsImNvbG9ycHJvZmlsZSIsImNvbG9ycmVuZGVyaW5nIiwiY29udGVudHNjcmlwdHR5cGUiLCJjb250ZW50c3R5bGV0eXBlIiwiY3Vyc29yIiwiY3giLCJjeSIsImQiLCJkYXRhdHlwZSIsImRlY2VsZXJhdGUiLCJkZXNjZW50IiwiZGlmZnVzZWNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGlzcGxheSIsImRpdmlzb3IiLCJkb21pbmFudGJhc2VsaW5lIiwiZHVyIiwiZHgiLCJkeSIsImVkZ2Vtb2RlIiwiZWxldmF0aW9uIiwiZW5hYmxlYmFja2dyb3VuZCIsImVuZCIsImV4cG9uZW50IiwiZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZCIsImZpbGwiLCJmaWxsb3BhY2l0eSIsImZpbGxydWxlIiwiZmlsdGVyIiwiZmlsdGVycmVzIiwiZmlsdGVydW5pdHMiLCJmbG9vZG9wYWNpdHkiLCJmbG9vZGNvbG9yIiwiZm9jdXNhYmxlIiwiZm9udGZhbWlseSIsImZvbnRzaXplIiwiZm9udHNpemVhZGp1c3QiLCJmb250c3RyZXRjaCIsImZvbnRzdHlsZSIsImZvbnR2YXJpYW50IiwiZm9udHdlaWdodCIsImZyb20iLCJmeCIsImZ5IiwiZzEiLCJnMiIsImdseXBobmFtZSIsImdseXBob3JpZW50YXRpb25ob3Jpem9udGFsIiwiZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsIiwiZ2x5cGhyZWYiLCJncmFkaWVudHRyYW5zZm9ybSIsImdyYWRpZW50dW5pdHMiLCJoYW5naW5nIiwiaG9yaXphZHZ4IiwiaG9yaXpvcmlnaW54IiwiaWRlb2dyYXBoaWMiLCJpbWFnZXJlbmRlcmluZyIsImluMiIsImluIiwiaW5saXN0IiwiaW50ZXJjZXB0IiwiazIiLCJrMyIsIms0IiwiayIsImtlcm5lbG1hdHJpeCIsImtlcm5lbHVuaXRsZW5ndGgiLCJrZXJuaW5nIiwia2V5cG9pbnRzIiwia2V5c3BsaW5lcyIsImtleXRpbWVzIiwibGVuZ3RoYWRqdXN0IiwibGV0dGVyc3BhY2luZyIsImxpZ2h0aW5nY29sb3IiLCJsaW1pdGluZ2NvbmVhbmdsZSIsImxvY2FsIiwibWFya2VyZW5kIiwibWFya2VyaGVpZ2h0IiwibWFya2VybWlkIiwibWFya2Vyc3RhcnQiLCJtYXJrZXJ1bml0cyIsIm1hcmtlcndpZHRoIiwibWFzayIsIm1hc2tjb250ZW50dW5pdHMiLCJtYXNrdW5pdHMiLCJtYXRoZW1hdGljYWwiLCJtb2RlIiwibnVtb2N0YXZlcyIsIm9mZnNldCIsIm9wYWNpdHkiLCJvcGVyYXRvciIsIm9yZGVyIiwib3JpZW50Iiwib3JpZW50YXRpb24iLCJvcmlnaW4iLCJvdmVyZmxvdyIsIm92ZXJsaW5lcG9zaXRpb24iLCJvdmVybGluZXRoaWNrbmVzcyIsInBhaW50b3JkZXIiLCJwYW5vc2UxIiwicGF0aGxlbmd0aCIsInBhdHRlcm5jb250ZW50dW5pdHMiLCJwYXR0ZXJudHJhbnNmb3JtIiwicGF0dGVybnVuaXRzIiwicG9pbnRlcmV2ZW50cyIsInBvaW50cyIsInBvaW50c2F0eCIsInBvaW50c2F0eSIsInBvaW50c2F0eiIsInByZWZpeCIsInByZXNlcnZlYWxwaGEiLCJwcmVzZXJ2ZWFzcGVjdHJhdGlvIiwicHJpbWl0aXZldW5pdHMiLCJwcm9wZXJ0eSIsInIiLCJyYWRpdXMiLCJyZWZ4IiwicmVmeSIsInJlbmRlcmluZ2ludGVudCIsInJlcGVhdGNvdW50IiwicmVwZWF0ZHVyIiwicmVxdWlyZWRleHRlbnNpb25zIiwicmVxdWlyZWRmZWF0dXJlcyIsInJlc291cmNlIiwicmVzdGFydCIsInJlc3VsdCIsInJlc3VsdHMiLCJyb3RhdGUiLCJyeCIsInJ5Iiwic2NhbGUiLCJzZWN1cml0eSIsInNoYXBlcmVuZGVyaW5nIiwic2xvcGUiLCJzcGFjaW5nIiwic3BlY3VsYXJjb25zdGFudCIsInNwZWN1bGFyZXhwb25lbnQiLCJzcGVlZCIsInNwcmVhZG1ldGhvZCIsInN0YXJ0b2Zmc2V0Iiwic3RkZGV2aWF0aW9uIiwic3RlbWgiLCJzdGVtdiIsInN0aXRjaHRpbGVzIiwic3RvcGNvbG9yIiwic3RvcG9wYWNpdHkiLCJzdHJpa2V0aHJvdWdocG9zaXRpb24iLCJzdHJpa2V0aHJvdWdodGhpY2tuZXNzIiwic3RyaW5nIiwic3Ryb2tlIiwic3Ryb2tlZGFzaGFycmF5Iiwic3Ryb2tlZGFzaG9mZnNldCIsInN0cm9rZWxpbmVjYXAiLCJzdHJva2VsaW5lam9pbiIsInN0cm9rZW1pdGVybGltaXQiLCJzdHJva2V3aWR0aCIsInN0cm9rZW9wYWNpdHkiLCJzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmciLCJzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmciLCJzdXJmYWNlc2NhbGUiLCJzeXN0ZW1sYW5ndWFnZSIsInRhYmxldmFsdWVzIiwidGFyZ2V0eCIsInRhcmdldHkiLCJ0ZXh0YW5jaG9yIiwidGV4dGRlY29yYXRpb24iLCJ0ZXh0bGVuZ3RoIiwidGV4dHJlbmRlcmluZyIsInRvIiwidHJhbnNmb3JtIiwidHJhbnNmb3Jtb3JpZ2luIiwidHlwZW9mIiwidTEiLCJ1MiIsInVuZGVybGluZXBvc2l0aW9uIiwidW5kZXJsaW5ldGhpY2tuZXNzIiwidW5pY29kZSIsInVuaWNvZGViaWRpIiwidW5pY29kZXJhbmdlIiwidW5pdHNwZXJlbSIsInVuc2VsZWN0YWJsZSIsInZhbHBoYWJldGljIiwidmFsdWVzIiwidmVjdG9yZWZmZWN0IiwidmVyc2lvbiIsInZlcnRhZHZ5IiwidmVydG9yaWdpbngiLCJ2ZXJ0b3JpZ2lueSIsInZoYW5naW5nIiwidmlkZW9ncmFwaGljIiwidmlld2JveCIsInZpZXd0YXJnZXQiLCJ2aXNpYmlsaXR5Iiwidm1hdGhlbWF0aWNhbCIsInZvY2FiIiwid2lkdGhzIiwid29yZHNwYWNpbmciLCJ3cml0aW5nbW9kZSIsIngxIiwieDIiLCJ4IiwieGNoYW5uZWxzZWxlY3RvciIsInhoZWlnaHQiLCJ4bGlua2FjdHVhdGUiLCJ4bGlua2FyY3JvbGUiLCJ4bGlua2hyZWYiLCJ4bGlua3JvbGUiLCJ4bGlua3Nob3ciLCJ4bGlua3RpdGxlIiwieGxpbmt0eXBlIiwieG1sYmFzZSIsInhtbGxhbmciLCJ4bWxucyIsInhtbG5zeGxpbmsiLCJ4bWxzcGFjZSIsInkxIiwieTIiLCJ5IiwieWNoYW5uZWxzZWxlY3RvciIsInoiLCJ6b29tYW5kcGFuIiwid2FybmVkUHJvcGVydGllcyIsIkVWRU5UX05BTUVfUkVHRVgiLCJJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgiLCJyQVJJQSIsInJBUklBQ2FtZWwiLCJ2YWxpZGF0ZVByb3BlcnR5IiwiZXZlbnRSZWdpc3RyeSIsInJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMiLCJwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIiwicmVnaXN0cmF0aW9uTmFtZSIsInVuZGVmaW5lZCIsImlzTmFOIiwid2FyblVua25vd25Qcm9wZXJ0aWVzIiwidW5rbm93blByb3BzIiwidmFsaWRhdGVQcm9wZXJ0aWVzIiwiYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuIiwibXNQYXR0ZXJuJDEiLCJoeXBoZW5QYXR0ZXJuIiwiYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuIiwid2FybmVkU3R5bGVOYW1lcyIsIndhcm5lZFN0eWxlVmFsdWVzIiwid2FybmVkRm9yTmFOVmFsdWUiLCJ3YXJuZWRGb3JJbmZpbml0eVZhbHVlIiwiY2FtZWxpemUiLCJyZXBsYWNlIiwiXyIsImNoYXJhY3RlciIsInRvVXBwZXJDYXNlIiwid2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUiLCJ3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUiLCJjaGFyQXQiLCJ3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24iLCJ3YXJuU3R5bGVWYWx1ZUlzTmFOIiwid2FyblN0eWxlVmFsdWVJc0luZmluaXR5Iiwid2FyblZhbGlkU3R5bGUiLCJpc0Zpbml0ZSIsImdldENyb3NzT3JpZ2luU3RyaW5nIiwiaW5wdXQiLCJtYXRjaEh0bWxSZWdFeHAiLCJlc2NhcGVIdG1sIiwic3RyIiwibWF0Y2giLCJleGVjIiwiZXNjYXBlIiwiaHRtbCIsImluZGV4IiwibGFzdEluZGV4IiwiZXNjYXBlVGV4dEZvckJyb3dzZXIiLCJ0ZXh0IiwidXBwZXJjYXNlUGF0dGVybiIsIm1zUGF0dGVybiIsImh5cGhlbmF0ZVN0eWxlTmFtZSIsImlzSmF2YVNjcmlwdFByb3RvY29sIiwiZGlkV2FybiIsInNhbml0aXplVVJMIiwidXJsIiwic3RyaW5naWZpZWRVUkwiLCJKU09OIiwic3RyaW5naWZ5IiwiaXNBcnJheUltcGwiLCJpc0FycmF5IiwiYSIsImNsaWVudFJlbmRlckJvdW5kYXJ5IiwiY29tcGxldGVCb3VuZGFyeSIsImNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzIiwiY29tcGxldGVTZWdtZW50IiwiZm9ybVJlcGxheWluZyIsImdldFZhbHVlRGVzY3JpcHRvckV4cGVjdGluZ09iamVjdEZvcldhcm5pbmciLCJ0aGluZyIsInNoYXJlZE5vdFBlbmRpbmdPYmplY3QiLCJwZW5kaW5nIiwiTm90UGVuZGluZyIsImZyZWV6ZSIsIlJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzIiwiUmVhY3RET01DdXJyZW50RGlzcGF0Y2hlciIsIkRpc3BhdGNoZXIiLCJSZWFjdERPTVNlcnZlckRpc3BhdGNoZXIiLCJwcmVmZXRjaEROUyIsInByZWNvbm5lY3QiLCJwcmVsb2FkTW9kdWxlIiwicHJlaW5pdFN0eWxlIiwicHJlaW5pdFNjcmlwdCIsInByZWluaXRNb2R1bGVTY3JpcHQiLCJwcmVwYXJlSG9zdERpc3BhdGNoZXIiLCJjdXJyZW50IiwiU2NyaXB0U3RyZWFtaW5nRm9ybWF0IiwiRGF0YVN0cmVhbWluZ0Zvcm1hdCIsIk5vdGhpbmdTZW50IiwiU2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uIiwiU2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbiIsIlNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbiIsIlNlbnRTdHlsZUluc2VydGlvbkZ1bmN0aW9uIiwiU2VudEZvcm1SZXBsYXlpbmdSdW50aW1lIiwiRVhJU1RTIiwiUFJFTE9BRF9OT19DUkVEUyIsImRhdGFFbGVtZW50UXVvdGVkRW5kIiwic3RhcnRJbmxpbmVTY3JpcHQiLCJlbmRJbmxpbmVTY3JpcHQiLCJzdGFydFNjcmlwdFNyYyIsInN0YXJ0TW9kdWxlU3JjIiwic2NyaXB0Tm9uY2UiLCJzY3JpcHRJbnRlZ2lydHkiLCJzY3JpcHRDcm9zc09yaWdpbiIsImVuZEFzeW5jU2NyaXB0IiwiZXNjYXBlQm9vdHN0cmFwQW5kSW1wb3J0TWFwU2NyaXB0Q29udGVudCIsInNjcmlwdFRleHQiLCJzY3JpcHRSZWdleCIsInNjcmlwdFJlcGxhY2VyIiwicyIsInN1ZmZpeCIsImltcG9ydE1hcFNjcmlwdFN0YXJ0IiwiaW1wb3J0TWFwU2NyaXB0RW5kIiwiREVGQVVMVF9IRUFERVJTX0NBUEFDSVRZX0lOX1VURjE2X0NPREVfVU5JVFMiLCJjcmVhdGVSZW5kZXJTdGF0ZSIsInJlc3VtYWJsZVN0YXRlIiwiZXh0ZXJuYWxSdW50aW1lQ29uZmlnIiwiaW1wb3J0TWFwIiwib25IZWFkZXJzIiwibWF4SGVhZGVyc0xlbmd0aCIsImlubGluZVNjcmlwdFdpdGhOb25jZSIsImlkUHJlZml4IiwiYm9vdHN0cmFwQ2h1bmtzIiwiZXh0ZXJuYWxSdW50aW1lU2NyaXB0IiwiYm9vdHN0cmFwU2NyaXB0Q29udGVudCIsImJvb3RzdHJhcFNjcmlwdHMiLCJib290c3RyYXBNb2R1bGVzIiwiY2h1bmtzIiwicHVzaFNjcmlwdEltcGwiLCJpbXBvcnRNYXBDaHVua3MiLCJwcmVjb25uZWN0cyIsImZvbnRQcmVsb2FkcyIsImhpZ2hJbWFnZVByZWxvYWRzIiwicmVtYWluaW5nQ2FwYWNpdHkiLCJyZW5kZXJTdGF0ZSIsInBsYWNlaG9sZGVyUHJlZml4Iiwic2VnbWVudFByZWZpeCIsImJvdW5kYXJ5UHJlZml4IiwiaHRtbENodW5rcyIsImhlYWRDaHVua3MiLCJyZXNldHMiLCJmb250IiwiZG5zIiwiY29ubmVjdCIsImFub255bW91cyIsImNyZWRlbnRpYWxzIiwiY2hhcnNldENodW5rcyIsInByZWNvbm5lY3RDaHVua3MiLCJwcmVsb2FkQ2h1bmtzIiwiaG9pc3RhYmxlQ2h1bmtzIiwic3R5bGVzIiwic2NyaXB0cyIsImJ1bGtQcmVsb2FkcyIsInByZWxvYWRzIiwiaW1hZ2VzIiwic3R5bGVzaGVldHMiLCJtb2R1bGVTY3JpcHRzIiwiYm91bmRhcnlSZXNvdXJjZXMiLCJzdHlsZXNUb0hvaXN0Iiwic2NyaXB0Q29uZmlnIiwiY3Jvc3NPcmlnaW4iLCJmZXRjaFByaW9yaXR5IiwicHJlbG9hZEJvb3RzdHJhcFNjcmlwdE9yTW9kdWxlIiwiX2kiLCJfc2NyaXB0Q29uZmlnIiwiX3NyYyIsIl9jcm9zc09yaWdpbiIsIl9pbnRlZ3JpdHkiLCJfcHJvcHMiLCJjcmVhdGVSZXN1bWFibGVTdGF0ZSIsImlkZW50aWZpZXJQcmVmaXgiLCJzdHJlYW1pbmdGb3JtYXQiLCJuZXh0Rm9ybUlEIiwiaW5zdHJ1Y3Rpb25zIiwiaGFzQm9keSIsImhhc0h0bWwiLCJ1bmtub3duUmVzb3VyY2VzIiwiZG5zUmVzb3VyY2VzIiwiY29ubmVjdFJlc291cmNlcyIsImltYWdlUmVzb3VyY2VzIiwic3R5bGVSZXNvdXJjZXMiLCJzY3JpcHRSZXNvdXJjZXMiLCJtb2R1bGVVbmtub3duUmVzb3VyY2VzIiwibW9kdWxlU2NyaXB0UmVzb3VyY2VzIiwiUk9PVF9IVE1MX01PREUiLCJIVE1MX0hUTUxfTU9ERSIsIkhUTUxfTU9ERSIsIlNWR19NT0RFIiwiTUFUSE1MX01PREUiLCJIVE1MX1RBQkxFX01PREUiLCJIVE1MX1RBQkxFX0JPRFlfTU9ERSIsIkhUTUxfVEFCTEVfUk9XX01PREUiLCJIVE1MX0NPTEdST1VQX01PREUiLCJOT19TQ09QRSIsIk5PU0NSSVBUX1NDT1BFIiwiUElDVFVSRV9TQ09QRSIsImNyZWF0ZUZvcm1hdENvbnRleHQiLCJpbnNlcnRpb25Nb2RlIiwic2VsZWN0ZWRWYWx1ZSIsInRhZ1Njb3BlIiwiY3JlYXRlUm9vdEZvcm1hdENvbnRleHQiLCJuYW1lc3BhY2VVUkkiLCJnZXRDaGlsZEZvcm1hdENvbnRleHQiLCJwYXJlbnRDb250ZXh0IiwiZGVmYXVsdFZhbHVlIiwibWFrZUlkIiwidHJlZUlkIiwibG9jYWxJZCIsInRvU3RyaW5nIiwiZW5jb2RlSFRNTFRleHROb2RlIiwidGV4dFNlcGFyYXRvciIsInB1c2hUZXh0SW5zdGFuY2UiLCJ0ZXh0RW1iZWRkZWQiLCJwdXNoU2VnbWVudEZpbmFsZSIsImxhc3RQdXNoZWRUZXh0Iiwic3R5bGVOYW1lQ2FjaGUiLCJwcm9jZXNzU3R5bGVOYW1lIiwic3R5bGVOYW1lIiwic3R5bGVBdHRyaWJ1dGVTdGFydCIsInN0eWxlQXNzaWduIiwic3R5bGVTZXBhcmF0b3IiLCJwdXNoU3R5bGVBdHRyaWJ1dGUiLCJFcnJvciIsImlzRmlyc3QiLCJzdHlsZVZhbHVlIiwibmFtZUNodW5rIiwidmFsdWVDaHVuayIsImlzQ3VzdG9tUHJvcGVydHkiLCJ0cmltIiwiYXR0cmlidXRlRW5kIiwiYXR0cmlidXRlU2VwYXJhdG9yIiwiYXR0cmlidXRlQXNzaWduIiwiYXR0cmlidXRlRW1wdHlTdHJpbmciLCJwdXNoQm9vbGVhbkF0dHJpYnV0ZSIsInB1c2hTdHJpbmdBdHRyaWJ1dGUiLCJtYWtlRm9ybUZpZWxkUHJlZml4IiwiYWN0aW9uSmF2YVNjcmlwdFVSTCIsInN0YXJ0SGlkZGVuSW5wdXRDaHVuayIsInB1c2hBZGRpdGlvbmFsRm9ybUZpZWxkIiwiZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nIiwicHVzaEFkZGl0aW9uYWxGb3JtRmllbGRzIiwiZm9ybURhdGEiLCJmb3JFYWNoIiwicHVzaEZvcm1BY3Rpb25BdHRyaWJ1dGUiLCJmb3JtQWN0aW9uIiwiZm9ybUVuY1R5cGUiLCJmb3JtTWV0aG9kIiwiZm9ybVRhcmdldCIsImRpZFdhcm5Gb3JtQWN0aW9uTmFtZSIsImRpZFdhcm5Gb3JtQWN0aW9uTWV0aG9kIiwiZGlkV2FybkZvcm1BY3Rpb25UYXJnZXQiLCJjdXN0b21BY3Rpb24iLCIkJEZPUk1fQUNUSU9OIiwiY3VzdG9tRmllbGRzIiwiZW5jVHlwZSIsImluamVjdEZvcm1SZXBsYXlpbmdSdW50aW1lIiwicHVzaEF0dHJpYnV0ZSIsInNhbml0aXplZFZhbHVlIiwiX3Nhbml0aXplZFZhbHVlIiwiZW5kT2ZTdGFydFRhZyIsInB1c2hJbm5lckhUTUwiLCJpbm5lckhUTUwiLCJfX2h0bWwiLCJkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUiLCJkaWRXYXJuRGVmYXVsdENoZWNrZWQiLCJkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlIiwiZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlIiwiZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiIsImRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MIiwiZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24iLCJkaWRXYXJuRm9ybUFjdGlvblR5cGUiLCJjaGVja1NlbGVjdFByb3AiLCJhcnJheSIsInB1c2hTdGFydFNlbGVjdCIsInN0YXJ0Q2h1bmtGb3JUYWciLCJwcm9wS2V5IiwicHJvcFZhbHVlIiwiZmxhdHRlbk9wdGlvbkNoaWxkcmVuIiwiQ2hpbGRyZW4iLCJjaGlsZCIsInNlbGVjdGVkTWFya2VyQXR0cmlidXRlIiwicHVzaFN0YXJ0T3B0aW9uIiwiZm9ybWF0Q29udGV4dCIsInN0cmluZ1ZhbHVlIiwidiIsImZvcm1SZXBsYXlpbmdSdW50aW1lU2NyaXB0IiwiZm9ybVN0YXRlTWFya2VySXNNYXRjaGluZyIsImZvcm1TdGF0ZU1hcmtlcklzTm90TWF0Y2hpbmciLCJwdXNoRm9ybVN0YXRlTWFya2VySXNNYXRjaGluZyIsInB1c2hGb3JtU3RhdGVNYXJrZXJJc05vdE1hdGNoaW5nIiwicHVzaFN0YXJ0Rm9ybSIsImZvcm1BY3Rpb25OYW1lIiwicHVzaElucHV0IiwiZGVmYXVsdENoZWNrZWQiLCJwdXNoU3RhcnRCdXR0b24iLCJwdXNoU3RhcnRUZXh0QXJlYSIsImxlYWRpbmdOZXdsaW5lIiwicHVzaE1ldGEiLCJub3NjcmlwdFRhZ0luU2NvcGUiLCJpdGVtUHJvcCIsInB1c2hTZWxmQ2xvc2luZyIsImNoYXJTZXQiLCJwdXNoTGluayIsInByZWNlZGVuY2UiLCJwdXNoTGlua0ltcGwiLCJnZXRSZXNvdXJjZUtleSIsIm9uTG9hZCIsIm9uRXJyb3IiLCJwcm9wRGVzY3JpcHRpb24iLCJzdHlsZVF1ZXVlIiwiaGFzS2V5IiwicmVzb3VyY2VTdGF0ZSIsInJ1bGVzIiwiaHJlZnMiLCJzaGVldHMiLCJzdGF0ZSIsIlBFTkRJTkckMSIsInN0eWxlc2hlZXRQcm9wc0Zyb21SYXdQcm9wcyIsInByZWxvYWRTdGF0ZSIsImFkb3B0UHJlbG9hZENyZWRlbnRpYWxzIiwicHJlbG9hZFJlc291cmNlIiwiUFJFTE9BREVEIiwiX3Jlc291cmNlIiwicHVzaFN0eWxlIiwiY2hpbGRUeXBlIiwicHVzaFN0eWxlSW1wbCIsImluY2x1ZGVzIiwicHVzaFN0eWxlQ29udGVudHMiLCJlbmRDaHVua0ZvclRhZyIsInB1c2hJbWciLCJwaWN0dXJlVGFnSW5TY29wZSIsInNyY1NldCIsImxvYWRpbmciLCJnZXRJbWFnZVJlc291cmNlS2V5IiwicHJvbW90YWJsZVByZWxvYWRzIiwiZGVsZXRlIiwiaGVhZGVyIiwiZ2V0UHJlbG9hZEFzSGVhZGVyIiwiaW1hZ2VTcmNTZXQiLCJpbWFnZVNpemVzIiwicmVmZXJyZXJQb2xpY3kiLCJyZWZlcmVyUG9saWN5IiwidGFnIiwicHVzaFN0YXJ0TWVudUl0ZW0iLCJwdXNoVGl0bGUiLCIkJHR5cGVvZiIsInB1c2hUaXRsZUltcGwiLCJwdXNoU3RhcnRIZWFkIiwicHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQiLCJwdXNoU3RhcnRIdG1sIiwiZG9jdHlwZUNodW5rIiwicHVzaFNjcmlwdCIsImFzeW5jUHJvcCIsInJlc291cmNlcyIsInNjcmlwdFByb3BzIiwiZGVzY3JpcHRpdmVTdGF0ZW1lbnQiLCJwdXNoU3RhcnRDdXN0b21FbGVtZW50IiwicHVzaFN0YXJ0UHJlZm9ybWF0dGVkRWxlbWVudCIsIlZBTElEX1RBR19SRUdFWCIsInZhbGlkYXRlZFRhZ0NhY2hlIiwidGFnU3RhcnRDaHVuayIsInB1c2hTdGFydEluc3RhbmNlIiwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiwiY29udGVudEVkaXRhYmxlIiwiZW5kVGFnQ2FjaGUiLCJwdXNoRW5kSW5zdGFuY2UiLCJ3cml0ZUJvb3RzdHJhcCIsImxhc3RDaHVuayIsIndyaXRlQ29tcGxldGVkUm9vdCIsInBsYWNlaG9sZGVyMSIsInBsYWNlaG9sZGVyMiIsIndyaXRlUGxhY2Vob2xkZXIiLCJmb3JtYXR0ZWRJRCIsInN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSIsInN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkxIiwic3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTIiLCJzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSIsImVuZFN1c3BlbnNlQm91bmRhcnkiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBIiwiY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQiIsImNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUMiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjIiLCJ3cml0ZVN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSIsIndyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeSIsIndyaXRlU3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkiLCJlcnJvckRpZ2VzdCIsImVycm9yTWVzc3NhZ2UiLCJlcnJvckNvbXBvbmVudFN0YWNrIiwid3JpdGVFbmRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5Iiwid3JpdGVFbmRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeSIsIndyaXRlRW5kQ2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5Iiwic3RhcnRTZWdtZW50SFRNTCIsInN0YXJ0U2VnbWVudEhUTUwyIiwiZW5kU2VnbWVudEhUTUwiLCJzdGFydFNlZ21lbnRTVkciLCJzdGFydFNlZ21lbnRTVkcyIiwiZW5kU2VnbWVudFNWRyIsInN0YXJ0U2VnbWVudE1hdGhNTCIsInN0YXJ0U2VnbWVudE1hdGhNTDIiLCJlbmRTZWdtZW50TWF0aE1MIiwic3RhcnRTZWdtZW50VGFibGUiLCJzdGFydFNlZ21lbnRUYWJsZTIiLCJlbmRTZWdtZW50VGFibGUiLCJzdGFydFNlZ21lbnRUYWJsZUJvZHkiLCJzdGFydFNlZ21lbnRUYWJsZUJvZHkyIiwiZW5kU2VnbWVudFRhYmxlQm9keSIsInN0YXJ0U2VnbWVudFRhYmxlUm93Iiwic3RhcnRTZWdtZW50VGFibGVSb3cyIiwiZW5kU2VnbWVudFRhYmxlUm93Iiwic3RhcnRTZWdtZW50Q29sR3JvdXAiLCJzdGFydFNlZ21lbnRDb2xHcm91cDIiLCJlbmRTZWdtZW50Q29sR3JvdXAiLCJ3cml0ZVN0YXJ0U2VnbWVudCIsIndyaXRlRW5kU2VnbWVudCIsImNvbXBsZXRlU2VnbWVudFNjcmlwdDFGdWxsIiwiY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwiLCJjb21wbGV0ZVNlZ21lbnRTY3JpcHQyIiwiY29tcGxldGVTZWdtZW50U2NyaXB0RW5kIiwiY29tcGxldGVTZWdtZW50RGF0YTEiLCJjb21wbGV0ZVNlZ21lbnREYXRhMiIsImNvbXBsZXRlU2VnbWVudERhdGFFbmQiLCJ3cml0ZUNvbXBsZXRlZFNlZ21lbnRJbnN0cnVjdGlvbiIsImNvbnRlbnRTZWdtZW50SUQiLCJzY3JpcHRGb3JtYXQiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MUZ1bGwiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MVBhcnRpYWwiLCJjb21wbGV0ZUJvdW5kYXJ5V2l0aFN0eWxlc1NjcmlwdDFGdWxsQm90aCIsImNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzU2NyaXB0MUZ1bGxQYXJ0aWFsIiwiY29tcGxldGVCb3VuZGFyeVdpdGhTdHlsZXNTY3JpcHQxUGFydGlhbCIsImNvbXBsZXRlQm91bmRhcnlTY3JpcHQyIiwiY29tcGxldGVCb3VuZGFyeVNjcmlwdDNhIiwiY29tcGxldGVCb3VuZGFyeVNjcmlwdDNiIiwiY29tcGxldGVCb3VuZGFyeVNjcmlwdEVuZCIsImNvbXBsZXRlQm91bmRhcnlEYXRhMSIsImNvbXBsZXRlQm91bmRhcnlXaXRoU3R5bGVzRGF0YTEiLCJjb21wbGV0ZUJvdW5kYXJ5RGF0YTIiLCJjb21wbGV0ZUJvdW5kYXJ5RGF0YTNhIiwiY29tcGxldGVCb3VuZGFyeURhdGFFbmQiLCJ3cml0ZUNvbXBsZXRlZEJvdW5kYXJ5SW5zdHJ1Y3Rpb24iLCJyZXF1aXJlc1N0eWxlSW5zZXJ0aW9uIiwiaWRDaHVuayIsIndyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY2llc0luSlMiLCJ3cml0ZVN0eWxlUmVzb3VyY2VEZXBlbmRlbmNpZXNJbkF0dHIiLCJ3cml0ZU1vcmUiLCJjbGllbnRSZW5kZXJTY3JpcHQxRnVsbCIsImNsaWVudFJlbmRlclNjcmlwdDFQYXJ0aWFsIiwiY2xpZW50UmVuZGVyU2NyaXB0MUEiLCJjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCIsImNsaWVudFJlbmRlclNjcmlwdEVuZCIsImNsaWVudFJlbmRlckRhdGExIiwiY2xpZW50UmVuZGVyRGF0YTIiLCJjbGllbnRSZW5kZXJEYXRhMyIsImNsaWVudFJlbmRlckRhdGE0IiwiY2xpZW50UmVuZGVyRGF0YUVuZCIsIndyaXRlQ2xpZW50UmVuZGVyQm91bmRhcnlJbnN0cnVjdGlvbiIsImVycm9yTWVzc2FnZSIsImVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyIsInJlZ2V4Rm9ySlNTdHJpbmdzSW5JbnN0cnVjdGlvblNjcmlwdHMiLCJlc2NhcGVkIiwicmVnZXhGb3JKU1N0cmluZ3NJblNjcmlwdHMiLCJlc2NhcGVKU09iamVjdEZvckluc3RydWN0aW9uU2NyaXB0cyIsImxhdGVTdHlsZVRhZ1Jlc291cmNlT3BlbjEiLCJsYXRlU3R5bGVUYWdSZXNvdXJjZU9wZW4yIiwibGF0ZVN0eWxlVGFnUmVzb3VyY2VPcGVuMyIsImxhdGVTdHlsZVRhZ1RlbXBsYXRlQ2xvc2UiLCJjdXJyZW50bHlSZW5kZXJpbmdCb3VuZGFyeUhhc1N0eWxlc1RvSG9pc3QiLCJkZXN0aW5hdGlvbkhhc0NhcGFjaXR5IiwiZmx1c2hTdHlsZVRhZ3NMYXRlRm9yQm91bmRhcnkiLCJzcGFjZVNlcGFyYXRvciIsImhhc1N0eWxlc1RvSG9pc3QiLCJzdHlsZXNoZWV0IiwiUFJFQU1CTEUiLCJ3cml0ZVJlc291cmNlc0ZvckJvdW5kYXJ5IiwiZmx1c2hSZXNvdXJjZSIsInN0eWxlc2hlZXRGbHVzaGluZ1F1ZXVlIiwiZmx1c2hTdHlsZUluUHJlYW1ibGUiLCJzdHlsZVRhZ1Jlc291cmNlT3BlbjEiLCJzdHlsZVRhZ1Jlc291cmNlT3BlbjIiLCJzdHlsZVRhZ1Jlc291cmNlT3BlbjMiLCJzdHlsZVRhZ1Jlc291cmNlQ2xvc2UiLCJmbHVzaFN0eWxlc0luUHJlYW1ibGUiLCJoYXNTdHlsZXNoZWV0cyIsImNsZWFyIiwicHJlbG9hZExhdGVTdHlsZSIsInByZWxvYWRQcm9wcyIsInByZWxvYWRBc1N0eWxlUHJvcHNGcm9tUHJvcHMiLCJwcmVsb2FkTGF0ZVN0eWxlcyIsIndyaXRlUHJlYW1ibGUiLCJ3aWxsRmx1c2hBbGxTZWdtZW50cyIsIl9yZW5kZXJTdGF0ZSRleHRlcm5hbCIsImludGVybmFsUHJlaW5pdFNjcmlwdCIsIndyaXRlSG9pc3RhYmxlcyIsIndyaXRlUG9zdGFtYmxlIiwiYXJyYXlGaXJzdE9wZW5CcmFja2V0IiwiYXJyYXlTdWJzZXF1ZW50T3BlbkJyYWNrZXQiLCJhcnJheUludGVyc3RpdGlhbCIsImFycmF5Q2xvc2VCcmFja2V0IiwibmV4dEFycmF5T3BlbkJyYWNrQ2h1bmsiLCJMQVRFIiwid3JpdGVTdHlsZVJlc291cmNlRGVwZW5kZW5jeUhyZWZPbmx5SW5KUyIsIndyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lJbkpTIiwiY29lcmNlZEhyZWYiLCJjb2VyY2VkUHJlY2VkZW5jZSIsIndyaXRlU3R5bGVSZXNvdXJjZUF0dHJpYnV0ZUluSlMiLCJhdHRyaWJ1dGVWYWx1ZSIsIndyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lIcmVmT25seUluQXR0ciIsIndyaXRlU3R5bGVSZXNvdXJjZURlcGVuZGVuY3lJbkF0dHIiLCJ3cml0ZVN0eWxlUmVzb3VyY2VBdHRyaWJ1dGVJbkF0dHIiLCJjcmVhdGVCb3VuZGFyeVJlc291cmNlcyIsInNldEN1cnJlbnRseVJlbmRlcmluZ0JvdW5kYXJ5UmVzb3VyY2VzVGFyZ2V0IiwicmVxdWVzdCIsInJlc29sdmVSZXF1ZXN0IiwiZ2V0UmVzdW1hYmxlU3RhdGUiLCJnZXRSZW5kZXJTdGF0ZSIsImdldFByZWZldGNoRE5TQXNIZWFkZXIiLCJmbHVzaFJlc291cmNlcyIsImJ1Y2tldCIsImdldFByZWNvbm5lY3RBc0hlYWRlciIsIm9wdGlvbnMiLCJfcmVzb3VyY2UyIiwiX3Jlc291cmNlMyIsIl9rZXkzIiwiaGFzQXNUeXBlIiwiX2hlYWRlcnMiLCJfaGVhZGVyIiwiX3Jlc291cmNlNCIsImhyZWZMYW5nIiwicmF3UHJvcHMiLCJlc2NhcGVkSHJlZiIsImVzY2FwZUhyZWZGb3JMaW5rSGVhZGVyVVJMQ29udGV4dCIsImVzY2FwZWRDcm9zc09yaWdpbiIsImVzY2FwZVN0cmluZ0ZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dCIsInBhcmFtcyIsImVzY2FwZWRBcyIsInBhcmFtTmFtZSIsInBhcmFtVmFsdWUiLCJnZXRTdHlsZXNoZWV0UHJlbG9hZEFzSGVhZGVyIiwicHJlbG9hZE9wdGlvbnMiLCJyZWdleEZvckhyZWZJbkxpbmtIZWFkZXJVUkxDb250ZXh0IiwiaHJlZklucHV0IiwiZXNjYXBlSHJlZkZvckxpbmtIZWFkZXJVUkxDb250ZXh0UmVwbGFjZXIiLCJyZWdleEZvckxpbmtIZWFkZXJRdW90ZWRQYXJhbVZhbHVlQ29udGV4dCIsImNvZXJjZWQiLCJlc2NhcGVTdHJpbmdGb3JMaW5rSGVhZGVyUXVvdGVkUGFyYW1WYWx1ZUNvbnRleHRSZXBsYWNlciIsImhvaXN0U3R5bGVRdWV1ZURlcGVuZGVuY3kiLCJob2lzdFN0eWxlc2hlZXREZXBlbmRlbmN5IiwiaG9pc3RSZXNvdXJjZXMiLCJzb3VyY2UiLCJjdXJyZW50Qm91bmRhcnlSZXNvdXJjZXMiLCJlbWl0RWFybHlQcmVsb2FkcyIsInNoZWxsQ29tcGxldGUiLCJsaW5rSGVhZGVyIiwicXVldWVJdGVyIiwib3V0ZXIiLCJxdWV1ZVN0ZXAiLCJuZXh0IiwiZG9uZSIsInNoZWV0SXRlciIsInNoZWV0U3RlcCIsInNoZWV0IiwiTGluayIsIk5vdFBlbmRpbmdUcmFuc2l0aW9uIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfU0NPUEVfVFlQRSIsIlJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUiLCJSRUFDVF9DQUNIRV9UWVBFIiwiUkVBQ1RfU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEIiwiTUFZQkVfSVRFUkFUT1JfU1lNQk9MIiwiaXRlcmF0b3IiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwibWF5YmVJdGVyYXRvciIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsImdldENvbnRleHROYW1lIiwiUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsImRpc2FibGVkRGVwdGgiLCJwcmV2TG9nIiwicHJldkluZm8iLCJwcmV2V2FybiIsInByZXZFcnJvciIsInByZXZHcm91cCIsInByZXZHcm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImRpc2FibGVkTG9nIiwiX19yZWFjdERpc2FibGVkTG9nIiwiZGlzYWJsZUxvZ3MiLCJsb2ciLCJpbmZvIiwiZ3JvdXAiLCJncm91cENvbGxhcHNlZCIsImdyb3VwRW5kIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsIm93bmVyRm4iLCJyZWVudHJ5IiwiY29tcG9uZW50RnJhbWVDYWNoZSIsIlBvc3NpYmx5V2Vha01hcCIsIldlYWtNYXAiLCJkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lIiwiZm4iLCJjb25zdHJ1Y3QiLCJmcmFtZSIsInByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInByZXZpb3VzRGlzcGF0Y2hlciIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsImMiLCJfZnJhbWUiLCJzeW50aGV0aWNGcmFtZSIsImRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZSIsImN0b3IiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QkMSIsIkNvbXBvbmVudCIsImlzUmVhY3RDb21wb25lbnQiLCJkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCIsImVsZW1lbnQiLCJvd25lciIsIl9vd25lciIsIl9zb3VyY2UiLCJzZXRFeHRyYVN0YWNrRnJhbWUiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsImxvY2F0aW9uIiwiY29tcG9uZW50TmFtZSIsImJpbmQiLCJ0eXBlU3BlY05hbWUiLCJlcnJvciQxIiwiZXJyIiwiZXgiLCJtZXNzYWdlIiwid2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0IiwiZW1wdHlDb250ZXh0T2JqZWN0IiwiZ2V0TWFza2VkQ29udGV4dCIsInVubWFza2VkQ29udGV4dCIsImNvbnRleHRUeXBlcyIsInByb2Nlc3NDaGlsZENvbnRleHQiLCJpbnN0YW5jZSIsImNoaWxkQ29udGV4dFR5cGVzIiwiZ2V0Q2hpbGRDb250ZXh0IiwiY2hpbGRDb250ZXh0IiwiY29udGV4dEtleSIsInJlbmRlcmVyU2lnaWwiLCJyb290Q29udGV4dFNuYXBzaG90IiwiY3VycmVudEFjdGl2ZVNuYXBzaG90IiwicG9wTm9kZSIsInByZXYiLCJfY3VycmVudFZhbHVlIiwicGFyZW50VmFsdWUiLCJwdXNoTm9kZSIsInBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yIiwicGFyZW50UHJldiIsInBhcmVudCIsInBhcmVudE5leHQiLCJwb3BBbGxQcmV2aW91cyIsInB1c2hBbGxOZXh0IiwicG9wUHJldmlvdXNUb0NvbW1vbkxldmVsIiwiZGVwdGgiLCJwb3BOZXh0VG9Db21tb25MZXZlbCIsInN3aXRjaENvbnRleHQiLCJuZXdTbmFwc2hvdCIsInB1c2hQcm92aWRlciIsIm5leHRWYWx1ZSIsInByZXZWYWx1ZSIsIl9jdXJyZW50UmVuZGVyZXIiLCJwcmV2Tm9kZSIsIm5ld05vZGUiLCJwb3BQcm92aWRlciIsInByZXZTbmFwc2hvdCIsIl9kZWZhdWx0VmFsdWUiLCJnZXRBY3RpdmVDb250ZXh0IiwicmVhZENvbnRleHQkMSIsIl9yZWFjdEludGVybmFscyIsImRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnQiLCJkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50IiwiZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlIiwiZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlIiwiZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSIsImRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSIsImRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlIiwiZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMiLCJkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUiLCJkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2siLCJ3YXJuT25JbnZhbGlkQ2FsbGJhY2siLCJjYWxsZXJOYW1lIiwid2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlIiwicGFydGlhbFN0YXRlIiwid2Fybk5vb3AiLCJwdWJsaWNJbnN0YW5jZSIsIl9jb25zdHJ1Y3RvciIsIndhcm5pbmdLZXkiLCJjbGFzc0NvbXBvbmVudFVwZGF0ZXIiLCJpc01vdW50ZWQiLCJpbnN0IiwiZW5xdWV1ZVNldFN0YXRlIiwiaW50ZXJuYWxzIiwicXVldWUiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwiYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJwcmV2U3RhdGUiLCJuZXh0UHJvcHMiLCJuZXdTdGF0ZSIsImNvbnN0cnVjdENsYXNzSW5zdGFuY2UiLCJtYXNrZWRMZWdhY3lDb250ZXh0IiwiY29udGV4dFR5cGUiLCJhZGRlbmR1bSIsImtleXMiLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImZvdW5kV2lsbE1vdW50TmFtZSIsImZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUiLCJmb3VuZFdpbGxVcGRhdGVOYW1lIiwiY29tcG9uZW50V2lsbE1vdW50IiwiX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUiLCJfY29tcG9uZW50TmFtZSIsIm5ld0FwaU5hbWUiLCJjaGVja0NsYXNzSW5zdGFuY2UiLCJuZXdQcm9wcyIsInJlbmRlclByZXNlbnQiLCJnZXRJbml0aWFsU3RhdGUiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsImdldERlZmF1bHRQcm9wcyIsInByb3BUeXBlcyIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsImlzUHVyZVJlYWN0Q29tcG9uZW50Iiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiY29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImhhc011dGF0ZWRQcm9wcyIsImRlZmF1bHRQcm9wcyIsImNvbXBvbmVudERpZFVwZGF0ZSIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImNhbGxDb21wb25lbnRXaWxsTW91bnQiLCJvbGRTdGF0ZSIsInByb2Nlc3NVcGRhdGVRdWV1ZSIsImludGVybmFsSW5zdGFuY2UiLCJvbGRRdWV1ZSIsIm9sZFJlcGxhY2UiLCJuZXh0U3RhdGUiLCJkb250TXV0YXRlIiwicGFydGlhbCIsIm1vdW50Q2xhc3NJbnN0YW5jZSIsImluaXRpYWxTdGF0ZSIsInVwZGF0ZXIiLCJlbXB0eVRyZWVDb250ZXh0IiwiZ2V0VHJlZUlkIiwiaWRXaXRoTGVhZGluZ0JpdCIsImdldExlYWRpbmdCaXQiLCJwdXNoVHJlZUNvbnRleHQiLCJiYXNlQ29udGV4dCIsInRvdGFsQ2hpbGRyZW4iLCJiYXNlSWRXaXRoTGVhZGluZ0JpdCIsImJhc2VPdmVyZmxvdyIsImJhc2VMZW5ndGgiLCJnZXRCaXRMZW5ndGgiLCJiYXNlSWQiLCJzbG90IiwibnVtYmVyT2ZPdmVyZmxvd0JpdHMiLCJuZXdPdmVyZmxvd0JpdHMiLCJuZXdPdmVyZmxvdyIsInJlc3RPZkJhc2VJZCIsInJlc3RPZkJhc2VMZW5ndGgiLCJyZXN0T2ZMZW5ndGgiLCJyZXN0T2ZOZXdCaXRzIiwibmV3Qml0cyIsIl9pZCIsIl9vdmVyZmxvdyIsIm51bWJlciIsImNsejMyIiwiTWF0aCIsImNsejMyRmFsbGJhY2siLCJMTjIiLCJhc1VpbnQiLCJTdXNwZW5zZUV4Y2VwdGlvbiIsImNyZWF0ZVRoZW5hYmxlU3RhdGUiLCJub29wJDIiLCJ0cmFja1VzZWRUaGVuYWJsZSIsInRoZW5hYmxlU3RhdGUiLCJ0aGVuYWJsZSIsInByZXZpb3VzIiwidGhlbiIsInN0YXR1cyIsImZ1bGZpbGxlZFZhbHVlIiwicmVqZWN0ZWRFcnJvciIsInJlYXNvbiIsInBlbmRpbmdUaGVuYWJsZSIsImZ1bGZpbGxlZFRoZW5hYmxlIiwicmVqZWN0ZWRUaGVuYWJsZSIsInN1c3BlbmRlZFRoZW5hYmxlIiwiZ2V0U3VzcGVuZGVkVGhlbmFibGUiLCJvYmplY3RJcyIsImN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCIsImN1cnJlbnRseVJlbmRlcmluZ1Rhc2siLCJjdXJyZW50bHlSZW5kZXJpbmdSZXF1ZXN0IiwiY3VycmVudGx5UmVuZGVyaW5nS2V5UGF0aCIsImZpcnN0V29ya0luUHJvZ3Jlc3NIb29rIiwid29ya0luUHJvZ3Jlc3NIb29rIiwiaXNSZVJlbmRlciIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUiLCJsb2NhbElkQ291bnRlciIsImZvcm1TdGF0ZUNvdW50ZXIiLCJmb3JtU3RhdGVNYXRjaGluZ0luZGV4IiwidGhlbmFibGVJbmRleENvdW50ZXIiLCJyZW5kZXJQaGFzZVVwZGF0ZXMiLCJudW1iZXJPZlJlUmVuZGVycyIsIlJFX1JFTkRFUl9MSU1JVCIsImlzSW5Ib29rVXNlckNvZGVJbkRldiIsImN1cnJlbnRIb29rTmFtZUluRGV2IiwicmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCIsImFyZUhvb2tJbnB1dHNFcXVhbCIsIm5leHREZXBzIiwicHJldkRlcHMiLCJjcmVhdGVIb29rIiwibWVtb2l6ZWRTdGF0ZSIsImNyZWF0ZVdvcmtJblByb2dyZXNzSG9vayIsInByZXBhcmVUb1VzZUhvb2tzIiwidGFzayIsImtleVBhdGgiLCJjb21wb25lbnRJZGVudGl0eSIsInByZXZUaGVuYWJsZVN0YXRlIiwiZmluaXNoSG9va3MiLCJyZWZPckNvbnRleHQiLCJyZXNldEhvb2tzU3RhdGUiLCJnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nIiwiY2hlY2tEaWRSZW5kZXJJZEhvb2siLCJkaWRSZW5kZXJJZEhvb2siLCJnZXRGb3JtU3RhdGVDb3VudCIsImdldEZvcm1TdGF0ZU1hdGNoaW5nSW5kZXgiLCJyZWFkQ29udGV4dCIsInVzZUNvbnRleHQiLCJiYXNpY1N0YXRlUmVkdWNlciIsInVzZVN0YXRlIiwidXNlUmVkdWNlciIsInJlZHVjZXIiLCJpbml0aWFsQXJnIiwiZGlzcGF0Y2giLCJmaXJzdFJlbmRlclBoYXNlVXBkYXRlIiwidXBkYXRlIiwiX3F1ZXVlIiwibGFzdCIsIl9kaXNwYXRjaCIsImRpc3BhdGNoQWN0aW9uIiwidXNlTWVtbyIsIm5leHRDcmVhdGUiLCJkZXBzIiwidXNlUmVmIiwiaW5pdGlhbFZhbHVlIiwicHJldmlvdXNSZWYiLCJyZWYiLCJzZWFsIiwibGFzdFJlbmRlclBoYXNlVXBkYXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInN1YnNjcmliZSIsImdldFNuYXBzaG90IiwiZ2V0U2VydmVyU25hcHNob3QiLCJ1c2VEZWZlcnJlZFZhbHVlIiwidW5zdXBwb3J0ZWRTdGFydFRyYW5zaXRpb24iLCJ1c2VUcmFuc2l0aW9uIiwidXNlSG9zdFRyYW5zaXRpb25TdGF0dXMiLCJ1bnN1cHBvcnRlZFNldE9wdGltaXN0aWNTdGF0ZSIsInVzZU9wdGltaXN0aWMiLCJwYXNzdGhyb3VnaCIsImNyZWF0ZVBvc3RiYWNrRm9ybVN0YXRlS2V5IiwicGVybWFsaW5rIiwiY29tcG9uZW50S2V5UGF0aCIsImhvb2tJbmRleCIsImtleVBhdGhIYXNoIiwidXNlRm9ybVN0YXRlIiwiZm9ybVN0YXRlSG9va0luZGV4IiwibmV4dFBvc3RiYWNrU3RhdGVLZXkiLCJwb3N0YmFja0Zvcm1TdGF0ZSIsImdldEZvcm1TdGF0ZSIsImlzU2lnbmF0dXJlRXF1YWwiLCIkJElTX1NJR05BVFVSRV9FUVVBTCIsInBvc3RiYWNrS2V5IiwicG9zdGJhY2tSZWZlcmVuY2VJZCIsInBvc3RiYWNrQm91bmRBcml0eSIsImJvdW5kQWN0aW9uIiwibWV0YWRhdGEiLCJhcHBlbmQiLCJfYm91bmRBY3Rpb24iLCJfZGlzcGF0Y2gyIiwidXNlSWQiLCJ0cmVlQ29udGV4dCIsImN1cnJlbnRSZXN1bWFibGVTdGF0ZSIsInVzZSIsInVzYWJsZSIsInVud3JhcFRoZW5hYmxlIiwidW5zdXBwb3J0ZWRSZWZyZXNoIiwidXNlQ2FjaGVSZWZyZXNoIiwibm9vcCQxIiwiSG9va3NEaXNwYXRjaGVyIiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZUVmZmVjdCIsInVzZURlYnVnVmFsdWUiLCJzZXRDdXJyZW50UmVzdW1hYmxlU3RhdGUiLCJnZXRDYWNoZVNpZ25hbCIsImdldENhY2hlRm9yVHlwZSIsInJlc291cmNlVHlwZSIsIkRlZmF1bHRDYWNoZURpc3BhdGNoZXIiLCJnZXRTdGFja0J5Q29tcG9uZW50U3RhY2tOb2RlIiwiY29tcG9uZW50U3RhY2siLCJub2RlIiwiUmVhY3RDdXJyZW50Q2FjaGUiLCJDTElFTlRfUkVOREVSRUQiLCJQRU5ESU5HIiwiQ09NUExFVEVEIiwiRkxVU0hFRCIsIkFCT1JURUQiLCJFUlJPUkVEIiwiUE9TVFBPTkVEIiwiT1BFTiIsIkNMT1NJTkciLCJDTE9TRUQiLCJERUZBVUxUX1BST0dSRVNTSVZFX0NIVU5LX1NJWkUiLCJkZWZhdWx0RXJyb3JIYW5kbGVyIiwibm9vcCIsImNyZWF0ZVJlcXVlc3QiLCJyb290Rm9ybWF0Q29udGV4dCIsInByb2dyZXNzaXZlQ2h1bmtTaXplIiwib25BbGxSZWFkeSIsIm9uU2hlbGxSZWFkeSIsIm9uU2hlbGxFcnJvciIsIm9uRmF0YWxFcnJvciIsIm9uUG9zdHBvbmUiLCJmb3JtU3RhdGUiLCJwaW5nZWRUYXNrcyIsImFib3J0U2V0IiwiZmx1c2hTY2hlZHVsZWQiLCJmYXRhbEVycm9yIiwibmV4dFNlZ21lbnRJZCIsImFsbFBlbmRpbmdUYXNrcyIsInBlbmRpbmdSb290VGFza3MiLCJjb21wbGV0ZWRSb290U2VnbWVudCIsImFib3J0YWJsZVRhc2tzIiwiY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzIiwiY29tcGxldGVkQm91bmRhcmllcyIsInBhcnRpYWxCb3VuZGFyaWVzIiwidHJhY2tlZFBvc3Rwb25lcyIsInJvb3RTZWdtZW50IiwiY3JlYXRlUGVuZGluZ1NlZ21lbnQiLCJwYXJlbnRGbHVzaGVkIiwicm9vdFRhc2siLCJjcmVhdGVSZW5kZXJUYXNrIiwiY3VycmVudFJlcXVlc3QiLCJwaW5nVGFzayIsInBlcmZvcm1Xb3JrIiwiY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSIsImZhbGxiYWNrQWJvcnRhYmxlVGFza3MiLCJyb290U2VnbWVudElEIiwicGVuZGluZ1Rhc2tzIiwiY29tcGxldGVkU2VnbWVudHMiLCJieXRlU2l6ZSIsInRyYWNrZWRDb250ZW50S2V5UGF0aCIsInRyYWNrZWRGYWxsYmFja05vZGUiLCJjaGlsZEluZGV4IiwiYmxvY2tlZEJvdW5kYXJ5IiwiYmxvY2tlZFNlZ21lbnQiLCJsZWdhY3lDb250ZXh0IiwicmVwbGF5IiwicGluZyIsImNyZWF0ZVJlcGxheVRhc2siLCJib3VuZGFyeSIsInBhcmVudEZvcm1hdENvbnRleHQiLCJjdXJyZW50VGFza0luREVWIiwiZ2V0Q3VycmVudFN0YWNrSW5ERVYiLCJnZXRTdGFja0Zyb21Ob2RlIiwic3RhY2tOb2RlIiwiY3JlYXRlQnVpbHRJbkNvbXBvbmVudFN0YWNrIiwiY3JlYXRlRnVuY3Rpb25Db21wb25lbnRTdGFjayIsImNyZWF0ZUNsYXNzQ29tcG9uZW50U3RhY2siLCJnZXRUaHJvd25JbmZvIiwiZW5jb2RlRXJyb3JGb3JCb3VuZGFyeSIsImRpZ2VzdCIsInRocm93bkluZm8iLCJsb2dSZWNvdmVyYWJsZUVycm9yIiwiZXJyb3JJbmZvIiwicmVuZGVyU3VzcGVuc2VCb3VuZGFyeSIsInNvbWVUYXNrIiwiX3ByZXZLZXlQYXRoIiwiX2NvbnRlbnQiLCJyZW5kZXJOb2RlIiwicHJldmlvdXNDb21wb25lbnRTdGFjayIsInN1c3BlbnNlQ29tcG9uZW50U3RhY2siLCJwcmV2S2V5UGF0aCIsInBhcmVudEJvdW5kYXJ5IiwicGFyZW50U2VnbWVudCIsImZhbGxiYWNrIiwiZmFsbGJhY2tBYm9ydFNldCIsIm5ld0JvdW5kYXJ5IiwiaW5zZXJ0aW9uSW5kZXgiLCJib3VuZGFyeVNlZ21lbnQiLCJjb250ZW50Um9vdFNlZ21lbnQiLCJxdWV1ZUNvbXBsZXRlZFNlZ21lbnQiLCJ1bnRyYWNrQm91bmRhcnkiLCJmYWxsYmFja0tleVBhdGgiLCJmYWxsYmFja1JlcGxheU5vZGUiLCJ3b3JraW5nTWFwIiwiYm91bmRhcnlSZXBsYXlOb2RlIiwic3VzcGVuZGVkRmFsbGJhY2tUYXNrIiwicmVwbGF5U3VzcGVuc2VCb3VuZGFyeSIsImNoaWxkTm9kZXMiLCJjaGlsZFNsb3RzIiwiZmFsbGJhY2tOb2RlcyIsImZhbGxiYWNrU2xvdHMiLCJwcmV2aW91c1JlcGxheVNldCIsInJlc3VtZWRCb3VuZGFyeSIsIm5vZGVzIiwic2xvdHMiLCJmYWxsYmFja1JlcGxheSIsInJlbmRlckhvc3RFbGVtZW50Iiwic2VnbWVudCIsInByZXZDb250ZXh0IiwiX2NoaWxkcmVuIiwiX3ByZXZDb250ZXh0IiwiX3ByZXZLZXlQYXRoMiIsInNob3VsZENvbnN0cnVjdCIsInJlbmRlcldpdGhIb29rcyIsInNlY29uZEFyZyIsImZpbmlzaENsYXNzQ29tcG9uZW50IiwibmV4dENoaWxkcmVuIiwiZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyIsInByZXZpb3VzQ29udGV4dCIsIm1lcmdlZENvbnRleHQiLCJyZW5kZXJOb2RlRGVzdHJ1Y3RpdmUiLCJyZW5kZXJDbGFzc0NvbXBvbmVudCIsIm1hc2tlZENvbnRleHQiLCJkaWRXYXJuQWJvdXRCYWRDbGFzcyIsImRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkV2FybkFib3V0RGVmYXVsdFByb3BzT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dEdlbmVyYXRvcnMiLCJkaWRXYXJuQWJvdXRNYXBzIiwiaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyIiwicmVuZGVySW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsImhhc0lkIiwiZm9ybVN0YXRlQ291bnQiLCJfY29tcG9uZW50TmFtZTIiLCJ2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYiLCJmaW5pc2hGdW5jdGlvbkNvbXBvbmVudCIsImRpZEVtaXRGb3JtU3RhdGVNYXJrZXJzIiwicHJldlRyZWVDb250ZXh0IiwiX2NvbXBvbmVudE5hbWUzIiwiX2NvbXBvbmVudE5hbWU0IiwicmVzb2x2ZURlZmF1bHRQcm9wcyIsImJhc2VQcm9wcyIsInJlbmRlckZvcndhcmRSZWYiLCJyZW5kZXJNZW1vIiwicmVzb2x2ZWRQcm9wcyIsInJlbmRlckVsZW1lbnQiLCJyZW5kZXJDb250ZXh0Q29uc3VtZXIiLCJDb25zdW1lciIsIm5ld1ZhbHVlIiwibmV3Q2hpbGRyZW4iLCJyZW5kZXJDb250ZXh0UHJvdmlkZXIiLCJyZW5kZXJMYXp5Q29tcG9uZW50IiwicmVuZGVyT2Zmc2NyZWVuIiwicHJlaW91c0NvbXBvbmVudFN0YWNrIiwiX3ByZXZLZXlQYXRoMyIsInJlc3VtZU5vZGUiLCJzZWdtZW50SWQiLCJwcmV2UmVwbGF5IiwicmVzdW1lZFNlZ21lbnQiLCJyZW5kZXJUYXNrIiwicmVwbGF5RWxlbWVudCIsImtleU9ySW5kZXgiLCJyZXBsYXlOb2RlcyIsImN1cnJlbnROb2RlIiwiZXJyb3JlZFJlcGxheSIsImV4cGVjdGVkVHlwZSIsInNwbGljZSIsInZhbGlkYXRlSXRlcmFibGUiLCJpdGVyYWJsZSIsIml0ZXJhdG9yRm4iLCJlbnRyaWVzIiwicmVzdW1lU2VnbWVudElEIiwibGF6eU5vZGUiLCJyZXNvbHZlZE5vZGUiLCJyZW5kZXJDaGlsZHJlbkFycmF5IiwibWF5YmVVc2FibGUiLCJjaGlsZFN0cmluZyIsIl9zZWdtZW50IiwicmVwbGF5RnJhZ21lbnQiLCJqIiwicmVzdW1lU2xvdHMiLCJfbm9kZSIsImJvdW5kYXJ5S2V5UGF0aCIsImJvdW5kYXJ5Tm9kZSIsInNwYXduTmV3U3VzcGVuZGVkUmVwbGF5VGFzayIsIm5ld1Rhc2siLCJzcGF3bk5ld1N1c3BlbmRlZFJlbmRlclRhc2siLCJuZXdTZWdtZW50IiwicHJldmlvdXNGb3JtYXRDb250ZXh0IiwicHJldmlvdXNMZWdhY3lDb250ZXh0IiwicHJldmlvdXNLZXlQYXRoIiwicHJldmlvdXNUcmVlQ29udGV4dCIsInRocm93blZhbHVlIiwid2FrZWFibGUiLCJjaGlsZHJlbkxlbmd0aCIsImNodW5rTGVuZ3RoIiwiX3dha2VhYmxlIiwiX3RoZW5hYmxlU3RhdGUiLCJhYm9ydFJlbWFpbmluZ1JlcGxheU5vZGVzIiwiZXJyb3JlZFRhc2siLCJjb21wbGV0ZUFsbCIsImFib3J0VGFza1NvZnQiLCJmaW5pc2hlZFRhc2siLCJhYm9ydFJlbWFpbmluZ1N1c3BlbnNlQm91bmRhcnkiLCJlcnJvclByZWZpeCIsImFib3J0VGFzayIsImNvbXBsZXRlU2hlbGwiLCJfZXJyb3JJbmZvIiwiX2Vycm9yRGlnZXN0IiwiZmFsbGJhY2tUYXNrIiwic2FmZWx5RW1pdEVhcmx5UHJlbG9hZHMiLCJjaGlsZFNlZ21lbnQiLCJyZXRyeVRhc2siLCJyZXRyeVJlcGxheVRhc2siLCJyZXRyeVJlbmRlclRhc2siLCJwcmV2VGFza0luREVWIiwicHJldkRpc3BhdGNoZXIiLCJwcmV2Q2FjaGVEaXNwYXRjaGVyIiwicHJldlJlcXVlc3QiLCJwcmV2R2V0Q3VycmVudFN0YWNrSW1wbCIsImdldEN1cnJlbnRTdGFjayIsInByZXZSZXN1bWFibGVTdGF0ZSIsImZsdXNoQ29tcGxldGVkUXVldWVzIiwiZmx1c2hTdWJ0cmVlIiwic2VnbWVudElEIiwiY2h1bmtJZHgiLCJjaGlsZElkeCIsIm5leHRDaGlsZCIsImZsdXNoU2VnbWVudCIsImNvbnRlbnRTZWdtZW50IiwiZmx1c2hDbGllbnRSZW5kZXJlZEJvdW5kYXJ5IiwiZmx1c2hTZWdtZW50Q29udGFpbmVyIiwiZmx1c2hDb21wbGV0ZWRCb3VuZGFyeSIsImZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudCIsImZsdXNoUGFydGlhbEJvdW5kYXJ5IiwiX2JvdW5kYXJ5IiwiX2JvdW5kYXJ5MiIsImxhcmdlQm91bmRhcmllcyIsIl9ib3VuZGFyeTMiLCJzdG9wRmxvd2luZyIsInN0YXJ0V29yayIsImVucXVldWVFYXJseVByZWxvYWRzQWZ0ZXJJbml0aWFsV29yayIsImVucXVldWVGbHVzaCIsInN0YXJ0Rmxvd2luZyIsImFib3J0IiwicmVuZGVyVG9SZWFkYWJsZVN0cmVhbSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiYWxsUmVhZHkiLCJyZXMiLCJyZWoiLCJzdHJlYW0iLCJSZWFkYWJsZVN0cmVhbSIsInB1bGwiLCJjb250cm9sbGVyIiwiY2FuY2VsIiwiaGlnaFdhdGVyTWFyayIsIm9uSGVhZGVyc0ltcGwiLCJoZWFkZXJzRGVzY3JpcHRvciIsIkhlYWRlcnMiLCJ1bnN0YWJsZV9leHRlcm5hbFJ1bnRpbWVTcmMiLCJzaWduYWwiLCJhYm9ydGVkIiwibGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.browser.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/server.browser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/server.browser.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar l, s;\nif (false) {} else {\n    l = __webpack_require__(/*! ./cjs/react-dom-server-legacy.browser.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-legacy.browser.development.js\");\n    s = __webpack_require__(/*! ./cjs/react-dom-server.browser.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom-server.browser.development.js\");\n}\nexports.version = l.version;\nexports.renderToString = l.renderToString;\nexports.renderToStaticMarkup = l.renderToStaticMarkup;\nexports.renderToNodeStream = l.renderToNodeStream;\nexports.renderToStaticNodeStream = l.renderToStaticNodeStream;\nexports.renderToReadableStream = s.renderToReadableStream;\nif (s.resume) {\n    exports.resume = s.resume;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL3NlcnZlci5icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsR0FBR0M7QUFDUCxJQUFJQyxLQUF5QixFQUFjLEVBRzFDLE1BQU07SUFDTEYsSUFBSUcsbUJBQU9BLENBQUM7SUFDWkYsSUFBSUUsbUJBQU9BLENBQUM7QUFDZDtBQUVBQyxlQUFlLEdBQUdKLEVBQUVLLE9BQU87QUFDM0JELHNCQUFzQixHQUFHSixFQUFFTSxjQUFjO0FBQ3pDRiw0QkFBNEIsR0FBR0osRUFBRU8sb0JBQW9CO0FBQ3JESCwwQkFBMEIsR0FBR0osRUFBRVEsa0JBQWtCO0FBQ2pESixnQ0FBZ0MsR0FBR0osRUFBRVMsd0JBQXdCO0FBQzdETCw4QkFBOEIsR0FBR0gsRUFBRVMsc0JBQXNCO0FBQ3pELElBQUlULEVBQUVVLE1BQU0sRUFBRTtJQUNaUCxjQUFjLEdBQUdILEVBQUVVLE1BQU07QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1kb20vc2VydmVyLmJyb3dzZXIuanM/YWVlOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBsLCBzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbCA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXItbGVnYWN5LmJyb3dzZXIucHJvZHVjdGlvbi5taW4uanMnKTtcbiAgcyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIuYnJvd3Nlci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbCA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXItbGVnYWN5LmJyb3dzZXIuZGV2ZWxvcG1lbnQuanMnKTtcbiAgcyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIuYnJvd3Nlci5kZXZlbG9wbWVudC5qcycpO1xufVxuXG5leHBvcnRzLnZlcnNpb24gPSBsLnZlcnNpb247XG5leHBvcnRzLnJlbmRlclRvU3RyaW5nID0gbC5yZW5kZXJUb1N0cmluZztcbmV4cG9ydHMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSBsLnJlbmRlclRvU3RhdGljTWFya3VwO1xuZXhwb3J0cy5yZW5kZXJUb05vZGVTdHJlYW0gPSBsLnJlbmRlclRvTm9kZVN0cmVhbTtcbmV4cG9ydHMucmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtID0gbC5yZW5kZXJUb1N0YXRpY05vZGVTdHJlYW07XG5leHBvcnRzLnJlbmRlclRvUmVhZGFibGVTdHJlYW0gPSBzLnJlbmRlclRvUmVhZGFibGVTdHJlYW07XG5pZiAocy5yZXN1bWUpIHtcbiAgZXhwb3J0cy5yZXN1bWUgPSBzLnJlc3VtZTtcbn1cbiJdLCJuYW1lcyI6WyJsIiwicyIsInByb2Nlc3MiLCJyZXF1aXJlIiwiZXhwb3J0cyIsInZlcnNpb24iLCJyZW5kZXJUb1N0cmluZyIsInJlbmRlclRvU3RhdGljTWFya3VwIiwicmVuZGVyVG9Ob2RlU3RyZWFtIiwicmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtIiwicmVuZGVyVG9SZWFkYWJsZVN0cmVhbSIsInJlc3VtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/server.browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/profile/page.tsx":
/*!**********************************!*\
  !*** ./src/app/profile/page.tsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Profile; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next-auth/react */ \"(app-pages-browser)/./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=Alert,Avatar,Box,Button,Card,Chip,CircularProgress,Container,Divider,Grid,IconButton,LinearProgress,Paper,TextField,Typography!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/Container/Container.js\");\n/* harmony import */ var _barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=Alert,Avatar,Box,Button,Card,Chip,CircularProgress,Container,Divider,Grid,IconButton,LinearProgress,Paper,TextField,Typography!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/Box/Box.js\");\n/* harmony import */ var _barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=Alert,Avatar,Box,Button,Card,Chip,CircularProgress,Container,Divider,Grid,IconButton,LinearProgress,Paper,TextField,Typography!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/CircularProgress/CircularProgress.js\");\n/* harmony import */ var _barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=Alert,Avatar,Box,Button,Card,Chip,CircularProgress,Container,Divider,Grid,IconButton,LinearProgress,Paper,TextField,Typography!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/Alert/Alert.js\");\n/* harmony import */ var _barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! __barrel_optimize__?names=Alert,Avatar,Box,Button,Card,Chip,CircularProgress,Container,Divider,Grid,IconButton,LinearProgress,Paper,TextField,Typography!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/Paper/Paper.js\");\n/* harmony import */ var _barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! __barrel_optimize__?names=Alert,Avatar,Box,Button,Card,Chip,CircularProgress,Container,Divider,Grid,IconButton,LinearProgress,Paper,TextField,Typography!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/Typography/Typography.js\");\n/* harmony import */ var _barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! __barrel_optimize__?names=Alert,Avatar,Box,Button,Card,Chip,CircularProgress,Container,Divider,Grid,IconButton,LinearProgress,Paper,TextField,Typography!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/Button/Button.js\");\n/* harmony import */ var _barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! __barrel_optimize__?names=Alert,Avatar,Box,Button,Card,Chip,CircularProgress,Container,Divider,Grid,IconButton,LinearProgress,Paper,TextField,Typography!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/Grid/Grid.js\");\n/* harmony import */ var _barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! __barrel_optimize__?names=Alert,Avatar,Box,Button,Card,Chip,CircularProgress,Container,Divider,Grid,IconButton,LinearProgress,Paper,TextField,Typography!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/Avatar/Avatar.js\");\n/* harmony import */ var _barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! __barrel_optimize__?names=Alert,Avatar,Box,Button,Card,Chip,CircularProgress,Container,Divider,Grid,IconButton,LinearProgress,Paper,TextField,Typography!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/IconButton/IconButton.js\");\n/* harmony import */ var _barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! __barrel_optimize__?names=Alert,Avatar,Box,Button,Card,Chip,CircularProgress,Container,Divider,Grid,IconButton,LinearProgress,Paper,TextField,Typography!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/Chip/Chip.js\");\n/* harmony import */ var _barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! __barrel_optimize__?names=Alert,Avatar,Box,Button,Card,Chip,CircularProgress,Container,Divider,Grid,IconButton,LinearProgress,Paper,TextField,Typography!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/TextField/TextField.js\");\n/* harmony import */ var _barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! __barrel_optimize__?names=Alert,Avatar,Box,Button,Card,Chip,CircularProgress,Container,Divider,Grid,IconButton,LinearProgress,Paper,TextField,Typography!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/Divider/Divider.js\");\n/* harmony import */ var _barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! __barrel_optimize__?names=Alert,Avatar,Box,Button,Card,Chip,CircularProgress,Container,Divider,Grid,IconButton,LinearProgress,Paper,TextField,Typography!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/Card/Card.js\");\n/* harmony import */ var _barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! __barrel_optimize__?names=Alert,Avatar,Box,Button,Card,Chip,CircularProgress,Container,Divider,Grid,IconButton,LinearProgress,Paper,TextField,Typography!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/LinearProgress/LinearProgress.js\");\n/* harmony import */ var _barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! __barrel_optimize__?names=Assignment,CalendarToday,Cancel,CheckCircle,Edit,Email,Person,PhotoCamera,Print,Save,TrendingUp!=!@mui/icons-material */ \"(app-pages-browser)/./node_modules/@mui/icons-material/esm/Print.js\");\n/* harmony import */ var _barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! __barrel_optimize__?names=Assignment,CalendarToday,Cancel,CheckCircle,Edit,Email,Person,PhotoCamera,Print,Save,TrendingUp!=!@mui/icons-material */ \"(app-pages-browser)/./node_modules/@mui/icons-material/esm/Edit.js\");\n/* harmony import */ var _barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! __barrel_optimize__?names=Assignment,CalendarToday,Cancel,CheckCircle,Edit,Email,Person,PhotoCamera,Print,Save,TrendingUp!=!@mui/icons-material */ \"(app-pages-browser)/./node_modules/@mui/icons-material/esm/Cancel.js\");\n/* harmony import */ var _barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! __barrel_optimize__?names=Assignment,CalendarToday,Cancel,CheckCircle,Edit,Email,Person,PhotoCamera,Print,Save,TrendingUp!=!@mui/icons-material */ \"(app-pages-browser)/./node_modules/@mui/icons-material/esm/Save.js\");\n/* harmony import */ var _barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! __barrel_optimize__?names=Assignment,CalendarToday,Cancel,CheckCircle,Edit,Email,Person,PhotoCamera,Print,Save,TrendingUp!=!@mui/icons-material */ \"(app-pages-browser)/./node_modules/@mui/icons-material/esm/PhotoCamera.js\");\n/* harmony import */ var _barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! __barrel_optimize__?names=Assignment,CalendarToday,Cancel,CheckCircle,Edit,Email,Person,PhotoCamera,Print,Save,TrendingUp!=!@mui/icons-material */ \"(app-pages-browser)/./node_modules/@mui/icons-material/esm/Email.js\");\n/* harmony import */ var _barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! __barrel_optimize__?names=Assignment,CalendarToday,Cancel,CheckCircle,Edit,Email,Person,PhotoCamera,Print,Save,TrendingUp!=!@mui/icons-material */ \"(app-pages-browser)/./node_modules/@mui/icons-material/esm/Person.js\");\n/* harmony import */ var _barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! __barrel_optimize__?names=Assignment,CalendarToday,Cancel,CheckCircle,Edit,Email,Person,PhotoCamera,Print,Save,TrendingUp!=!@mui/icons-material */ \"(app-pages-browser)/./node_modules/@mui/icons-material/esm/CalendarToday.js\");\n/* harmony import */ var _barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! __barrel_optimize__?names=Assignment,CalendarToday,Cancel,CheckCircle,Edit,Email,Person,PhotoCamera,Print,Save,TrendingUp!=!@mui/icons-material */ \"(app-pages-browser)/./node_modules/@mui/icons-material/esm/Assignment.js\");\n/* harmony import */ var _barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! __barrel_optimize__?names=Assignment,CalendarToday,Cancel,CheckCircle,Edit,Email,Person,PhotoCamera,Print,Save,TrendingUp!=!@mui/icons-material */ \"(app-pages-browser)/./node_modules/@mui/icons-material/esm/TrendingUp.js\");\n/* harmony import */ var _barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! __barrel_optimize__?names=Assignment,CalendarToday,Cancel,CheckCircle,Edit,Email,Person,PhotoCamera,Print,Save,TrendingUp!=!@mui/icons-material */ \"(app-pages-browser)/./node_modules/@mui/icons-material/esm/CheckCircle.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _components_PrintableTasks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/PrintableTasks */ \"(app-pages-browser)/./src/components/PrintableTasks.tsx\");\n/* harmony import */ var react_dom_server__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-dom/server */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/server.browser.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nfunction Profile() {\n    var _tempProfile_name_, _tempProfile_name;\n    _s();\n    const { data: session, update } = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_2__.useSession)();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter)();\n    const [isEditing, setIsEditing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [saving, setSaving] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [tasks, setTasks] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [profile, setProfile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        id: \"\",\n        name: \"\",\n        email: \"\",\n        bio: null,\n        avatar: null,\n        createdAt: \"\",\n        totalTasks: 0,\n        completedTasks: 0,\n        pendingTasks: 0,\n        inProgressTasks: 0,\n        overdueTasks: 0\n    });\n    const [tempProfile, setTempProfile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(profile);\n    const [message, setMessage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const fetchUserProfile = async ()=>{\n        try {\n            const response = await fetch(\"/api/profile\");\n            if (response.ok) {\n                const userData = await response.json();\n                setProfile((prev)=>({\n                        ...prev,\n                        ...userData\n                    }));\n                setTempProfile((prev)=>({\n                        ...prev,\n                        ...userData\n                    }));\n            }\n        } catch (error) {\n            console.error(\"Error fetching user profile:\", error);\n        }\n    };\n    const fetchUserStats = async ()=>{\n        try {\n            const response = await fetch(\"/api/tasks\");\n            const fetchedTasks = await response.json();\n            setTasks(fetchedTasks);\n            const stats = {\n                total: fetchedTasks.length,\n                completed: fetchedTasks.filter((t)=>t.status === \"COMPLETED\").length,\n                pending: fetchedTasks.filter((t)=>t.status === \"PENDING\").length,\n                inProgress: fetchedTasks.filter((t)=>t.status === \"IN_PROGRESS\").length,\n                overdue: fetchedTasks.filter((t)=>{\n                    const dueDate = new Date(t.dueDate);\n                    const now = new Date();\n                    const daysUntilDue = Math.ceil((dueDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));\n                    return daysUntilDue < 0 && t.status !== \"COMPLETED\";\n                }).length\n            };\n            setProfile((prev)=>({\n                    ...prev,\n                    totalTasks: stats.total,\n                    completedTasks: stats.completed,\n                    pendingTasks: stats.pending,\n                    inProgressTasks: stats.inProgress,\n                    overdueTasks: stats.overdue\n                }));\n        } catch (error) {\n            console.error(\"Error fetching user stats:\", error);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!session) {\n            router.push(\"/login\");\n            return;\n        }\n        const loadProfileData = async ()=>{\n            await fetchUserProfile();\n            await fetchUserStats();\n            setLoading(false);\n        };\n        loadProfileData();\n    }, [\n        session,\n        router\n    ]);\n    const handleEdit = ()=>{\n        setTempProfile(profile);\n        setIsEditing(true);\n    };\n    const handleCancel = ()=>{\n        setTempProfile(profile);\n        setIsEditing(false);\n    };\n    const handleSave = async ()=>{\n        setSaving(true);\n        try {\n            const response = await fetch(\"/api/profile\", {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    name: tempProfile.name,\n                    bio: tempProfile.bio,\n                    avatar: tempProfile.avatar\n                })\n            });\n            if (response.ok) {\n                const updatedProfile = await response.json();\n                setProfile((prev)=>({\n                        ...prev,\n                        ...updatedProfile\n                    }));\n                setIsEditing(false);\n                setMessage({\n                    type: \"success\",\n                    text: \"Profile updated successfully!\"\n                });\n                // Update session with new name\n                await update({\n                    ...session,\n                    user: {\n                        ...session === null || session === void 0 ? void 0 : session.user,\n                        name: tempProfile.name\n                    }\n                });\n                // Clear message after 3 seconds\n                setTimeout(()=>setMessage(null), 3000);\n            } else {\n                const error = await response.json();\n                setMessage({\n                    type: \"error\",\n                    text: error.error || \"Failed to update profile. Please try again.\"\n                });\n            }\n        } catch (error) {\n            setMessage({\n                type: \"error\",\n                text: \"Failed to update profile. Please try again.\"\n            });\n        } finally{\n            setSaving(false);\n        }\n    };\n    const handleAvatarChange = (event)=>{\n        var _event_target_files;\n        const file = (_event_target_files = event.target.files) === null || _event_target_files === void 0 ? void 0 : _event_target_files[0];\n        if (file) {\n            // Validate file size (max 5MB)\n            if (file.size > 5 * 1024 * 1024) {\n                setMessage({\n                    type: \"error\",\n                    text: \"Image size must be less than 5MB.\"\n                });\n                return;\n            }\n            // Validate file type\n            if (!file.type.startsWith(\"image/\")) {\n                setMessage({\n                    type: \"error\",\n                    text: \"Please select a valid image file.\"\n                });\n                return;\n            }\n            const reader = new FileReader();\n            reader.onloadend = ()=>{\n                setTempProfile({\n                    ...tempProfile,\n                    avatar: reader.result\n                });\n            };\n            reader.readAsDataURL(file);\n        }\n    };\n    const handlePrint = ()=>{\n        const printWindow = window.open(\"\", \"_blank\");\n        if (!printWindow) return;\n        const printableComponent = /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_PrintableTasks__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n            tasks: tasks,\n            userProfile: {\n                name: profile.name,\n                email: profile.email\n            },\n            printDate: new Date()\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n            lineNumber: 244,\n            columnNumber: 4\n        }, this);\n        const printContent = react_dom_server__WEBPACK_IMPORTED_MODULE_5__.renderToString(printableComponent);\n        printWindow.document.write(\"\\n\t\t\t<!DOCTYPE html>\\n\t\t\t<html>\\n\t\t\t<head>\\n\t\t\t\t<title>MyDo - Task Report</title>\\n\t\t\t\t<style>\\n\t\t\t\t\tbody { \\n\t\t\t\t\t\tfont-family: Arial, sans-serif; \\n\t\t\t\t\t}\\n\t\t\t\t\t@media print {\\n\t\t\t\t\t\tbody { margin: 20px; }\\n\t\t\t\t\t\t@page { \\n\t\t\t\t\t\t\tsize: auto;\\n\t\t\t\t\t\t\tmargin: 20mm;\\n\t\t\t\t\t\t}\\n\t\t\t\t\t}\\n\t\t\t\t</style>\\n\t\t\t</head>\\n\t\t\t<body>\\n\t\t\t\t\".concat(printContent, \"\\n\t\t\t\t<script>\\n\t\t\t\t\twindow.onload = function() {\\n\t\t\t\t\t\tsetTimeout(function() {\\n\t\t\t\t\t\t\twindow.print();\\n\t\t\t\t\t\t\twindow.close();\\n\t\t\t\t\t\t}, 500); // Delay to ensure content loads\\n\t\t\t\t\t};\\n\t\t\t\t</script>\\n\t\t\t</body>\\n\t\t\t</html>\\n\t\t\"));\n        printWindow.document.close();\n    };\n    const completionRate = profile.totalTasks > 0 ? profile.completedTasks / profile.totalTasks * 100 : 0;\n    if (!session) {\n        return null;\n    }\n    if (loading) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n            maxWidth: \"md\",\n            sx: {\n                py: 4\n            },\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                display: \"flex\",\n                justifyContent: \"center\",\n                alignItems: \"center\",\n                minHeight: \"400px\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {}, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                    lineNumber: 306,\n                    columnNumber: 6\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                lineNumber: 301,\n                columnNumber: 5\n            }, this)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n            lineNumber: 298,\n            columnNumber: 4\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n        maxWidth: \"md\",\n        sx: {\n            py: 4\n        },\n        children: [\n            message && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                severity: message.type,\n                sx: {\n                    mb: 3\n                },\n                children: message.text\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                lineNumber: 317,\n                columnNumber: 5\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n                elevation: 3,\n                sx: {\n                    p: 4\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                        sx: {\n                            display: \"flex\",\n                            justifyContent: \"space-between\",\n                            alignItems: \"center\",\n                            mb: 3\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                variant: \"h4\",\n                                component: \"h1\",\n                                children: \"Profile\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                lineNumber: 334,\n                                columnNumber: 6\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                sx: {\n                                    display: \"flex\",\n                                    gap: 1\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n                                        variant: \"outlined\",\n                                        startIcon: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_13__[\"default\"], {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                            lineNumber: 342,\n                                            columnNumber: 19\n                                        }, void 0),\n                                        onClick: handlePrint,\n                                        children: \"Print Profile\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                        lineNumber: 340,\n                                        columnNumber: 7\n                                    }, this),\n                                    !isEditing ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n                                        variant: \"outlined\",\n                                        startIcon: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_14__[\"default\"], {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                            lineNumber: 349,\n                                            columnNumber: 20\n                                        }, void 0),\n                                        onClick: handleEdit,\n                                        children: \"Edit Profile\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                        lineNumber: 347,\n                                        columnNumber: 8\n                                    }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n                                                variant: \"outlined\",\n                                                startIcon: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_15__[\"default\"], {}, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                    lineNumber: 357,\n                                                    columnNumber: 21\n                                                }, void 0),\n                                                onClick: handleCancel,\n                                                sx: {\n                                                    mr: 1\n                                                },\n                                                disabled: saving,\n                                                children: \"Cancel\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 355,\n                                                columnNumber: 9\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n                                                variant: \"contained\",\n                                                startIcon: saving ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                                    size: 16\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                    lineNumber: 366,\n                                                    columnNumber: 20\n                                                }, void 0) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_16__[\"default\"], {}, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                    lineNumber: 366,\n                                                    columnNumber: 53\n                                                }, void 0),\n                                                onClick: handleSave,\n                                                disabled: saving,\n                                                children: saving ? \"Saving...\" : \"Save\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 363,\n                                                columnNumber: 9\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                        lineNumber: 354,\n                                        columnNumber: 8\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                lineNumber: 339,\n                                columnNumber: 6\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                        lineNumber: 327,\n                        columnNumber: 5\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_17__[\"default\"], {\n                        container: true,\n                        spacing: 4,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_17__[\"default\"], {\n                                item: true,\n                                xs: 12,\n                                md: 4,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                    sx: {\n                                        textAlign: \"center\"\n                                    },\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                            sx: {\n                                                position: \"relative\",\n                                                display: \"inline-block\"\n                                            },\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_18__[\"default\"], {\n                                                    src: tempProfile.avatar || undefined,\n                                                    sx: {\n                                                        width: 120,\n                                                        height: 120,\n                                                        mb: 2\n                                                    },\n                                                    children: (_tempProfile_name = tempProfile.name) === null || _tempProfile_name === void 0 ? void 0 : (_tempProfile_name_ = _tempProfile_name[0]) === null || _tempProfile_name_ === void 0 ? void 0 : _tempProfile_name_.toUpperCase()\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                    lineNumber: 386,\n                                                    columnNumber: 9\n                                                }, this),\n                                                isEditing && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                                    htmlFor: \"avatar-upload\",\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                            accept: \"image/*\",\n                                                            id: \"avatar-upload\",\n                                                            type: \"file\",\n                                                            style: {\n                                                                display: \"none\"\n                                                            },\n                                                            onChange: handleAvatarChange\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 393,\n                                                            columnNumber: 11\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_19__[\"default\"], {\n                                                            color: \"primary\",\n                                                            \"aria-label\": \"upload picture\",\n                                                            component: \"span\",\n                                                            sx: {\n                                                                position: \"absolute\",\n                                                                bottom: 0,\n                                                                right: 0,\n                                                                backgroundColor: \"background.paper\"\n                                                            },\n                                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_20__[\"default\"], {}, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                                lineNumber: 410,\n                                                                columnNumber: 12\n                                                            }, this)\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 400,\n                                                            columnNumber: 11\n                                                        }, this)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                    lineNumber: 392,\n                                                    columnNumber: 10\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                            lineNumber: 385,\n                                            columnNumber: 8\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                            variant: \"h6\",\n                                            gutterBottom: true,\n                                            children: tempProfile.name\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                            lineNumber: 415,\n                                            columnNumber: 8\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_21__[\"default\"], {\n                                            icon: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_22__[\"default\"], {}, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 421,\n                                                columnNumber: 15\n                                            }, void 0),\n                                            label: tempProfile.email,\n                                            variant: \"outlined\",\n                                            size: \"small\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                            lineNumber: 420,\n                                            columnNumber: 8\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                    lineNumber: 384,\n                                    columnNumber: 7\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                lineNumber: 380,\n                                columnNumber: 6\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_17__[\"default\"], {\n                                item: true,\n                                xs: 12,\n                                md: 8,\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_17__[\"default\"], {\n                                        container: true,\n                                        spacing: 3,\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_17__[\"default\"], {\n                                                item: true,\n                                                xs: 12,\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_23__[\"default\"], {\n                                                    fullWidth: true,\n                                                    label: \"Display Name\",\n                                                    value: tempProfile.name,\n                                                    onChange: (e)=>setTempProfile({\n                                                            ...tempProfile,\n                                                            name: e.target.value\n                                                        }),\n                                                    disabled: !isEditing,\n                                                    InputProps: {\n                                                        startAdornment: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_24__[\"default\"], {\n                                                            sx: {\n                                                                mr: 1,\n                                                                color: \"text.secondary\"\n                                                            }\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 449,\n                                                            columnNumber: 12\n                                                        }, void 0)\n                                                    }\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                    lineNumber: 439,\n                                                    columnNumber: 9\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 436,\n                                                columnNumber: 8\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_17__[\"default\"], {\n                                                item: true,\n                                                xs: 12,\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_23__[\"default\"], {\n                                                    fullWidth: true,\n                                                    label: \"Email\",\n                                                    value: tempProfile.email,\n                                                    disabled: true,\n                                                    InputProps: {\n                                                        startAdornment: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_22__[\"default\"], {\n                                                            sx: {\n                                                                mr: 1,\n                                                                color: \"text.secondary\"\n                                                            }\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 465,\n                                                            columnNumber: 12\n                                                        }, void 0)\n                                                    }\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                    lineNumber: 458,\n                                                    columnNumber: 9\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 455,\n                                                columnNumber: 8\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_17__[\"default\"], {\n                                                item: true,\n                                                xs: 12,\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_23__[\"default\"], {\n                                                    fullWidth: true,\n                                                    label: \"Bio\",\n                                                    value: tempProfile.bio || \"\",\n                                                    onChange: (e)=>setTempProfile({\n                                                            ...tempProfile,\n                                                            bio: e.target.value\n                                                        }),\n                                                    disabled: !isEditing,\n                                                    multiline: true,\n                                                    rows: 3,\n                                                    placeholder: \"Tell us about yourself...\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                    lineNumber: 474,\n                                                    columnNumber: 9\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 471,\n                                                columnNumber: 8\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_17__[\"default\"], {\n                                                item: true,\n                                                xs: 12,\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_23__[\"default\"], {\n                                                    fullWidth: true,\n                                                    label: \"Member Since\",\n                                                    value: new Date(profile.createdAt).toLocaleDateString(),\n                                                    disabled: true,\n                                                    InputProps: {\n                                                        startAdornment: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_25__[\"default\"], {\n                                                            sx: {\n                                                                mr: 1,\n                                                                color: \"text.secondary\"\n                                                            }\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 498,\n                                                            columnNumber: 12\n                                                        }, void 0)\n                                                    }\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                    lineNumber: 491,\n                                                    columnNumber: 9\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 488,\n                                                columnNumber: 8\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                        lineNumber: 433,\n                                        columnNumber: 7\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_26__[\"default\"], {\n                                        sx: {\n                                            my: 3\n                                        }\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                        lineNumber: 505,\n                                        columnNumber: 7\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                        variant: \"h6\",\n                                        gutterBottom: true,\n                                        children: \"Task Statistics\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                        lineNumber: 507,\n                                        columnNumber: 7\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_27__[\"default\"], {\n                                        elevation: 1,\n                                        sx: {\n                                            mb: 3,\n                                            p: 2\n                                        },\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                                sx: {\n                                                    display: \"flex\",\n                                                    justifyContent: \"space-between\",\n                                                    alignItems: \"center\",\n                                                    mb: 1\n                                                },\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                                        variant: \"body2\",\n                                                        color: \"text.secondary\",\n                                                        children: \"Completion Rate\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                        lineNumber: 524,\n                                                        columnNumber: 9\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                                        variant: \"body2\",\n                                                        fontWeight: \"bold\",\n                                                        children: [\n                                                            completionRate.toFixed(1),\n                                                            \"%\"\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                        lineNumber: 529,\n                                                        columnNumber: 9\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 517,\n                                                columnNumber: 8\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_28__[\"default\"], {\n                                                variant: \"determinate\",\n                                                value: completionRate,\n                                                sx: {\n                                                    height: 8,\n                                                    borderRadius: 4\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 535,\n                                                columnNumber: 8\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                        lineNumber: 514,\n                                        columnNumber: 7\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_17__[\"default\"], {\n                                        container: true,\n                                        spacing: 2,\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_17__[\"default\"], {\n                                                item: true,\n                                                xs: 6,\n                                                sm: 3,\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n                                                    elevation: 2,\n                                                    sx: {\n                                                        p: 2,\n                                                        textAlign: \"center\",\n                                                        background: \"linear-gradient(45deg, #2196F3 30%, #21CBF3 90%)\",\n                                                        color: \"white\"\n                                                    },\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_29__[\"default\"], {\n                                                            sx: {\n                                                                fontSize: 24,\n                                                                mb: 1\n                                                            }\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 558,\n                                                            columnNumber: 10\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                                            variant: \"h5\",\n                                                            children: profile.totalTasks\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 559,\n                                                            columnNumber: 10\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                                            variant: \"caption\",\n                                                            children: \"Total\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 560,\n                                                            columnNumber: 10\n                                                        }, this)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                    lineNumber: 549,\n                                                    columnNumber: 9\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 545,\n                                                columnNumber: 8\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_17__[\"default\"], {\n                                                item: true,\n                                                xs: 6,\n                                                sm: 3,\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n                                                    elevation: 2,\n                                                    sx: {\n                                                        p: 2,\n                                                        textAlign: \"center\",\n                                                        background: \"linear-gradient(45deg, #FF9800 30%, #FFC107 90%)\",\n                                                        color: \"white\"\n                                                    },\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_30__[\"default\"], {\n                                                            sx: {\n                                                                fontSize: 24,\n                                                                mb: 1\n                                                            }\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 576,\n                                                            columnNumber: 10\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                                            variant: \"h5\",\n                                                            children: profile.pendingTasks\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 577,\n                                                            columnNumber: 10\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                                            variant: \"caption\",\n                                                            children: \"Pending\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 578,\n                                                            columnNumber: 10\n                                                        }, this)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                    lineNumber: 567,\n                                                    columnNumber: 9\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 563,\n                                                columnNumber: 8\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_17__[\"default\"], {\n                                                item: true,\n                                                xs: 6,\n                                                sm: 3,\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n                                                    elevation: 2,\n                                                    sx: {\n                                                        p: 2,\n                                                        textAlign: \"center\",\n                                                        background: \"linear-gradient(45deg, #9C27B0 30%, #E1BEE7 90%)\",\n                                                        color: \"white\"\n                                                    },\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_30__[\"default\"], {\n                                                            sx: {\n                                                                fontSize: 24,\n                                                                mb: 1\n                                                            }\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 594,\n                                                            columnNumber: 10\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                                            variant: \"h5\",\n                                                            children: profile.inProgressTasks\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 595,\n                                                            columnNumber: 10\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                                            variant: \"caption\",\n                                                            children: \"In Progress\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 598,\n                                                            columnNumber: 10\n                                                        }, this)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                    lineNumber: 585,\n                                                    columnNumber: 9\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 581,\n                                                columnNumber: 8\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_17__[\"default\"], {\n                                                item: true,\n                                                xs: 6,\n                                                sm: 3,\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n                                                    elevation: 2,\n                                                    sx: {\n                                                        p: 2,\n                                                        textAlign: \"center\",\n                                                        background: \"linear-gradient(45deg, #4CAF50 30%, #8BC34A 90%)\",\n                                                        color: \"white\"\n                                                    },\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Assignment_CalendarToday_Cancel_CheckCircle_Edit_Email_Person_PhotoCamera_Print_Save_TrendingUp_mui_icons_material__WEBPACK_IMPORTED_MODULE_31__[\"default\"], {\n                                                            sx: {\n                                                                fontSize: 24,\n                                                                mb: 1\n                                                            }\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 614,\n                                                            columnNumber: 10\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                                            variant: \"h5\",\n                                                            children: profile.completedTasks\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 615,\n                                                            columnNumber: 10\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                                            variant: \"caption\",\n                                                            children: \"Completed\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                            lineNumber: 616,\n                                                            columnNumber: 10\n                                                        }, this)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                    lineNumber: 605,\n                                                    columnNumber: 9\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                lineNumber: 601,\n                                                columnNumber: 8\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                        lineNumber: 542,\n                                        columnNumber: 7\n                                    }, this),\n                                    profile.overdueTasks > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                        sx: {\n                                            mt: 2\n                                        },\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n                                            elevation: 2,\n                                            sx: {\n                                                p: 2,\n                                                textAlign: \"center\",\n                                                background: \"linear-gradient(45deg, #F44336 30%, #FF5722 90%)\",\n                                                color: \"white\"\n                                            },\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                                    variant: \"h6\",\n                                                    gutterBottom: true,\n                                                    children: [\n                                                        \" \",\n                                                        profile.overdueTasks,\n                                                        \" Overdue Tasks\"\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                    lineNumber: 632,\n                                                    columnNumber: 10\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Alert_Avatar_Box_Button_Card_Chip_CircularProgress_Container_Divider_Grid_IconButton_LinearProgress_Paper_TextField_Typography_mui_material__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                                    variant: \"body2\",\n                                                    children: [\n                                                        \"You have \",\n                                                        profile.overdueTasks,\n                                                        \" task\",\n                                                        profile.overdueTasks > 1 ? \"s\" : \"\",\n                                                        \" that need attention.\"\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                                    lineNumber: 637,\n                                                    columnNumber: 10\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                            lineNumber: 623,\n                                            columnNumber: 9\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                        lineNumber: 622,\n                                        columnNumber: 8\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                                lineNumber: 429,\n                                columnNumber: 6\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                        lineNumber: 377,\n                        columnNumber: 5\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n                lineNumber: 324,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\app\\\\profile\\\\page.tsx\",\n        lineNumber: 313,\n        columnNumber: 3\n    }, this);\n}\n_s(Profile, \"A9cg0SwNoypJ4l3gTUyAOLMJCYc=\", false, function() {\n    return [\n        next_auth_react__WEBPACK_IMPORTED_MODULE_2__.useSession,\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter\n    ];\n});\n_c = Profile;\nvar _c;\n$RefreshReg$(_c, \"Profile\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcHJvZmlsZS9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRTRDO0FBQ0M7QUFrQnRCO0FBYU07QUFDZTtBQUVhO0FBQ1g7QUFnQi9CLFNBQVMyQztRQThVZEMsb0JBQUFBOztJQTdVVCxNQUFNLEVBQUVDLE1BQU1DLE9BQU8sRUFBRUMsTUFBTSxFQUFFLEdBQUc3QywyREFBVUE7SUFDNUMsTUFBTThDLFNBQVNSLDBEQUFTQTtJQUN4QixNQUFNLENBQUNTLFdBQVdDLGFBQWEsR0FBR2xELCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ21ELFNBQVNDLFdBQVcsR0FBR3BELCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQ3FELFFBQVFDLFVBQVUsR0FBR3RELCtDQUFRQSxDQUFDO0lBQ3JDLE1BQU0sQ0FBQ3VELE9BQU9DLFNBQVMsR0FBR3hELCtDQUFRQSxDQUFTLEVBQUU7SUFDN0MsTUFBTSxDQUFDeUQsU0FBU0MsV0FBVyxHQUFHMUQsK0NBQVFBLENBQWM7UUFDbkQyRCxJQUFJO1FBQ0pDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxLQUFLO1FBQ0xDLFFBQVE7UUFDUkMsV0FBVztRQUNYQyxZQUFZO1FBQ1pDLGdCQUFnQjtRQUNoQkMsY0FBYztRQUNkQyxpQkFBaUI7UUFDakJDLGNBQWM7SUFDZjtJQUNBLE1BQU0sQ0FBQ3pCLGFBQWEwQixlQUFlLEdBQUd0RSwrQ0FBUUEsQ0FBY3lEO0lBQzVELE1BQU0sQ0FBQ2MsU0FBU0MsV0FBVyxHQUFHeEUsK0NBQVFBLENBRzVCO0lBRVYsTUFBTXlFLG1CQUFtQjtRQUN4QixJQUFJO1lBQ0gsTUFBTUMsV0FBVyxNQUFNQyxNQUFNO1lBQzdCLElBQUlELFNBQVNFLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsV0FBVyxNQUFNSCxTQUFTSSxJQUFJO2dCQUNwQ3BCLFdBQVcsQ0FBQ3FCLE9BQVU7d0JBQ3JC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Ozs7Ozs7OzBEQUdoQyw4REFBQzlJLDJNQUFJQTtnREFDSnVKLElBQUk7Z0RBQ0pDLElBQUk7Z0RBQ0ptQyxJQUFJOzBEQUNKLDRFQUFDL0wsMk1BQUtBO29EQUNMZ0osV0FBVztvREFDWFIsSUFBSTt3REFDSFMsR0FBRzt3REFDSGEsV0FBVzt3REFDWGtDLFlBQ0M7d0RBQ0RyQixPQUFPO29EQUNSOztzRUFDQSw4REFBQzlJLGtMQUFlQTs0REFBQzJHLElBQUk7Z0VBQUV5RCxVQUFVO2dFQUFJbEQsSUFBSTs0REFBRTs7Ozs7O3NFQUMzQyw4REFBQ2pKLDJNQUFVQTs0REFBQ29KLFNBQVE7c0VBQU0vRixRQUFRUyxjQUFjOzs7Ozs7c0VBQ2hELDhEQUFDOUQsMk1BQVVBOzREQUFDb0osU0FBUTtzRUFBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0NBS2hDL0YsUUFBUVksWUFBWSxHQUFHLG1CQUN2Qiw4REFBQ2hFLDBNQUFHQTt3Q0FBQ3lJLElBQUk7NENBQUUwRCxJQUFJO3dDQUFFO2tEQUNoQiw0RUFBQ2xNLDJNQUFLQTs0Q0FDTGdKLFdBQVc7NENBQ1hSLElBQUk7Z0RBQ0hTLEdBQUc7Z0RBQ0hhLFdBQVc7Z0RBQ1hrQyxZQUNDO2dEQUNEckIsT0FBTzs0Q0FDUjs7OERBQ0EsOERBQUM3SywyTUFBVUE7b0RBQ1ZvSixTQUFRO29EQUNSOEIsWUFBWTs7d0RBQUM7d0RBQ1Q3SCxRQUFRWSxZQUFZO3dEQUFDOzs7Ozs7OzhEQUUxQiw4REFBQ2pFLDJNQUFVQTtvREFBQ29KLFNBQVE7O3dEQUFRO3dEQUNqQi9GLFFBQVFZLFlBQVk7d0RBQUM7d0RBQzlCWixRQUFRWSxZQUFZLEdBQUcsSUFBSSxNQUFNO3dEQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFVL0M7R0FsbEJ3QjFCOztRQUNXekMsdURBQVVBO1FBQzdCc0Msc0RBQVNBOzs7S0FGREciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9wcm9maWxlL3BhZ2UudHN4P2M0ZTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcblxyXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZVNlc3Npb24gfSBmcm9tIFwibmV4dC1hdXRoL3JlYWN0XCI7XHJcbmltcG9ydCB7XHJcblx0Q29udGFpbmVyLFxyXG5cdFR5cG9ncmFwaHksXHJcblx0Qm94LFxyXG5cdFBhcGVyLFxyXG5cdEF2YXRhcixcclxuXHRUZXh0RmllbGQsXHJcblx0QnV0dG9uLFxyXG5cdEdyaWQsXHJcblx0SWNvbkJ1dHRvbixcclxuXHRBbGVydCxcclxuXHREaXZpZGVyLFxyXG5cdENoaXAsXHJcblx0Q2lyY3VsYXJQcm9ncmVzcyxcclxuXHRDYXJkLFxyXG5cdENhcmRDb250ZW50LFxyXG5cdExpbmVhclByb2dyZXNzLFxyXG59IGZyb20gXCJAbXVpL21hdGVyaWFsXCI7XHJcbmltcG9ydCB7XHJcblx0RWRpdCBhcyBFZGl0SWNvbixcclxuXHRTYXZlIGFzIFNhdmVJY29uLFxyXG5cdENhbmNlbCBhcyBDYW5jZWxJY29uLFxyXG5cdFBob3RvQ2FtZXJhIGFzIFBob3RvQ2FtZXJhSWNvbixcclxuXHRFbWFpbCBhcyBFbWFpbEljb24sXHJcblx0UGVyc29uIGFzIFBlcnNvbkljb24sXHJcblx0Q2FsZW5kYXJUb2RheSBhcyBDYWxlbmRhckljb24sXHJcblx0QXNzaWdubWVudCBhcyBBc3NpZ25tZW50SWNvbixcclxuXHRDaGVja0NpcmNsZSBhcyBDaGVja0NpcmNsZUljb24sXHJcblx0VHJlbmRpbmdVcCBhcyBUcmVuZGluZ1VwSWNvbixcclxuXHRQcmludCBhcyBQcmludEljb24sXHJcbn0gZnJvbSBcIkBtdWkvaWNvbnMtbWF0ZXJpYWxcIjtcclxuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvbmF2aWdhdGlvblwiO1xyXG5pbXBvcnQgeyBUYXNrIH0gZnJvbSBcIkBwcmlzbWEvY2xpZW50XCI7XHJcbmltcG9ydCBQcmludGFibGVUYXNrcyBmcm9tIFwiQC9jb21wb25lbnRzL1ByaW50YWJsZVRhc2tzXCI7XHJcbmltcG9ydCBSZWFjdERPTVNlcnZlciBmcm9tIFwicmVhY3QtZG9tL3NlcnZlclwiO1xyXG5cclxuaW50ZXJmYWNlIFVzZXJQcm9maWxlIHtcclxuXHRpZDogc3RyaW5nO1xyXG5cdG5hbWU6IHN0cmluZztcclxuXHRlbWFpbDogc3RyaW5nO1xyXG5cdGJpbzogc3RyaW5nIHwgbnVsbDtcclxuXHRhdmF0YXI6IHN0cmluZyB8IG51bGw7XHJcblx0Y3JlYXRlZEF0OiBzdHJpbmc7XHJcblx0dG90YWxUYXNrczogbnVtYmVyO1xyXG5cdGNvbXBsZXRlZFRhc2tzOiBudW1iZXI7XHJcblx0cGVuZGluZ1Rhc2tzOiBudW1iZXI7XHJcblx0aW5Qcm9ncmVzc1Rhc2tzOiBudW1iZXI7XHJcblx0b3ZlcmR1ZVRhc2tzOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFByb2ZpbGUoKSB7XHJcblx0Y29uc3QgeyBkYXRhOiBzZXNzaW9uLCB1cGRhdGUgfSA9IHVzZVNlc3Npb24oKTtcclxuXHRjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcclxuXHRjb25zdCBbaXNFZGl0aW5nLCBzZXRJc0VkaXRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cdGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xyXG5cdGNvbnN0IFtzYXZpbmcsIHNldFNhdmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblx0Y29uc3QgW3Rhc2tzLCBzZXRUYXNrc10gPSB1c2VTdGF0ZTxUYXNrW10+KFtdKTtcclxuXHRjb25zdCBbcHJvZmlsZSwgc2V0UHJvZmlsZV0gPSB1c2VTdGF0ZTxVc2VyUHJvZmlsZT4oe1xyXG5cdFx0aWQ6IFwiXCIsXHJcblx0XHRuYW1lOiBcIlwiLFxyXG5cdFx0ZW1haWw6IFwiXCIsXHJcblx0XHRiaW86IG51bGwsXHJcblx0XHRhdmF0YXI6IG51bGwsXHJcblx0XHRjcmVhdGVkQXQ6IFwiXCIsXHJcblx0XHR0b3RhbFRhc2tzOiAwLFxyXG5cdFx0Y29tcGxldGVkVGFza3M6IDAsXHJcblx0XHRwZW5kaW5nVGFza3M6IDAsXHJcblx0XHRpblByb2dyZXNzVGFza3M6IDAsXHJcblx0XHRvdmVyZHVlVGFza3M6IDAsXHJcblx0fSk7XHJcblx0Y29uc3QgW3RlbXBQcm9maWxlLCBzZXRUZW1wUHJvZmlsZV0gPSB1c2VTdGF0ZTxVc2VyUHJvZmlsZT4ocHJvZmlsZSk7XHJcblx0Y29uc3QgW21lc3NhZ2UsIHNldE1lc3NhZ2VdID0gdXNlU3RhdGU8e1xyXG5cdFx0dHlwZTogXCJzdWNjZXNzXCIgfCBcImVycm9yXCI7XHJcblx0XHR0ZXh0OiBzdHJpbmc7XHJcblx0fSB8IG51bGw+KG51bGwpO1xyXG5cclxuXHRjb25zdCBmZXRjaFVzZXJQcm9maWxlID0gYXN5bmMgKCkgPT4ge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9hcGkvcHJvZmlsZVwiKTtcclxuXHRcdFx0aWYgKHJlc3BvbnNlLm9rKSB7XHJcblx0XHRcdFx0Y29uc3QgdXNlckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblx0XHRcdFx0c2V0UHJvZmlsZSgocHJldikgPT4gKHtcclxuXHRcdFx0XHRcdC4uLnByZXYsXHJcblx0XHRcdFx0XHQuLi51c2VyRGF0YSxcclxuXHRcdFx0XHR9KSk7XHJcblx0XHRcdFx0c2V0VGVtcFByb2ZpbGUoKHByZXYpID0+ICh7XHJcblx0XHRcdFx0XHQuLi5wcmV2LFxyXG5cdFx0XHRcdFx0Li4udXNlckRhdGEsXHJcblx0XHRcdFx0fSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnJvcikge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgdXNlciBwcm9maWxlOlwiLCBlcnJvcik7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Y29uc3QgZmV0Y2hVc2VyU3RhdHMgPSBhc3luYyAoKSA9PiB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiL2FwaS90YXNrc1wiKTtcclxuXHRcdFx0Y29uc3QgZmV0Y2hlZFRhc2tzOiBUYXNrW10gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblx0XHRcdHNldFRhc2tzKGZldGNoZWRUYXNrcyk7XHJcblxyXG5cdFx0XHRjb25zdCBzdGF0cyA9IHtcclxuXHRcdFx0XHR0b3RhbDogZmV0Y2hlZFRhc2tzLmxlbmd0aCxcclxuXHRcdFx0XHRjb21wbGV0ZWQ6IGZldGNoZWRUYXNrcy5maWx0ZXIoKHQpID0+IHQuc3RhdHVzID09PSBcIkNPTVBMRVRFRFwiKS5sZW5ndGgsXHJcblx0XHRcdFx0cGVuZGluZzogZmV0Y2hlZFRhc2tzLmZpbHRlcigodCkgPT4gdC5zdGF0dXMgPT09IFwiUEVORElOR1wiKS5sZW5ndGgsXHJcblx0XHRcdFx0aW5Qcm9ncmVzczogZmV0Y2hlZFRhc2tzLmZpbHRlcigodCkgPT4gdC5zdGF0dXMgPT09IFwiSU5fUFJPR1JFU1NcIilcclxuXHRcdFx0XHRcdC5sZW5ndGgsXHJcblx0XHRcdFx0b3ZlcmR1ZTogZmV0Y2hlZFRhc2tzLmZpbHRlcigodCkgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgZHVlRGF0ZSA9IG5ldyBEYXRlKHQuZHVlRGF0ZSk7XHJcblx0XHRcdFx0XHRjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG5cdFx0XHRcdFx0Y29uc3QgZGF5c1VudGlsRHVlID0gTWF0aC5jZWlsKFxyXG5cdFx0XHRcdFx0XHQoZHVlRGF0ZS5nZXRUaW1lKCkgLSBub3cuZ2V0VGltZSgpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdHJldHVybiBkYXlzVW50aWxEdWUgPCAwICYmIHQuc3RhdHVzICE9PSBcIkNPTVBMRVRFRFwiO1xyXG5cdFx0XHRcdH0pLmxlbmd0aCxcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHNldFByb2ZpbGUoKHByZXYpID0+ICh7XHJcblx0XHRcdFx0Li4ucHJldixcclxuXHRcdFx0XHR0b3RhbFRhc2tzOiBzdGF0cy50b3RhbCxcclxuXHRcdFx0XHRjb21wbGV0ZWRUYXNrczogc3RhdHMuY29tcGxldGVkLFxyXG5cdFx0XHRcdHBlbmRpbmdUYXNrczogc3RhdHMucGVuZGluZyxcclxuXHRcdFx0XHRpblByb2dyZXNzVGFza3M6IHN0YXRzLmluUHJvZ3Jlc3MsXHJcblx0XHRcdFx0b3ZlcmR1ZVRhc2tzOiBzdGF0cy5vdmVyZHVlLFxyXG5cdFx0XHR9KSk7XHJcblx0XHR9IGNhdGNoIChlcnJvcikge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgdXNlciBzdGF0czpcIiwgZXJyb3IpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHVzZUVmZmVjdCgoKSA9PiB7XHJcblx0XHRpZiAoIXNlc3Npb24pIHtcclxuXHRcdFx0cm91dGVyLnB1c2goXCIvbG9naW5cIik7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBsb2FkUHJvZmlsZURhdGEgPSBhc3luYyAoKSA9PiB7XHJcblx0XHRcdGF3YWl0IGZldGNoVXNlclByb2ZpbGUoKTtcclxuXHRcdFx0YXdhaXQgZmV0Y2hVc2VyU3RhdHMoKTtcclxuXHRcdFx0c2V0TG9hZGluZyhmYWxzZSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGxvYWRQcm9maWxlRGF0YSgpO1xyXG5cdH0sIFtzZXNzaW9uLCByb3V0ZXJdKTtcclxuXHJcblx0Y29uc3QgaGFuZGxlRWRpdCA9ICgpID0+IHtcclxuXHRcdHNldFRlbXBQcm9maWxlKHByb2ZpbGUpO1xyXG5cdFx0c2V0SXNFZGl0aW5nKHRydWUpO1xyXG5cdH07XHJcblxyXG5cdGNvbnN0IGhhbmRsZUNhbmNlbCA9ICgpID0+IHtcclxuXHRcdHNldFRlbXBQcm9maWxlKHByb2ZpbGUpO1xyXG5cdFx0c2V0SXNFZGl0aW5nKGZhbHNlKTtcclxuXHR9O1xyXG5cclxuXHRjb25zdCBoYW5kbGVTYXZlID0gYXN5bmMgKCkgPT4ge1xyXG5cdFx0c2V0U2F2aW5nKHRydWUpO1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9hcGkvcHJvZmlsZVwiLCB7XHJcblx0XHRcdFx0bWV0aG9kOiBcIlBVVFwiLFxyXG5cdFx0XHRcdGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcclxuXHRcdFx0XHRib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcblx0XHRcdFx0XHRuYW1lOiB0ZW1wUHJvZmlsZS5uYW1lLFxyXG5cdFx0XHRcdFx0YmlvOiB0ZW1wUHJvZmlsZS5iaW8sXHJcblx0XHRcdFx0XHRhdmF0YXI6IHRlbXBQcm9maWxlLmF2YXRhcixcclxuXHRcdFx0XHR9KSxcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRpZiAocmVzcG9uc2Uub2spIHtcclxuXHRcdFx0XHRjb25zdCB1cGRhdGVkUHJvZmlsZSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHRcdFx0XHRzZXRQcm9maWxlKChwcmV2KSA9PiAoe1xyXG5cdFx0XHRcdFx0Li4ucHJldixcclxuXHRcdFx0XHRcdC4uLnVwZGF0ZWRQcm9maWxlLFxyXG5cdFx0XHRcdH0pKTtcclxuXHRcdFx0XHRzZXRJc0VkaXRpbmcoZmFsc2UpO1xyXG5cdFx0XHRcdHNldE1lc3NhZ2UoeyB0eXBlOiBcInN1Y2Nlc3NcIiwgdGV4dDogXCJQcm9maWxlIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5IVwiIH0pO1xyXG5cclxuXHRcdFx0XHQvLyBVcGRhdGUgc2Vzc2lvbiB3aXRoIG5ldyBuYW1lXHJcblx0XHRcdFx0YXdhaXQgdXBkYXRlKHtcclxuXHRcdFx0XHRcdC4uLnNlc3Npb24sXHJcblx0XHRcdFx0XHR1c2VyOiB7XHJcblx0XHRcdFx0XHRcdC4uLnNlc3Npb24/LnVzZXIsXHJcblx0XHRcdFx0XHRcdG5hbWU6IHRlbXBQcm9maWxlLm5hbWUsXHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHQvLyBDbGVhciBtZXNzYWdlIGFmdGVyIDMgc2Vjb25kc1xyXG5cdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4gc2V0TWVzc2FnZShudWxsKSwgMzAwMCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblx0XHRcdFx0c2V0TWVzc2FnZSh7XHJcblx0XHRcdFx0XHR0eXBlOiBcImVycm9yXCIsXHJcblx0XHRcdFx0XHR0ZXh0OiBlcnJvci5lcnJvciB8fCBcIkZhaWxlZCB0byB1cGRhdGUgcHJvZmlsZS4gUGxlYXNlIHRyeSBhZ2Fpbi5cIixcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcclxuXHRcdFx0c2V0TWVzc2FnZSh7XHJcblx0XHRcdFx0dHlwZTogXCJlcnJvclwiLFxyXG5cdFx0XHRcdHRleHQ6IFwiRmFpbGVkIHRvIHVwZGF0ZSBwcm9maWxlLiBQbGVhc2UgdHJ5IGFnYWluLlwiLFxyXG5cdFx0XHR9KTtcclxuXHRcdH0gZmluYWxseSB7XHJcblx0XHRcdHNldFNhdmluZyhmYWxzZSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Y29uc3QgaGFuZGxlQXZhdGFyQ2hhbmdlID0gKGV2ZW50OiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xyXG5cdFx0Y29uc3QgZmlsZSA9IGV2ZW50LnRhcmdldC5maWxlcz8uWzBdO1xyXG5cdFx0aWYgKGZpbGUpIHtcclxuXHRcdFx0Ly8gVmFsaWRhdGUgZmlsZSBzaXplIChtYXggNU1CKVxyXG5cdFx0XHRpZiAoZmlsZS5zaXplID4gNSAqIDEwMjQgKiAxMDI0KSB7XHJcblx0XHRcdFx0c2V0TWVzc2FnZSh7XHJcblx0XHRcdFx0XHR0eXBlOiBcImVycm9yXCIsXHJcblx0XHRcdFx0XHR0ZXh0OiBcIkltYWdlIHNpemUgbXVzdCBiZSBsZXNzIHRoYW4gNU1CLlwiLFxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVmFsaWRhdGUgZmlsZSB0eXBlXHJcblx0XHRcdGlmICghZmlsZS50eXBlLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpIHtcclxuXHRcdFx0XHRzZXRNZXNzYWdlKHtcclxuXHRcdFx0XHRcdHR5cGU6IFwiZXJyb3JcIixcclxuXHRcdFx0XHRcdHRleHQ6IFwiUGxlYXNlIHNlbGVjdCBhIHZhbGlkIGltYWdlIGZpbGUuXCIsXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG5cdFx0XHRyZWFkZXIub25sb2FkZW5kID0gKCkgPT4ge1xyXG5cdFx0XHRcdHNldFRlbXBQcm9maWxlKHsgLi4udGVtcFByb2ZpbGUsIGF2YXRhcjogcmVhZGVyLnJlc3VsdCBhcyBzdHJpbmcgfSk7XHJcblx0XHRcdH07XHJcblx0XHRcdHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdGNvbnN0IGhhbmRsZVByaW50ID0gKCkgPT4ge1xyXG5cdFx0Y29uc3QgcHJpbnRXaW5kb3cgPSB3aW5kb3cub3BlbihcIlwiLCBcIl9ibGFua1wiKTtcclxuXHRcdGlmICghcHJpbnRXaW5kb3cpIHJldHVybjtcclxuXHJcblx0XHRjb25zdCBwcmludGFibGVDb21wb25lbnQgPSAoXHJcblx0XHRcdDxQcmludGFibGVUYXNrc1xyXG5cdFx0XHRcdHRhc2tzPXt0YXNrc31cclxuXHRcdFx0XHR1c2VyUHJvZmlsZT17eyBuYW1lOiBwcm9maWxlLm5hbWUsIGVtYWlsOiBwcm9maWxlLmVtYWlsIH19XHJcblx0XHRcdFx0cHJpbnREYXRlPXtuZXcgRGF0ZSgpfVxyXG5cdFx0XHQvPlxyXG5cdFx0KTtcclxuXHJcblx0XHRjb25zdCBwcmludENvbnRlbnQgPSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZyhwcmludGFibGVDb21wb25lbnQpO1xyXG5cclxuXHRcdHByaW50V2luZG93LmRvY3VtZW50LndyaXRlKGBcclxuXHRcdFx0PCFET0NUWVBFIGh0bWw+XHJcblx0XHRcdDxodG1sPlxyXG5cdFx0XHQ8aGVhZD5cclxuXHRcdFx0XHQ8dGl0bGU+TXlEbyAtIFRhc2sgUmVwb3J0PC90aXRsZT5cclxuXHRcdFx0XHQ8c3R5bGU+XHJcblx0XHRcdFx0XHRib2R5IHsgXHJcblx0XHRcdFx0XHRcdGZvbnQtZmFtaWx5OiBBcmlhbCwgc2Fucy1zZXJpZjsgXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRAbWVkaWEgcHJpbnQge1xyXG5cdFx0XHRcdFx0XHRib2R5IHsgbWFyZ2luOiAyMHB4OyB9XHJcblx0XHRcdFx0XHRcdEBwYWdlIHsgXHJcblx0XHRcdFx0XHRcdFx0c2l6ZTogYXV0bztcclxuXHRcdFx0XHRcdFx0XHRtYXJnaW46IDIwbW07XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHQ8L3N0eWxlPlxyXG5cdFx0XHQ8L2hlYWQ+XHJcblx0XHRcdDxib2R5PlxyXG5cdFx0XHRcdCR7cHJpbnRDb250ZW50fVxyXG5cdFx0XHRcdDxzY3JpcHQ+XHJcblx0XHRcdFx0XHR3aW5kb3cub25sb2FkID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdFx0d2luZG93LnByaW50KCk7XHJcblx0XHRcdFx0XHRcdFx0d2luZG93LmNsb3NlKCk7XHJcblx0XHRcdFx0XHRcdH0sIDUwMCk7IC8vIERlbGF5IHRvIGVuc3VyZSBjb250ZW50IGxvYWRzXHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdDwvc2NyaXB0PlxyXG5cdFx0XHQ8L2JvZHk+XHJcblx0XHRcdDwvaHRtbD5cclxuXHRcdGApO1xyXG5cdFx0cHJpbnRXaW5kb3cuZG9jdW1lbnQuY2xvc2UoKTtcclxuXHR9O1xyXG5cclxuXHRjb25zdCBjb21wbGV0aW9uUmF0ZSA9XHJcblx0XHRwcm9maWxlLnRvdGFsVGFza3MgPiAwXHJcblx0XHRcdD8gKHByb2ZpbGUuY29tcGxldGVkVGFza3MgLyBwcm9maWxlLnRvdGFsVGFza3MpICogMTAwXHJcblx0XHRcdDogMDtcclxuXHJcblx0aWYgKCFzZXNzaW9uKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdGlmIChsb2FkaW5nKSB7XHJcblx0XHRyZXR1cm4gKFxyXG5cdFx0XHQ8Q29udGFpbmVyXHJcblx0XHRcdFx0bWF4V2lkdGg9XCJtZFwiXHJcblx0XHRcdFx0c3g9e3sgcHk6IDQgfX0+XHJcblx0XHRcdFx0PEJveFxyXG5cdFx0XHRcdFx0ZGlzcGxheT1cImZsZXhcIlxyXG5cdFx0XHRcdFx0anVzdGlmeUNvbnRlbnQ9XCJjZW50ZXJcIlxyXG5cdFx0XHRcdFx0YWxpZ25JdGVtcz1cImNlbnRlclwiXHJcblx0XHRcdFx0XHRtaW5IZWlnaHQ9XCI0MDBweFwiPlxyXG5cdFx0XHRcdFx0PENpcmN1bGFyUHJvZ3Jlc3MgLz5cclxuXHRcdFx0XHQ8L0JveD5cclxuXHRcdFx0PC9Db250YWluZXI+XHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIChcclxuXHRcdDxDb250YWluZXJcclxuXHRcdFx0bWF4V2lkdGg9XCJtZFwiXHJcblx0XHRcdHN4PXt7IHB5OiA0IH19PlxyXG5cdFx0XHR7bWVzc2FnZSAmJiAoXHJcblx0XHRcdFx0PEFsZXJ0XHJcblx0XHRcdFx0XHRzZXZlcml0eT17bWVzc2FnZS50eXBlfVxyXG5cdFx0XHRcdFx0c3g9e3sgbWI6IDMgfX0+XHJcblx0XHRcdFx0XHR7bWVzc2FnZS50ZXh0fVxyXG5cdFx0XHRcdDwvQWxlcnQ+XHJcblx0XHRcdCl9XHJcblxyXG5cdFx0XHQ8UGFwZXJcclxuXHRcdFx0XHRlbGV2YXRpb249ezN9XHJcblx0XHRcdFx0c3g9e3sgcDogNCB9fT5cclxuXHRcdFx0XHQ8Qm94XHJcblx0XHRcdFx0XHRzeD17e1xyXG5cdFx0XHRcdFx0XHRkaXNwbGF5OiBcImZsZXhcIixcclxuXHRcdFx0XHRcdFx0anVzdGlmeUNvbnRlbnQ6IFwic3BhY2UtYmV0d2VlblwiLFxyXG5cdFx0XHRcdFx0XHRhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxyXG5cdFx0XHRcdFx0XHRtYjogMyxcclxuXHRcdFx0XHRcdH19PlxyXG5cdFx0XHRcdFx0PFR5cG9ncmFwaHlcclxuXHRcdFx0XHRcdFx0dmFyaWFudD1cImg0XCJcclxuXHRcdFx0XHRcdFx0Y29tcG9uZW50PVwiaDFcIj5cclxuXHRcdFx0XHRcdFx0UHJvZmlsZVxyXG5cdFx0XHRcdFx0PC9UeXBvZ3JhcGh5PlxyXG5cdFx0XHRcdFx0PEJveCBzeD17eyBkaXNwbGF5OiBcImZsZXhcIiwgZ2FwOiAxIH19PlxyXG5cdFx0XHRcdFx0XHQ8QnV0dG9uXHJcblx0XHRcdFx0XHRcdFx0dmFyaWFudD1cIm91dGxpbmVkXCJcclxuXHRcdFx0XHRcdFx0XHRzdGFydEljb249ezxQcmludEljb24gLz59XHJcblx0XHRcdFx0XHRcdFx0b25DbGljaz17aGFuZGxlUHJpbnR9PlxyXG5cdFx0XHRcdFx0XHRcdFByaW50IFByb2ZpbGVcclxuXHRcdFx0XHRcdFx0PC9CdXR0b24+XHJcblx0XHRcdFx0XHRcdHshaXNFZGl0aW5nID8gKFxyXG5cdFx0XHRcdFx0XHRcdDxCdXR0b25cclxuXHRcdFx0XHRcdFx0XHRcdHZhcmlhbnQ9XCJvdXRsaW5lZFwiXHJcblx0XHRcdFx0XHRcdFx0XHRzdGFydEljb249ezxFZGl0SWNvbiAvPn1cclxuXHRcdFx0XHRcdFx0XHRcdG9uQ2xpY2s9e2hhbmRsZUVkaXR9PlxyXG5cdFx0XHRcdFx0XHRcdFx0RWRpdCBQcm9maWxlXHJcblx0XHRcdFx0XHRcdFx0PC9CdXR0b24+XHJcblx0XHRcdFx0XHRcdCkgOiAoXHJcblx0XHRcdFx0XHRcdFx0PEJveD5cclxuXHRcdFx0XHRcdFx0XHRcdDxCdXR0b25cclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyaWFudD1cIm91dGxpbmVkXCJcclxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhcnRJY29uPXs8Q2FuY2VsSWNvbiAvPn1cclxuXHRcdFx0XHRcdFx0XHRcdFx0b25DbGljaz17aGFuZGxlQ2FuY2VsfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRzeD17eyBtcjogMSB9fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRkaXNhYmxlZD17c2F2aW5nfT5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Q2FuY2VsXHJcblx0XHRcdFx0XHRcdFx0XHQ8L0J1dHRvbj5cclxuXHRcdFx0XHRcdFx0XHRcdDxCdXR0b25cclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyaWFudD1cImNvbnRhaW5lZFwiXHJcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0SWNvbj17XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0c2F2aW5nID8gPENpcmN1bGFyUHJvZ3Jlc3Mgc2l6ZT17MTZ9IC8+IDogPFNhdmVJY29uIC8+XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0b25DbGljaz17aGFuZGxlU2F2ZX1cclxuXHRcdFx0XHRcdFx0XHRcdFx0ZGlzYWJsZWQ9e3NhdmluZ30+XHJcblx0XHRcdFx0XHRcdFx0XHRcdHtzYXZpbmcgPyBcIlNhdmluZy4uLlwiIDogXCJTYXZlXCJ9XHJcblx0XHRcdFx0XHRcdFx0XHQ8L0J1dHRvbj5cclxuXHRcdFx0XHRcdFx0XHQ8L0JveD5cclxuXHRcdFx0XHRcdFx0KX1cclxuXHRcdFx0XHRcdDwvQm94PlxyXG5cdFx0XHRcdDwvQm94PlxyXG5cclxuXHRcdFx0XHQ8R3JpZFxyXG5cdFx0XHRcdFx0Y29udGFpbmVyXHJcblx0XHRcdFx0XHRzcGFjaW5nPXs0fT5cclxuXHRcdFx0XHRcdDxHcmlkXHJcblx0XHRcdFx0XHRcdGl0ZW1cclxuXHRcdFx0XHRcdFx0eHM9ezEyfVxyXG5cdFx0XHRcdFx0XHRtZD17NH0+XHJcblx0XHRcdFx0XHRcdDxCb3ggc3g9e3sgdGV4dEFsaWduOiBcImNlbnRlclwiIH19PlxyXG5cdFx0XHRcdFx0XHRcdDxCb3ggc3g9e3sgcG9zaXRpb246IFwicmVsYXRpdmVcIiwgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIiB9fT5cclxuXHRcdFx0XHRcdFx0XHRcdDxBdmF0YXJcclxuXHRcdFx0XHRcdFx0XHRcdFx0c3JjPXt0ZW1wUHJvZmlsZS5hdmF0YXIgfHwgdW5kZWZpbmVkfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRzeD17eyB3aWR0aDogMTIwLCBoZWlnaHQ6IDEyMCwgbWI6IDIgfX0+XHJcblx0XHRcdFx0XHRcdFx0XHRcdHt0ZW1wUHJvZmlsZS5uYW1lPy5bMF0/LnRvVXBwZXJDYXNlKCl9XHJcblx0XHRcdFx0XHRcdFx0XHQ8L0F2YXRhcj5cclxuXHRcdFx0XHRcdFx0XHRcdHtpc0VkaXRpbmcgJiYgKFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQ8bGFiZWwgaHRtbEZvcj1cImF2YXRhci11cGxvYWRcIj5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8aW5wdXRcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFjY2VwdD1cImltYWdlLypcIlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ9XCJhdmF0YXItdXBsb2FkXCJcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU9XCJmaWxlXCJcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHN0eWxlPXt7IGRpc3BsYXk6IFwibm9uZVwiIH19XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbkNoYW5nZT17aGFuZGxlQXZhdGFyQ2hhbmdlfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8+XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0PEljb25CdXR0b25cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbG9yPVwicHJpbWFyeVwiXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmlhLWxhYmVsPVwidXBsb2FkIHBpY3R1cmVcIlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29tcG9uZW50PVwic3BhblwiXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzeD17e1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib3R0b206IDAsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJpZ2h0OiAwLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IFwiYmFja2dyb3VuZC5wYXBlclwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fX0+XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8UGhvdG9DYW1lcmFJY29uIC8+XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0PC9JY29uQnV0dG9uPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQ8L2xhYmVsPlxyXG5cdFx0XHRcdFx0XHRcdFx0KX1cclxuXHRcdFx0XHRcdFx0XHQ8L0JveD5cclxuXHRcdFx0XHRcdFx0XHQ8VHlwb2dyYXBoeVxyXG5cdFx0XHRcdFx0XHRcdFx0dmFyaWFudD1cImg2XCJcclxuXHRcdFx0XHRcdFx0XHRcdGd1dHRlckJvdHRvbT5cclxuXHRcdFx0XHRcdFx0XHRcdHt0ZW1wUHJvZmlsZS5uYW1lfVxyXG5cdFx0XHRcdFx0XHRcdDwvVHlwb2dyYXBoeT5cclxuXHRcdFx0XHRcdFx0XHQ8Q2hpcFxyXG5cdFx0XHRcdFx0XHRcdFx0aWNvbj17PEVtYWlsSWNvbiAvPn1cclxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXt0ZW1wUHJvZmlsZS5lbWFpbH1cclxuXHRcdFx0XHRcdFx0XHRcdHZhcmlhbnQ9XCJvdXRsaW5lZFwiXHJcblx0XHRcdFx0XHRcdFx0XHRzaXplPVwic21hbGxcIlxyXG5cdFx0XHRcdFx0XHRcdC8+XHJcblx0XHRcdFx0XHRcdDwvQm94PlxyXG5cdFx0XHRcdFx0PC9HcmlkPlxyXG5cclxuXHRcdFx0XHRcdDxHcmlkXHJcblx0XHRcdFx0XHRcdGl0ZW1cclxuXHRcdFx0XHRcdFx0eHM9ezEyfVxyXG5cdFx0XHRcdFx0XHRtZD17OH0+XHJcblx0XHRcdFx0XHRcdDxHcmlkXHJcblx0XHRcdFx0XHRcdFx0Y29udGFpbmVyXHJcblx0XHRcdFx0XHRcdFx0c3BhY2luZz17M30+XHJcblx0XHRcdFx0XHRcdFx0PEdyaWRcclxuXHRcdFx0XHRcdFx0XHRcdGl0ZW1cclxuXHRcdFx0XHRcdFx0XHRcdHhzPXsxMn0+XHJcblx0XHRcdFx0XHRcdFx0XHQ8VGV4dEZpZWxkXHJcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bGxXaWR0aFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD1cIkRpc3BsYXkgTmFtZVwiXHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlPXt0ZW1wUHJvZmlsZS5uYW1lfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRvbkNoYW5nZT17KGUpID0+XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0c2V0VGVtcFByb2ZpbGUoeyAuLi50ZW1wUHJvZmlsZSwgbmFtZTogZS50YXJnZXQudmFsdWUgfSlcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRkaXNhYmxlZD17IWlzRWRpdGluZ31cclxuXHRcdFx0XHRcdFx0XHRcdFx0SW5wdXRQcm9wcz17e1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0QWRvcm5tZW50OiAoXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8UGVyc29uSWNvbiBzeD17eyBtcjogMSwgY29sb3I6IFwidGV4dC5zZWNvbmRhcnlcIiB9fSAvPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCksXHJcblx0XHRcdFx0XHRcdFx0XHRcdH19XHJcblx0XHRcdFx0XHRcdFx0XHQvPlxyXG5cdFx0XHRcdFx0XHRcdDwvR3JpZD5cclxuXHJcblx0XHRcdFx0XHRcdFx0PEdyaWRcclxuXHRcdFx0XHRcdFx0XHRcdGl0ZW1cclxuXHRcdFx0XHRcdFx0XHRcdHhzPXsxMn0+XHJcblx0XHRcdFx0XHRcdFx0XHQ8VGV4dEZpZWxkXHJcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bGxXaWR0aFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD1cIkVtYWlsXCJcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWU9e3RlbXBQcm9maWxlLmVtYWlsfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRkaXNhYmxlZFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRJbnB1dFByb3BzPXt7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhcnRBZG9ybm1lbnQ6IChcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxFbWFpbEljb24gc3g9e3sgbXI6IDEsIGNvbG9yOiBcInRleHQuc2Vjb25kYXJ5XCIgfX0gLz5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9fVxyXG5cdFx0XHRcdFx0XHRcdFx0Lz5cclxuXHRcdFx0XHRcdFx0XHQ8L0dyaWQ+XHJcblxyXG5cdFx0XHRcdFx0XHRcdDxHcmlkXHJcblx0XHRcdFx0XHRcdFx0XHRpdGVtXHJcblx0XHRcdFx0XHRcdFx0XHR4cz17MTJ9PlxyXG5cdFx0XHRcdFx0XHRcdFx0PFRleHRGaWVsZFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRmdWxsV2lkdGhcclxuXHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9XCJCaW9cIlxyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZT17dGVtcFByb2ZpbGUuYmlvIHx8IFwiXCJ9XHJcblx0XHRcdFx0XHRcdFx0XHRcdG9uQ2hhbmdlPXsoZSkgPT5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzZXRUZW1wUHJvZmlsZSh7IC4uLnRlbXBQcm9maWxlLCBiaW86IGUudGFyZ2V0LnZhbHVlIH0pXHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0ZGlzYWJsZWQ9eyFpc0VkaXRpbmd9XHJcblx0XHRcdFx0XHRcdFx0XHRcdG11bHRpbGluZVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRyb3dzPXszfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj1cIlRlbGwgdXMgYWJvdXQgeW91cnNlbGYuLi5cIlxyXG5cdFx0XHRcdFx0XHRcdFx0Lz5cclxuXHRcdFx0XHRcdFx0XHQ8L0dyaWQ+XHJcblxyXG5cdFx0XHRcdFx0XHRcdDxHcmlkXHJcblx0XHRcdFx0XHRcdFx0XHRpdGVtXHJcblx0XHRcdFx0XHRcdFx0XHR4cz17MTJ9PlxyXG5cdFx0XHRcdFx0XHRcdFx0PFRleHRGaWVsZFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRmdWxsV2lkdGhcclxuXHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9XCJNZW1iZXIgU2luY2VcIlxyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZT17bmV3IERhdGUocHJvZmlsZS5jcmVhdGVkQXQpLnRvTG9jYWxlRGF0ZVN0cmluZygpfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRkaXNhYmxlZFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRJbnB1dFByb3BzPXt7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhcnRBZG9ybm1lbnQ6IChcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxDYWxlbmRhckljb24gc3g9e3sgbXI6IDEsIGNvbG9yOiBcInRleHQuc2Vjb25kYXJ5XCIgfX0gLz5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9fVxyXG5cdFx0XHRcdFx0XHRcdFx0Lz5cclxuXHRcdFx0XHRcdFx0XHQ8L0dyaWQ+XHJcblx0XHRcdFx0XHRcdDwvR3JpZD5cclxuXHJcblx0XHRcdFx0XHRcdDxEaXZpZGVyIHN4PXt7IG15OiAzIH19IC8+XHJcblxyXG5cdFx0XHRcdFx0XHQ8VHlwb2dyYXBoeVxyXG5cdFx0XHRcdFx0XHRcdHZhcmlhbnQ9XCJoNlwiXHJcblx0XHRcdFx0XHRcdFx0Z3V0dGVyQm90dG9tPlxyXG5cdFx0XHRcdFx0XHRcdFRhc2sgU3RhdGlzdGljc1xyXG5cdFx0XHRcdFx0XHQ8L1R5cG9ncmFwaHk+XHJcblxyXG5cdFx0XHRcdFx0XHR7LyogUHJvZ3Jlc3MgT3ZlcnZpZXcgKi99XHJcblx0XHRcdFx0XHRcdDxDYXJkXHJcblx0XHRcdFx0XHRcdFx0ZWxldmF0aW9uPXsxfVxyXG5cdFx0XHRcdFx0XHRcdHN4PXt7IG1iOiAzLCBwOiAyIH19PlxyXG5cdFx0XHRcdFx0XHRcdDxCb3hcclxuXHRcdFx0XHRcdFx0XHRcdHN4PXt7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGRpc3BsYXk6IFwiZmxleFwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRqdXN0aWZ5Q29udGVudDogXCJzcGFjZS1iZXR3ZWVuXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdG1iOiAxLFxyXG5cdFx0XHRcdFx0XHRcdFx0fX0+XHJcblx0XHRcdFx0XHRcdFx0XHQ8VHlwb2dyYXBoeVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXJpYW50PVwiYm9keTJcIlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRjb2xvcj1cInRleHQuc2Vjb25kYXJ5XCI+XHJcblx0XHRcdFx0XHRcdFx0XHRcdENvbXBsZXRpb24gUmF0ZVxyXG5cdFx0XHRcdFx0XHRcdFx0PC9UeXBvZ3JhcGh5PlxyXG5cdFx0XHRcdFx0XHRcdFx0PFR5cG9ncmFwaHlcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyaWFudD1cImJvZHkyXCJcclxuXHRcdFx0XHRcdFx0XHRcdFx0Zm9udFdlaWdodD1cImJvbGRcIj5cclxuXHRcdFx0XHRcdFx0XHRcdFx0e2NvbXBsZXRpb25SYXRlLnRvRml4ZWQoMSl9JVxyXG5cdFx0XHRcdFx0XHRcdFx0PC9UeXBvZ3JhcGh5PlxyXG5cdFx0XHRcdFx0XHRcdDwvQm94PlxyXG5cdFx0XHRcdFx0XHRcdDxMaW5lYXJQcm9ncmVzc1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyaWFudD1cImRldGVybWluYXRlXCJcclxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlPXtjb21wbGV0aW9uUmF0ZX1cclxuXHRcdFx0XHRcdFx0XHRcdHN4PXt7IGhlaWdodDogOCwgYm9yZGVyUmFkaXVzOiA0IH19XHJcblx0XHRcdFx0XHRcdFx0Lz5cclxuXHRcdFx0XHRcdFx0PC9DYXJkPlxyXG5cclxuXHRcdFx0XHRcdFx0PEdyaWRcclxuXHRcdFx0XHRcdFx0XHRjb250YWluZXJcclxuXHRcdFx0XHRcdFx0XHRzcGFjaW5nPXsyfT5cclxuXHRcdFx0XHRcdFx0XHQ8R3JpZFxyXG5cdFx0XHRcdFx0XHRcdFx0aXRlbVxyXG5cdFx0XHRcdFx0XHRcdFx0eHM9ezZ9XHJcblx0XHRcdFx0XHRcdFx0XHRzbT17M30+XHJcblx0XHRcdFx0XHRcdFx0XHQ8UGFwZXJcclxuXHRcdFx0XHRcdFx0XHRcdFx0ZWxldmF0aW9uPXsyfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRzeD17e1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHA6IDIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dEFsaWduOiBcImNlbnRlclwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJhY2tncm91bmQ6XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImxpbmVhci1ncmFkaWVudCg0NWRlZywgIzIxOTZGMyAzMCUsICMyMUNCRjMgOTAlKVwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbG9yOiBcIndoaXRlXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdH19PlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQ8QXNzaWdubWVudEljb24gc3g9e3sgZm9udFNpemU6IDI0LCBtYjogMSB9fSAvPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQ8VHlwb2dyYXBoeSB2YXJpYW50PVwiaDVcIj57cHJvZmlsZS50b3RhbFRhc2tzfTwvVHlwb2dyYXBoeT5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PFR5cG9ncmFwaHkgdmFyaWFudD1cImNhcHRpb25cIj5Ub3RhbDwvVHlwb2dyYXBoeT5cclxuXHRcdFx0XHRcdFx0XHRcdDwvUGFwZXI+XHJcblx0XHRcdFx0XHRcdFx0PC9HcmlkPlxyXG5cdFx0XHRcdFx0XHRcdDxHcmlkXHJcblx0XHRcdFx0XHRcdFx0XHRpdGVtXHJcblx0XHRcdFx0XHRcdFx0XHR4cz17Nn1cclxuXHRcdFx0XHRcdFx0XHRcdHNtPXszfT5cclxuXHRcdFx0XHRcdFx0XHRcdDxQYXBlclxyXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGV2YXRpb249ezJ9XHJcblx0XHRcdFx0XHRcdFx0XHRcdHN4PXt7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cDogMixcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZXh0QWxpZ246IFwiY2VudGVyXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YmFja2dyb3VuZDpcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibGluZWFyLWdyYWRpZW50KDQ1ZGVnLCAjRkY5ODAwIDMwJSwgI0ZGQzEwNyA5MCUpXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29sb3I6IFwid2hpdGVcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0fX0+XHJcblx0XHRcdFx0XHRcdFx0XHRcdDxUcmVuZGluZ1VwSWNvbiBzeD17eyBmb250U2l6ZTogMjQsIG1iOiAxIH19IC8+XHJcblx0XHRcdFx0XHRcdFx0XHRcdDxUeXBvZ3JhcGh5IHZhcmlhbnQ9XCJoNVwiPntwcm9maWxlLnBlbmRpbmdUYXNrc308L1R5cG9ncmFwaHk+XHJcblx0XHRcdFx0XHRcdFx0XHRcdDxUeXBvZ3JhcGh5IHZhcmlhbnQ9XCJjYXB0aW9uXCI+UGVuZGluZzwvVHlwb2dyYXBoeT5cclxuXHRcdFx0XHRcdFx0XHRcdDwvUGFwZXI+XHJcblx0XHRcdFx0XHRcdFx0PC9HcmlkPlxyXG5cdFx0XHRcdFx0XHRcdDxHcmlkXHJcblx0XHRcdFx0XHRcdFx0XHRpdGVtXHJcblx0XHRcdFx0XHRcdFx0XHR4cz17Nn1cclxuXHRcdFx0XHRcdFx0XHRcdHNtPXszfT5cclxuXHRcdFx0XHRcdFx0XHRcdDxQYXBlclxyXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGV2YXRpb249ezJ9XHJcblx0XHRcdFx0XHRcdFx0XHRcdHN4PXt7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cDogMixcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZXh0QWxpZ246IFwiY2VudGVyXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YmFja2dyb3VuZDpcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibGluZWFyLWdyYWRpZW50KDQ1ZGVnLCAjOUMyN0IwIDMwJSwgI0UxQkVFNyA5MCUpXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29sb3I6IFwid2hpdGVcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0fX0+XHJcblx0XHRcdFx0XHRcdFx0XHRcdDxUcmVuZGluZ1VwSWNvbiBzeD17eyBmb250U2l6ZTogMjQsIG1iOiAxIH19IC8+XHJcblx0XHRcdFx0XHRcdFx0XHRcdDxUeXBvZ3JhcGh5IHZhcmlhbnQ9XCJoNVwiPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHtwcm9maWxlLmluUHJvZ3Jlc3NUYXNrc31cclxuXHRcdFx0XHRcdFx0XHRcdFx0PC9UeXBvZ3JhcGh5PlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQ8VHlwb2dyYXBoeSB2YXJpYW50PVwiY2FwdGlvblwiPkluIFByb2dyZXNzPC9UeXBvZ3JhcGh5PlxyXG5cdFx0XHRcdFx0XHRcdFx0PC9QYXBlcj5cclxuXHRcdFx0XHRcdFx0XHQ8L0dyaWQ+XHJcblx0XHRcdFx0XHRcdFx0PEdyaWRcclxuXHRcdFx0XHRcdFx0XHRcdGl0ZW1cclxuXHRcdFx0XHRcdFx0XHRcdHhzPXs2fVxyXG5cdFx0XHRcdFx0XHRcdFx0c209ezN9PlxyXG5cdFx0XHRcdFx0XHRcdFx0PFBhcGVyXHJcblx0XHRcdFx0XHRcdFx0XHRcdGVsZXZhdGlvbj17Mn1cclxuXHRcdFx0XHRcdFx0XHRcdFx0c3g9e3tcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwOiAyLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRleHRBbGlnbjogXCJjZW50ZXJcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRiYWNrZ3JvdW5kOlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJsaW5lYXItZ3JhZGllbnQoNDVkZWcsICM0Q0FGNTAgMzAlLCAjOEJDMzRBIDkwJSlcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb2xvcjogXCJ3aGl0ZVwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9fT5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PENoZWNrQ2lyY2xlSWNvbiBzeD17eyBmb250U2l6ZTogMjQsIG1iOiAxIH19IC8+XHJcblx0XHRcdFx0XHRcdFx0XHRcdDxUeXBvZ3JhcGh5IHZhcmlhbnQ9XCJoNVwiPntwcm9maWxlLmNvbXBsZXRlZFRhc2tzfTwvVHlwb2dyYXBoeT5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PFR5cG9ncmFwaHkgdmFyaWFudD1cImNhcHRpb25cIj5Db21wbGV0ZWQ8L1R5cG9ncmFwaHk+XHJcblx0XHRcdFx0XHRcdFx0XHQ8L1BhcGVyPlxyXG5cdFx0XHRcdFx0XHRcdDwvR3JpZD5cclxuXHRcdFx0XHRcdFx0PC9HcmlkPlxyXG5cclxuXHRcdFx0XHRcdFx0e3Byb2ZpbGUub3ZlcmR1ZVRhc2tzID4gMCAmJiAoXHJcblx0XHRcdFx0XHRcdFx0PEJveCBzeD17eyBtdDogMiB9fT5cclxuXHRcdFx0XHRcdFx0XHRcdDxQYXBlclxyXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGV2YXRpb249ezJ9XHJcblx0XHRcdFx0XHRcdFx0XHRcdHN4PXt7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cDogMixcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZXh0QWxpZ246IFwiY2VudGVyXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YmFja2dyb3VuZDpcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibGluZWFyLWdyYWRpZW50KDQ1ZGVnLCAjRjQ0MzM2IDMwJSwgI0ZGNTcyMiA5MCUpXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29sb3I6IFwid2hpdGVcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0fX0+XHJcblx0XHRcdFx0XHRcdFx0XHRcdDxUeXBvZ3JhcGh5XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyaWFudD1cImg2XCJcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRndXR0ZXJCb3R0b20+XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx04pqg77iPIHtwcm9maWxlLm92ZXJkdWVUYXNrc30gT3ZlcmR1ZSBUYXNrc1xyXG5cdFx0XHRcdFx0XHRcdFx0XHQ8L1R5cG9ncmFwaHk+XHJcblx0XHRcdFx0XHRcdFx0XHRcdDxUeXBvZ3JhcGh5IHZhcmlhbnQ9XCJib2R5MlwiPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFlvdSBoYXZlIHtwcm9maWxlLm92ZXJkdWVUYXNrc30gdGFza1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHtwcm9maWxlLm92ZXJkdWVUYXNrcyA+IDEgPyBcInNcIiA6IFwiXCJ9IHRoYXQgbmVlZCBhdHRlbnRpb24uXHJcblx0XHRcdFx0XHRcdFx0XHRcdDwvVHlwb2dyYXBoeT5cclxuXHRcdFx0XHRcdFx0XHRcdDwvUGFwZXI+XHJcblx0XHRcdFx0XHRcdFx0PC9Cb3g+XHJcblx0XHRcdFx0XHRcdCl9XHJcblx0XHRcdFx0XHQ8L0dyaWQ+XHJcblx0XHRcdFx0PC9HcmlkPlxyXG5cdFx0XHQ8L1BhcGVyPlxyXG5cdFx0PC9Db250YWluZXI+XHJcblx0KTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VTZXNzaW9uIiwiQ29udGFpbmVyIiwiVHlwb2dyYXBoeSIsIkJveCIsIlBhcGVyIiwiQXZhdGFyIiwiVGV4dEZpZWxkIiwiQnV0dG9uIiwiR3JpZCIsIkljb25CdXR0b24iLCJBbGVydCIsIkRpdmlkZXIiLCJDaGlwIiwiQ2lyY3VsYXJQcm9ncmVzcyIsIkNhcmQiLCJMaW5lYXJQcm9ncmVzcyIsIkVkaXQiLCJFZGl0SWNvbiIsIlNhdmUiLCJTYXZlSWNvbiIsIkNhbmNlbCIsIkNhbmNlbEljb24iLCJQaG90b0NhbWVyYSIsIlBob3RvQ2FtZXJhSWNvbiIsIkVtYWlsIiwiRW1haWxJY29uIiwiUGVyc29uIiwiUGVyc29uSWNvbiIsIkNhbGVuZGFyVG9kYXkiLCJDYWxlbmRhckljb24iLCJBc3NpZ25tZW50IiwiQXNzaWdubWVudEljb24iLCJDaGVja0NpcmNsZSIsIkNoZWNrQ2lyY2xlSWNvbiIsIlRyZW5kaW5nVXAiLCJUcmVuZGluZ1VwSWNvbiIsIlByaW50IiwiUHJpbnRJY29uIiwidXNlUm91dGVyIiwiUHJpbnRhYmxlVGFza3MiLCJSZWFjdERPTVNlcnZlciIsIlByb2ZpbGUiLCJ0ZW1wUHJvZmlsZSIsImRhdGEiLCJzZXNzaW9uIiwidXBkYXRlIiwicm91dGVyIiwiaXNFZGl0aW5nIiwic2V0SXNFZGl0aW5nIiwibG9hZGluZyIsInNldExvYWRpbmciLCJzYXZpbmciLCJzZXRTYXZpbmciLCJ0YXNrcyIsInNldFRhc2tzIiwicHJvZmlsZSIsInNldFByb2ZpbGUiLCJpZCIsIm5hbWUiLCJlbWFpbCIsImJpbyIsImF2YXRhciIsImNyZWF0ZWRBdCIsInRvdGFsVGFza3MiLCJjb21wbGV0ZWRUYXNrcyIsInBlbmRpbmdUYXNrcyIsImluUHJvZ3Jlc3NUYXNrcyIsIm92ZXJkdWVUYXNrcyIsInNldFRlbXBQcm9maWxlIiwibWVzc2FnZSIsInNldE1lc3NhZ2UiLCJmZXRjaFVzZXJQcm9maWxlIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwidXNlckRhdGEiLCJqc29uIiwicHJldiIsImVycm9yIiwiY29uc29sZSIsImZldGNoVXNlclN0YXRzIiwiZmV0Y2hlZFRhc2tzIiwic3RhdHMiLCJ0b3RhbCIsImxlbmd0aCIsImNvbXBsZXRlZCIsImZpbHRlciIsInQiLCJzdGF0dXMiLCJwZW5kaW5nIiwiaW5Qcm9ncmVzcyIsIm92ZXJkdWUiLCJkdWVEYXRlIiwiRGF0ZSIsIm5vdyIsImRheXNVbnRpbER1ZSIsIk1hdGgiLCJjZWlsIiwiZ2V0VGltZSIsInB1c2giLCJsb2FkUHJvZmlsZURhdGEiLCJoYW5kbGVFZGl0IiwiaGFuZGxlQ2FuY2VsIiwiaGFuZGxlU2F2ZSIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInVwZGF0ZWRQcm9maWxlIiwidHlwZSIsInRleHQiLCJ1c2VyIiwic2V0VGltZW91dCIsImhhbmRsZUF2YXRhckNoYW5nZSIsImV2ZW50IiwiZmlsZSIsInRhcmdldCIsImZpbGVzIiwic2l6ZSIsInN0YXJ0c1dpdGgiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkZW5kIiwicmVzdWx0IiwicmVhZEFzRGF0YVVSTCIsImhhbmRsZVByaW50IiwicHJpbnRXaW5kb3ciLCJ3aW5kb3ciLCJvcGVuIiwicHJpbnRhYmxlQ29tcG9uZW50IiwidXNlclByb2ZpbGUiLCJwcmludERhdGUiLCJwcmludENvbnRlbnQiLCJyZW5kZXJUb1N0cmluZyIsImRvY3VtZW50Iiwid3JpdGUiLCJjbG9zZSIsImNvbXBsZXRpb25SYXRlIiwibWF4V2lkdGgiLCJzeCIsInB5IiwiZGlzcGxheSIsImp1c3RpZnlDb250ZW50IiwiYWxpZ25JdGVtcyIsIm1pbkhlaWdodCIsInNldmVyaXR5IiwibWIiLCJlbGV2YXRpb24iLCJwIiwidmFyaWFudCIsImNvbXBvbmVudCIsImdhcCIsInN0YXJ0SWNvbiIsIm9uQ2xpY2siLCJtciIsImRpc2FibGVkIiwiY29udGFpbmVyIiwic3BhY2luZyIsIml0ZW0iLCJ4cyIsIm1kIiwidGV4dEFsaWduIiwicG9zaXRpb24iLCJzcmMiLCJ1bmRlZmluZWQiLCJ3aWR0aCIsImhlaWdodCIsInRvVXBwZXJDYXNlIiwibGFiZWwiLCJodG1sRm9yIiwiaW5wdXQiLCJhY2NlcHQiLCJzdHlsZSIsIm9uQ2hhbmdlIiwiY29sb3IiLCJhcmlhLWxhYmVsIiwiYm90dG9tIiwicmlnaHQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJndXR0ZXJCb3R0b20iLCJpY29uIiwiZnVsbFdpZHRoIiwidmFsdWUiLCJlIiwiSW5wdXRQcm9wcyIsInN0YXJ0QWRvcm5tZW50IiwibXVsdGlsaW5lIiwicm93cyIsInBsYWNlaG9sZGVyIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwibXkiLCJmb250V2VpZ2h0IiwidG9GaXhlZCIsImJvcmRlclJhZGl1cyIsInNtIiwiYmFja2dyb3VuZCIsImZvbnRTaXplIiwibXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/profile/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/PrintableTasks.tsx":
/*!*******************************************!*\
  !*** ./src/components/PrintableTasks.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=format!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/format.mjs\");\n\n\n\nconst PrintableTasks = (param)=>{\n    let { tasks, userProfile, printDate } = param;\n    var _this = undefined;\n    const getPriorityColor = (priority)=>{\n        switch(priority){\n            case \"HIGH\":\n                return \"#f44336\";\n            case \"MEDIUM\":\n                return \"#ff9800\";\n            case \"LOW\":\n                return \"#4caf50\";\n            default:\n                return \"#757575\";\n        }\n    };\n    const getStatusText = (status)=>{\n        switch(status){\n            case \"PENDING\":\n                return \"Pending\";\n            case \"IN_PROGRESS\":\n                return \"In Progress\";\n            case \"COMPLETED\":\n                return \"Completed\";\n            default:\n                return status;\n        }\n    };\n    const getStatusColor = (status)=>{\n        switch(status){\n            case \"COMPLETED\":\n                return \"#4caf50\";\n            case \"IN_PROGRESS\":\n                return \"#2196f3\";\n            case \"PENDING\":\n                return \"#ff9800\";\n            default:\n                return \"#757575\";\n        }\n    };\n    const getFrequencyText = (frequency)=>{\n        switch(frequency){\n            case \"DAILY\":\n                return \"Daily\";\n            case \"WEEKLY\":\n                return \"Weekly\";\n            case \"MONTHLY\":\n                return \"Monthly\";\n            case \"CUSTOM\":\n                return \"Custom\";\n            default:\n                return \"Once\";\n        }\n    };\n    const getDaysUntilDue = (dueDate)=>{\n        const due = new Date(dueDate);\n        const now = new Date();\n        const diffTime = due.getTime() - now.getTime();\n        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n        return diffDays;\n    };\n    const pendingTasks = tasks.filter((task)=>task.status === \"PENDING\");\n    const inProgressTasks = tasks.filter((task)=>task.status === \"IN_PROGRESS\");\n    const completedTasks = tasks.filter((task)=>task.status === \"COMPLETED\");\n    const overdueTasks = tasks.filter((task)=>{\n        const daysUntilDue = getDaysUntilDue(task.dueDate);\n        return daysUntilDue < 0 && task.status !== \"COMPLETED\";\n    });\n    const renderTaskCard = function(task) {\n        let isCompleted = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        const daysUntilDue = getDaysUntilDue(task.dueDate);\n        const isOverdue = daysUntilDue < 0 && task.status !== \"COMPLETED\";\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                border: isOverdue ? \"2px solid #f44336\" : \"1px solid #ddd\",\n                borderRadius: \"8px\",\n                padding: \"20px\",\n                marginBottom: \"20px\",\n                backgroundColor: isCompleted ? \"#f8f8f8\" : isOverdue ? \"#ffebee\" : \"#fafafa\",\n                boxShadow: \"0 2px 4px rgba(0,0,0,0.1)\"\n            },\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        display: \"flex\",\n                        justifyContent: \"space-between\",\n                        alignItems: \"flex-start\",\n                        marginBottom: \"15px\",\n                        borderBottom: \"1px solid #e0e0e0\",\n                        paddingBottom: \"10px\"\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            style: {\n                                margin: \"0\",\n                                fontSize: \"18px\",\n                                fontWeight: \"bold\",\n                                color: isCompleted ? \"#666\" : isOverdue ? \"#d32f2f\" : \"#333\",\n                                flex: \"1\",\n                                textDecoration: isCompleted ? \"line-through\" : \"none\"\n                            },\n                            children: task.title\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                            lineNumber: 118,\n                            columnNumber: 6\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                display: \"flex\",\n                                gap: \"8px\"\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    style: {\n                                        backgroundColor: getPriorityColor(task.priority),\n                                        color: \"white\",\n                                        padding: \"6px 12px\",\n                                        borderRadius: \"6px\",\n                                        fontSize: \"12px\",\n                                        fontWeight: \"bold\",\n                                        textTransform: \"uppercase\"\n                                    },\n                                    children: task.priority\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                    lineNumber: 130,\n                                    columnNumber: 7\n                                }, _this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    style: {\n                                        backgroundColor: getStatusColor(task.status),\n                                        color: \"white\",\n                                        padding: \"6px 12px\",\n                                        borderRadius: \"6px\",\n                                        fontSize: \"12px\",\n                                        fontWeight: \"bold\",\n                                        textTransform: \"uppercase\"\n                                    },\n                                    children: getStatusText(task.status)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                    lineNumber: 142,\n                                    columnNumber: 7\n                                }, _this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                            lineNumber: 129,\n                            columnNumber: 6\n                        }, _this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                    lineNumber: 109,\n                    columnNumber: 5\n                }, _this),\n                task.description && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        marginBottom: \"15px\"\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                            style: {\n                                margin: \"0 0 8px 0\",\n                                fontSize: \"14px\",\n                                color: \"#666\",\n                                fontWeight: \"bold\"\n                            },\n                            children: \"Description:\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                            lineNumber: 160,\n                            columnNumber: 7\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            style: {\n                                margin: \"0\",\n                                fontSize: \"14px\",\n                                color: \"#666\",\n                                lineHeight: \"1.5\",\n                                textDecoration: isCompleted ? \"line-through\" : \"none\",\n                                padding: \"10px\",\n                                backgroundColor: \"white\",\n                                borderRadius: \"4px\",\n                                border: \"1px solid #e0e0e0\"\n                            },\n                            children: task.description\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                            lineNumber: 169,\n                            columnNumber: 7\n                        }, _this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                    lineNumber: 159,\n                    columnNumber: 6\n                }, _this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        display: \"grid\",\n                        gridTemplateColumns: \"1fr 1fr\",\n                        gap: \"15px\",\n                        marginBottom: \"15px\",\n                        padding: \"10px\",\n                        backgroundColor: \"white\",\n                        borderRadius: \"4px\",\n                        border: \"1px solid #e0e0e0\"\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                    style: {\n                                        color: \"#333\",\n                                        fontSize: \"13px\"\n                                    },\n                                    children: \"Due Date:\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                    lineNumber: 199,\n                                    columnNumber: 7\n                                }, _this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                    lineNumber: 202,\n                                    columnNumber: 7\n                                }, _this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    style: {\n                                        color: isOverdue ? \"#d32f2f\" : \"#666\",\n                                        fontSize: \"13px\",\n                                        fontWeight: isOverdue ? \"bold\" : \"normal\"\n                                    },\n                                    children: [\n                                        (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(new Date(task.dueDate), \"PPP\"),\n                                        isOverdue && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            style: {\n                                                color: \"#f44336\",\n                                                fontWeight: \"bold\",\n                                                marginLeft: \"5px\"\n                                            },\n                                            children: [\n                                                \"(\",\n                                                Math.abs(daysUntilDue),\n                                                \" day\",\n                                                Math.abs(daysUntilDue) > 1 ? \"s\" : \"\",\n                                                \" overdue)\"\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                            lineNumber: 211,\n                                            columnNumber: 9\n                                        }, _this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                    lineNumber: 203,\n                                    columnNumber: 7\n                                }, _this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                            lineNumber: 198,\n                            columnNumber: 6\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                    style: {\n                                        color: \"#333\",\n                                        fontSize: \"13px\"\n                                    },\n                                    children: \"Created:\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                    lineNumber: 224,\n                                    columnNumber: 7\n                                }, _this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                    lineNumber: 227,\n                                    columnNumber: 7\n                                }, _this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    style: {\n                                        color: \"#666\",\n                                        fontSize: \"13px\"\n                                    },\n                                    children: (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(new Date(task.createdAt), \"PPP\")\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                    lineNumber: 228,\n                                    columnNumber: 7\n                                }, _this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                            lineNumber: 223,\n                            columnNumber: 6\n                        }, _this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                    lineNumber: 187,\n                    columnNumber: 5\n                }, _this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        display: \"flex\",\n                        flexWrap: \"wrap\",\n                        gap: \"8px\",\n                        alignItems: \"center\",\n                        padding: \"10px\",\n                        backgroundColor: \"white\",\n                        borderRadius: \"4px\",\n                        border: \"1px solid #e0e0e0\"\n                    },\n                    children: [\n                        task.category && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            style: {\n                                backgroundColor: \"#e0e0e0\",\n                                padding: \"4px 8px\",\n                                borderRadius: \"4px\",\n                                fontSize: \"12px\",\n                                color: \"#666\",\n                                fontWeight: \"bold\"\n                            },\n                            children: [\n                                \"\\uD83D\\uDCC1 \",\n                                task.category\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                            lineNumber: 247,\n                            columnNumber: 7\n                        }, _this),\n                        task.isRecurring && task.frequency && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            style: {\n                                backgroundColor: \"#e3f2fd\",\n                                padding: \"4px 8px\",\n                                borderRadius: \"4px\",\n                                fontSize: \"12px\",\n                                color: \"#1976d2\",\n                                fontWeight: \"bold\"\n                            },\n                            children: [\n                                \"\\uD83D\\uDD04 \",\n                                getFrequencyText(task.frequency),\n                                task.interval && task.interval > 1 && \" (\".concat(task.interval, \")\")\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                            lineNumber: 261,\n                            columnNumber: 7\n                        }, _this),\n                        task.tags && task.tags.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    style: {\n                                        fontSize: \"12px\",\n                                        color: \"#666\",\n                                        fontWeight: \"bold\"\n                                    },\n                                    children: \"Tags:\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                    lineNumber: 277,\n                                    columnNumber: 8\n                                }, _this),\n                                task.tags.map((tag, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        style: {\n                                            backgroundColor: \"#f0f0f0\",\n                                            padding: \"4px 8px\",\n                                            borderRadius: \"4px\",\n                                            fontSize: \"12px\",\n                                            color: \"#666\",\n                                            border: \"1px solid #ddd\"\n                                        },\n                                        children: [\n                                            \"\\uD83C\\uDFF7 \",\n                                            tag\n                                        ]\n                                    }, index, true, {\n                                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                        lineNumber: 282,\n                                        columnNumber: 9\n                                    }, _this))\n                            ]\n                        }, void 0, true)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                    lineNumber: 235,\n                    columnNumber: 5\n                }, _this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        marginTop: \"10px\",\n                        fontSize: \"10px\",\n                        color: \"#999\",\n                        textAlign: \"right\",\n                        fontStyle: \"italic\"\n                    },\n                    children: [\n                        \"Task ID: \",\n                        task.id\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                    lineNumber: 331,\n                    columnNumber: 5\n                }, _this)\n            ]\n        }, task.id, true, {\n            fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n            lineNumber: 94,\n            columnNumber: 4\n        }, _this);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            fontFamily: \"Arial, sans-serif\",\n            maxWidth: \"800px\",\n            margin: \"0 auto\",\n            padding: \"20px\",\n            backgroundColor: \"white\",\n            color: \"black\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    textAlign: \"center\",\n                    borderBottom: \"2px solid #333\",\n                    paddingBottom: \"20px\",\n                    marginBottom: \"30px\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        style: {\n                            margin: \"0\",\n                            color: \"#1976d2\",\n                            fontSize: \"28px\"\n                        },\n                        children: \"MyDo - Task Report\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                        lineNumber: 363,\n                        columnNumber: 5\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        style: {\n                            margin: \"10px 0 0 0\",\n                            color: \"#666\"\n                        },\n                        children: [\n                            \"Generated on \",\n                            (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(printDate, \"PPP 'at' p\")\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                        lineNumber: 366,\n                        columnNumber: 5\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                lineNumber: 356,\n                columnNumber: 4\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    backgroundColor: \"#f5f5f5\",\n                    padding: \"15px\",\n                    borderRadius: \"8px\",\n                    marginBottom: \"30px\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        style: {\n                            margin: \"0 0 10px 0\",\n                            fontSize: \"20px\",\n                            color: \"#333\"\n                        },\n                        children: \"User Information\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                        lineNumber: 379,\n                        columnNumber: 5\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        style: {\n                            margin: \"5px 0\",\n                            fontSize: \"14px\"\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                children: \"Name:\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                lineNumber: 383,\n                                columnNumber: 6\n                            }, undefined),\n                            \" \",\n                            userProfile.name\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                        lineNumber: 382,\n                        columnNumber: 5\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        style: {\n                            margin: \"5px 0\",\n                            fontSize: \"14px\"\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                children: \"Email:\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                lineNumber: 386,\n                                columnNumber: 6\n                            }, undefined),\n                            \" \",\n                            userProfile.email\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                        lineNumber: 385,\n                        columnNumber: 5\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                lineNumber: 372,\n                columnNumber: 4\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    display: \"grid\",\n                    gridTemplateColumns: \"repeat(auto-fit, minmax(150px, 1fr))\",\n                    gap: \"15px\",\n                    marginBottom: \"30px\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            backgroundColor: \"#e3f2fd\",\n                            padding: \"15px\",\n                            borderRadius: \"8px\",\n                            textAlign: \"center\"\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                style: {\n                                    margin: \"0 0 5px 0\",\n                                    fontSize: \"24px\",\n                                    color: \"#1976d2\"\n                                },\n                                children: tasks.length\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                lineNumber: 405,\n                                columnNumber: 6\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                style: {\n                                    margin: \"0\",\n                                    fontSize: \"12px\",\n                                    color: \"#666\"\n                                },\n                                children: \"Total Tasks\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                lineNumber: 409,\n                                columnNumber: 6\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                        lineNumber: 398,\n                        columnNumber: 5\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            backgroundColor: \"#fff3e0\",\n                            padding: \"15px\",\n                            borderRadius: \"8px\",\n                            textAlign: \"center\"\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                style: {\n                                    margin: \"0 0 5px 0\",\n                                    fontSize: \"24px\",\n                                    color: \"#ff9800\"\n                                },\n                                children: pendingTasks.length\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                lineNumber: 420,\n                                columnNumber: 6\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                style: {\n                                    margin: \"0\",\n                                    fontSize: \"12px\",\n                                    color: \"#666\"\n                                },\n                                children: \"Pending\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                lineNumber: 424,\n                                columnNumber: 6\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                        lineNumber: 413,\n                        columnNumber: 5\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            backgroundColor: \"#e8f5e8\",\n                            padding: \"15px\",\n                            borderRadius: \"8px\",\n                            textAlign: \"center\"\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                style: {\n                                    margin: \"0 0 5px 0\",\n                                    fontSize: \"24px\",\n                                    color: \"#4caf50\"\n                                },\n                                children: completedTasks.length\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                lineNumber: 435,\n                                columnNumber: 6\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                style: {\n                                    margin: \"0\",\n                                    fontSize: \"12px\",\n                                    color: \"#666\"\n                                },\n                                children: \"Completed\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                lineNumber: 439,\n                                columnNumber: 6\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                        lineNumber: 428,\n                        columnNumber: 5\n                    }, undefined),\n                    overdueTasks.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            backgroundColor: \"#ffebee\",\n                            padding: \"15px\",\n                            borderRadius: \"8px\",\n                            textAlign: \"center\"\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                style: {\n                                    margin: \"0 0 5px 0\",\n                                    fontSize: \"24px\",\n                                    color: \"#f44336\"\n                                },\n                                children: overdueTasks.length\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                lineNumber: 451,\n                                columnNumber: 7\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                style: {\n                                    margin: \"0\",\n                                    fontSize: \"12px\",\n                                    color: \"#666\"\n                                },\n                                children: \"Overdue\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                                lineNumber: 459,\n                                columnNumber: 7\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                        lineNumber: 444,\n                        columnNumber: 6\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                lineNumber: 391,\n                columnNumber: 4\n            }, undefined),\n            pendingTasks.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    marginBottom: \"30px\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        style: {\n                            borderBottom: \"2px solid #ff9800\",\n                            paddingBottom: \"10px\",\n                            marginBottom: \"20px\",\n                            color: \"#333\",\n                            fontSize: \"22px\"\n                        },\n                        children: [\n                            \"Pending Tasks (\",\n                            pendingTasks.length,\n                            \")\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                        lineNumber: 470,\n                        columnNumber: 6\n                    }, undefined),\n                    pendingTasks.map((task)=>renderTaskCard(task))\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                lineNumber: 469,\n                columnNumber: 5\n            }, undefined),\n            inProgressTasks.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    marginBottom: \"30px\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        style: {\n                            borderBottom: \"2px solid #2196f3\",\n                            paddingBottom: \"10px\",\n                            marginBottom: \"20px\",\n                            color: \"#333\",\n                            fontSize: \"22px\"\n                        },\n                        children: [\n                            \"In Progress Tasks (\",\n                            inProgressTasks.length,\n                            \")\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                        lineNumber: 487,\n                        columnNumber: 6\n                    }, undefined),\n                    inProgressTasks.map((task)=>renderTaskCard(task))\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                lineNumber: 486,\n                columnNumber: 5\n            }, undefined),\n            completedTasks.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    marginBottom: \"30px\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        style: {\n                            borderBottom: \"2px solid #4caf50\",\n                            paddingBottom: \"10px\",\n                            marginBottom: \"20px\",\n                            color: \"#333\",\n                            fontSize: \"22px\"\n                        },\n                        children: [\n                            \"Completed Tasks (\",\n                            completedTasks.length,\n                            \")\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                        lineNumber: 504,\n                        columnNumber: 6\n                    }, undefined),\n                    completedTasks.map((task)=>renderTaskCard(task, true))\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                lineNumber: 503,\n                columnNumber: 5\n            }, undefined),\n            overdueTasks.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    marginBottom: \"30px\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        style: {\n                            borderBottom: \"2px solid #f44336\",\n                            paddingBottom: \"10px\",\n                            marginBottom: \"20px\",\n                            color: \"#333\",\n                            fontSize: \"22px\"\n                        },\n                        children: [\n                            \" Overdue Tasks (\",\n                            overdueTasks.length,\n                            \")\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                        lineNumber: 521,\n                        columnNumber: 6\n                    }, undefined),\n                    overdueTasks.map((task)=>renderTaskCard(task))\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                lineNumber: 520,\n                columnNumber: 5\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    marginTop: \"40px\",\n                    paddingTop: \"20px\",\n                    borderTop: \"1px solid #ddd\",\n                    textAlign: \"center\",\n                    fontSize: \"12px\",\n                    color: \"#666\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        style: {\n                            margin: \"0\"\n                        },\n                        children: \"This report was generated by MyDo Task Management System\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                        lineNumber: 545,\n                        columnNumber: 5\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        style: {\n                            margin: \"5px 0 0 0\"\n                        },\n                        children: \"For more information, visit your MyDo dashboard\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                        lineNumber: 548,\n                        columnNumber: 5\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n                lineNumber: 536,\n                columnNumber: 4\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\cursor ai projects\\\\To Do List\\\\src\\\\components\\\\PrintableTasks.tsx\",\n        lineNumber: 346,\n        columnNumber: 3\n    }, undefined);\n};\n_c = PrintableTasks;\n/* harmony default export */ __webpack_exports__[\"default\"] = (PrintableTasks);\nvar _c;\n$RefreshReg$(_c, \"PrintableTasks\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1ByaW50YWJsZVRhc2tzLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEI7QUFFUTtBQVdsQyxNQUFNRSxpQkFBZ0Q7UUFBQyxFQUN0REMsS0FBSyxFQUNMQyxXQUFXLEVBQ1hDLFNBQVMsRUFDVDs7SUFDQSxNQUFNQyxtQkFBbUIsQ0FBQ0M7UUFDekIsT0FBUUE7WUFDUCxLQUFLO2dCQUNKLE9BQU87WUFDUixLQUFLO2dCQUNKLE9BQU87WUFDUixLQUFLO2dCQUNKLE9BQU87WUFDUjtnQkFDQyxPQUFPO1FBQ1Q7SUFDRDtJQUVBLE1BQU1DLGdCQUFnQixDQUFDQztRQUN0QixPQUFRQTtZQUNQLEtBQUs7Z0JBQ0osT0FBTztZQUNSLEtBQUs7Z0JBQ0osT0FBTztZQUNSLEtBQUs7Z0JBQ0osT0FBTztZQUNSO2dCQUNDLE9BQU9BO1FBQ1Q7SUFDRDtJQUVBLE1BQU1DLGlCQUFpQixDQUFDRDtRQUN2QixPQUFRQTtZQUNQLEtBQUs7Z0JBQ0osT0FBTztZQUNSLEtBQUs7Z0JBQ0osT0FBTztZQUNSLEtBQUs7Z0JBQ0osT0FBTztZQUNSO2dCQUNDLE9BQU87UUFDVDtJQUNEO0lBRUEsTUFBTUUsbUJBQW1CLENBQUNDO1FBQ3pCLE9BQVFBO1lBQ1AsS0FBSztnQkFDSixPQUFPO1lBQ1IsS0FBSztnQkFDSixPQUFPO1lBQ1IsS0FBSztnQkFDSixPQUFPO1lBQ1IsS0FBSztnQkFDSixPQUFPO1lBQ1I7Z0JBQ0MsT0FBTztRQUNUO0lBQ0Q7SUFFQSxNQUFNQyxrQkFBa0IsQ0FBQ0M7UUFDeEIsTUFBTUMsTUFBTSxJQUFJQyxLQUFLRjtRQUNyQixNQUFNRyxNQUFNLElBQUlEO1FBQ2hCLE1BQU1FLFdBQVdILElBQUlJLE9BQU8sS0FBS0YsSUFBSUUsT0FBTztRQUM1QyxNQUFNQyxXQUFXQyxLQUFLQyxJQUFJLENBQUNKLFdBQVksUUFBTyxLQUFLLEtBQUssRUFBQztRQUN6RCxPQUFPRTtJQUNSO0lBRUEsTUFB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Q0FqRCxPQUFPOzRCQUNOVSxjQUFjOzRCQUNkQyxlQUFlOzRCQUNmUCxjQUFjOzRCQUNkWSxPQUFPOzRCQUNQRixVQUFVO3dCQUNYOzs0QkFBRzs0QkFDZ0JwQixhQUFhNEMsTUFBTTs0QkFBQzs7Ozs7OztvQkFFdkM1QyxhQUFhNkMsR0FBRyxDQUFDLENBQUNoRCxPQUFTSyxlQUFlTDs7Ozs7OzswQkFLN0MsOERBQUNRO2dCQUNBQyxPQUFPO29CQUNOMEMsV0FBVztvQkFDWFUsWUFBWTtvQkFDWkMsV0FBVztvQkFDWFYsV0FBVztvQkFDWDdCLFVBQVU7b0JBQ1ZFLE9BQU87Z0JBQ1I7O2tDQUNBLDhEQUFDUzt3QkFBRXpCLE9BQU87NEJBQUVhLFFBQVE7d0JBQUk7a0NBQUc7Ozs7OztrQ0FHM0IsOERBQUNZO3dCQUFFekIsT0FBTzs0QkFBRWEsUUFBUTt3QkFBWTtrQ0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTXZDO0tBNWhCTTdDO0FBOGhCTiwrREFBZUEsY0FBY0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9QcmludGFibGVUYXNrcy50c3g/Mzg3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IFRhc2ssIFByaW9yaXR5LCBTdGF0dXMsIEZyZXF1ZW5jeSB9IGZyb20gXCJAcHJpc21hL2NsaWVudFwiO1xyXG5pbXBvcnQgeyBmb3JtYXQgfSBmcm9tIFwiZGF0ZS1mbnNcIjtcclxuXHJcbmludGVyZmFjZSBQcmludGFibGVUYXNrc1Byb3BzIHtcclxuXHR0YXNrczogVGFza1tdO1xyXG5cdHVzZXJQcm9maWxlOiB7XHJcblx0XHRuYW1lOiBzdHJpbmc7XHJcblx0XHRlbWFpbDogc3RyaW5nO1xyXG5cdH07XHJcblx0cHJpbnREYXRlOiBEYXRlO1xyXG59XHJcblxyXG5jb25zdCBQcmludGFibGVUYXNrczogUmVhY3QuRkM8UHJpbnRhYmxlVGFza3NQcm9wcz4gPSAoe1xyXG5cdHRhc2tzLFxyXG5cdHVzZXJQcm9maWxlLFxyXG5cdHByaW50RGF0ZSxcclxufSkgPT4ge1xyXG5cdGNvbnN0IGdldFByaW9yaXR5Q29sb3IgPSAocHJpb3JpdHk6IFByaW9yaXR5KSA9PiB7XHJcblx0XHRzd2l0Y2ggKHByaW9yaXR5KSB7XHJcblx0XHRcdGNhc2UgXCJISUdIXCI6XHJcblx0XHRcdFx0cmV0dXJuIFwiI2Y0NDMzNlwiO1xyXG5cdFx0XHRjYXNlIFwiTUVESVVNXCI6XHJcblx0XHRcdFx0cmV0dXJuIFwiI2ZmOTgwMFwiO1xyXG5cdFx0XHRjYXNlIFwiTE9XXCI6XHJcblx0XHRcdFx0cmV0dXJuIFwiIzRjYWY1MFwiO1xyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdHJldHVybiBcIiM3NTc1NzVcIjtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRjb25zdCBnZXRTdGF0dXNUZXh0ID0gKHN0YXR1czogU3RhdHVzKSA9PiB7XHJcblx0XHRzd2l0Y2ggKHN0YXR1cykge1xyXG5cdFx0XHRjYXNlIFwiUEVORElOR1wiOlxyXG5cdFx0XHRcdHJldHVybiBcIlBlbmRpbmdcIjtcclxuXHRcdFx0Y2FzZSBcIklOX1BST0dSRVNTXCI6XHJcblx0XHRcdFx0cmV0dXJuIFwiSW4gUHJvZ3Jlc3NcIjtcclxuXHRcdFx0Y2FzZSBcIkNPTVBMRVRFRFwiOlxyXG5cdFx0XHRcdHJldHVybiBcIkNvbXBsZXRlZFwiO1xyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdHJldHVybiBzdGF0dXM7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Y29uc3QgZ2V0U3RhdHVzQ29sb3IgPSAoc3RhdHVzOiBTdGF0dXMpID0+IHtcclxuXHRcdHN3aXRjaCAoc3RhdHVzKSB7XHJcblx0XHRcdGNhc2UgXCJDT01QTEVURURcIjpcclxuXHRcdFx0XHRyZXR1cm4gXCIjNGNhZjUwXCI7XHJcblx0XHRcdGNhc2UgXCJJTl9QUk9HUkVTU1wiOlxyXG5cdFx0XHRcdHJldHVybiBcIiMyMTk2ZjNcIjtcclxuXHRcdFx0Y2FzZSBcIlBFTkRJTkdcIjpcclxuXHRcdFx0XHRyZXR1cm4gXCIjZmY5ODAwXCI7XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0cmV0dXJuIFwiIzc1NzU3NVwiO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdGNvbnN0IGdldEZyZXF1ZW5jeVRleHQgPSAoZnJlcXVlbmN5OiBGcmVxdWVuY3kgfCBudWxsKSA9PiB7XHJcblx0XHRzd2l0Y2ggKGZyZXF1ZW5jeSkge1xyXG5cdFx0XHRjYXNlIFwiREFJTFlcIjpcclxuXHRcdFx0XHRyZXR1cm4gXCJEYWlseVwiO1xyXG5cdFx0XHRjYXNlIFwiV0VFS0xZXCI6XHJcblx0XHRcdFx0cmV0dXJuIFwiV2Vla2x5XCI7XHJcblx0XHRcdGNhc2UgXCJNT05USExZXCI6XHJcblx0XHRcdFx0cmV0dXJuIFwiTW9udGhseVwiO1xyXG5cdFx0XHRjYXNlIFwiQ1VTVE9NXCI6XHJcblx0XHRcdFx0cmV0dXJuIFwiQ3VzdG9tXCI7XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0cmV0dXJuIFwiT25jZVwiO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdGNvbnN0IGdldERheXNVbnRpbER1ZSA9IChkdWVEYXRlOiBEYXRlKSA9PiB7XHJcblx0XHRjb25zdCBkdWUgPSBuZXcgRGF0ZShkdWVEYXRlKTtcclxuXHRcdGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcblx0XHRjb25zdCBkaWZmVGltZSA9IGR1ZS5nZXRUaW1lKCkgLSBub3cuZ2V0VGltZSgpO1xyXG5cdFx0Y29uc3QgZGlmZkRheXMgPSBNYXRoLmNlaWwoZGlmZlRpbWUgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xyXG5cdFx0cmV0dXJuIGRpZmZEYXlzO1xyXG5cdH07XHJcblxyXG5cdGNvbnN0IHBlbmRpbmdUYXNrcyA9IHRhc2tzLmZpbHRlcigodGFzaykgPT4gdGFzay5zdGF0dXMgPT09IFwiUEVORElOR1wiKTtcclxuXHRjb25zdCBpblByb2dyZXNzVGFza3MgPSB0YXNrcy5maWx0ZXIoKHRhc2spID0+IHRhc2suc3RhdHVzID09PSBcIklOX1BST0dSRVNTXCIpO1xyXG5cdGNvbnN0IGNvbXBsZXRlZFRhc2tzID0gdGFza3MuZmlsdGVyKCh0YXNrKSA9PiB0YXNrLnN0YXR1cyA9PT0gXCJDT01QTEVURURcIik7XHJcblx0Y29uc3Qgb3ZlcmR1ZVRhc2tzID0gdGFza3MuZmlsdGVyKCh0YXNrKSA9PiB7XHJcblx0XHRjb25zdCBkYXlzVW50aWxEdWUgPSBnZXREYXlzVW50aWxEdWUodGFzay5kdWVEYXRlKTtcclxuXHRcdHJldHVybiBkYXlzVW50aWxEdWUgPCAwICYmIHRhc2suc3RhdHVzICE9PSBcIkNPTVBMRVRFRFwiO1xyXG5cdH0pO1xyXG5cclxuXHRjb25zdCByZW5kZXJUYXNrQ2FyZCA9ICh0YXNrOiBUYXNrLCBpc0NvbXBsZXRlZDogYm9vbGVhbiA9IGZhbHNlKSA9PiB7XHJcblx0XHRjb25zdCBkYXlzVW50aWxEdWUgPSBnZXREYXlzVW50aWxEdWUodGFzay5kdWVEYXRlKTtcclxuXHRcdGNvbnN0IGlzT3ZlcmR1ZSA9IGRheXNVbnRpbER1ZSA8IDAgJiYgdGFzay5zdGF0dXMgIT09IFwiQ09NUExFVEVEXCI7XHJcblxyXG5cdFx0cmV0dXJuIChcclxuXHRcdFx0PGRpdlxyXG5cdFx0XHRcdGtleT17dGFzay5pZH1cclxuXHRcdFx0XHRzdHlsZT17e1xyXG5cdFx0XHRcdFx0Ym9yZGVyOiBpc092ZXJkdWUgPyBcIjJweCBzb2xpZCAjZjQ0MzM2XCIgOiBcIjFweCBzb2xpZCAjZGRkXCIsXHJcblx0XHRcdFx0XHRib3JkZXJSYWRpdXM6IFwiOHB4XCIsXHJcblx0XHRcdFx0XHRwYWRkaW5nOiBcIjIwcHhcIixcclxuXHRcdFx0XHRcdG1hcmdpbkJvdHRvbTogXCIyMHB4XCIsXHJcblx0XHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGlzQ29tcGxldGVkXHJcblx0XHRcdFx0XHRcdD8gXCIjZjhmOGY4XCJcclxuXHRcdFx0XHRcdFx0OiBpc092ZXJkdWVcclxuXHRcdFx0XHRcdFx0PyBcIiNmZmViZWVcIlxyXG5cdFx0XHRcdFx0XHQ6IFwiI2ZhZmFmYVwiLFxyXG5cdFx0XHRcdFx0Ym94U2hhZG93OiBcIjAgMnB4IDRweCByZ2JhKDAsMCwwLDAuMSlcIixcclxuXHRcdFx0XHR9fT5cclxuXHRcdFx0XHR7LyogVGFzayBIZWFkZXIgd2l0aCBUaXRsZSBhbmQgU3RhdHVzICovfVxyXG5cdFx0XHRcdDxkaXZcclxuXHRcdFx0XHRcdHN0eWxlPXt7XHJcblx0XHRcdFx0XHRcdGRpc3BsYXk6IFwiZmxleFwiLFxyXG5cdFx0XHRcdFx0XHRqdXN0aWZ5Q29udGVudDogXCJzcGFjZS1iZXR3ZWVuXCIsXHJcblx0XHRcdFx0XHRcdGFsaWduSXRlbXM6IFwiZmxleC1zdGFydFwiLFxyXG5cdFx0XHRcdFx0XHRtYXJnaW5Cb3R0b206IFwiMTVweFwiLFxyXG5cdFx0XHRcdFx0XHRib3JkZXJCb3R0b206IFwiMXB4IHNvbGlkICNlMGUwZTBcIixcclxuXHRcdFx0XHRcdFx0cGFkZGluZ0JvdHRvbTogXCIxMHB4XCIsXHJcblx0XHRcdFx0XHR9fT5cclxuXHRcdFx0XHRcdDxoM1xyXG5cdFx0XHRcdFx0XHRzdHlsZT17e1xyXG5cdFx0XHRcdFx0XHRcdG1hcmdpbjogXCIwXCIsXHJcblx0XHRcdFx0XHRcdFx0Zm9udFNpemU6IFwiMThweFwiLFxyXG5cdFx0XHRcdFx0XHRcdGZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxyXG5cdFx0XHRcdFx0XHRcdGNvbG9yOiBpc0NvbXBsZXRlZCA/IFwiIzY2NlwiIDogaXNPdmVyZHVlID8gXCIjZDMyZjJmXCIgOiBcIiMzMzNcIixcclxuXHRcdFx0XHRcdFx0XHRmbGV4OiBcIjFcIixcclxuXHRcdFx0XHRcdFx0XHR0ZXh0RGVjb3JhdGlvbjogaXNDb21wbGV0ZWQgPyBcImxpbmUtdGhyb3VnaFwiIDogXCJub25lXCIsXHJcblx0XHRcdFx0XHRcdH19PlxyXG5cdFx0XHRcdFx0XHR7dGFzay50aXRsZX1cclxuXHRcdFx0XHRcdDwvaDM+XHJcblx0XHRcdFx0XHQ8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBnYXA6IFwiOHB4XCIgfX0+XHJcblx0XHRcdFx0XHRcdDxzcGFuXHJcblx0XHRcdFx0XHRcdFx0c3R5bGU9e3tcclxuXHRcdFx0XHRcdFx0XHRcdGJhY2tncm91bmRDb2xvcjogZ2V0UHJpb3JpdHlDb2xvcih0YXNrLnByaW9yaXR5KSxcclxuXHRcdFx0XHRcdFx0XHRcdGNvbG9yOiBcIndoaXRlXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRwYWRkaW5nOiBcIjZweCAxMnB4XCIsXHJcblx0XHRcdFx0XHRcdFx0XHRib3JkZXJSYWRpdXM6IFwiNnB4XCIsXHJcblx0XHRcdFx0XHRcdFx0XHRmb250U2l6ZTogXCIxMnB4XCIsXHJcblx0XHRcdFx0XHRcdFx0XHRmb250V2VpZ2h0OiBcImJvbGRcIixcclxuXHRcdFx0XHRcdFx0XHRcdHRleHRUcmFuc2Zvcm06IFwidXBwZXJjYXNlXCIsXHJcblx0XHRcdFx0XHRcdFx0fX0+XHJcblx0XHRcdFx0XHRcdFx0e3Rhc2sucHJpb3JpdHl9XHJcblx0XHRcdFx0XHRcdDwvc3Bhbj5cclxuXHRcdFx0XHRcdFx0PHNwYW5cclxuXHRcdFx0XHRcdFx0XHRzdHlsZT17e1xyXG5cdFx0XHRcdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBnZXRTdGF0dXNDb2xvcih0YXNrLnN0YXR1cyksXHJcblx0XHRcdFx0XHRcdFx0XHRjb2xvcjogXCJ3aGl0ZVwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0cGFkZGluZzogXCI2cHggMTJweFwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0Ym9yZGVyUmFkaXVzOiBcIjZweFwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0Zm9udFNpemU6IFwiMTJweFwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0Zm9udFdlaWdodDogXCJib2xkXCIsXHJcblx0XHRcdFx0XHRcdFx0XHR0ZXh0VHJhbnNmb3JtOiBcInVwcGVyY2FzZVwiLFxyXG5cdFx0XHRcdFx0XHRcdH19PlxyXG5cdFx0XHRcdFx0XHRcdHtnZXRTdGF0dXNUZXh0KHRhc2suc3RhdHVzKX1cclxuXHRcdFx0XHRcdFx0PC9zcGFuPlxyXG5cdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0PC9kaXY+XHJcblxyXG5cdFx0XHRcdHsvKiBUYXNrIERlc2NyaXB0aW9uICovfVxyXG5cdFx0XHRcdHt0YXNrLmRlc2NyaXB0aW9uICYmIChcclxuXHRcdFx0XHRcdDxkaXYgc3R5bGU9e3sgbWFyZ2luQm90dG9tOiBcIjE1cHhcIiB9fT5cclxuXHRcdFx0XHRcdFx0PGg0XHJcblx0XHRcdFx0XHRcdFx0c3R5bGU9e3tcclxuXHRcdFx0XHRcdFx0XHRcdG1hcmdpbjogXCIwIDAgOHB4IDBcIixcclxuXHRcdFx0XHRcdFx0XHRcdGZvbnRTaXplOiBcIjE0cHhcIixcclxuXHRcdFx0XHRcdFx0XHRcdGNvbG9yOiBcIiM2NjZcIixcclxuXHRcdFx0XHRcdFx0XHRcdGZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxyXG5cdFx0XHRcdFx0XHRcdH19PlxyXG5cdFx0XHRcdFx0XHRcdERlc2NyaXB0aW9uOlxyXG5cdFx0XHRcdFx0XHQ8L2g0PlxyXG5cdFx0XHRcdFx0XHQ8cFxyXG5cdFx0XHRcdFx0XHRcdHN0eWxlPXt7XHJcblx0XHRcdFx0XHRcdFx0XHRtYXJnaW46IFwiMFwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0Zm9udFNpemU6IFwiMTRweFwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0Y29sb3I6IFwiIzY2NlwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0bGluZUhlaWdodDogXCIxLjVcIixcclxuXHRcdFx0XHRcdFx0XHRcdHRleHREZWNvcmF0aW9uOiBpc0NvbXBsZXRlZCA/IFwibGluZS10aHJvdWdoXCIgOiBcIm5vbmVcIixcclxuXHRcdFx0XHRcdFx0XHRcdHBhZGRpbmc6IFwiMTBweFwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRib3JkZXJSYWRpdXM6IFwiNHB4XCIsXHJcblx0XHRcdFx0XHRcdFx0XHRib3JkZXI6IFwiMXB4IHNvbGlkICNlMGUwZTBcIixcclxuXHRcdFx0XHRcdFx0XHR9fT5cclxuXHRcdFx0XHRcdFx0XHR7dGFzay5kZXNjcmlwdGlvbn1cclxuXHRcdFx0XHRcdFx0PC9wPlxyXG5cdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0KX1cclxuXHJcblx0XHRcdFx0ey8qIFRhc2sgRGF0ZXMgKi99XHJcblx0XHRcdFx0PGRpdlxyXG5cdFx0XHRcdFx0c3R5bGU9e3tcclxuXHRcdFx0XHRcdFx0ZGlzcGxheTogXCJncmlkXCIsXHJcblx0XHRcdFx0XHRcdGdyaWRUZW1wbGF0ZUNvbHVtbnM6IFwiMWZyIDFmclwiLFxyXG5cdFx0XHRcdFx0XHRnYXA6IFwiMTVweFwiLFxyXG5cdFx0XHRcdFx0XHRtYXJnaW5Cb3R0b206IFwiMTVweFwiLFxyXG5cdFx0XHRcdFx0XHRwYWRkaW5nOiBcIjEwcHhcIixcclxuXHRcdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCIsXHJcblx0XHRcdFx0XHRcdGJvcmRlclJhZGl1czogXCI0cHhcIixcclxuXHRcdFx0XHRcdFx0Ym9yZGVyOiBcIjFweCBzb2xpZCAjZTBlMGUwXCIsXHJcblx0XHRcdFx0XHR9fT5cclxuXHRcdFx0XHRcdDxkaXY+XHJcblx0XHRcdFx0XHRcdDxzdHJvbmcgc3R5bGU9e3sgY29sb3I6IFwiIzMzM1wiLCBmb250U2l6ZTogXCIxM3B4XCIgfX0+XHJcblx0XHRcdFx0XHRcdFx0RHVlIERhdGU6XHJcblx0XHRcdFx0XHRcdDwvc3Ryb25nPlxyXG5cdFx0XHRcdFx0XHQ8YnIgLz5cclxuXHRcdFx0XHRcdFx0PHNwYW5cclxuXHRcdFx0XHRcdFx0XHRzdHlsZT17e1xyXG5cdFx0XHRcdFx0XHRcdFx0Y29sb3I6IGlzT3ZlcmR1ZSA/IFwiI2QzMmYyZlwiIDogXCIjNjY2XCIsXHJcblx0XHRcdFx0XHRcdFx0XHRmb250U2l6ZTogXCIxM3B4XCIsXHJcblx0XHRcdFx0XHRcdFx0XHRmb250V2VpZ2h0OiBpc092ZXJkdWUgPyBcImJvbGRcIiA6IFwibm9ybWFsXCIsXHJcblx0XHRcdFx0XHRcdFx0fX0+XHJcblx0XHRcdFx0XHRcdFx0e2Zvcm1hdChuZXcgRGF0ZSh0YXNrLmR1ZURhdGUpLCBcIlBQUFwiKX1cclxuXHRcdFx0XHRcdFx0XHR7aXNPdmVyZHVlICYmIChcclxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuXHJcblx0XHRcdFx0XHRcdFx0XHRcdHN0eWxlPXt7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29sb3I6IFwiI2Y0NDMzNlwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1hcmdpbkxlZnQ6IFwiNXB4XCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdH19PlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQoe01hdGguYWJzKGRheXNVbnRpbER1ZSl9IGRheVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR7TWF0aC5hYnMoZGF5c1VudGlsRHVlKSA+IDEgPyBcInNcIiA6IFwiXCJ9IG92ZXJkdWUpXHJcblx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XHJcblx0XHRcdFx0XHRcdFx0KX1cclxuXHRcdFx0XHRcdFx0PC9zcGFuPlxyXG5cdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHQ8ZGl2PlxyXG5cdFx0XHRcdFx0XHQ8c3Ryb25nIHN0eWxlPXt7IGNvbG9yOiBcIiMzMzNcIiwgZm9udFNpemU6IFwiMTNweFwiIH19PlxyXG5cdFx0XHRcdFx0XHRcdENyZWF0ZWQ6XHJcblx0XHRcdFx0XHRcdDwvc3Ryb25nPlxyXG5cdFx0XHRcdFx0XHQ8YnIgLz5cclxuXHRcdFx0XHRcdFx0PHNwYW4gc3R5bGU9e3sgY29sb3I6IFwiIzY2NlwiLCBmb250U2l6ZTogXCIxM3B4XCIgfX0+XHJcblx0XHRcdFx0XHRcdFx0e2Zvcm1hdChuZXcgRGF0ZSh0YXNrLmNyZWF0ZWRBdCksIFwiUFBQXCIpfVxyXG5cdFx0XHRcdFx0XHQ8L3NwYW4+XHJcblx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHJcblx0XHRcdFx0ey8qIFRhc2sgTWV0YWRhdGEgKi99XHJcblx0XHRcdFx0PGRpdlxyXG5cdFx0XHRcdFx0c3R5bGU9e3tcclxuXHRcdFx0XHRcdFx0ZGlzcGxheTogXCJmbGV4XCIsXHJcblx0XHRcdFx0XHRcdGZsZXhXcmFwOiBcIndyYXBcIixcclxuXHRcdFx0XHRcdFx0Z2FwOiBcIjhweFwiLFxyXG5cdFx0XHRcdFx0XHRhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxyXG5cdFx0XHRcdFx0XHRwYWRkaW5nOiBcIjEwcHhcIixcclxuXHRcdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCIsXHJcblx0XHRcdFx0XHRcdGJvcmRlclJhZGl1czogXCI0cHhcIixcclxuXHRcdFx0XHRcdFx0Ym9yZGVyOiBcIjFweCBzb2xpZCAjZTBlMGUwXCIsXHJcblx0XHRcdFx0XHR9fT5cclxuXHRcdFx0XHRcdHt0YXNrLmNhdGVnb3J5ICYmIChcclxuXHRcdFx0XHRcdFx0PHNwYW5cclxuXHRcdFx0XHRcdFx0XHRzdHlsZT17e1xyXG5cdFx0XHRcdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBcIiNlMGUwZTBcIixcclxuXHRcdFx0XHRcdFx0XHRcdHBhZGRpbmc6IFwiNHB4IDhweFwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0Ym9yZGVyUmFkaXVzOiBcIjRweFwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0Zm9udFNpemU6IFwiMTJweFwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0Y29sb3I6IFwiIzY2NlwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0Zm9udFdlaWdodDogXCJib2xkXCIsXHJcblx0XHRcdFx0XHRcdFx0fX0+XHJcblx0XHRcdFx0XHRcdFx08J+TgSB7dGFzay5jYXRlZ29yeX1cclxuXHRcdFx0XHRcdFx0PC9zcGFuPlxyXG5cdFx0XHRcdFx0KX1cclxuXHJcblx0XHRcdFx0XHR7dGFzay5pc1JlY3VycmluZyAmJiB0YXNrLmZyZXF1ZW5jeSAmJiAoXHJcblx0XHRcdFx0XHRcdDxzcGFuXHJcblx0XHRcdFx0XHRcdFx0c3R5bGU9e3tcclxuXHRcdFx0XHRcdFx0XHRcdGJhY2tncm91bmRDb2xvcjogXCIjZTNmMmZkXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRwYWRkaW5nOiBcIjRweCA4cHhcIixcclxuXHRcdFx0XHRcdFx0XHRcdGJvcmRlclJhZGl1czogXCI0cHhcIixcclxuXHRcdFx0XHRcdFx0XHRcdGZvbnRTaXplOiBcIjEycHhcIixcclxuXHRcdFx0XHRcdFx0XHRcdGNvbG9yOiBcIiMxOTc2ZDJcIixcclxuXHRcdFx0XHRcdFx0XHRcdGZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxyXG5cdFx0XHRcdFx0XHRcdH19PlxyXG5cdFx0XHRcdFx0XHRcdPCflIQge2dldEZyZXF1ZW5jeVRleHQodGFzay5mcmVxdWVuY3kpfVxyXG5cdFx0XHRcdFx0XHRcdHt0YXNrLmludGVydmFsICYmIHRhc2suaW50ZXJ2YWwgPiAxICYmIGAgKCR7dGFzay5pbnRlcnZhbH0pYH1cclxuXHRcdFx0XHRcdFx0PC9zcGFuPlxyXG5cdFx0XHRcdFx0KX1cclxuXHJcblx0XHRcdFx0XHR7dGFzay50YWdzICYmIHRhc2sudGFncy5sZW5ndGggPiAwICYmIChcclxuXHRcdFx0XHRcdFx0PD5cclxuXHRcdFx0XHRcdFx0XHQ8c3BhblxyXG5cdFx0XHRcdFx0XHRcdFx0c3R5bGU9e3sgZm9udFNpemU6IFwiMTJweFwiLCBjb2xvcjogXCIjNjY2XCIsIGZvbnRXZWlnaHQ6IFwiYm9sZFwiIH19PlxyXG5cdFx0XHRcdFx0XHRcdFx0VGFnczpcclxuXHRcdFx0XHRcdFx0XHQ8L3NwYW4+XHJcblx0XHRcdFx0XHRcdFx0e3Rhc2sudGFncy5tYXAoKHRhZywgaW5kZXgpID0+IChcclxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGtleT17aW5kZXh9XHJcblx0XHRcdFx0XHRcdFx0XHRcdHN0eWxlPXt7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBcIiNmMGYwZjBcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYWRkaW5nOiBcIjRweCA4cHhcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRib3JkZXJSYWRpdXM6IFwiNHB4XCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9udFNpemU6IFwiMTJweFwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbG9yOiBcIiM2NjZcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRib3JkZXI6IFwiMXB4IHNvbGlkICNkZGRcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0fX0+XHJcblx0XHRcdFx0XHRcdFx0XHRcdPCfj7fvuI8ge3RhZ31cclxuXHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cclxuXHRcdFx0XHRcdFx0XHQpKX1cclxuXHRcdFx0XHRcdFx0PC8+XHJcblx0XHRcdFx0XHQpfVxyXG5cdFx0XHRcdDwvZGl2PlxyXG5cclxuXHRcdFx0XHR7LyogQXR0YWNobWVudHMgU2VjdGlvbiAtIFBsYWNlaG9sZGVyIGZvciBmdXR1cmUgaW1wbGVtZW50YXRpb24gKi99XHJcblx0XHRcdFx0ey8qIFxyXG5cdFx0XHRcdHt0YXNrLmF0dGFjaG1lbnRzICYmIHRhc2suYXR0YWNobWVudHMubGVuZ3RoID4gMCAmJiAoXHJcblx0XHRcdFx0XHQ8ZGl2IHN0eWxlPXt7IG1hcmdpblRvcDogXCIxNXB4XCIgfX0+XHJcblx0XHRcdFx0XHRcdDxoNCBzdHlsZT17eyBtYXJnaW46IFwiMCAwIDhweCAwXCIsIGZvbnRTaXplOiBcIjE0cHhcIiwgY29sb3I6IFwiIzY2NlwiLCBmb250V2VpZ2h0OiBcImJvbGRcIiB9fT5cclxuXHRcdFx0XHRcdFx0XHTwn5OOIEF0dGFjaG1lbnRzOlxyXG5cdFx0XHRcdFx0XHQ8L2g0PlxyXG5cdFx0XHRcdFx0XHQ8ZGl2IHN0eWxlPXt7XHJcblx0XHRcdFx0XHRcdFx0cGFkZGluZzogXCIxMHB4XCIsXHJcblx0XHRcdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCIsXHJcblx0XHRcdFx0XHRcdFx0Ym9yZGVyUmFkaXVzOiBcIjRweFwiLFxyXG5cdFx0XHRcdFx0XHRcdGJvcmRlcjogXCIxcHggc29saWQgI2UwZTBlMFwiLFxyXG5cdFx0XHRcdFx0XHR9fT5cclxuXHRcdFx0XHRcdFx0XHR7dGFzay5hdHRhY2htZW50cy5tYXAoKGF0dGFjaG1lbnQsIGluZGV4KSA9PiAoXHJcblx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGtleT17aW5kZXh9IHN0eWxlPXt7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGRpc3BsYXk6IFwiZmxleFwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRnYXA6IFwiOHB4XCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdG1hcmdpbkJvdHRvbTogXCI1cHhcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0Zm9udFNpemU6IFwiMTJweFwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRjb2xvcjogXCIjNjY2XCIsXHJcblx0XHRcdFx0XHRcdFx0XHR9fT5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4+8J+ThCB7YXR0YWNobWVudC5uYW1lfTwvc3Bhbj5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4+KHthdHRhY2htZW50LnNpemV9KTwvc3Bhbj5cclxuXHRcdFx0XHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdFx0XHRcdCkpfVxyXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdCl9XHJcblx0XHRcdFx0Ki99XHJcblxyXG5cdFx0XHRcdHsvKiBUYXNrIElEIGZvciByZWZlcmVuY2UgKi99XHJcblx0XHRcdFx0PGRpdlxyXG5cdFx0XHRcdFx0c3R5bGU9e3tcclxuXHRcdFx0XHRcdFx0bWFyZ2luVG9wOiBcIjEwcHhcIixcclxuXHRcdFx0XHRcdFx0Zm9udFNpemU6IFwiMTBweFwiLFxyXG5cdFx0XHRcdFx0XHRjb2xvcjogXCIjOTk5XCIsXHJcblx0XHRcdFx0XHRcdHRleHRBbGlnbjogXCJyaWdodFwiLFxyXG5cdFx0XHRcdFx0XHRmb250U3R5bGU6IFwiaXRhbGljXCIsXHJcblx0XHRcdFx0XHR9fT5cclxuXHRcdFx0XHRcdFRhc2sgSUQ6IHt0YXNrLmlkfVxyXG5cdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHQ8L2Rpdj5cclxuXHRcdCk7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIChcclxuXHRcdDxkaXZcclxuXHRcdFx0c3R5bGU9e3tcclxuXHRcdFx0XHRmb250RmFtaWx5OiBcIkFyaWFsLCBzYW5zLXNlcmlmXCIsXHJcblx0XHRcdFx0bWF4V2lkdGg6IFwiODAwcHhcIixcclxuXHRcdFx0XHRtYXJnaW46IFwiMCBhdXRvXCIsXHJcblx0XHRcdFx0cGFkZGluZzogXCIyMHB4XCIsXHJcblx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCIsXHJcblx0XHRcdFx0Y29sb3I6IFwiYmxhY2tcIixcclxuXHRcdFx0fX0+XHJcblx0XHRcdHsvKiBIZWFkZXIgKi99XHJcblx0XHRcdDxkaXZcclxuXHRcdFx0XHRzdHlsZT17e1xyXG5cdFx0XHRcdFx0dGV4dEFsaWduOiBcImNlbnRlclwiLFxyXG5cdFx0XHRcdFx0Ym9yZGVyQm90dG9tOiBcIjJweCBzb2xpZCAjMzMzXCIsXHJcblx0XHRcdFx0XHRwYWRkaW5nQm90dG9tOiBcIjIwcHhcIixcclxuXHRcdFx0XHRcdG1hcmdpbkJvdHRvbTogXCIzMHB4XCIsXHJcblx0XHRcdFx0fX0+XHJcblx0XHRcdFx0PGgxIHN0eWxlPXt7IG1hcmdpbjogXCIwXCIsIGNvbG9yOiBcIiMxOTc2ZDJcIiwgZm9udFNpemU6IFwiMjhweFwiIH19PlxyXG5cdFx0XHRcdFx0TXlEbyAtIFRhc2sgUmVwb3J0XHJcblx0XHRcdFx0PC9oMT5cclxuXHRcdFx0XHQ8cCBzdHlsZT17eyBtYXJnaW46IFwiMTBweCAwIDAgMFwiLCBjb2xvcjogXCIjNjY2XCIgfX0+XHJcblx0XHRcdFx0XHRHZW5lcmF0ZWQgb24ge2Zvcm1hdChwcmludERhdGUsIFwiUFBQICdhdCcgcFwiKX1cclxuXHRcdFx0XHQ8L3A+XHJcblx0XHRcdDwvZGl2PlxyXG5cclxuXHRcdFx0ey8qIFVzZXIgSW5mb3JtYXRpb24gKi99XHJcblx0XHRcdDxkaXZcclxuXHRcdFx0XHRzdHlsZT17e1xyXG5cdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIixcclxuXHRcdFx0XHRcdHBhZGRpbmc6IFwiMTVweFwiLFxyXG5cdFx0XHRcdFx0Ym9yZGVyUmFkaXVzOiBcIjhweFwiLFxyXG5cdFx0XHRcdFx0bWFyZ2luQm90dG9tOiBcIjMwcHhcIixcclxuXHRcdFx0XHR9fT5cclxuXHRcdFx0XHQ8aDIgc3R5bGU9e3sgbWFyZ2luOiBcIjAgMCAxMHB4IDBcIiwgZm9udFNpemU6IFwiMjBweFwiLCBjb2xvcjogXCIjMzMzXCIgfX0+XHJcblx0XHRcdFx0XHRVc2VyIEluZm9ybWF0aW9uXHJcblx0XHRcdFx0PC9oMj5cclxuXHRcdFx0XHQ8cCBzdHlsZT17eyBtYXJnaW46IFwiNXB4IDBcIiwgZm9udFNpemU6IFwiMTRweFwiIH19PlxyXG5cdFx0XHRcdFx0PHN0cm9uZz5OYW1lOjwvc3Ryb25nPiB7dXNlclByb2ZpbGUubmFtZX1cclxuXHRcdFx0XHQ8L3A+XHJcblx0XHRcdFx0PHAgc3R5bGU9e3sgbWFyZ2luOiBcIjVweCAwXCIsIGZvbnRTaXplOiBcIjE0cHhcIiB9fT5cclxuXHRcdFx0XHRcdDxzdHJvbmc+RW1haWw6PC9zdHJvbmc+IHt1c2VyUHJvZmlsZS5lbWFpbH1cclxuXHRcdFx0XHQ8L3A+XHJcblx0XHRcdDwvZGl2PlxyXG5cclxuXHRcdFx0ey8qIFN1bW1hcnkgKi99XHJcblx0XHRcdDxkaXZcclxuXHRcdFx0XHRzdHlsZT17e1xyXG5cdFx0XHRcdFx0ZGlzcGxheTogXCJncmlkXCIsXHJcblx0XHRcdFx0XHRncmlkVGVtcGxhdGVDb2x1bW5zOiBcInJlcGVhdChhdXRvLWZpdCwgbWlubWF4KDE1MHB4LCAxZnIpKVwiLFxyXG5cdFx0XHRcdFx0Z2FwOiBcIjE1cHhcIixcclxuXHRcdFx0XHRcdG1hcmdpbkJvdHRvbTogXCIzMHB4XCIsXHJcblx0XHRcdFx0fX0+XHJcblx0XHRcdFx0PGRpdlxyXG5cdFx0XHRcdFx0c3R5bGU9e3tcclxuXHRcdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBcIiNlM2YyZmRcIixcclxuXHRcdFx0XHRcdFx0cGFkZGluZzogXCIxNXB4XCIsXHJcblx0XHRcdFx0XHRcdGJvcmRlclJhZGl1czogXCI4cHhcIixcclxuXHRcdFx0XHRcdFx0dGV4dEFsaWduOiBcImNlbnRlclwiLFxyXG5cdFx0XHRcdFx0fX0+XHJcblx0XHRcdFx0XHQ8aDNcclxuXHRcdFx0XHRcdFx0c3R5bGU9e3sgbWFyZ2luOiBcIjAgMCA1cHggMFwiLCBmb250U2l6ZTogXCIyNHB4XCIsIGNvbG9yOiBcIiMxOTc2ZDJcIiB9fT5cclxuXHRcdFx0XHRcdFx0e3Rhc2tzLmxlbmd0aH1cclxuXHRcdFx0XHRcdDwvaDM+XHJcblx0XHRcdFx0XHQ8cCBzdHlsZT17eyBtYXJnaW46IFwiMFwiLCBmb250U2l6ZTogXCIxMnB4XCIsIGNvbG9yOiBcIiM2NjZcIiB9fT5cclxuXHRcdFx0XHRcdFx0VG90YWwgVGFza3NcclxuXHRcdFx0XHRcdDwvcD5cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHQ8ZGl2XHJcblx0XHRcdFx0XHRzdHlsZT17e1xyXG5cdFx0XHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmZjNlMFwiLFxyXG5cdFx0XHRcdFx0XHRwYWRkaW5nOiBcIjE1cHhcIixcclxuXHRcdFx0XHRcdFx0Ym9yZGVyUmFkaXVzOiBcIjhweFwiLFxyXG5cdFx0XHRcdFx0XHR0ZXh0QWxpZ246IFwiY2VudGVyXCIsXHJcblx0XHRcdFx0XHR9fT5cclxuXHRcdFx0XHRcdDxoM1xyXG5cdFx0XHRcdFx0XHRzdHlsZT17eyBtYXJnaW46IFwiMCAwIDVweCAwXCIsIGZvbnRTaXplOiBcIjI0cHhcIiwgY29sb3I6IFwiI2ZmOTgwMFwiIH19PlxyXG5cdFx0XHRcdFx0XHR7cGVuZGluZ1Rhc2tzLmxlbmd0aH1cclxuXHRcdFx0XHRcdDwvaDM+XHJcblx0XHRcdFx0XHQ8cCBzdHlsZT17eyBtYXJnaW46IFwiMFwiLCBmb250U2l6ZTogXCIxMnB4XCIsIGNvbG9yOiBcIiM2NjZcIiB9fT5cclxuXHRcdFx0XHRcdFx0UGVuZGluZ1xyXG5cdFx0XHRcdFx0PC9wPlxyXG5cdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdDxkaXZcclxuXHRcdFx0XHRcdHN0eWxlPXt7XHJcblx0XHRcdFx0XHRcdGJhY2tncm91bmRDb2xvcjogXCIjZThmNWU4XCIsXHJcblx0XHRcdFx0XHRcdHBhZGRpbmc6IFwiMTVweFwiLFxyXG5cdFx0XHRcdFx0XHRib3JkZXJSYWRpdXM6IFwiOHB4XCIsXHJcblx0XHRcdFx0XHRcdHRleHRBbGlnbjogXCJjZW50ZXJcIixcclxuXHRcdFx0XHRcdH19PlxyXG5cdFx0XHRcdFx0PGgzXHJcblx0XHRcdFx0XHRcdHN0eWxlPXt7IG1hcmdpbjogXCIwIDAgNXB4IDBcIiwgZm9udFNpemU6IFwiMjRweFwiLCBjb2xvcjogXCIjNGNhZjUwXCIgfX0+XHJcblx0XHRcdFx0XHRcdHtjb21wbGV0ZWRUYXNrcy5sZW5ndGh9XHJcblx0XHRcdFx0XHQ8L2gzPlxyXG5cdFx0XHRcdFx0PHAgc3R5bGU9e3sgbWFyZ2luOiBcIjBcIiwgZm9udFNpemU6IFwiMTJweFwiLCBjb2xvcjogXCIjNjY2XCIgfX0+XHJcblx0XHRcdFx0XHRcdENvbXBsZXRlZFxyXG5cdFx0XHRcdFx0PC9wPlxyXG5cdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdHtvdmVyZHVlVGFza3MubGVuZ3RoID4gMCAmJiAoXHJcblx0XHRcdFx0XHQ8ZGl2XHJcblx0XHRcdFx0XHRcdHN0eWxlPXt7XHJcblx0XHRcdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBcIiNmZmViZWVcIixcclxuXHRcdFx0XHRcdFx0XHRwYWRkaW5nOiBcIjE1cHhcIixcclxuXHRcdFx0XHRcdFx0XHRib3JkZXJSYWRpdXM6IFwiOHB4XCIsXHJcblx0XHRcdFx0XHRcdFx0dGV4dEFsaWduOiBcImNlbnRlclwiLFxyXG5cdFx0XHRcdFx0XHR9fT5cclxuXHRcdFx0XHRcdFx0PGgzXHJcblx0XHRcdFx0XHRcdFx0c3R5bGU9e3tcclxuXHRcdFx0XHRcdFx0XHRcdG1hcmdpbjogXCIwIDAgNXB4IDBcIixcclxuXHRcdFx0XHRcdFx0XHRcdGZvbnRTaXplOiBcIjI0cHhcIixcclxuXHRcdFx0XHRcdFx0XHRcdGNvbG9yOiBcIiNmNDQzMzZcIixcclxuXHRcdFx0XHRcdFx0XHR9fT5cclxuXHRcdFx0XHRcdFx0XHR7b3ZlcmR1ZVRhc2tzLmxlbmd0aH1cclxuXHRcdFx0XHRcdFx0PC9oMz5cclxuXHRcdFx0XHRcdFx0PHAgc3R5bGU9e3sgbWFyZ2luOiBcIjBcIiwgZm9udFNpemU6IFwiMTJweFwiLCBjb2xvcjogXCIjNjY2XCIgfX0+XHJcblx0XHRcdFx0XHRcdFx0T3ZlcmR1ZVxyXG5cdFx0XHRcdFx0XHQ8L3A+XHJcblx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHQpfVxyXG5cdFx0XHQ8L2Rpdj5cclxuXHJcblx0XHRcdHsvKiBUYXNrcyBieSBTdGF0dXMgKi99XHJcblx0XHRcdHsvKiBQZW5kaW5nIFRhc2tzICovfVxyXG5cdFx0XHR7cGVuZGluZ1Rhc2tzLmxlbmd0aCA+IDAgJiYgKFxyXG5cdFx0XHRcdDxkaXYgc3R5bGU9e3sgbWFyZ2luQm90dG9tOiBcIjMwcHhcIiB9fT5cclxuXHRcdFx0XHRcdDxoMlxyXG5cdFx0XHRcdFx0XHRzdHlsZT17e1xyXG5cdFx0XHRcdFx0XHRcdGJvcmRlckJvdHRvbTogXCIycHggc29saWQgI2ZmOTgwMFwiLFxyXG5cdFx0XHRcdFx0XHRcdHBhZGRpbmdCb3R0b206IFwiMTBweFwiLFxyXG5cdFx0XHRcdFx0XHRcdG1hcmdpbkJvdHRvbTogXCIyMHB4XCIsXHJcblx0XHRcdFx0XHRcdFx0Y29sb3I6IFwiIzMzM1wiLFxyXG5cdFx0XHRcdFx0XHRcdGZvbnRTaXplOiBcIjIycHhcIixcclxuXHRcdFx0XHRcdFx0fX0+XHJcblx0XHRcdFx0XHRcdFBlbmRpbmcgVGFza3MgKHtwZW5kaW5nVGFza3MubGVuZ3RofSlcclxuXHRcdFx0XHRcdDwvaDI+XHJcblx0XHRcdFx0XHR7cGVuZGluZ1Rhc2tzLm1hcCgodGFzaykgPT4gcmVuZGVyVGFza0NhcmQodGFzaykpfVxyXG5cdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHQpfVxyXG5cclxuXHRcdFx0ey8qIEluIFByb2dyZXNzIFRhc2tzICovfVxyXG5cdFx0XHR7aW5Qcm9ncmVzc1Rhc2tzLmxlbmd0aCA+IDAgJiYgKFxyXG5cdFx0XHRcdDxkaXYgc3R5bGU9e3sgbWFyZ2luQm90dG9tOiBcIjMwcHhcIiB9fT5cclxuXHRcdFx0XHRcdDxoMlxyXG5cdFx0XHRcdFx0XHRzdHlsZT17e1xyXG5cdFx0XHRcdFx0XHRcdGJvcmRlckJvdHRvbTogXCIycHggc29saWQgIzIxOTZmM1wiLFxyXG5cdFx0XHRcdFx0XHRcdHBhZGRpbmdCb3R0b206IFwiMTBweFwiLFxyXG5cdFx0XHRcdFx0XHRcdG1hcmdpbkJvdHRvbTogXCIyMHB4XCIsXHJcblx0XHRcdFx0XHRcdFx0Y29sb3I6IFwiIzMzM1wiLFxyXG5cdFx0XHRcdFx0XHRcdGZvbnRTaXplOiBcIjIycHhcIixcclxuXHRcdFx0XHRcdFx0fX0+XHJcblx0XHRcdFx0XHRcdEluIFByb2dyZXNzIFRhc2tzICh7aW5Qcm9ncmVzc1Rhc2tzLmxlbmd0aH0pXHJcblx0XHRcdFx0XHQ8L2gyPlxyXG5cdFx0XHRcdFx0e2luUHJvZ3Jlc3NUYXNrcy5tYXAoKHRhc2spID0+IHJlbmRlclRhc2tDYXJkKHRhc2spKX1cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0KX1cclxuXHJcblx0XHRcdHsvKiBDb21wbGV0ZWQgVGFza3MgKi99XHJcblx0XHRcdHtjb21wbGV0ZWRUYXNrcy5sZW5ndGggPiAwICYmIChcclxuXHRcdFx0XHQ8ZGl2IHN0eWxlPXt7IG1hcmdpbkJvdHRvbTogXCIzMHB4XCIgfX0+XHJcblx0XHRcdFx0XHQ8aDJcclxuXHRcdFx0XHRcdFx0c3R5bGU9e3tcclxuXHRcdFx0XHRcdFx0XHRib3JkZXJCb3R0b206IFwiMnB4IHNvbGlkICM0Y2FmNTBcIixcclxuXHRcdFx0XHRcdFx0XHRwYWRkaW5nQm90dG9tOiBcIjEwcHhcIixcclxuXHRcdFx0XHRcdFx0XHRtYXJnaW5Cb3R0b206IFwiMjBweFwiLFxyXG5cdFx0XHRcdFx0XHRcdGNvbG9yOiBcIiMzMzNcIixcclxuXHRcdFx0XHRcdFx0XHRmb250U2l6ZTogXCIyMnB4XCIsXHJcblx0XHRcdFx0XHRcdH19PlxyXG5cdFx0XHRcdFx0XHRDb21wbGV0ZWQgVGFza3MgKHtjb21wbGV0ZWRUYXNrcy5sZW5ndGh9KVxyXG5cdFx0XHRcdFx0PC9oMj5cclxuXHRcdFx0XHRcdHtjb21wbGV0ZWRUYXNrcy5tYXAoKHRhc2spID0+IHJlbmRlclRhc2tDYXJkKHRhc2ssIHRydWUpKX1cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0KX1cclxuXHJcblx0XHRcdHsvKiBPdmVyZHVlIFRhc2tzICovfVxyXG5cdFx0XHR7b3ZlcmR1ZVRhc2tzLmxlbmd0aCA+IDAgJiYgKFxyXG5cdFx0XHRcdDxkaXYgc3R5bGU9e3sgbWFyZ2luQm90dG9tOiBcIjMwcHhcIiB9fT5cclxuXHRcdFx0XHRcdDxoMlxyXG5cdFx0XHRcdFx0XHRzdHlsZT17e1xyXG5cdFx0XHRcdFx0XHRcdGJvcmRlckJvdHRvbTogXCIycHggc29saWQgI2Y0NDMzNlwiLFxyXG5cdFx0XHRcdFx0XHRcdHBhZGRpbmdCb3R0b206IFwiMTBweFwiLFxyXG5cdFx0XHRcdFx0XHRcdG1hcmdpbkJvdHRvbTogXCIyMHB4XCIsXHJcblx0XHRcdFx0XHRcdFx0Y29sb3I6IFwiIzMzM1wiLFxyXG5cdFx0XHRcdFx0XHRcdGZvbnRTaXplOiBcIjIycHhcIixcclxuXHRcdFx0XHRcdFx0fX0+XHJcblx0XHRcdFx0XHRcdOKaoO+4jyBPdmVyZHVlIFRhc2tzICh7b3ZlcmR1ZVRhc2tzLmxlbmd0aH0pXHJcblx0XHRcdFx0XHQ8L2gyPlxyXG5cdFx0XHRcdFx0e292ZXJkdWVUYXNrcy5tYXAoKHRhc2spID0+IHJlbmRlclRhc2tDYXJkKHRhc2spKX1cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0KX1cclxuXHJcblx0XHRcdHsvKiBGb290ZXIgKi99XHJcblx0XHRcdDxkaXZcclxuXHRcdFx0XHRzdHlsZT17e1xyXG5cdFx0XHRcdFx0bWFyZ2luVG9wOiBcIjQwcHhcIixcclxuXHRcdFx0XHRcdHBhZGRpbmdUb3A6IFwiMjBweFwiLFxyXG5cdFx0XHRcdFx0Ym9yZGVyVG9wOiBcIjFweCBzb2xpZCAjZGRkXCIsXHJcblx0XHRcdFx0XHR0ZXh0QWxpZ246IFwiY2VudGVyXCIsXHJcblx0XHRcdFx0XHRmb250U2l6ZTogXCIxMnB4XCIsXHJcblx0XHRcdFx0XHRjb2xvcjogXCIjNjY2XCIsXHJcblx0XHRcdFx0fX0+XHJcblx0XHRcdFx0PHAgc3R5bGU9e3sgbWFyZ2luOiBcIjBcIiB9fT5cclxuXHRcdFx0XHRcdFRoaXMgcmVwb3J0IHdhcyBnZW5lcmF0ZWQgYnkgTXlEbyBUYXNrIE1hbmFnZW1lbnQgU3lzdGVtXHJcblx0XHRcdFx0PC9wPlxyXG5cdFx0XHRcdDxwIHN0eWxlPXt7IG1hcmdpbjogXCI1cHggMCAwIDBcIiB9fT5cclxuXHRcdFx0XHRcdEZvciBtb3JlIGluZm9ybWF0aW9uLCB2aXNpdCB5b3VyIE15RG8gZGFzaGJvYXJkXHJcblx0XHRcdFx0PC9wPlxyXG5cdFx0XHQ8L2Rpdj5cclxuXHRcdDwvZGl2PlxyXG5cdCk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQcmludGFibGVUYXNrcztcclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiZm9ybWF0IiwiUHJpbnRhYmxlVGFza3MiLCJ0YXNrcyIsInVzZXJQcm9maWxlIiwicHJpbnREYXRlIiwiZ2V0UHJpb3JpdHlDb2xvciIsInByaW9yaXR5IiwiZ2V0U3RhdHVzVGV4dCIsInN0YXR1cyIsImdldFN0YXR1c0NvbG9yIiwiZ2V0RnJlcXVlbmN5VGV4dCIsImZyZXF1ZW5jeSIsImdldERheXNVbnRpbER1ZSIsImR1ZURhdGUiLCJkdWUiLCJEYXRlIiwibm93IiwiZGlmZlRpbWUiLCJnZXRUaW1lIiwiZGlmZkRheXMiLCJNYXRoIiwiY2VpbCIsInBlbmRpbmdUYXNrcyIsImZpbHRlciIsInRhc2siLCJpblByb2dyZXNzVGFza3MiLCJjb21wbGV0ZWRUYXNrcyIsIm92ZXJkdWVUYXNrcyIsImRheXNVbnRpbER1ZSIsInJlbmRlclRhc2tDYXJkIiwiaXNDb21wbGV0ZWQiLCJpc092ZXJkdWUiLCJkaXYiLCJzdHlsZSIsImJvcmRlciIsImJvcmRlclJhZGl1cyIsInBhZGRpbmciLCJtYXJnaW5Cb3R0b20iLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3hTaGFkb3ciLCJkaXNwbGF5IiwianVzdGlmeUNvbnRlbnQiLCJhbGlnbkl0ZW1zIiwiYm9yZGVyQm90dG9tIiwicGFkZGluZ0JvdHRvbSIsImgzIiwibWFyZ2luIiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwiY29sb3IiLCJmbGV4IiwidGV4dERlY29yYXRpb24iLCJ0aXRsZSIsImdhcCIsInNwYW4iLCJ0ZXh0VHJhbnNmb3JtIiwiZGVzY3JpcHRpb24iLCJoNCIsInAiLCJsaW5lSGVpZ2h0IiwiZ3JpZFRlbXBsYXRlQ29sdW1ucyIsInN0cm9uZyIsImJyIiwibWFyZ2luTGVmdCIsImFicyIsImNyZWF0ZWRBdCIsImZsZXhXcmFwIiwiY2F0ZWdvcnkiLCJpc1JlY3VycmluZyIsImludGVydmFsIiwidGFncyIsImxlbmd0aCIsIm1hcCIsInRhZyIsImluZGV4IiwibWFyZ2luVG9wIiwidGV4dEFsaWduIiwiZm9udFN0eWxlIiwiaWQiLCJmb250RmFtaWx5IiwibWF4V2lkdGgiLCJoMSIsImgyIiwibmFtZSIsImVtYWlsIiwicGFkZGluZ1RvcCIsImJvcmRlclRvcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/PrintableTasks.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/_lib/addLeadingZeros.mjs":
/*!********************************************************!*\
  !*** ./node_modules/date-fns/_lib/addLeadingZeros.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addLeadingZeros: function() { return /* binding */ addLeadingZeros; }\n/* harmony export */ });\nfunction addLeadingZeros(number, targetLength) {\n    const sign = number < 0 ? \"-\" : \"\";\n    const output = Math.abs(number).toString().padStart(targetLength, \"0\");\n    return sign + output;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9fbGliL2FkZExlYWRpbmdaZXJvcy5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLFNBQVNBLGdCQUFnQkMsTUFBTSxFQUFFQyxZQUFZO0lBQ2xELE1BQU1DLE9BQU9GLFNBQVMsSUFBSSxNQUFNO0lBQ2hDLE1BQU1HLFNBQVNDLEtBQUtDLEdBQUcsQ0FBQ0wsUUFBUU0sUUFBUSxHQUFHQyxRQUFRLENBQUNOLGNBQWM7SUFDbEUsT0FBT0MsT0FBT0M7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL19saWIvYWRkTGVhZGluZ1plcm9zLm1qcz9lY2RlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBhZGRMZWFkaW5nWmVyb3MobnVtYmVyLCB0YXJnZXRMZW5ndGgpIHtcbiAgY29uc3Qgc2lnbiA9IG51bWJlciA8IDAgPyBcIi1cIiA6IFwiXCI7XG4gIGNvbnN0IG91dHB1dCA9IE1hdGguYWJzKG51bWJlcikudG9TdHJpbmcoKS5wYWRTdGFydCh0YXJnZXRMZW5ndGgsIFwiMFwiKTtcbiAgcmV0dXJuIHNpZ24gKyBvdXRwdXQ7XG59XG4iXSwibmFtZXMiOlsiYWRkTGVhZGluZ1plcm9zIiwibnVtYmVyIiwidGFyZ2V0TGVuZ3RoIiwic2lnbiIsIm91dHB1dCIsIk1hdGgiLCJhYnMiLCJ0b1N0cmluZyIsInBhZFN0YXJ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/_lib/addLeadingZeros.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/_lib/defaultOptions.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/date-fns/_lib/defaultOptions.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDefaultOptions: function() { return /* binding */ getDefaultOptions; },\n/* harmony export */   setDefaultOptions: function() { return /* binding */ setDefaultOptions; }\n/* harmony export */ });\nlet defaultOptions = {};\nfunction getDefaultOptions() {\n    return defaultOptions;\n}\nfunction setDefaultOptions(newOptions) {\n    defaultOptions = newOptions;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9fbGliL2RlZmF1bHRPcHRpb25zLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLElBQUlBLGlCQUFpQixDQUFDO0FBRWYsU0FBU0M7SUFDZCxPQUFPRDtBQUNUO0FBRU8sU0FBU0Usa0JBQWtCQyxVQUFVO0lBQzFDSCxpQkFBaUJHO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9fbGliL2RlZmF1bHRPcHRpb25zLm1qcz81MGNhIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBkZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdE9wdGlvbnMoKSB7XG4gIHJldHVybiBkZWZhdWx0T3B0aW9ucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldERlZmF1bHRPcHRpb25zKG5ld09wdGlvbnMpIHtcbiAgZGVmYXVsdE9wdGlvbnMgPSBuZXdPcHRpb25zO1xufVxuIl0sIm5hbWVzIjpbImRlZmF1bHRPcHRpb25zIiwiZ2V0RGVmYXVsdE9wdGlvbnMiLCJzZXREZWZhdWx0T3B0aW9ucyIsIm5ld09wdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/_lib/defaultOptions.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/_lib/format/formatters.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/date-fns/_lib/format/formatters.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatters: function() { return /* binding */ formatters; }\n/* harmony export */ });\n/* harmony import */ var _getDayOfYear_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../getDayOfYear.mjs */ \"(app-pages-browser)/./node_modules/date-fns/getDayOfYear.mjs\");\n/* harmony import */ var _getISOWeek_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../getISOWeek.mjs */ \"(app-pages-browser)/./node_modules/date-fns/getISOWeek.mjs\");\n/* harmony import */ var _getISOWeekYear_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../getISOWeekYear.mjs */ \"(app-pages-browser)/./node_modules/date-fns/getISOWeekYear.mjs\");\n/* harmony import */ var _getWeek_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../getWeek.mjs */ \"(app-pages-browser)/./node_modules/date-fns/getWeek.mjs\");\n/* harmony import */ var _getWeekYear_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../getWeekYear.mjs */ \"(app-pages-browser)/./node_modules/date-fns/getWeekYear.mjs\");\n/* harmony import */ var _addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../addLeadingZeros.mjs */ \"(app-pages-browser)/./node_modules/date-fns/_lib/addLeadingZeros.mjs\");\n/* harmony import */ var _lightFormatters_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lightFormatters.mjs */ \"(app-pages-browser)/./node_modules/date-fns/_lib/format/lightFormatters.mjs\");\n\n\n\n\n\n\n\nconst dayPeriodEnum = {\n    am: \"am\",\n    pm: \"pm\",\n    midnight: \"midnight\",\n    noon: \"noon\",\n    morning: \"morning\",\n    afternoon: \"afternoon\",\n    evening: \"evening\",\n    night: \"night\"\n};\n/*\n * |     | Unit                           |     | Unit                           |\n * |-----|--------------------------------|-----|--------------------------------|\n * |  a  | AM, PM                         |  A* | Milliseconds in day            |\n * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |\n * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |\n * |  d  | Day of month                   |  D  | Day of year                    |\n * |  e  | Local day of week              |  E  | Day of week                    |\n * |  f  |                                |  F* | Day of week in month           |\n * |  g* | Modified Julian day            |  G  | Era                            |\n * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |\n * |  i! | ISO day of week                |  I! | ISO week of year               |\n * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |\n * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |\n * |  l* | (deprecated)                   |  L  | Stand-alone month              |\n * |  m  | Minute                         |  M  | Month                          |\n * |  n  |                                |  N  |                                |\n * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |\n * |  p! | Long localized time            |  P! | Long localized date            |\n * |  q  | Stand-alone quarter            |  Q  | Quarter                        |\n * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |\n * |  s  | Second                         |  S  | Fraction of second             |\n * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |\n * |  u  | Extended year                  |  U* | Cyclic year                    |\n * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |\n * |  w  | Local week of year             |  W* | Week of month                  |\n * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |\n * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |\n * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |\n *\n * Letters marked by * are not implemented but reserved by Unicode standard.\n *\n * Letters marked by ! are non-standard, but implemented by date-fns:\n * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)\n * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,\n *   i.e. 7 for Sunday, 1 for Monday, etc.\n * - `I` is ISO week of year, as opposed to `w` which is local week of year.\n * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.\n *   `R` is supposed to be used in conjunction with `I` and `i`\n *   for universal ISO week-numbering date, whereas\n *   `Y` is supposed to be used in conjunction with `w` and `e`\n *   for week-numbering date specific to the locale.\n * - `P` is long localized date format\n * - `p` is long localized time format\n */ const formatters = {\n    // Era\n    G: function(date, token, localize) {\n        const era = date.getFullYear() > 0 ? 1 : 0;\n        switch(token){\n            // AD, BC\n            case \"G\":\n            case \"GG\":\n            case \"GGG\":\n                return localize.era(era, {\n                    width: \"abbreviated\"\n                });\n            // A, B\n            case \"GGGGG\":\n                return localize.era(era, {\n                    width: \"narrow\"\n                });\n            // Anno Domini, Before Christ\n            case \"GGGG\":\n            default:\n                return localize.era(era, {\n                    width: \"wide\"\n                });\n        }\n    },\n    // Year\n    y: function(date, token, localize) {\n        // Ordinal number\n        if (token === \"yo\") {\n            const signedYear = date.getFullYear();\n            // Returns 1 for 1 BC (which is year 0 in JavaScript)\n            const year = signedYear > 0 ? signedYear : 1 - signedYear;\n            return localize.ordinalNumber(year, {\n                unit: \"year\"\n            });\n        }\n        return _lightFormatters_mjs__WEBPACK_IMPORTED_MODULE_0__.lightFormatters.y(date, token);\n    },\n    // Local week-numbering year\n    Y: function(date, token, localize, options) {\n        const signedWeekYear = (0,_getWeekYear_mjs__WEBPACK_IMPORTED_MODULE_1__.getWeekYear)(date, options);\n        // Returns 1 for 1 BC (which is year 0 in JavaScript)\n        const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;\n        // Two digit year\n        if (token === \"YY\") {\n            const twoDigitYear = weekYear % 100;\n            return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(twoDigitYear, 2);\n        }\n        // Ordinal number\n        if (token === \"Yo\") {\n            return localize.ordinalNumber(weekYear, {\n                unit: \"year\"\n            });\n        }\n        // Padding\n        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(weekYear, token.length);\n    },\n    // ISO week-numbering year\n    R: function(date, token) {\n        const isoWeekYear = (0,_getISOWeekYear_mjs__WEBPACK_IMPORTED_MODULE_3__.getISOWeekYear)(date);\n        // Padding\n        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(isoWeekYear, token.length);\n    },\n    // Extended year. This is a single number designating the year of this calendar system.\n    // The main difference between `y` and `u` localizers are B.C. years:\n    // | Year | `y` | `u` |\n    // |------|-----|-----|\n    // | AC 1 |   1 |   1 |\n    // | BC 1 |   1 |   0 |\n    // | BC 2 |   2 |  -1 |\n    // Also `yy` always returns the last two digits of a year,\n    // while `uu` pads single digit years to 2 characters and returns other years unchanged.\n    u: function(date, token) {\n        const year = date.getFullYear();\n        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(year, token.length);\n    },\n    // Quarter\n    Q: function(date, token, localize) {\n        const quarter = Math.ceil((date.getMonth() + 1) / 3);\n        switch(token){\n            // 1, 2, 3, 4\n            case \"Q\":\n                return String(quarter);\n            // 01, 02, 03, 04\n            case \"QQ\":\n                return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(quarter, 2);\n            // 1st, 2nd, 3rd, 4th\n            case \"Qo\":\n                return localize.ordinalNumber(quarter, {\n                    unit: \"quarter\"\n                });\n            // Q1, Q2, Q3, Q4\n            case \"QQQ\":\n                return localize.quarter(quarter, {\n                    width: \"abbreviated\",\n                    context: \"formatting\"\n                });\n            // 1, 2, 3, 4 (narrow quarter; could be not numerical)\n            case \"QQQQQ\":\n                return localize.quarter(quarter, {\n                    width: \"narrow\",\n                    context: \"formatting\"\n                });\n            // 1st quarter, 2nd quarter, ...\n            case \"QQQQ\":\n            default:\n                return localize.quarter(quarter, {\n                    width: \"wide\",\n                    context: \"formatting\"\n                });\n        }\n    },\n    // Stand-alone quarter\n    q: function(date, token, localize) {\n        const quarter = Math.ceil((date.getMonth() + 1) / 3);\n        switch(token){\n            // 1, 2, 3, 4\n            case \"q\":\n                return String(quarter);\n            // 01, 02, 03, 04\n            case \"qq\":\n                return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(quarter, 2);\n            // 1st, 2nd, 3rd, 4th\n            case \"qo\":\n                return localize.ordinalNumber(quarter, {\n                    unit: \"quarter\"\n                });\n            // Q1, Q2, Q3, Q4\n            case \"qqq\":\n                return localize.quarter(quarter, {\n                    width: \"abbreviated\",\n                    context: \"standalone\"\n                });\n            // 1, 2, 3, 4 (narrow quarter; could be not numerical)\n            case \"qqqqq\":\n                return localize.quarter(quarter, {\n                    width: \"narrow\",\n                    context: \"standalone\"\n                });\n            // 1st quarter, 2nd quarter, ...\n            case \"qqqq\":\n            default:\n                return localize.quarter(quarter, {\n                    width: \"wide\",\n                    context: \"standalone\"\n                });\n        }\n    },\n    // Month\n    M: function(date, token, localize) {\n        const month = date.getMonth();\n        switch(token){\n            case \"M\":\n            case \"MM\":\n                return _lightFormatters_mjs__WEBPACK_IMPORTED_MODULE_0__.lightFormatters.M(date, token);\n            // 1st, 2nd, ..., 12th\n            case \"Mo\":\n                return localize.ordinalNumber(month + 1, {\n                    unit: \"month\"\n                });\n            // Jan, Feb, ..., Dec\n            case \"MMM\":\n                return localize.month(month, {\n                    width: \"abbreviated\",\n                    context: \"formatting\"\n                });\n            // J, F, ..., D\n            case \"MMMMM\":\n                return localize.month(month, {\n                    width: \"narrow\",\n                    context: \"formatting\"\n                });\n            // January, February, ..., December\n            case \"MMMM\":\n            default:\n                return localize.month(month, {\n                    width: \"wide\",\n                    context: \"formatting\"\n                });\n        }\n    },\n    // Stand-alone month\n    L: function(date, token, localize) {\n        const month = date.getMonth();\n        switch(token){\n            // 1, 2, ..., 12\n            case \"L\":\n                return String(month + 1);\n            // 01, 02, ..., 12\n            case \"LL\":\n                return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(month + 1, 2);\n            // 1st, 2nd, ..., 12th\n            case \"Lo\":\n                return localize.ordinalNumber(month + 1, {\n                    unit: \"month\"\n                });\n            // Jan, Feb, ..., Dec\n            case \"LLL\":\n                return localize.month(month, {\n                    width: \"abbreviated\",\n                    context: \"standalone\"\n                });\n            // J, F, ..., D\n            case \"LLLLL\":\n                return localize.month(month, {\n                    width: \"narrow\",\n                    context: \"standalone\"\n                });\n            // January, February, ..., December\n            case \"LLLL\":\n            default:\n                return localize.month(month, {\n                    width: \"wide\",\n                    context: \"standalone\"\n                });\n        }\n    },\n    // Local week of year\n    w: function(date, token, localize, options) {\n        const week = (0,_getWeek_mjs__WEBPACK_IMPORTED_MODULE_4__.getWeek)(date, options);\n        if (token === \"wo\") {\n            return localize.ordinalNumber(week, {\n                unit: \"week\"\n            });\n        }\n        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(week, token.length);\n    },\n    // ISO week of year\n    I: function(date, token, localize) {\n        const isoWeek = (0,_getISOWeek_mjs__WEBPACK_IMPORTED_MODULE_5__.getISOWeek)(date);\n        if (token === \"Io\") {\n            return localize.ordinalNumber(isoWeek, {\n                unit: \"week\"\n            });\n        }\n        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(isoWeek, token.length);\n    },\n    // Day of the month\n    d: function(date, token, localize) {\n        if (token === \"do\") {\n            return localize.ordinalNumber(date.getDate(), {\n                unit: \"date\"\n            });\n        }\n        return _lightFormatters_mjs__WEBPACK_IMPORTED_MODULE_0__.lightFormatters.d(date, token);\n    },\n    // Day of year\n    D: function(date, token, localize) {\n        const dayOfYear = (0,_getDayOfYear_mjs__WEBPACK_IMPORTED_MODULE_6__.getDayOfYear)(date);\n        if (token === \"Do\") {\n            return localize.ordinalNumber(dayOfYear, {\n                unit: \"dayOfYear\"\n            });\n        }\n        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(dayOfYear, token.length);\n    },\n    // Day of week\n    E: function(date, token, localize) {\n        const dayOfWeek = date.getDay();\n        switch(token){\n            // Tue\n            case \"E\":\n            case \"EE\":\n            case \"EEE\":\n                return localize.day(dayOfWeek, {\n                    width: \"abbreviated\",\n                    context: \"formatting\"\n                });\n            // T\n            case \"EEEEE\":\n                return localize.day(dayOfWeek, {\n                    width: \"narrow\",\n                    context: \"formatting\"\n                });\n            // Tu\n            case \"EEEEEE\":\n                return localize.day(dayOfWeek, {\n                    width: \"short\",\n                    context: \"formatting\"\n                });\n            // Tuesday\n            case \"EEEE\":\n            default:\n                return localize.day(dayOfWeek, {\n                    width: \"wide\",\n                    context: \"formatting\"\n                });\n        }\n    },\n    // Local day of week\n    e: function(date, token, localize, options) {\n        const dayOfWeek = date.getDay();\n        const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;\n        switch(token){\n            // Numerical value (Nth day of week with current locale or weekStartsOn)\n            case \"e\":\n                return String(localDayOfWeek);\n            // Padded numerical value\n            case \"ee\":\n                return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(localDayOfWeek, 2);\n            // 1st, 2nd, ..., 7th\n            case \"eo\":\n                return localize.ordinalNumber(localDayOfWeek, {\n                    unit: \"day\"\n                });\n            case \"eee\":\n                return localize.day(dayOfWeek, {\n                    width: \"abbreviated\",\n                    context: \"formatting\"\n                });\n            // T\n            case \"eeeee\":\n                return localize.day(dayOfWeek, {\n                    width: \"narrow\",\n                    context: \"formatting\"\n                });\n            // Tu\n            case \"eeeeee\":\n                return localize.day(dayOfWeek, {\n                    width: \"short\",\n                    context: \"formatting\"\n                });\n            // Tuesday\n            case \"eeee\":\n            default:\n                return localize.day(dayOfWeek, {\n                    width: \"wide\",\n                    context: \"formatting\"\n                });\n        }\n    },\n    // Stand-alone local day of week\n    c: function(date, token, localize, options) {\n        const dayOfWeek = date.getDay();\n        const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;\n        switch(token){\n            // Numerical value (same as in `e`)\n            case \"c\":\n                return String(localDayOfWeek);\n            // Padded numerical value\n            case \"cc\":\n                return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(localDayOfWeek, token.length);\n            // 1st, 2nd, ..., 7th\n            case \"co\":\n                return localize.ordinalNumber(localDayOfWeek, {\n                    unit: \"day\"\n                });\n            case \"ccc\":\n                return localize.day(dayOfWeek, {\n                    width: \"abbreviated\",\n                    context: \"standalone\"\n                });\n            // T\n            case \"ccccc\":\n                return localize.day(dayOfWeek, {\n                    width: \"narrow\",\n                    context: \"standalone\"\n                });\n            // Tu\n            case \"cccccc\":\n                return localize.day(dayOfWeek, {\n                    width: \"short\",\n                    context: \"standalone\"\n                });\n            // Tuesday\n            case \"cccc\":\n            default:\n                return localize.day(dayOfWeek, {\n                    width: \"wide\",\n                    context: \"standalone\"\n                });\n        }\n    },\n    // ISO day of week\n    i: function(date, token, localize) {\n        const dayOfWeek = date.getDay();\n        const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;\n        switch(token){\n            // 2\n            case \"i\":\n                return String(isoDayOfWeek);\n            // 02\n            case \"ii\":\n                return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(isoDayOfWeek, token.length);\n            // 2nd\n            case \"io\":\n                return localize.ordinalNumber(isoDayOfWeek, {\n                    unit: \"day\"\n                });\n            // Tue\n            case \"iii\":\n                return localize.day(dayOfWeek, {\n                    width: \"abbreviated\",\n                    context: \"formatting\"\n                });\n            // T\n            case \"iiiii\":\n                return localize.day(dayOfWeek, {\n                    width: \"narrow\",\n                    context: \"formatting\"\n                });\n            // Tu\n            case \"iiiiii\":\n                return localize.day(dayOfWeek, {\n                    width: \"short\",\n                    context: \"formatting\"\n                });\n            // Tuesday\n            case \"iiii\":\n            default:\n                return localize.day(dayOfWeek, {\n                    width: \"wide\",\n                    context: \"formatting\"\n                });\n        }\n    },\n    // AM or PM\n    a: function(date, token, localize) {\n        const hours = date.getHours();\n        const dayPeriodEnumValue = hours / 12 >= 1 ? \"pm\" : \"am\";\n        switch(token){\n            case \"a\":\n            case \"aa\":\n                return localize.dayPeriod(dayPeriodEnumValue, {\n                    width: \"abbreviated\",\n                    context: \"formatting\"\n                });\n            case \"aaa\":\n                return localize.dayPeriod(dayPeriodEnumValue, {\n                    width: \"abbreviated\",\n                    context: \"formatting\"\n                }).toLowerCase();\n            case \"aaaaa\":\n                return localize.dayPeriod(dayPeriodEnumValue, {\n                    width: \"narrow\",\n                    context: \"formatting\"\n                });\n            case \"aaaa\":\n            default:\n                return localize.dayPeriod(dayPeriodEnumValue, {\n                    width: \"wide\",\n                    context: \"formatting\"\n                });\n        }\n    },\n    // AM, PM, midnight, noon\n    b: function(date, token, localize) {\n        const hours = date.getHours();\n        let dayPeriodEnumValue;\n        if (hours === 12) {\n            dayPeriodEnumValue = dayPeriodEnum.noon;\n        } else if (hours === 0) {\n            dayPeriodEnumValue = dayPeriodEnum.midnight;\n        } else {\n            dayPeriodEnumValue = hours / 12 >= 1 ? \"pm\" : \"am\";\n        }\n        switch(token){\n            case \"b\":\n            case \"bb\":\n                return localize.dayPeriod(dayPeriodEnumValue, {\n                    width: \"abbreviated\",\n                    context: \"formatting\"\n                });\n            case \"bbb\":\n                return localize.dayPeriod(dayPeriodEnumValue, {\n                    width: \"abbreviated\",\n                    context: \"formatting\"\n                }).toLowerCase();\n            case \"bbbbb\":\n                return localize.dayPeriod(dayPeriodEnumValue, {\n                    width: \"narrow\",\n                    context: \"formatting\"\n                });\n            case \"bbbb\":\n            default:\n                return localize.dayPeriod(dayPeriodEnumValue, {\n                    width: \"wide\",\n                    context: \"formatting\"\n                });\n        }\n    },\n    // in the morning, in the afternoon, in the evening, at night\n    B: function(date, token, localize) {\n        const hours = date.getHours();\n        let dayPeriodEnumValue;\n        if (hours >= 17) {\n            dayPeriodEnumValue = dayPeriodEnum.evening;\n        } else if (hours >= 12) {\n            dayPeriodEnumValue = dayPeriodEnum.afternoon;\n        } else if (hours >= 4) {\n            dayPeriodEnumValue = dayPeriodEnum.morning;\n        } else {\n            dayPeriodEnumValue = dayPeriodEnum.night;\n        }\n        switch(token){\n            case \"B\":\n            case \"BB\":\n            case \"BBB\":\n                return localize.dayPeriod(dayPeriodEnumValue, {\n                    width: \"abbreviated\",\n                    context: \"formatting\"\n                });\n            case \"BBBBB\":\n                return localize.dayPeriod(dayPeriodEnumValue, {\n                    width: \"narrow\",\n                    context: \"formatting\"\n                });\n            case \"BBBB\":\n            default:\n                return localize.dayPeriod(dayPeriodEnumValue, {\n                    width: \"wide\",\n                    context: \"formatting\"\n                });\n        }\n    },\n    // Hour [1-12]\n    h: function(date, token, localize) {\n        if (token === \"ho\") {\n            let hours = date.getHours() % 12;\n            if (hours === 0) hours = 12;\n            return localize.ordinalNumber(hours, {\n                unit: \"hour\"\n            });\n        }\n        return _lightFormatters_mjs__WEBPACK_IMPORTED_MODULE_0__.lightFormatters.h(date, token);\n    },\n    // Hour [0-23]\n    H: function(date, token, localize) {\n        if (token === \"Ho\") {\n            return localize.ordinalNumber(date.getHours(), {\n                unit: \"hour\"\n            });\n        }\n        return _lightFormatters_mjs__WEBPACK_IMPORTED_MODULE_0__.lightFormatters.H(date, token);\n    },\n    // Hour [0-11]\n    K: function(date, token, localize) {\n        const hours = date.getHours() % 12;\n        if (token === \"Ko\") {\n            return localize.ordinalNumber(hours, {\n                unit: \"hour\"\n            });\n        }\n        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(hours, token.length);\n    },\n    // Hour [1-24]\n    k: function(date, token, localize) {\n        let hours = date.getHours();\n        if (hours === 0) hours = 24;\n        if (token === \"ko\") {\n            return localize.ordinalNumber(hours, {\n                unit: \"hour\"\n            });\n        }\n        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(hours, token.length);\n    },\n    // Minute\n    m: function(date, token, localize) {\n        if (token === \"mo\") {\n            return localize.ordinalNumber(date.getMinutes(), {\n                unit: \"minute\"\n            });\n        }\n        return _lightFormatters_mjs__WEBPACK_IMPORTED_MODULE_0__.lightFormatters.m(date, token);\n    },\n    // Second\n    s: function(date, token, localize) {\n        if (token === \"so\") {\n            return localize.ordinalNumber(date.getSeconds(), {\n                unit: \"second\"\n            });\n        }\n        return _lightFormatters_mjs__WEBPACK_IMPORTED_MODULE_0__.lightFormatters.s(date, token);\n    },\n    // Fraction of second\n    S: function(date, token) {\n        return _lightFormatters_mjs__WEBPACK_IMPORTED_MODULE_0__.lightFormatters.S(date, token);\n    },\n    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)\n    X: function(date, token, _localize) {\n        const timezoneOffset = date.getTimezoneOffset();\n        if (timezoneOffset === 0) {\n            return \"Z\";\n        }\n        switch(token){\n            // Hours and optional minutes\n            case \"X\":\n                return formatTimezoneWithOptionalMinutes(timezoneOffset);\n            // Hours, minutes and optional seconds without `:` delimiter\n            // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets\n            // so this token always has the same output as `XX`\n            case \"XXXX\":\n            case \"XX\":\n                return formatTimezone(timezoneOffset);\n            // Hours, minutes and optional seconds with `:` delimiter\n            // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets\n            // so this token always has the same output as `XXX`\n            case \"XXXXX\":\n            case \"XXX\":\n            default:\n                return formatTimezone(timezoneOffset, \":\");\n        }\n    },\n    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)\n    x: function(date, token, _localize) {\n        const timezoneOffset = date.getTimezoneOffset();\n        switch(token){\n            // Hours and optional minutes\n            case \"x\":\n                return formatTimezoneWithOptionalMinutes(timezoneOffset);\n            // Hours, minutes and optional seconds without `:` delimiter\n            // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets\n            // so this token always has the same output as `xx`\n            case \"xxxx\":\n            case \"xx\":\n                return formatTimezone(timezoneOffset);\n            // Hours, minutes and optional seconds with `:` delimiter\n            // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets\n            // so this token always has the same output as `xxx`\n            case \"xxxxx\":\n            case \"xxx\":\n            default:\n                return formatTimezone(timezoneOffset, \":\");\n        }\n    },\n    // Timezone (GMT)\n    O: function(date, token, _localize) {\n        const timezoneOffset = date.getTimezoneOffset();\n        switch(token){\n            // Short\n            case \"O\":\n            case \"OO\":\n            case \"OOO\":\n                return \"GMT\" + formatTimezoneShort(timezoneOffset, \":\");\n            // Long\n            case \"OOOO\":\n            default:\n                return \"GMT\" + formatTimezone(timezoneOffset, \":\");\n        }\n    },\n    // Timezone (specific non-location)\n    z: function(date, token, _localize) {\n        const timezoneOffset = date.getTimezoneOffset();\n        switch(token){\n            // Short\n            case \"z\":\n            case \"zz\":\n            case \"zzz\":\n                return \"GMT\" + formatTimezoneShort(timezoneOffset, \":\");\n            // Long\n            case \"zzzz\":\n            default:\n                return \"GMT\" + formatTimezone(timezoneOffset, \":\");\n        }\n    },\n    // Seconds timestamp\n    t: function(date, token, _localize) {\n        const timestamp = Math.trunc(date.getTime() / 1000);\n        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(timestamp, token.length);\n    },\n    // Milliseconds timestamp\n    T: function(date, token, _localize) {\n        const timestamp = date.getTime();\n        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(timestamp, token.length);\n    }\n};\nfunction formatTimezoneShort(offset) {\n    let delimiter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n    const sign = offset > 0 ? \"-\" : \"+\";\n    const absOffset = Math.abs(offset);\n    const hours = Math.trunc(absOffset / 60);\n    const minutes = absOffset % 60;\n    if (minutes === 0) {\n        return sign + String(hours);\n    }\n    return sign + String(hours) + delimiter + (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(minutes, 2);\n}\nfunction formatTimezoneWithOptionalMinutes(offset, delimiter) {\n    if (offset % 60 === 0) {\n        const sign = offset > 0 ? \"-\" : \"+\";\n        return sign + (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(Math.abs(offset) / 60, 2);\n    }\n    return formatTimezone(offset, delimiter);\n}\nfunction formatTimezone(offset) {\n    let delimiter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n    const sign = offset > 0 ? \"-\" : \"+\";\n    const absOffset = Math.abs(offset);\n    const hours = (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(Math.trunc(absOffset / 60), 2);\n    const minutes = (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_2__.addLeadingZeros)(absOffset % 60, 2);\n    return sign + hours + delimiter + minutes;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9fbGliL2Zvcm1hdC9mb3JtYXR0ZXJzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFzRDtBQUNKO0FBQ1E7QUFDZDtBQUNRO0FBQ0s7QUFDRDtBQUV4RCxNQUFNTyxnQkFBZ0I7SUFDcEJDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxVQUFVO0lBQ1ZDLE1BQU07SUFDTkMsU0FBUztJQUNUQyxXQUFXO0lBQ1hDLFNBQVM7SUFDVEMsT0FBTztBQUNUO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNENDLEdBRU0sTUFBTUMsYUFBYTtJQUN4QixNQUFNO0lBQ05DLEdBQUcsU0FBVUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLFFBQVE7UUFDaEMsTUFBTUMsTUFBTUgsS0FBS0ksV0FBVyxLQUFLLElBQUksSUFBSTtRQUN6QyxPQUFRSDtZQUNOLFNBQVM7WUFDVCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsT0FBT0MsU0FBU0MsR0FBRyxDQUFDQSxLQUFLO29CQUFFRSxPQUFPO2dCQUFjO1lBQ2xELE9BQU87WUFDUCxLQUFLO2dCQUNILE9BQU9ILFNBQVNDLEdBQUcsQ0FBQ0EsS0FBSztvQkFBRUUsT0FBTztnQkFBUztZQUM3Qyw2QkFBNkI7WUFDN0IsS0FBSztZQUNMO2dCQUNFLE9BQU9ILFNBQVNDLEdBQUcsQ0FBQ0EsS0FBSztvQkFBRUUsT0FBTztnQkFBTztRQUM3QztJQUNGO0lBRUEsT0FBTztJQUNQQyxHQUFHLFNBQVVOLElBQUksRUFBRUMsS0FBSyxFQUFFQyxRQUFRO1FBQ2hDLGlCQUFpQjtRQUNqQixJQUFJRCxVQUFVLE1BQU07WUFDbEIsTUFBTU0sYUFBYVAsS0FBS0ksV0FBVztZQUNuQyxxREFBcUQ7WUFDckQsTUFBTUksT0FBT0QsYUFBYSxJQUFJQSxhQUFhLElBQUlBO1lBQy9DLE9BQU9MLFNBQVNPLGFBQWEsQ0FB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UUFDckIsTUFBTUUsT0FBT0YsU0FBUyxJQUFJLE1BQU07UUFDaEMsT0FBT0UsT0FBT2hHLHFFQUFlQSxDQUFDbUMsS0FBSytELEdBQUcsQ0FBQ0osVUFBVSxJQUFJO0lBQ3ZEO0lBQ0EsT0FBT1YsZUFBZVUsUUFBUUM7QUFDaEM7QUFFQSxTQUFTWCxlQUFlVSxNQUFNO1FBQUVDLFlBQUFBLGlFQUFZO0lBQzFDLE1BQU1DLE9BQU9GLFNBQVMsSUFBSSxNQUFNO0lBQ2hDLE1BQU1HLFlBQVk5RCxLQUFLK0QsR0FBRyxDQUFDSjtJQUMzQixNQUFNL0IsUUFBUS9ELHFFQUFlQSxDQUFDbUMsS0FBS3dELEtBQUssQ0FBQ00sWUFBWSxLQUFLO0lBQzFELE1BQU1FLFVBQVVuRyxxRUFBZUEsQ0FBQ2lHLFlBQVksSUFBSTtJQUNoRCxPQUFPRCxPQUFPakMsUUFBUWdDLFlBQVlJO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9fbGliL2Zvcm1hdC9mb3JtYXR0ZXJzLm1qcz8wYTAzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldERheU9mWWVhciB9IGZyb20gXCIuLi8uLi9nZXREYXlPZlllYXIubWpzXCI7XG5pbXBvcnQgeyBnZXRJU09XZWVrIH0gZnJvbSBcIi4uLy4uL2dldElTT1dlZWsubWpzXCI7XG5pbXBvcnQgeyBnZXRJU09XZWVrWWVhciB9IGZyb20gXCIuLi8uLi9nZXRJU09XZWVrWWVhci5tanNcIjtcbmltcG9ydCB7IGdldFdlZWsgfSBmcm9tIFwiLi4vLi4vZ2V0V2Vlay5tanNcIjtcbmltcG9ydCB7IGdldFdlZWtZZWFyIH0gZnJvbSBcIi4uLy4uL2dldFdlZWtZZWFyLm1qc1wiO1xuaW1wb3J0IHsgYWRkTGVhZGluZ1plcm9zIH0gZnJvbSBcIi4uL2FkZExlYWRpbmdaZXJvcy5tanNcIjtcbmltcG9ydCB7IGxpZ2h0Rm9ybWF0dGVycyB9IGZyb20gXCIuL2xpZ2h0Rm9ybWF0dGVycy5tanNcIjtcblxuY29uc3QgZGF5UGVyaW9kRW51bSA9IHtcbiAgYW06IFwiYW1cIixcbiAgcG06IFwicG1cIixcbiAgbWlkbmlnaHQ6IFwibWlkbmlnaHRcIixcbiAgbm9vbjogXCJub29uXCIsXG4gIG1vcm5pbmc6IFwibW9ybmluZ1wiLFxuICBhZnRlcm5vb246IFwiYWZ0ZXJub29uXCIsXG4gIGV2ZW5pbmc6IFwiZXZlbmluZ1wiLFxuICBuaWdodDogXCJuaWdodFwiLFxufTtcblxuLypcbiAqIHwgICAgIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgIGEgIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgIHwgIEEqIHwgTWlsbGlzZWNvbmRzIGluIGRheSAgICAgICAgICAgIHxcbiAqIHwgIGIgIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgIHwgIEIgIHwgRmxleGlibGUgZGF5IHBlcmlvZCAgICAgICAgICAgIHxcbiAqIHwgIGMgIHwgU3RhbmQtYWxvbmUgbG9jYWwgZGF5IG9mIHdlZWsgIHwgIEMqIHwgTG9jYWxpemVkIGhvdXIgdy8gZGF5IHBlcmlvZCAgIHxcbiAqIHwgIGQgIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgICAgICAgIHwgIEQgIHwgRGF5IG9mIHllYXIgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGUgIHwgTG9jYWwgZGF5IG9mIHdlZWsgICAgICAgICAgICAgIHwgIEUgIHwgRGF5IG9mIHdlZWsgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGYgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIEYqIHwgRGF5IG9mIHdlZWsgaW4gbW9udGggICAgICAgICAgIHxcbiAqIHwgIGcqIHwgTW9kaWZpZWQgSnVsaWFuIGRheSAgICAgICAgICAgIHwgIEcgIHwgRXJhICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGggIHwgSG91ciBbMS0xMl0gICAgICAgICAgICAgICAgICAgIHwgIEggIHwgSG91ciBbMC0yM10gICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGkhIHwgSVNPIGRheSBvZiB3ZWVrICAgICAgICAgICAgICAgIHwgIEkhIHwgSVNPIHdlZWsgb2YgeWVhciAgICAgICAgICAgICAgIHxcbiAqIHwgIGoqIHwgTG9jYWxpemVkIGhvdXIgdy8gZGF5IHBlcmlvZCAgIHwgIEoqIHwgTG9jYWxpemVkIGhvdXIgdy9vIGRheSBwZXJpb2QgIHxcbiAqIHwgIGsgIHwgSG91ciBbMS0yNF0gICAgICAgICAgICAgICAgICAgIHwgIEsgIHwgSG91ciBbMC0xMV0gICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIGwqIHwgKGRlcHJlY2F0ZWQpICAgICAgICAgICAgICAgICAgIHwgIEwgIHwgU3RhbmQtYWxvbmUgbW9udGggICAgICAgICAgICAgIHxcbiAqIHwgIG0gIHwgTWludXRlICAgICAgICAgICAgICAgICAgICAgICAgIHwgIE0gIHwgTW9udGggICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIG4gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIE4gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIG8hIHwgT3JkaW5hbCBudW1iZXIgbW9kaWZpZXIgICAgICAgIHwgIE8gIHwgVGltZXpvbmUgKEdNVCkgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHAhIHwgTG9uZyBsb2NhbGl6ZWQgdGltZSAgICAgICAgICAgIHwgIFAhIHwgTG9uZyBsb2NhbGl6ZWQgZGF0ZSAgICAgICAgICAgIHxcbiAqIHwgIHEgIHwgU3RhbmQtYWxvbmUgcXVhcnRlciAgICAgICAgICAgIHwgIFEgIHwgUXVhcnRlciAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHIqIHwgUmVsYXRlZCBHcmVnb3JpYW4geWVhciAgICAgICAgIHwgIFIhIHwgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICAgIHxcbiAqIHwgIHMgIHwgU2Vjb25kICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFMgIHwgRnJhY3Rpb24gb2Ygc2Vjb25kICAgICAgICAgICAgIHxcbiAqIHwgIHQhIHwgU2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICAgICAgIHwgIFQhIHwgTWlsbGlzZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgIHxcbiAqIHwgIHUgIHwgRXh0ZW5kZWQgeWVhciAgICAgICAgICAgICAgICAgIHwgIFUqIHwgQ3ljbGljIHllYXIgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHYqIHwgVGltZXpvbmUgKGdlbmVyaWMgbm9uLWxvY2F0LikgIHwgIFYqIHwgVGltZXpvbmUgKGxvY2F0aW9uKSAgICAgICAgICAgIHxcbiAqIHwgIHcgIHwgTG9jYWwgd2VlayBvZiB5ZWFyICAgICAgICAgICAgIHwgIFcqIHwgV2VlayBvZiBtb250aCAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIHggIHwgVGltZXpvbmUgKElTTy04NjAxIHcvbyBaKSAgICAgIHwgIFggIHwgVGltZXpvbmUgKElTTy04NjAxKSAgICAgICAgICAgIHxcbiAqIHwgIHkgIHwgWWVhciAoYWJzKSAgICAgICAgICAgICAgICAgICAgIHwgIFkgIHwgTG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhciAgICAgIHxcbiAqIHwgIHogIHwgVGltZXpvbmUgKHNwZWNpZmljIG5vbi1sb2NhdC4pIHwgIFoqIHwgVGltZXpvbmUgKGFsaWFzZXMpICAgICAgICAgICAgIHxcbiAqXG4gKiBMZXR0ZXJzIG1hcmtlZCBieSAqIGFyZSBub3QgaW1wbGVtZW50ZWQgYnV0IHJlc2VydmVkIGJ5IFVuaWNvZGUgc3RhbmRhcmQuXG4gKlxuICogTGV0dGVycyBtYXJrZWQgYnkgISBhcmUgbm9uLXN0YW5kYXJkLCBidXQgaW1wbGVtZW50ZWQgYnkgZGF0ZS1mbnM6XG4gKiAtIGBvYCBtb2RpZmllcyB0aGUgcHJldmlvdXMgdG9rZW4gdG8gdHVybiBpdCBpbnRvIGFuIG9yZGluYWwgKHNlZSBgZm9ybWF0YCBkb2NzKVxuICogLSBgaWAgaXMgSVNPIGRheSBvZiB3ZWVrLiBGb3IgYGlgIGFuZCBgaWlgIGlzIHJldHVybnMgbnVtZXJpYyBJU08gd2VlayBkYXlzLFxuICogICBpLmUuIDcgZm9yIFN1bmRheSwgMSBmb3IgTW9uZGF5LCBldGMuXG4gKiAtIGBJYCBpcyBJU08gd2VlayBvZiB5ZWFyLCBhcyBvcHBvc2VkIHRvIGB3YCB3aGljaCBpcyBsb2NhbCB3ZWVrIG9mIHllYXIuXG4gKiAtIGBSYCBpcyBJU08gd2Vlay1udW1iZXJpbmcgeWVhciwgYXMgb3Bwb3NlZCB0byBgWWAgd2hpY2ggaXMgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhci5cbiAqICAgYFJgIGlzIHN1cHBvc2VkIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgSWAgYW5kIGBpYFxuICogICBmb3IgdW5pdmVyc2FsIElTTyB3ZWVrLW51bWJlcmluZyBkYXRlLCB3aGVyZWFzXG4gKiAgIGBZYCBpcyBzdXBwb3NlZCB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYHdgIGFuZCBgZWBcbiAqICAgZm9yIHdlZWstbnVtYmVyaW5nIGRhdGUgc3BlY2lmaWMgdG8gdGhlIGxvY2FsZS5cbiAqIC0gYFBgIGlzIGxvbmcgbG9jYWxpemVkIGRhdGUgZm9ybWF0XG4gKiAtIGBwYCBpcyBsb25nIGxvY2FsaXplZCB0aW1lIGZvcm1hdFxuICovXG5cbmV4cG9ydCBjb25zdCBmb3JtYXR0ZXJzID0ge1xuICAvLyBFcmFcbiAgRzogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGNvbnN0IGVyYSA9IGRhdGUuZ2V0RnVsbFllYXIoKSA+IDAgPyAxIDogMDtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBBRCwgQkNcbiAgICAgIGNhc2UgXCJHXCI6XG4gICAgICBjYXNlIFwiR0dcIjpcbiAgICAgIGNhc2UgXCJHR0dcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmVyYShlcmEsIHsgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIiB9KTtcbiAgICAgIC8vIEEsIEJcbiAgICAgIGNhc2UgXCJHR0dHR1wiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZXJhKGVyYSwgeyB3aWR0aDogXCJuYXJyb3dcIiB9KTtcbiAgICAgIC8vIEFubm8gRG9taW5pLCBCZWZvcmUgQ2hyaXN0XG4gICAgICBjYXNlIFwiR0dHR1wiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmVyYShlcmEsIHsgd2lkdGg6IFwid2lkZVwiIH0pO1xuICAgIH1cbiAgfSxcblxuICAvLyBZZWFyXG4gIHk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICAvLyBPcmRpbmFsIG51bWJlclxuICAgIGlmICh0b2tlbiA9PT0gXCJ5b1wiKSB7XG4gICAgICBjb25zdCBzaWduZWRZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgLy8gUmV0dXJucyAxIGZvciAxIEJDICh3aGljaCBpcyB5ZWFyIDAgaW4gSmF2YVNjcmlwdClcbiAgICAgIGNvbnN0IHllYXIgPSBzaWduZWRZZWFyID4gMCA/IHNpZ25lZFllYXIgOiAxIC0gc2lnbmVkWWVhcjtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKHllYXIsIHsgdW5pdDogXCJ5ZWFyXCIgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpZ2h0Rm9ybWF0dGVycy55KGRhdGUsIHRva2VuKTtcbiAgfSxcblxuICAvLyBMb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gIFk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzaWduZWRXZWVrWWVhciA9IGdldFdlZWtZZWFyKGRhdGUsIG9wdGlvbnMpO1xuICAgIC8vIFJldHVybnMgMSBmb3IgMSBCQyAod2hpY2ggaXMgeWVhciAwIGluIEphdmFTY3JpcHQpXG4gICAgY29uc3Qgd2Vla1llYXIgPSBzaWduZWRXZWVrWWVhciA+IDAgPyBzaWduZWRXZWVrWWVhciA6IDEgLSBzaWduZWRXZWVrWWVhcjtcblxuICAgIC8vIFR3byBkaWdpdCB5ZWFyXG4gICAgaWYgKHRva2VuID09PSBcIllZXCIpIHtcbiAgICAgIGNvbnN0IHR3b0RpZ2l0WWVhciA9IHdlZWtZZWFyICUgMTAwO1xuICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh0d29EaWdpdFllYXIsIDIpO1xuICAgIH1cblxuICAgIC8vIE9yZGluYWwgbnVtYmVyXG4gICAgaWYgKHRva2VuID09PSBcIllvXCIpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKHdlZWtZZWFyLCB7IHVuaXQ6IFwieWVhclwiIH0pO1xuICAgIH1cblxuICAgIC8vIFBhZGRpbmdcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHdlZWtZZWFyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuXG4gIC8vIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gIFI6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbikge1xuICAgIGNvbnN0IGlzb1dlZWtZZWFyID0gZ2V0SVNPV2Vla1llYXIoZGF0ZSk7XG5cbiAgICAvLyBQYWRkaW5nXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhpc29XZWVrWWVhciwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBFeHRlbmRlZCB5ZWFyLiBUaGlzIGlzIGEgc2luZ2xlIG51bWJlciBkZXNpZ25hdGluZyB0aGUgeWVhciBvZiB0aGlzIGNhbGVuZGFyIHN5c3RlbS5cbiAgLy8gVGhlIG1haW4gZGlmZmVyZW5jZSBiZXR3ZWVuIGB5YCBhbmQgYHVgIGxvY2FsaXplcnMgYXJlIEIuQy4geWVhcnM6XG4gIC8vIHwgWWVhciB8IGB5YCB8IGB1YCB8XG4gIC8vIHwtLS0tLS18LS0tLS18LS0tLS18XG4gIC8vIHwgQUMgMSB8ICAgMSB8ICAgMSB8XG4gIC8vIHwgQkMgMSB8ICAgMSB8ICAgMCB8XG4gIC8vIHwgQkMgMiB8ICAgMiB8ICAtMSB8XG4gIC8vIEFsc28gYHl5YCBhbHdheXMgcmV0dXJucyB0aGUgbGFzdCB0d28gZGlnaXRzIG9mIGEgeWVhcixcbiAgLy8gd2hpbGUgYHV1YCBwYWRzIHNpbmdsZSBkaWdpdCB5ZWFycyB0byAyIGNoYXJhY3RlcnMgYW5kIHJldHVybnMgb3RoZXIgeWVhcnMgdW5jaGFuZ2VkLlxuICB1OiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoeWVhciwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBRdWFydGVyXG4gIFE6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBjb25zdCBxdWFydGVyID0gTWF0aC5jZWlsKChkYXRlLmdldE1vbnRoKCkgKyAxKSAvIDMpO1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIDEsIDIsIDMsIDRcbiAgICAgIGNhc2UgXCJRXCI6XG4gICAgICAgIHJldHVybiBTdHJpbmcocXVhcnRlcik7XG4gICAgICAvLyAwMSwgMDIsIDAzLCAwNFxuICAgICAgY2FzZSBcIlFRXCI6XG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MocXVhcnRlciwgMik7XG4gICAgICAvLyAxc3QsIDJuZCwgM3JkLCA0dGhcbiAgICAgIGNhc2UgXCJRb1wiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihxdWFydGVyLCB7IHVuaXQ6IFwicXVhcnRlclwiIH0pO1xuICAgICAgLy8gUTEsIFEyLCBRMywgUTRcbiAgICAgIGNhc2UgXCJRUVFcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge1xuICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gMSwgMiwgMywgNCAobmFycm93IHF1YXJ0ZXI7IGNvdWxkIGJlIG5vdCBudW1lcmljYWwpXG4gICAgICBjYXNlIFwiUVFRUVFcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge1xuICAgICAgICAgIHdpZHRoOiBcIm5hcnJvd1wiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIC8vIDFzdCBxdWFydGVyLCAybmQgcXVhcnRlciwgLi4uXG4gICAgICBjYXNlIFwiUVFRUVwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge1xuICAgICAgICAgIHdpZHRoOiBcIndpZGVcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFN0YW5kLWFsb25lIHF1YXJ0ZXJcbiAgcTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGNvbnN0IHF1YXJ0ZXIgPSBNYXRoLmNlaWwoKGRhdGUuZ2V0TW9udGgoKSArIDEpIC8gMyk7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gMSwgMiwgMywgNFxuICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhxdWFydGVyKTtcbiAgICAgIC8vIDAxLCAwMiwgMDMsIDA0XG4gICAgICBjYXNlIFwicXFcIjpcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhxdWFydGVyLCAyKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAzcmQsIDR0aFxuICAgICAgY2FzZSBcInFvXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKHF1YXJ0ZXIsIHsgdW5pdDogXCJxdWFydGVyXCIgfSk7XG4gICAgICAvLyBRMSwgUTIsIFEzLCBRNFxuICAgICAgY2FzZSBcInFxcVwiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7XG4gICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICBjb250ZXh0OiBcInN0YW5kYWxvbmVcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyAxLCAyLCAzLCA0IChuYXJyb3cgcXVhcnRlcjsgY291bGQgYmUgbm90IG51bWVyaWNhbClcbiAgICAgIGNhc2UgXCJxcXFxcVwiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJzdGFuZGFsb25lXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi5cbiAgICAgIGNhc2UgXCJxcXFxXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7XG4gICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gTW9udGhcbiAgTTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGNvbnN0IG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJNXCI6XG4gICAgICBjYXNlIFwiTU1cIjpcbiAgICAgICAgcmV0dXJuIGxpZ2h0Rm9ybWF0dGVycy5NKGRhdGUsIHRva2VuKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDEydGhcbiAgICAgIGNhc2UgXCJNb1wiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihtb250aCArIDEsIHsgdW5pdDogXCJtb250aFwiIH0pO1xuICAgICAgLy8gSmFuLCBGZWIsIC4uLiwgRGVjXG4gICAgICBjYXNlIFwiTU1NXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwge1xuICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gSiwgRiwgLi4uLCBEXG4gICAgICBjYXNlIFwiTU1NTU1cIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXJcbiAgICAgIGNhc2UgXCJNTU1NXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHsgd2lkdGg6IFwid2lkZVwiLCBjb250ZXh0OiBcImZvcm1hdHRpbmdcIiB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gU3RhbmQtYWxvbmUgbW9udGhcbiAgTDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGNvbnN0IG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIDEsIDIsIC4uLiwgMTJcbiAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgIHJldHVybiBTdHJpbmcobW9udGggKyAxKTtcbiAgICAgIC8vIDAxLCAwMiwgLi4uLCAxMlxuICAgICAgY2FzZSBcIkxMXCI6XG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MobW9udGggKyAxLCAyKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDEydGhcbiAgICAgIGNhc2UgXCJMb1wiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihtb250aCArIDEsIHsgdW5pdDogXCJtb250aFwiIH0pO1xuICAgICAgLy8gSmFuLCBGZWIsIC4uLiwgRGVjXG4gICAgICBjYXNlIFwiTExMXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwge1xuICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgY29udGV4dDogXCJzdGFuZGFsb25lXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gSiwgRiwgLi4uLCBEXG4gICAgICBjYXNlIFwiTExMTExcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJzdGFuZGFsb25lXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXJcbiAgICAgIGNhc2UgXCJMTExMXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHsgd2lkdGg6IFwid2lkZVwiLCBjb250ZXh0OiBcInN0YW5kYWxvbmVcIiB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gTG9jYWwgd2VlayBvZiB5ZWFyXG4gIHc6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB3ZWVrID0gZ2V0V2VlayhkYXRlLCBvcHRpb25zKTtcblxuICAgIGlmICh0b2tlbiA9PT0gXCJ3b1wiKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcih3ZWVrLCB7IHVuaXQ6IFwid2Vla1wiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3Mod2VlaywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBJU08gd2VlayBvZiB5ZWFyXG4gIEk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBjb25zdCBpc29XZWVrID0gZ2V0SVNPV2VlayhkYXRlKTtcblxuICAgIGlmICh0b2tlbiA9PT0gXCJJb1wiKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihpc29XZWVrLCB7IHVuaXQ6IFwid2Vla1wiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoaXNvV2VlaywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBEYXkgb2YgdGhlIG1vbnRoXG4gIGQ6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBpZiAodG9rZW4gPT09IFwiZG9cIikge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF0ZS5nZXREYXRlKCksIHsgdW5pdDogXCJkYXRlXCIgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpZ2h0Rm9ybWF0dGVycy5kKGRhdGUsIHRva2VuKTtcbiAgfSxcblxuICAvLyBEYXkgb2YgeWVhclxuICBEOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgY29uc3QgZGF5T2ZZZWFyID0gZ2V0RGF5T2ZZZWFyKGRhdGUpO1xuXG4gICAgaWYgKHRva2VuID09PSBcIkRvXCIpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGRheU9mWWVhciwgeyB1bml0OiBcImRheU9mWWVhclwiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF5T2ZZZWFyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuXG4gIC8vIERheSBvZiB3ZWVrXG4gIEU6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBjb25zdCBkYXlPZldlZWsgPSBkYXRlLmdldERheSgpO1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIC8vIFR1ZVxuICAgICAgY2FzZSBcIkVcIjpcbiAgICAgIGNhc2UgXCJFRVwiOlxuICAgICAgY2FzZSBcIkVFRVwiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gVFxuICAgICAgY2FzZSBcIkVFRUVFXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVcbiAgICAgIGNhc2UgXCJFRUVFRUVcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogXCJzaG9ydFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIC8vIFR1ZXNkYXlcbiAgICAgIGNhc2UgXCJFRUVFXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiBcIndpZGVcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIExvY2FsIGRheSBvZiB3ZWVrXG4gIGU6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkYXlPZldlZWsgPSBkYXRlLmdldERheSgpO1xuICAgIGNvbnN0IGxvY2FsRGF5T2ZXZWVrID0gKGRheU9mV2VlayAtIG9wdGlvbnMud2Vla1N0YXJ0c09uICsgOCkgJSA3IHx8IDc7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gTnVtZXJpY2FsIHZhbHVlIChOdGggZGF5IG9mIHdlZWsgd2l0aCBjdXJyZW50IGxvY2FsZSBvciB3ZWVrU3RhcnRzT24pXG4gICAgICBjYXNlIFwiZVwiOlxuICAgICAgICByZXR1cm4gU3RyaW5nKGxvY2FsRGF5T2ZXZWVrKTtcbiAgICAgIC8vIFBhZGRlZCBudW1lcmljYWwgdmFsdWVcbiAgICAgIGNhc2UgXCJlZVwiOlxuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGxvY2FsRGF5T2ZXZWVrLCAyKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDd0aFxuICAgICAgY2FzZSBcImVvXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGxvY2FsRGF5T2ZXZWVrLCB7IHVuaXQ6IFwiZGF5XCIgfSk7XG4gICAgICBjYXNlIFwiZWVlXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyBUXG4gICAgICBjYXNlIFwiZWVlZWVcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdVxuICAgICAgY2FzZSBcImVlZWVlZVwiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiBcInNob3J0XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVlc2RheVxuICAgICAgY2FzZSBcImVlZWVcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gU3RhbmQtYWxvbmUgbG9jYWwgZGF5IG9mIHdlZWtcbiAgYzogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRheU9mV2VlayA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgY29uc3QgbG9jYWxEYXlPZldlZWsgPSAoZGF5T2ZXZWVrIC0gb3B0aW9ucy53ZWVrU3RhcnRzT24gKyA4KSAlIDcgfHwgNztcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBOdW1lcmljYWwgdmFsdWUgKHNhbWUgYXMgaW4gYGVgKVxuICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhsb2NhbERheU9mV2Vlayk7XG4gICAgICAvLyBQYWRkZWQgbnVtZXJpY2FsIHZhbHVlXG4gICAgICBjYXNlIFwiY2NcIjpcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhsb2NhbERheU9mV2VlaywgdG9rZW4ubGVuZ3RoKTtcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDd0aFxuICAgICAgY2FzZSBcImNvXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGxvY2FsRGF5T2ZXZWVrLCB7IHVuaXQ6IFwiZGF5XCIgfSk7XG4gICAgICBjYXNlIFwiY2NjXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICBjb250ZXh0OiBcInN0YW5kYWxvbmVcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyBUXG4gICAgICBjYXNlIFwiY2NjY2NcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICBjb250ZXh0OiBcInN0YW5kYWxvbmVcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdVxuICAgICAgY2FzZSBcImNjY2NjY1wiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiBcInNob3J0XCIsXG4gICAgICAgICAgY29udGV4dDogXCJzdGFuZGFsb25lXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVlc2RheVxuICAgICAgY2FzZSBcImNjY2NcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwic3RhbmRhbG9uZVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gSVNPIGRheSBvZiB3ZWVrXG4gIGk6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBjb25zdCBkYXlPZldlZWsgPSBkYXRlLmdldERheSgpO1xuICAgIGNvbnN0IGlzb0RheU9mV2VlayA9IGRheU9mV2VlayA9PT0gMCA/IDcgOiBkYXlPZldlZWs7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgLy8gMlxuICAgICAgY2FzZSBcImlcIjpcbiAgICAgICAgcmV0dXJuIFN0cmluZyhpc29EYXlPZldlZWspO1xuICAgICAgLy8gMDJcbiAgICAgIGNhc2UgXCJpaVwiOlxuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGlzb0RheU9mV2VlaywgdG9rZW4ubGVuZ3RoKTtcbiAgICAgIC8vIDJuZFxuICAgICAgY2FzZSBcImlvXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGlzb0RheU9mV2VlaywgeyB1bml0OiBcImRheVwiIH0pO1xuICAgICAgLy8gVHVlXG4gICAgICBjYXNlIFwiaWlpXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyBUXG4gICAgICBjYXNlIFwiaWlpaWlcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHtcbiAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgICAvLyBUdVxuICAgICAgY2FzZSBcImlpaWlpaVwiOlxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge1xuICAgICAgICAgIHdpZHRoOiBcInNob3J0XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgLy8gVHVlc2RheVxuICAgICAgY2FzZSBcImlpaWlcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7XG4gICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gQU0gb3IgUE1cbiAgYTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGNvbnN0IGhvdXJzID0gZGF0ZS5nZXRIb3VycygpO1xuICAgIGNvbnN0IGRheVBlcmlvZEVudW1WYWx1ZSA9IGhvdXJzIC8gMTIgPj0gMSA/IFwicG1cIiA6IFwiYW1cIjtcblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJhXCI6XG4gICAgICBjYXNlIFwiYWFcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJhYWFcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplXG4gICAgICAgICAgLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgICAgY2FzZSBcImFhYWFhXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcImFhYWFcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gQU0sIFBNLCBtaWRuaWdodCwgbm9vblxuICBiOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgY29uc3QgaG91cnMgPSBkYXRlLmdldEhvdXJzKCk7XG4gICAgbGV0IGRheVBlcmlvZEVudW1WYWx1ZTtcbiAgICBpZiAoaG91cnMgPT09IDEyKSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLm5vb247XG4gICAgfSBlbHNlIGlmIChob3VycyA9PT0gMCkge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5taWRuaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gaG91cnMgLyAxMiA+PSAxID8gXCJwbVwiIDogXCJhbVwiO1xuICAgIH1cblxuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJiXCI6XG4gICAgICBjYXNlIFwiYmJcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogXCJhYmJyZXZpYXRlZFwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJiYmJcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplXG4gICAgICAgICAgLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcImFiYnJldmlhdGVkXCIsXG4gICAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgICAgY2FzZSBcImJiYmJiXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6IFwibmFycm93XCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcImJiYmJcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6IFwid2lkZVwiLFxuICAgICAgICAgIGNvbnRleHQ6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gaW4gdGhlIG1vcm5pbmcsIGluIHRoZSBhZnRlcm5vb24sIGluIHRoZSBldmVuaW5nLCBhdCBuaWdodFxuICBCOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgY29uc3QgaG91cnMgPSBkYXRlLmdldEhvdXJzKCk7XG4gICAgbGV0IGRheVBlcmlvZEVudW1WYWx1ZTtcbiAgICBpZiAoaG91cnMgPj0gMTcpIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0uZXZlbmluZztcbiAgICB9IGVsc2UgaWYgKGhvdXJzID49IDEyKSB7XG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLmFmdGVybm9vbjtcbiAgICB9IGVsc2UgaWYgKGhvdXJzID49IDQpIHtcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0ubW9ybmluZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5uaWdodDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlIFwiQlwiOlxuICAgICAgY2FzZSBcIkJCXCI6XG4gICAgICBjYXNlIFwiQkJCXCI6XG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7XG4gICAgICAgICAgd2lkdGg6IFwiYWJicmV2aWF0ZWRcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFwiQkJCQkJcIjpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogXCJuYXJyb3dcIixcbiAgICAgICAgICBjb250ZXh0OiBcImZvcm1hdHRpbmdcIixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFwiQkJCQlwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHtcbiAgICAgICAgICB3aWR0aDogXCJ3aWRlXCIsXG4gICAgICAgICAgY29udGV4dDogXCJmb3JtYXR0aW5nXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvLyBIb3VyIFsxLTEyXVxuICBoOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgaWYgKHRva2VuID09PSBcImhvXCIpIHtcbiAgICAgIGxldCBob3VycyA9IGRhdGUuZ2V0SG91cnMoKSAlIDEyO1xuICAgICAgaWYgKGhvdXJzID09PSAwKSBob3VycyA9IDEyO1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaG91cnMsIHsgdW5pdDogXCJob3VyXCIgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpZ2h0Rm9ybWF0dGVycy5oKGRhdGUsIHRva2VuKTtcbiAgfSxcblxuICAvLyBIb3VyIFswLTIzXVxuICBIOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplKSB7XG4gICAgaWYgKHRva2VuID09PSBcIkhvXCIpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGRhdGUuZ2V0SG91cnMoKSwgeyB1bml0OiBcImhvdXJcIiB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlnaHRGb3JtYXR0ZXJzLkgoZGF0ZSwgdG9rZW4pO1xuICB9LFxuXG4gIC8vIEhvdXIgWzAtMTFdXG4gIEs6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBjb25zdCBob3VycyA9IGRhdGUuZ2V0SG91cnMoKSAlIDEyO1xuXG4gICAgaWYgKHRva2VuID09PSBcIktvXCIpIHtcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGhvdXJzLCB7IHVuaXQ6IFwiaG91clwiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoaG91cnMsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG5cbiAgLy8gSG91ciBbMS0yNF1cbiAgazogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGxldCBob3VycyA9IGRhdGUuZ2V0SG91cnMoKTtcbiAgICBpZiAoaG91cnMgPT09IDApIGhvdXJzID0gMjQ7XG5cbiAgICBpZiAodG9rZW4gPT09IFwia29cIikge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaG91cnMsIHsgdW5pdDogXCJob3VyXCIgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhob3VycywgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBNaW51dGVcbiAgbTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xuICAgIGlmICh0b2tlbiA9PT0gXCJtb1wiKSB7XG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihkYXRlLmdldE1pbnV0ZXMoKSwgeyB1bml0OiBcIm1pbnV0ZVwiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBsaWdodEZvcm1hdHRlcnMubShkYXRlLCB0b2tlbik7XG4gIH0sXG5cbiAgLy8gU2Vjb25kXG4gIHM6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcbiAgICBpZiAodG9rZW4gPT09IFwic29cIikge1xuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoZGF0ZS5nZXRTZWNvbmRzKCksIHsgdW5pdDogXCJzZWNvbmRcIiB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlnaHRGb3JtYXR0ZXJzLnMoZGF0ZSwgdG9rZW4pO1xuICB9LFxuXG4gIC8vIEZyYWN0aW9uIG9mIHNlY29uZFxuICBTOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gbGlnaHRGb3JtYXR0ZXJzLlMoZGF0ZSwgdG9rZW4pO1xuICB9LFxuXG4gIC8vIFRpbWV6b25lIChJU08tODYwMS4gSWYgb2Zmc2V0IGlzIDAsIG91dHB1dCBpcyBhbHdheXMgYCdaJ2ApXG4gIFg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplKSB7XG4gICAgY29uc3QgdGltZXpvbmVPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBpZiAodGltZXpvbmVPZmZzZXQgPT09IDApIHtcbiAgICAgIHJldHVybiBcIlpcIjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBIb3VycyBhbmQgb3B0aW9uYWwgbWludXRlc1xuICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lV2l0aE9wdGlvbmFsTWludXRlcyh0aW1lem9uZU9mZnNldCk7XG5cbiAgICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBvcHRpb25hbCBzZWNvbmRzIHdpdGhvdXQgYDpgIGRlbGltaXRlclxuICAgICAgLy8gTm90ZTogbmVpdGhlciBJU08tODYwMSBub3IgSmF2YVNjcmlwdCBzdXBwb3J0cyBzZWNvbmRzIGluIHRpbWV6b25lIG9mZnNldHNcbiAgICAgIC8vIHNvIHRoaXMgdG9rZW4gYWx3YXlzIGhhcyB0aGUgc2FtZSBvdXRwdXQgYXMgYFhYYFxuICAgICAgY2FzZSBcIlhYWFhcIjpcbiAgICAgIGNhc2UgXCJYWFwiOiAvLyBIb3VycyBhbmQgbWludXRlcyB3aXRob3V0IGA6YCBkZWxpbWl0ZXJcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0KTtcblxuICAgICAgLy8gSG91cnMsIG1pbnV0ZXMgYW5kIG9wdGlvbmFsIHNlY29uZHMgd2l0aCBgOmAgZGVsaW1pdGVyXG4gICAgICAvLyBOb3RlOiBuZWl0aGVyIElTTy04NjAxIG5vciBKYXZhU2NyaXB0IHN1cHBvcnRzIHNlY29uZHMgaW4gdGltZXpvbmUgb2Zmc2V0c1xuICAgICAgLy8gc28gdGhpcyB0b2tlbiBhbHdheXMgaGFzIHRoZSBzYW1lIG91dHB1dCBhcyBgWFhYYFxuICAgICAgY2FzZSBcIlhYWFhYXCI6XG4gICAgICBjYXNlIFwiWFhYXCI6IC8vIEhvdXJzIGFuZCBtaW51dGVzIHdpdGggYDpgIGRlbGltaXRlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCBcIjpcIik7XG4gICAgfVxuICB9LFxuXG4gIC8vIFRpbWV6b25lIChJU08tODYwMS4gSWYgb2Zmc2V0IGlzIDAsIG91dHB1dCBpcyBgJyswMDowMCdgIG9yIGVxdWl2YWxlbnQpXG4gIHg6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplKSB7XG4gICAgY29uc3QgdGltZXpvbmVPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBIb3VycyBhbmQgb3B0aW9uYWwgbWludXRlc1xuICAgICAgY2FzZSBcInhcIjpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lV2l0aE9wdGlvbmFsTWludXRlcyh0aW1lem9uZU9mZnNldCk7XG5cbiAgICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBvcHRpb25hbCBzZWNvbmRzIHdpdGhvdXQgYDpgIGRlbGltaXRlclxuICAgICAgLy8gTm90ZTogbmVpdGhlciBJU08tODYwMSBub3IgSmF2YVNjcmlwdCBzdXBwb3J0cyBzZWNvbmRzIGluIHRpbWV6b25lIG9mZnNldHNcbiAgICAgIC8vIHNvIHRoaXMgdG9rZW4gYWx3YXlzIGhhcyB0aGUgc2FtZSBvdXRwdXQgYXMgYHh4YFxuICAgICAgY2FzZSBcInh4eHhcIjpcbiAgICAgIGNhc2UgXCJ4eFwiOiAvLyBIb3VycyBhbmQgbWludXRlcyB3aXRob3V0IGA6YCBkZWxpbWl0ZXJcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0KTtcblxuICAgICAgLy8gSG91cnMsIG1pbnV0ZXMgYW5kIG9wdGlvbmFsIHNlY29uZHMgd2l0aCBgOmAgZGVsaW1pdGVyXG4gICAgICAvLyBOb3RlOiBuZWl0aGVyIElTTy04NjAxIG5vciBKYXZhU2NyaXB0IHN1cHBvcnRzIHNlY29uZHMgaW4gdGltZXpvbmUgb2Zmc2V0c1xuICAgICAgLy8gc28gdGhpcyB0b2tlbiBhbHdheXMgaGFzIHRoZSBzYW1lIG91dHB1dCBhcyBgeHh4YFxuICAgICAgY2FzZSBcInh4eHh4XCI6XG4gICAgICBjYXNlIFwieHh4XCI6IC8vIEhvdXJzIGFuZCBtaW51dGVzIHdpdGggYDpgIGRlbGltaXRlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCBcIjpcIik7XG4gICAgfVxuICB9LFxuXG4gIC8vIFRpbWV6b25lIChHTVQpXG4gIE86IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplKSB7XG4gICAgY29uc3QgdGltZXpvbmVPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBTaG9ydFxuICAgICAgY2FzZSBcIk9cIjpcbiAgICAgIGNhc2UgXCJPT1wiOlxuICAgICAgY2FzZSBcIk9PT1wiOlxuICAgICAgICByZXR1cm4gXCJHTVRcIiArIGZvcm1hdFRpbWV6b25lU2hvcnQodGltZXpvbmVPZmZzZXQsIFwiOlwiKTtcbiAgICAgIC8vIExvbmdcbiAgICAgIGNhc2UgXCJPT09PXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJHTVRcIiArIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCBcIjpcIik7XG4gICAgfVxuICB9LFxuXG4gIC8vIFRpbWV6b25lIChzcGVjaWZpYyBub24tbG9jYXRpb24pXG4gIHo6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplKSB7XG4gICAgY29uc3QgdGltZXpvbmVPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAvLyBTaG9ydFxuICAgICAgY2FzZSBcInpcIjpcbiAgICAgIGNhc2UgXCJ6elwiOlxuICAgICAgY2FzZSBcInp6elwiOlxuICAgICAgICByZXR1cm4gXCJHTVRcIiArIGZvcm1hdFRpbWV6b25lU2hvcnQodGltZXpvbmVPZmZzZXQsIFwiOlwiKTtcbiAgICAgIC8vIExvbmdcbiAgICAgIGNhc2UgXCJ6enp6XCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJHTVRcIiArIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCBcIjpcIik7XG4gICAgfVxuICB9LFxuXG4gIC8vIFNlY29uZHMgdGltZXN0YW1wXG4gIHQ6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgX2xvY2FsaXplKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gTWF0aC50cnVuYyhkYXRlLmdldFRpbWUoKSAvIDEwMDApO1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3ModGltZXN0YW1wLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuXG4gIC8vIE1pbGxpc2Vjb25kcyB0aW1lc3RhbXBcbiAgVDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBfbG9jYWxpemUpIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHRpbWVzdGFtcCwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWV6b25lU2hvcnQob2Zmc2V0LCBkZWxpbWl0ZXIgPSBcIlwiKSB7XG4gIGNvbnN0IHNpZ24gPSBvZmZzZXQgPiAwID8gXCItXCIgOiBcIitcIjtcbiAgY29uc3QgYWJzT2Zmc2V0ID0gTWF0aC5hYnMob2Zmc2V0KTtcbiAgY29uc3QgaG91cnMgPSBNYXRoLnRydW5jKGFic09mZnNldCAvIDYwKTtcbiAgY29uc3QgbWludXRlcyA9IGFic09mZnNldCAlIDYwO1xuICBpZiAobWludXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBzaWduICsgU3RyaW5nKGhvdXJzKTtcbiAgfVxuICByZXR1cm4gc2lnbiArIFN0cmluZyhob3VycykgKyBkZWxpbWl0ZXIgKyBhZGRMZWFkaW5nWmVyb3MobWludXRlcywgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWV6b25lV2l0aE9wdGlvbmFsTWludXRlcyhvZmZzZXQsIGRlbGltaXRlcikge1xuICBpZiAob2Zmc2V0ICUgNjAgPT09IDApIHtcbiAgICBjb25zdCBzaWduID0gb2Zmc2V0ID4gMCA/IFwiLVwiIDogXCIrXCI7XG4gICAgcmV0dXJuIHNpZ24gKyBhZGRMZWFkaW5nWmVyb3MoTWF0aC5hYnMob2Zmc2V0KSAvIDYwLCAyKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0VGltZXpvbmUob2Zmc2V0LCBkZWxpbWl0ZXIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUaW1lem9uZShvZmZzZXQsIGRlbGltaXRlciA9IFwiXCIpIHtcbiAgY29uc3Qgc2lnbiA9IG9mZnNldCA+IDAgPyBcIi1cIiA6IFwiK1wiO1xuICBjb25zdCBhYnNPZmZzZXQgPSBNYXRoLmFicyhvZmZzZXQpO1xuICBjb25zdCBob3VycyA9IGFkZExlYWRpbmdaZXJvcyhNYXRoLnRydW5jKGFic09mZnNldCAvIDYwKSwgMik7XG4gIGNvbnN0IG1pbnV0ZXMgPSBhZGRMZWFkaW5nWmVyb3MoYWJzT2Zmc2V0ICUgNjAsIDIpO1xuICByZXR1cm4gc2lnbiArIGhvdXJzICsgZGVsaW1pdGVyICsgbWludXRlcztcbn1cbiJdLCJuYW1lcyI6WyJnZXREYXlPZlllYXIiLCJnZXRJU09XZWVrIiwiZ2V0SVNPV2Vla1llYXIiLCJnZXRXZWVrIiwiZ2V0V2Vla1llYXIiLCJhZGRMZWFkaW5nWmVyb3MiLCJsaWdodEZvcm1hdHRlcnMiLCJkYXlQZXJpb2RFbnVtIiwiYW0iLCJwbSIsIm1pZG5pZ2h0Iiwibm9vbiIsIm1vcm5pbmciLCJhZnRlcm5vb24iLCJldmVuaW5nIiwibmlnaHQiLCJmb3JtYXR0ZXJzIiwiRyIsImRhdGUiLCJ0b2tlbiIsImxvY2FsaXplIiwiZXJhIiwiZ2V0RnVsbFllYXIiLCJ3aWR0aCIsInkiLCJzaWduZWRZZWFyIiwieWVhciIsIm9yZGluYWxOdW1iZXIiLCJ1bml0IiwiWSIsIm9wdGlvbnMiLCJzaWduZWRXZWVrWWVhciIsIndlZWtZZWFyIiwidHdvRGlnaXRZZWFyIiwibGVuZ3RoIiwiUiIsImlzb1dlZWtZZWFyIiwidSIsIlEiLCJxdWFydGVyIiwiTWF0aCIsImNlaWwiLCJnZXRNb250aCIsIlN0cmluZyIsImNvbnRleHQiLCJxIiwiTSIsIm1vbnRoIiwiTCIsInciLCJ3ZWVrIiwiSSIsImlzb1dlZWsiLCJkIiwiZ2V0RGF0ZSIsIkQiLCJkYXlPZlllYXIiLCJFIiwiZGF5T2ZXZWVrIiwiZ2V0RGF5IiwiZGF5IiwiZSIsImxvY2FsRGF5T2ZXZWVrIiwid2Vla1N0YXJ0c09uIiwiYyIsImkiLCJpc29EYXlPZldlZWsiLCJhIiwiaG91cnMiLCJnZXRIb3VycyIsImRheVBlcmlvZEVudW1WYWx1ZSIsImRheVBlcmlvZCIsInRvTG93ZXJDYXNlIiwiYiIsIkIiLCJoIiwiSCIsIksiLCJrIiwibSIsImdldE1pbnV0ZXMiLCJzIiwiZ2V0U2Vjb25kcyIsIlMiLCJYIiwiX2xvY2FsaXplIiwidGltZXpvbmVPZmZzZXQiLCJnZXRUaW1lem9uZU9mZnNldCIsImZvcm1hdFRpbWV6b25lV2l0aE9wdGlvbmFsTWludXRlcyIsImZvcm1hdFRpbWV6b25lIiwieCIsIk8iLCJmb3JtYXRUaW1lem9uZVNob3J0IiwieiIsInQiLCJ0aW1lc3RhbXAiLCJ0cnVuYyIsImdldFRpbWUiLCJUIiwib2Zmc2V0IiwiZGVsaW1pdGVyIiwic2lnbiIsImFic09mZnNldCIsImFicyIsIm1pbnV0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/_lib/format/formatters.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/_lib/format/lightFormatters.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/date-fns/_lib/format/lightFormatters.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lightFormatters: function() { return /* binding */ lightFormatters; }\n/* harmony export */ });\n/* harmony import */ var _addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../addLeadingZeros.mjs */ \"(app-pages-browser)/./node_modules/date-fns/_lib/addLeadingZeros.mjs\");\n\n/*\n * |     | Unit                           |     | Unit                           |\n * |-----|--------------------------------|-----|--------------------------------|\n * |  a  | AM, PM                         |  A* |                                |\n * |  d  | Day of month                   |  D  |                                |\n * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |\n * |  m  | Minute                         |  M  | Month                          |\n * |  s  | Second                         |  S  | Fraction of second             |\n * |  y  | Year (abs)                     |  Y  |                                |\n *\n * Letters marked by * are not implemented but reserved by Unicode standard.\n */ const lightFormatters = {\n    // Year\n    y (date, token) {\n        // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens\n        // | Year     |     y | yy |   yyy |  yyyy | yyyyy |\n        // |----------|-------|----|-------|-------|-------|\n        // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |\n        // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |\n        // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |\n        // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |\n        // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |\n        const signedYear = date.getFullYear();\n        // Returns 1 for 1 BC (which is year 0 in JavaScript)\n        const year = signedYear > 0 ? signedYear : 1 - signedYear;\n        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_0__.addLeadingZeros)(token === \"yy\" ? year % 100 : year, token.length);\n    },\n    // Month\n    M (date, token) {\n        const month = date.getMonth();\n        return token === \"M\" ? String(month + 1) : (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_0__.addLeadingZeros)(month + 1, 2);\n    },\n    // Day of the month\n    d (date, token) {\n        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_0__.addLeadingZeros)(date.getDate(), token.length);\n    },\n    // AM or PM\n    a (date, token) {\n        const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? \"pm\" : \"am\";\n        switch(token){\n            case \"a\":\n            case \"aa\":\n                return dayPeriodEnumValue.toUpperCase();\n            case \"aaa\":\n                return dayPeriodEnumValue;\n            case \"aaaaa\":\n                return dayPeriodEnumValue[0];\n            case \"aaaa\":\n            default:\n                return dayPeriodEnumValue === \"am\" ? \"a.m.\" : \"p.m.\";\n        }\n    },\n    // Hour [1-12]\n    h (date, token) {\n        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_0__.addLeadingZeros)(date.getHours() % 12 || 12, token.length);\n    },\n    // Hour [0-23]\n    H (date, token) {\n        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_0__.addLeadingZeros)(date.getHours(), token.length);\n    },\n    // Minute\n    m (date, token) {\n        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_0__.addLeadingZeros)(date.getMinutes(), token.length);\n    },\n    // Second\n    s (date, token) {\n        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_0__.addLeadingZeros)(date.getSeconds(), token.length);\n    },\n    // Fraction of second\n    S (date, token) {\n        const numberOfDigits = token.length;\n        const milliseconds = date.getMilliseconds();\n        const fractionalSeconds = Math.trunc(milliseconds * Math.pow(10, numberOfDigits - 3));\n        return (0,_addLeadingZeros_mjs__WEBPACK_IMPORTED_MODULE_0__.addLeadingZeros)(fractionalSeconds, token.length);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9fbGliL2Zvcm1hdC9saWdodEZvcm1hdHRlcnMubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXlEO0FBRXpEOzs7Ozs7Ozs7OztDQVdDLEdBRU0sTUFBTUMsa0JBQWtCO0lBQzdCLE9BQU87SUFDUEMsR0FBRUMsSUFBSSxFQUFFQyxLQUFLO1FBQ1gsc0ZBQXNGO1FBQ3RGLG9EQUFvRDtRQUNwRCxvREFBb0Q7UUFDcEQsb0RBQW9EO1FBQ3BELG9EQUFvRDtRQUNwRCxvREFBb0Q7UUFDcEQsb0RBQW9EO1FBQ3BELG9EQUFvRDtRQUVwRCxNQUFNQyxhQUFhRixLQUFLRyxXQUFXO1FBQ25DLHFEQUFxRDtRQUNyRCxNQUFNQyxPQUFPRixhQUFhLElBQUlBLGFBQWEsSUFBSUE7UUFDL0MsT0FBT0wscUVBQWVBLENBQUNJLFVBQVUsT0FBT0csT0FBTyxNQUFNQSxNQUFNSCxNQUFNSSxNQUFNO0lBQ3pFO0lBRUEsUUFBUTtJQUNSQyxHQUFFTixJQUFJLEVBQUVDLEtBQUs7UUFDWCxNQUFNTSxRQUFRUCxLQUFLUSxRQUFRO1FBQzNCLE9BQU9QLFVBQVUsTUFBTVEsT0FBT0YsUUFBUSxLQUFLVixxRUFBZUEsQ0FBQ1UsUUFBUSxHQUFHO0lBQ3hFO0lBRUEsbUJBQW1CO0lBQ25CRyxHQUFFVixJQUFJLEVBQUVDLEtBQUs7UUFDWCxPQUFPSixxRUFBZUEsQ0FBQ0csS0FBS1csT0FBTyxJQUFJVixNQUFNSSxNQUFNO0lBQ3JEO0lBRUEsV0FBVztJQUNYTyxHQUFFWixJQUFJLEVBQUVDLEtBQUs7UUFDWCxNQUFNWSxxQkFBcUJiLEtBQUtjLFFBQVEsS0FBSyxNQUFNLElBQUksT0FBTztRQUU5RCxPQUFRYjtZQUNOLEtBQUs7WUFDTCxLQUFLO2dCQUNILE9BQU9ZLG1CQUFtQkUsV0FBVztZQUN2QyxLQUFLO2dCQUNILE9BQU9GO1lBQ1QsS0FBSztnQkFDSCxPQUFPQSxrQkFBa0IsQ0FBQyxFQUFFO1lBQzlCLEtBQUs7WUFDTDtnQkFDRSxPQUFPQSx1QkFBdUIsT0FBTyxTQUFTO1FBQ2xEO0lBQ0Y7SUFFQSxjQUFjO0lBQ2RHLEdBQUVoQixJQUFJLEVBQUVDLEtBQUs7UUFDWCxPQUFPSixxRUFBZUEsQ0FBQ0csS0FBS2MsUUFBUSxLQUFLLE1BQU0sSUFBSWIsTUFBTUksTUFBTTtJQUNqRTtJQUVBLGNBQWM7SUFDZFksR0FBRWpCLElBQUksRUFBRUMsS0FBSztRQUNYLE9BQU9KLHFFQUFlQSxDQUFDRyxLQUFLYyxRQUFRLElBQUliLE1BQU1JLE1BQU07SUFDdEQ7SUFFQSxTQUFTO0lBQ1RhLEdBQUVsQixJQUFJLEVBQUVDLEtBQUs7UUFDWCxPQUFPSixxRUFBZUEsQ0FBQ0csS0FBS21CLFVBQVUsSUFBSWxCLE1BQU1JLE1BQU07SUFDeEQ7SUFFQSxTQUFTO0lBQ1RlLEdBQUVwQixJQUFJLEVBQUVDLEtBQUs7UUFDWCxPQUFPSixxRUFBZUEsQ0FBQ0csS0FBS3FCLFVBQVUsSUFBSXBCLE1BQU1JLE1BQU07SUFDeEQ7SUFFQSxxQkFBcUI7SUFDckJpQixHQUFFdEIsSUFBSSxFQUFFQyxLQUFLO1FBQ1gsTUFBTXNCLGlCQUFpQnRCLE1BQU1JLE1BQU07UUFDbkMsTUFBTW1CLGVBQWV4QixLQUFLeUIsZUFBZTtRQUN6QyxNQUFNQyxvQkFBb0JDLEtBQUtDLEtBQUssQ0FDbENKLGVBQWVHLEtBQUtFLEdBQUcsQ0FBQyxJQUFJTixpQkFBaUI7UUFFL0MsT0FBTzFCLHFFQUFlQSxDQUFDNkIsbUJBQW1CekIsTUFBTUksTUFBTTtJQUN4RDtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL19saWIvZm9ybWF0L2xpZ2h0Rm9ybWF0dGVycy5tanM/MjNmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhZGRMZWFkaW5nWmVyb3MgfSBmcm9tIFwiLi4vYWRkTGVhZGluZ1plcm9zLm1qc1wiO1xuXG4vKlxuICogfCAgICAgfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfC0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCAgYSAgfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgfCAgQSogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgZCAgfCBEYXkgb2YgbW9udGggICAgICAgICAgICAgICAgICAgfCAgRCAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgaCAgfCBIb3VyIFsxLTEyXSAgICAgICAgICAgICAgICAgICAgfCAgSCAgfCBIb3VyIFswLTIzXSAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgbSAgfCBNaW51dGUgICAgICAgICAgICAgICAgICAgICAgICAgfCAgTSAgfCBNb250aCAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgcyAgfCBTZWNvbmQgICAgICAgICAgICAgICAgICAgICAgICAgfCAgUyAgfCBGcmFjdGlvbiBvZiBzZWNvbmQgICAgICAgICAgICAgfFxuICogfCAgeSAgfCBZZWFyIChhYnMpICAgICAgICAgICAgICAgICAgICAgfCAgWSAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICpcbiAqIExldHRlcnMgbWFya2VkIGJ5ICogYXJlIG5vdCBpbXBsZW1lbnRlZCBidXQgcmVzZXJ2ZWQgYnkgVW5pY29kZSBzdGFuZGFyZC5cbiAqL1xuXG5leHBvcnQgY29uc3QgbGlnaHRGb3JtYXR0ZXJzID0ge1xuICAvLyBZZWFyXG4gIHkoZGF0ZSwgdG9rZW4pIHtcbiAgICAvLyBGcm9tIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtMzEvdHIzNS1kYXRlcy5odG1sI0RhdGVfRm9ybWF0X3Rva2Vuc1xuICAgIC8vIHwgWWVhciAgICAgfCAgICAgeSB8IHl5IHwgICB5eXkgfCAgeXl5eSB8IHl5eXl5IHxcbiAgICAvLyB8LS0tLS0tLS0tLXwtLS0tLS0tfC0tLS18LS0tLS0tLXwtLS0tLS0tfC0tLS0tLS18XG4gICAgLy8gfCBBRCAxICAgICB8ICAgICAxIHwgMDEgfCAgIDAwMSB8ICAwMDAxIHwgMDAwMDEgfFxuICAgIC8vIHwgQUQgMTIgICAgfCAgICAxMiB8IDEyIHwgICAwMTIgfCAgMDAxMiB8IDAwMDEyIHxcbiAgICAvLyB8IEFEIDEyMyAgIHwgICAxMjMgfCAyMyB8ICAgMTIzIHwgIDAxMjMgfCAwMDEyMyB8XG4gICAgLy8gfCBBRCAxMjM0ICB8ICAxMjM0IHwgMzQgfCAgMTIzNCB8ICAxMjM0IHwgMDEyMzQgfFxuICAgIC8vIHwgQUQgMTIzNDUgfCAxMjM0NSB8IDQ1IHwgMTIzNDUgfCAxMjM0NSB8IDEyMzQ1IHxcblxuICAgIGNvbnN0IHNpZ25lZFllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgLy8gUmV0dXJucyAxIGZvciAxIEJDICh3aGljaCBpcyB5ZWFyIDAgaW4gSmF2YVNjcmlwdClcbiAgICBjb25zdCB5ZWFyID0gc2lnbmVkWWVhciA+IDAgPyBzaWduZWRZZWFyIDogMSAtIHNpZ25lZFllYXI7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh0b2tlbiA9PT0gXCJ5eVwiID8geWVhciAlIDEwMCA6IHllYXIsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG5cbiAgLy8gTW9udGhcbiAgTShkYXRlLCB0b2tlbikge1xuICAgIGNvbnN0IG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuICAgIHJldHVybiB0b2tlbiA9PT0gXCJNXCIgPyBTdHJpbmcobW9udGggKyAxKSA6IGFkZExlYWRpbmdaZXJvcyhtb250aCArIDEsIDIpO1xuICB9LFxuXG4gIC8vIERheSBvZiB0aGUgbW9udGhcbiAgZChkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXREYXRlKCksIHRva2VuLmxlbmd0aCk7XG4gIH0sXG5cbiAgLy8gQU0gb3IgUE1cbiAgYShkYXRlLCB0b2tlbikge1xuICAgIGNvbnN0IGRheVBlcmlvZEVudW1WYWx1ZSA9IGRhdGUuZ2V0SG91cnMoKSAvIDEyID49IDEgPyBcInBtXCIgOiBcImFtXCI7XG5cbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlIFwiYVwiOlxuICAgICAgY2FzZSBcImFhXCI6XG4gICAgICAgIHJldHVybiBkYXlQZXJpb2RFbnVtVmFsdWUudG9VcHBlckNhc2UoKTtcbiAgICAgIGNhc2UgXCJhYWFcIjpcbiAgICAgICAgcmV0dXJuIGRheVBlcmlvZEVudW1WYWx1ZTtcbiAgICAgIGNhc2UgXCJhYWFhYVwiOlxuICAgICAgICByZXR1cm4gZGF5UGVyaW9kRW51bVZhbHVlWzBdO1xuICAgICAgY2FzZSBcImFhYWFcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBkYXlQZXJpb2RFbnVtVmFsdWUgPT09IFwiYW1cIiA/IFwiYS5tLlwiIDogXCJwLm0uXCI7XG4gICAgfVxuICB9LFxuXG4gIC8vIEhvdXIgWzEtMTJdXG4gIGgoZGF0ZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0SG91cnMoKSAlIDEyIHx8IDEyLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuXG4gIC8vIEhvdXIgWzAtMjNdXG4gIEgoZGF0ZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0SG91cnMoKSwgdG9rZW4ubGVuZ3RoKTtcbiAgfSxcblxuICAvLyBNaW51dGVcbiAgbShkYXRlLCB0b2tlbikge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRNaW51dGVzKCksIHRva2VuLmxlbmd0aCk7XG4gIH0sXG5cbiAgLy8gU2Vjb25kXG4gIHMoZGF0ZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0U2Vjb25kcygpLCB0b2tlbi5sZW5ndGgpO1xuICB9LFxuXG4gIC8vIEZyYWN0aW9uIG9mIHNlY29uZFxuICBTKGRhdGUsIHRva2VuKSB7XG4gICAgY29uc3QgbnVtYmVyT2ZEaWdpdHMgPSB0b2tlbi5sZW5ndGg7XG4gICAgY29uc3QgbWlsbGlzZWNvbmRzID0gZGF0ZS5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICBjb25zdCBmcmFjdGlvbmFsU2Vjb25kcyA9IE1hdGgudHJ1bmMoXG4gICAgICBtaWxsaXNlY29uZHMgKiBNYXRoLnBvdygxMCwgbnVtYmVyT2ZEaWdpdHMgLSAzKSxcbiAgICApO1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZnJhY3Rpb25hbFNlY29uZHMsIHRva2VuLmxlbmd0aCk7XG4gIH0sXG59O1xuIl0sIm5hbWVzIjpbImFkZExlYWRpbmdaZXJvcyIsImxpZ2h0Rm9ybWF0dGVycyIsInkiLCJkYXRlIiwidG9rZW4iLCJzaWduZWRZZWFyIiwiZ2V0RnVsbFllYXIiLCJ5ZWFyIiwibGVuZ3RoIiwiTSIsIm1vbnRoIiwiZ2V0TW9udGgiLCJTdHJpbmciLCJkIiwiZ2V0RGF0ZSIsImEiLCJkYXlQZXJpb2RFbnVtVmFsdWUiLCJnZXRIb3VycyIsInRvVXBwZXJDYXNlIiwiaCIsIkgiLCJtIiwiZ2V0TWludXRlcyIsInMiLCJnZXRTZWNvbmRzIiwiUyIsIm51bWJlck9mRGlnaXRzIiwibWlsbGlzZWNvbmRzIiwiZ2V0TWlsbGlzZWNvbmRzIiwiZnJhY3Rpb25hbFNlY29uZHMiLCJNYXRoIiwidHJ1bmMiLCJwb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/_lib/format/lightFormatters.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/_lib/format/longFormatters.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/date-fns/_lib/format/longFormatters.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   longFormatters: function() { return /* binding */ longFormatters; }\n/* harmony export */ });\nconst dateLongFormatter = (pattern, formatLong)=>{\n    switch(pattern){\n        case \"P\":\n            return formatLong.date({\n                width: \"short\"\n            });\n        case \"PP\":\n            return formatLong.date({\n                width: \"medium\"\n            });\n        case \"PPP\":\n            return formatLong.date({\n                width: \"long\"\n            });\n        case \"PPPP\":\n        default:\n            return formatLong.date({\n                width: \"full\"\n            });\n    }\n};\nconst timeLongFormatter = (pattern, formatLong)=>{\n    switch(pattern){\n        case \"p\":\n            return formatLong.time({\n                width: \"short\"\n            });\n        case \"pp\":\n            return formatLong.time({\n                width: \"medium\"\n            });\n        case \"ppp\":\n            return formatLong.time({\n                width: \"long\"\n            });\n        case \"pppp\":\n        default:\n            return formatLong.time({\n                width: \"full\"\n            });\n    }\n};\nconst dateTimeLongFormatter = (pattern, formatLong)=>{\n    const matchResult = pattern.match(/(P+)(p+)?/) || [];\n    const datePattern = matchResult[1];\n    const timePattern = matchResult[2];\n    if (!timePattern) {\n        return dateLongFormatter(pattern, formatLong);\n    }\n    let dateTimeFormat;\n    switch(datePattern){\n        case \"P\":\n            dateTimeFormat = formatLong.dateTime({\n                width: \"short\"\n            });\n            break;\n        case \"PP\":\n            dateTimeFormat = formatLong.dateTime({\n                width: \"medium\"\n            });\n            break;\n        case \"PPP\":\n            dateTimeFormat = formatLong.dateTime({\n                width: \"long\"\n            });\n            break;\n        case \"PPPP\":\n        default:\n            dateTimeFormat = formatLong.dateTime({\n                width: \"full\"\n            });\n            break;\n    }\n    return dateTimeFormat.replace(\"{{date}}\", dateLongFormatter(datePattern, formatLong)).replace(\"{{time}}\", timeLongFormatter(timePattern, formatLong));\n};\nconst longFormatters = {\n    p: timeLongFormatter,\n    P: dateTimeLongFormatter\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9fbGliL2Zvcm1hdC9sb25nRm9ybWF0dGVycy5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLG9CQUFvQixDQUFDQyxTQUFTQztJQUNsQyxPQUFRRDtRQUNOLEtBQUs7WUFDSCxPQUFPQyxXQUFXQyxJQUFJLENBQUM7Z0JBQUVDLE9BQU87WUFBUTtRQUMxQyxLQUFLO1lBQ0gsT0FBT0YsV0FBV0MsSUFBSSxDQUFDO2dCQUFFQyxPQUFPO1lBQVM7UUFDM0MsS0FBSztZQUNILE9BQU9GLFdBQVdDLElBQUksQ0FBQztnQkFBRUMsT0FBTztZQUFPO1FBQ3pDLEtBQUs7UUFDTDtZQUNFLE9BQU9GLFdBQVdDLElBQUksQ0FBQztnQkFBRUMsT0FBTztZQUFPO0lBQzNDO0FBQ0Y7QUFFQSxNQUFNQyxvQkFBb0IsQ0FBQ0osU0FBU0M7SUFDbEMsT0FBUUQ7UUFDTixLQUFLO1lBQ0gsT0FBT0MsV0FBV0ksSUFBSSxDQUFDO2dCQUFFRixPQUFPO1lBQVE7UUFDMUMsS0FBSztZQUNILE9BQU9GLFdBQVdJLElBQUksQ0FBQztnQkFBRUYsT0FBTztZQUFTO1FBQzNDLEtBQUs7WUFDSCxPQUFPRixXQUFXSSxJQUFJLENBQUM7Z0JBQUVGLE9BQU87WUFBTztRQUN6QyxLQUFLO1FBQ0w7WUFDRSxPQUFPRixXQUFXSSxJQUFJLENBQUM7Z0JBQUVGLE9BQU87WUFBTztJQUMzQztBQUNGO0FBRUEsTUFBTUcsd0JBQXdCLENBQUNOLFNBQVNDO0lBQ3RDLE1BQU1NLGNBQWNQLFFBQVFRLEtBQUssQ0FBQyxnQkFBZ0IsRUFBRTtJQUNwRCxNQUFNQyxjQUFjRixXQUFXLENBQUMsRUFBRTtJQUNsQyxNQUFNRyxjQUFjSCxXQUFXLENBQUMsRUFBRTtJQUVsQyxJQUFJLENBQUNHLGFBQWE7UUFDaEIsT0FBT1gsa0JBQWtCQyxTQUFTQztJQUNwQztJQUVBLElBQUlVO0lBRUosT0FBUUY7UUFDTixLQUFLO1lBQ0hFLGlCQUFpQlYsV0FBV1csUUFBUSxDQUFDO2dCQUFFVCxPQUFPO1lBQVE7WUFDdEQ7UUFDRixLQUFLO1lBQ0hRLGlCQUFpQlYsV0FBV1csUUFBUSxDQUFDO2dCQUFFVCxPQUFPO1lBQVM7WUFDdkQ7UUFDRixLQUFLO1lBQ0hRLGlCQUFpQlYsV0FBV1csUUFBUSxDQUFDO2dCQUFFVCxPQUFPO1lBQU87WUFDckQ7UUFDRixLQUFLO1FBQ0w7WUFDRVEsaUJBQWlCVixXQUFXVyxRQUFRLENBQUM7Z0JBQUVULE9BQU87WUFBTztZQUNyRDtJQUNKO0lBRUEsT0FBT1EsZUFDSkUsT0FBTyxDQUFDLFlBQVlkLGtCQUFrQlUsYUFBYVIsYUFDbkRZLE9BQU8sQ0FBQyxZQUFZVCxrQkFBa0JNLGFBQWFUO0FBQ3hEO0FBRU8sTUFBTWEsaUJBQWlCO0lBQzVCQyxHQUFHWDtJQUNIWSxHQUFHVjtBQUNMLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL19saWIvZm9ybWF0L2xvbmdGb3JtYXR0ZXJzLm1qcz9kYWZiIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGRhdGVMb25nRm9ybWF0dGVyID0gKHBhdHRlcm4sIGZvcm1hdExvbmcpID0+IHtcbiAgc3dpdGNoIChwYXR0ZXJuKSB7XG4gICAgY2FzZSBcIlBcIjpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLmRhdGUoeyB3aWR0aDogXCJzaG9ydFwiIH0pO1xuICAgIGNhc2UgXCJQUFwiOlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcuZGF0ZSh7IHdpZHRoOiBcIm1lZGl1bVwiIH0pO1xuICAgIGNhc2UgXCJQUFBcIjpcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLmRhdGUoeyB3aWR0aDogXCJsb25nXCIgfSk7XG4gICAgY2FzZSBcIlBQUFBcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcuZGF0ZSh7IHdpZHRoOiBcImZ1bGxcIiB9KTtcbiAgfVxufTtcblxuY29uc3QgdGltZUxvbmdGb3JtYXR0ZXIgPSAocGF0dGVybiwgZm9ybWF0TG9uZykgPT4ge1xuICBzd2l0Y2ggKHBhdHRlcm4pIHtcbiAgICBjYXNlIFwicFwiOlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcudGltZSh7IHdpZHRoOiBcInNob3J0XCIgfSk7XG4gICAgY2FzZSBcInBwXCI6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy50aW1lKHsgd2lkdGg6IFwibWVkaXVtXCIgfSk7XG4gICAgY2FzZSBcInBwcFwiOlxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcudGltZSh7IHdpZHRoOiBcImxvbmdcIiB9KTtcbiAgICBjYXNlIFwicHBwcFwiOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZm9ybWF0TG9uZy50aW1lKHsgd2lkdGg6IFwiZnVsbFwiIH0pO1xuICB9XG59O1xuXG5jb25zdCBkYXRlVGltZUxvbmdGb3JtYXR0ZXIgPSAocGF0dGVybiwgZm9ybWF0TG9uZykgPT4ge1xuICBjb25zdCBtYXRjaFJlc3VsdCA9IHBhdHRlcm4ubWF0Y2goLyhQKykocCspPy8pIHx8IFtdO1xuICBjb25zdCBkYXRlUGF0dGVybiA9IG1hdGNoUmVzdWx0WzFdO1xuICBjb25zdCB0aW1lUGF0dGVybiA9IG1hdGNoUmVzdWx0WzJdO1xuXG4gIGlmICghdGltZVBhdHRlcm4pIHtcbiAgICByZXR1cm4gZGF0ZUxvbmdGb3JtYXR0ZXIocGF0dGVybiwgZm9ybWF0TG9uZyk7XG4gIH1cblxuICBsZXQgZGF0ZVRpbWVGb3JtYXQ7XG5cbiAgc3dpdGNoIChkYXRlUGF0dGVybikge1xuICAgIGNhc2UgXCJQXCI6XG4gICAgICBkYXRlVGltZUZvcm1hdCA9IGZvcm1hdExvbmcuZGF0ZVRpbWUoeyB3aWR0aDogXCJzaG9ydFwiIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlBQXCI6XG4gICAgICBkYXRlVGltZUZvcm1hdCA9IGZvcm1hdExvbmcuZGF0ZVRpbWUoeyB3aWR0aDogXCJtZWRpdW1cIiB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQUFBcIjpcbiAgICAgIGRhdGVUaW1lRm9ybWF0ID0gZm9ybWF0TG9uZy5kYXRlVGltZSh7IHdpZHRoOiBcImxvbmdcIiB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQUFBQXCI6XG4gICAgZGVmYXVsdDpcbiAgICAgIGRhdGVUaW1lRm9ybWF0ID0gZm9ybWF0TG9uZy5kYXRlVGltZSh7IHdpZHRoOiBcImZ1bGxcIiB9KTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGRhdGVUaW1lRm9ybWF0XG4gICAgLnJlcGxhY2UoXCJ7e2RhdGV9fVwiLCBkYXRlTG9uZ0Zvcm1hdHRlcihkYXRlUGF0dGVybiwgZm9ybWF0TG9uZykpXG4gICAgLnJlcGxhY2UoXCJ7e3RpbWV9fVwiLCB0aW1lTG9uZ0Zvcm1hdHRlcih0aW1lUGF0dGVybiwgZm9ybWF0TG9uZykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGxvbmdGb3JtYXR0ZXJzID0ge1xuICBwOiB0aW1lTG9uZ0Zvcm1hdHRlcixcbiAgUDogZGF0ZVRpbWVMb25nRm9ybWF0dGVyLFxufTtcbiJdLCJuYW1lcyI6WyJkYXRlTG9uZ0Zvcm1hdHRlciIsInBhdHRlcm4iLCJmb3JtYXRMb25nIiwiZGF0ZSIsIndpZHRoIiwidGltZUxvbmdGb3JtYXR0ZXIiLCJ0aW1lIiwiZGF0ZVRpbWVMb25nRm9ybWF0dGVyIiwibWF0Y2hSZXN1bHQiLCJtYXRjaCIsImRhdGVQYXR0ZXJuIiwidGltZVBhdHRlcm4iLCJkYXRlVGltZUZvcm1hdCIsImRhdGVUaW1lIiwicmVwbGFjZSIsImxvbmdGb3JtYXR0ZXJzIiwicCIsIlAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/_lib/format/longFormatters.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTimezoneOffsetInMilliseconds: function() { return /* binding */ getTimezoneOffsetInMilliseconds; }\n/* harmony export */ });\n/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../toDate.mjs */ \"(app-pages-browser)/./node_modules/date-fns/toDate.mjs\");\n\n/**\n * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.\n * They usually appear for dates that denote time before the timezones were introduced\n * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891\n * and GMT+01:00:00 after that date)\n *\n * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,\n * which would lead to incorrect calculations.\n *\n * This function returns the timezone offset in milliseconds that takes seconds in account.\n */ function getTimezoneOffsetInMilliseconds(date) {\n    const _date = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_0__.toDate)(date);\n    const utcDate = new Date(Date.UTC(_date.getFullYear(), _date.getMonth(), _date.getDate(), _date.getHours(), _date.getMinutes(), _date.getSeconds(), _date.getMilliseconds()));\n    utcDate.setUTCFullYear(_date.getFullYear());\n    return +date - +utcDate;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9fbGliL2dldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVDO0FBRXZDOzs7Ozs7Ozs7O0NBVUMsR0FDTSxTQUFTQyxnQ0FBZ0NDLElBQUk7SUFDbEQsTUFBTUMsUUFBUUgsbURBQU1BLENBQUNFO0lBQ3JCLE1BQU1FLFVBQVUsSUFBSUMsS0FDbEJBLEtBQUtDLEdBQUcsQ0FDTkgsTUFBTUksV0FBVyxJQUNqQkosTUFBTUssUUFBUSxJQUNkTCxNQUFNTSxPQUFPLElBQ2JOLE1BQU1PLFFBQVEsSUFDZFAsTUFBTVEsVUFBVSxJQUNoQlIsTUFBTVMsVUFBVSxJQUNoQlQsTUFBTVUsZUFBZTtJQUd6QlQsUUFBUVUsY0FBYyxDQUFDWCxNQUFNSSxXQUFXO0lBQ3hDLE9BQU8sQ0FBQ0wsT0FBTyxDQUFDRTtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvX2xpYi9nZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzLm1qcz9iNTBhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvRGF0ZSB9IGZyb20gXCIuLi90b0RhdGUubWpzXCI7XG5cbi8qKlxuICogR29vZ2xlIENocm9tZSBhcyBvZiA2Ny4wLjMzOTYuODcgaW50cm9kdWNlZCB0aW1lem9uZXMgd2l0aCBvZmZzZXQgdGhhdCBpbmNsdWRlcyBzZWNvbmRzLlxuICogVGhleSB1c3VhbGx5IGFwcGVhciBmb3IgZGF0ZXMgdGhhdCBkZW5vdGUgdGltZSBiZWZvcmUgdGhlIHRpbWV6b25lcyB3ZXJlIGludHJvZHVjZWRcbiAqIChlLmcuIGZvciAnRXVyb3BlL1ByYWd1ZScgdGltZXpvbmUgdGhlIG9mZnNldCBpcyBHTVQrMDA6NTc6NDQgYmVmb3JlIDEgT2N0b2JlciAxODkxXG4gKiBhbmQgR01UKzAxOjAwOjAwIGFmdGVyIHRoYXQgZGF0ZSlcbiAqXG4gKiBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgdGhlIG9mZnNldCBpbiBtaW51dGVzIGFuZCB3b3VsZCByZXR1cm4gNTcgZm9yIHRoZSBleGFtcGxlIGFib3ZlLFxuICogd2hpY2ggd291bGQgbGVhZCB0byBpbmNvcnJlY3QgY2FsY3VsYXRpb25zLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgdGltZXpvbmUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kcyB0aGF0IHRha2VzIHNlY29uZHMgaW4gYWNjb3VudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMoZGF0ZSkge1xuICBjb25zdCBfZGF0ZSA9IHRvRGF0ZShkYXRlKTtcbiAgY29uc3QgdXRjRGF0ZSA9IG5ldyBEYXRlKFxuICAgIERhdGUuVVRDKFxuICAgICAgX2RhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgIF9kYXRlLmdldE1vbnRoKCksXG4gICAgICBfZGF0ZS5nZXREYXRlKCksXG4gICAgICBfZGF0ZS5nZXRIb3VycygpLFxuICAgICAgX2RhdGUuZ2V0TWludXRlcygpLFxuICAgICAgX2RhdGUuZ2V0U2Vjb25kcygpLFxuICAgICAgX2RhdGUuZ2V0TWlsbGlzZWNvbmRzKCksXG4gICAgKSxcbiAgKTtcbiAgdXRjRGF0ZS5zZXRVVENGdWxsWWVhcihfZGF0ZS5nZXRGdWxsWWVhcigpKTtcbiAgcmV0dXJuICtkYXRlIC0gK3V0Y0RhdGU7XG59XG4iXSwibmFtZXMiOlsidG9EYXRlIiwiZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyIsImRhdGUiLCJfZGF0ZSIsInV0Y0RhdGUiLCJEYXRlIiwiVVRDIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0TWlsbGlzZWNvbmRzIiwic2V0VVRDRnVsbFllYXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/_lib/protectedTokens.mjs":
/*!********************************************************!*\
  !*** ./node_modules/date-fns/_lib/protectedTokens.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isProtectedDayOfYearToken: function() { return /* binding */ isProtectedDayOfYearToken; },\n/* harmony export */   isProtectedWeekYearToken: function() { return /* binding */ isProtectedWeekYearToken; },\n/* harmony export */   warnOrThrowProtectedError: function() { return /* binding */ warnOrThrowProtectedError; }\n/* harmony export */ });\nconst dayOfYearTokenRE = /^D+$/;\nconst weekYearTokenRE = /^Y+$/;\nconst throwTokens = [\n    \"D\",\n    \"DD\",\n    \"YY\",\n    \"YYYY\"\n];\nfunction isProtectedDayOfYearToken(token) {\n    return dayOfYearTokenRE.test(token);\n}\nfunction isProtectedWeekYearToken(token) {\n    return weekYearTokenRE.test(token);\n}\nfunction warnOrThrowProtectedError(token, format, input) {\n    const _message = message(token, format, input);\n    console.warn(_message);\n    if (throwTokens.includes(token)) throw new RangeError(_message);\n}\nfunction message(token, format, input) {\n    const subject = token[0] === \"Y\" ? \"years\" : \"days of the month\";\n    return \"Use `\".concat(token.toLowerCase(), \"` instead of `\").concat(token, \"` (in `\").concat(format, \"`) for formatting \").concat(subject, \" to the input `\").concat(input, \"`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9fbGliL3Byb3RlY3RlZFRva2Vucy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsTUFBTUEsbUJBQW1CO0FBQ3pCLE1BQU1DLGtCQUFrQjtBQUV4QixNQUFNQyxjQUFjO0lBQUM7SUFBSztJQUFNO0lBQU07Q0FBTztBQUV0QyxTQUFTQywwQkFBMEJDLEtBQUs7SUFDN0MsT0FBT0osaUJBQWlCSyxJQUFJLENBQUNEO0FBQy9CO0FBRU8sU0FBU0UseUJBQXlCRixLQUFLO0lBQzVDLE9BQU9ILGdCQUFnQkksSUFBSSxDQUFDRDtBQUM5QjtBQUVPLFNBQVNHLDBCQUEwQkgsS0FBSyxFQUFFSSxNQUFNLEVBQUVDLEtBQUs7SUFDNUQsTUFBTUMsV0FBV0MsUUFBUVAsT0FBT0ksUUFBUUM7SUFDeENHLFFBQVFDLElBQUksQ0FBQ0g7SUFDYixJQUFJUixZQUFZWSxRQUFRLENBQUNWLFFBQVEsTUFBTSxJQUFJVyxXQUFXTDtBQUN4RDtBQUVBLFNBQVNDLFFBQVFQLEtBQUssRUFBRUksTUFBTSxFQUFFQyxLQUFLO0lBQ25DLE1BQU1PLFVBQVVaLEtBQUssQ0FBQyxFQUFFLEtBQUssTUFBTSxVQUFVO0lBQzdDLE9BQU8sUUFBK0NBLE9BQXRDQSxNQUFNYSxXQUFXLElBQUcsa0JBQW1DVCxPQUFqQkosT0FBTSxXQUF1Q1ksT0FBNUJSLFFBQU8sc0JBQStDQyxPQUExQk8sU0FBUSxtQkFBd0IsT0FBTlAsT0FBTTtBQUNySSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvX2xpYi9wcm90ZWN0ZWRUb2tlbnMubWpzP2U3NDMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZGF5T2ZZZWFyVG9rZW5SRSA9IC9eRCskLztcbmNvbnN0IHdlZWtZZWFyVG9rZW5SRSA9IC9eWSskLztcblxuY29uc3QgdGhyb3dUb2tlbnMgPSBbXCJEXCIsIFwiRERcIiwgXCJZWVwiLCBcIllZWVlcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Byb3RlY3RlZERheU9mWWVhclRva2VuKHRva2VuKSB7XG4gIHJldHVybiBkYXlPZlllYXJUb2tlblJFLnRlc3QodG9rZW4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQcm90ZWN0ZWRXZWVrWWVhclRva2VuKHRva2VuKSB7XG4gIHJldHVybiB3ZWVrWWVhclRva2VuUkUudGVzdCh0b2tlbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXJuT3JUaHJvd1Byb3RlY3RlZEVycm9yKHRva2VuLCBmb3JtYXQsIGlucHV0KSB7XG4gIGNvbnN0IF9tZXNzYWdlID0gbWVzc2FnZSh0b2tlbiwgZm9ybWF0LCBpbnB1dCk7XG4gIGNvbnNvbGUud2FybihfbWVzc2FnZSk7XG4gIGlmICh0aHJvd1Rva2Vucy5pbmNsdWRlcyh0b2tlbikpIHRocm93IG5ldyBSYW5nZUVycm9yKF9tZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gbWVzc2FnZSh0b2tlbiwgZm9ybWF0LCBpbnB1dCkge1xuICBjb25zdCBzdWJqZWN0ID0gdG9rZW5bMF0gPT09IFwiWVwiID8gXCJ5ZWFyc1wiIDogXCJkYXlzIG9mIHRoZSBtb250aFwiO1xuICByZXR1cm4gYFVzZSBcXGAke3Rva2VuLnRvTG93ZXJDYXNlKCl9XFxgIGluc3RlYWQgb2YgXFxgJHt0b2tlbn1cXGAgKGluIFxcYCR7Zm9ybWF0fVxcYCkgZm9yIGZvcm1hdHRpbmcgJHtzdWJqZWN0fSB0byB0aGUgaW5wdXQgXFxgJHtpbnB1dH1cXGA7IHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdW5pY29kZVRva2Vucy5tZGA7XG59XG4iXSwibmFtZXMiOlsiZGF5T2ZZZWFyVG9rZW5SRSIsIndlZWtZZWFyVG9rZW5SRSIsInRocm93VG9rZW5zIiwiaXNQcm90ZWN0ZWREYXlPZlllYXJUb2tlbiIsInRva2VuIiwidGVzdCIsImlzUHJvdGVjdGVkV2Vla1llYXJUb2tlbiIsIndhcm5PclRocm93UHJvdGVjdGVkRXJyb3IiLCJmb3JtYXQiLCJpbnB1dCIsIl9tZXNzYWdlIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwiaW5jbHVkZXMiLCJSYW5nZUVycm9yIiwic3ViamVjdCIsInRvTG93ZXJDYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/_lib/protectedTokens.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/constants.mjs":
/*!*********************************************!*\
  !*** ./node_modules/date-fns/constants.mjs ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   daysInWeek: function() { return /* binding */ daysInWeek; },\n/* harmony export */   daysInYear: function() { return /* binding */ daysInYear; },\n/* harmony export */   maxTime: function() { return /* binding */ maxTime; },\n/* harmony export */   millisecondsInDay: function() { return /* binding */ millisecondsInDay; },\n/* harmony export */   millisecondsInHour: function() { return /* binding */ millisecondsInHour; },\n/* harmony export */   millisecondsInMinute: function() { return /* binding */ millisecondsInMinute; },\n/* harmony export */   millisecondsInSecond: function() { return /* binding */ millisecondsInSecond; },\n/* harmony export */   millisecondsInWeek: function() { return /* binding */ millisecondsInWeek; },\n/* harmony export */   minTime: function() { return /* binding */ minTime; },\n/* harmony export */   minutesInDay: function() { return /* binding */ minutesInDay; },\n/* harmony export */   minutesInHour: function() { return /* binding */ minutesInHour; },\n/* harmony export */   minutesInMonth: function() { return /* binding */ minutesInMonth; },\n/* harmony export */   minutesInYear: function() { return /* binding */ minutesInYear; },\n/* harmony export */   monthsInQuarter: function() { return /* binding */ monthsInQuarter; },\n/* harmony export */   monthsInYear: function() { return /* binding */ monthsInYear; },\n/* harmony export */   quartersInYear: function() { return /* binding */ quartersInYear; },\n/* harmony export */   secondsInDay: function() { return /* binding */ secondsInDay; },\n/* harmony export */   secondsInHour: function() { return /* binding */ secondsInHour; },\n/* harmony export */   secondsInMinute: function() { return /* binding */ secondsInMinute; },\n/* harmony export */   secondsInMonth: function() { return /* binding */ secondsInMonth; },\n/* harmony export */   secondsInQuarter: function() { return /* binding */ secondsInQuarter; },\n/* harmony export */   secondsInWeek: function() { return /* binding */ secondsInWeek; },\n/* harmony export */   secondsInYear: function() { return /* binding */ secondsInYear; }\n/* harmony export */ });\n/**\n * @module constants\n * @summary Useful constants\n * @description\n * Collection of useful date constants.\n *\n * The constants could be imported from `date-fns/constants`:\n *\n * ```ts\n * import { maxTime, minTime } from \"./constants/date-fns/constants\";\n *\n * function isAllowedTime(time) {\n *   return time <= maxTime && time >= minTime;\n * }\n * ```\n */ /**\n * @constant\n * @name daysInWeek\n * @summary Days in 1 week.\n */ const daysInWeek = 7;\n/**\n * @constant\n * @name daysInYear\n * @summary Days in 1 year.\n *\n * @description\n * How many days in a year.\n *\n * One years equals 365.2425 days according to the formula:\n *\n * > Leap year occures every 4 years, except for years that are divisable by 100 and not divisable by 400.\n * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days\n */ const daysInYear = 365.2425;\n/**\n * @constant\n * @name maxTime\n * @summary Maximum allowed time.\n *\n * @example\n * import { maxTime } from \"./constants/date-fns/constants\";\n *\n * const isValid = 8640000000000001 <= maxTime;\n * //=> false\n *\n * new Date(8640000000000001);\n * //=> Invalid Date\n */ const maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;\n/**\n * @constant\n * @name minTime\n * @summary Minimum allowed time.\n *\n * @example\n * import { minTime } from \"./constants/date-fns/constants\";\n *\n * const isValid = -8640000000000001 >= minTime;\n * //=> false\n *\n * new Date(-8640000000000001)\n * //=> Invalid Date\n */ const minTime = -maxTime;\n/**\n * @constant\n * @name millisecondsInWeek\n * @summary Milliseconds in 1 week.\n */ const millisecondsInWeek = 604800000;\n/**\n * @constant\n * @name millisecondsInDay\n * @summary Milliseconds in 1 day.\n */ const millisecondsInDay = 86400000;\n/**\n * @constant\n * @name millisecondsInMinute\n * @summary Milliseconds in 1 minute\n */ const millisecondsInMinute = 60000;\n/**\n * @constant\n * @name millisecondsInHour\n * @summary Milliseconds in 1 hour\n */ const millisecondsInHour = 3600000;\n/**\n * @constant\n * @name millisecondsInSecond\n * @summary Milliseconds in 1 second\n */ const millisecondsInSecond = 1000;\n/**\n * @constant\n * @name minutesInYear\n * @summary Minutes in 1 year.\n */ const minutesInYear = 525600;\n/**\n * @constant\n * @name minutesInMonth\n * @summary Minutes in 1 month.\n */ const minutesInMonth = 43200;\n/**\n * @constant\n * @name minutesInDay\n * @summary Minutes in 1 day.\n */ const minutesInDay = 1440;\n/**\n * @constant\n * @name minutesInHour\n * @summary Minutes in 1 hour.\n */ const minutesInHour = 60;\n/**\n * @constant\n * @name monthsInQuarter\n * @summary Months in 1 quarter.\n */ const monthsInQuarter = 3;\n/**\n * @constant\n * @name monthsInYear\n * @summary Months in 1 year.\n */ const monthsInYear = 12;\n/**\n * @constant\n * @name quartersInYear\n * @summary Quarters in 1 year\n */ const quartersInYear = 4;\n/**\n * @constant\n * @name secondsInHour\n * @summary Seconds in 1 hour.\n */ const secondsInHour = 3600;\n/**\n * @constant\n * @name secondsInMinute\n * @summary Seconds in 1 minute.\n */ const secondsInMinute = 60;\n/**\n * @constant\n * @name secondsInDay\n * @summary Seconds in 1 day.\n */ const secondsInDay = secondsInHour * 24;\n/**\n * @constant\n * @name secondsInWeek\n * @summary Seconds in 1 week.\n */ const secondsInWeek = secondsInDay * 7;\n/**\n * @constant\n * @name secondsInYear\n * @summary Seconds in 1 year.\n */ const secondsInYear = secondsInDay * daysInYear;\n/**\n * @constant\n * @name secondsInMonth\n * @summary Seconds in 1 month\n */ const secondsInMonth = secondsInYear / 12;\n/**\n * @constant\n * @name secondsInQuarter\n * @summary Seconds in 1 quarter.\n */ const secondsInQuarter = secondsInMonth * 3;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9jb25zdGFudHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBRUQ7Ozs7Q0FJQyxHQUNNLE1BQU1BLGFBQWEsRUFBRTtBQUU1Qjs7Ozs7Ozs7Ozs7O0NBWUMsR0FDTSxNQUFNQyxhQUFhLFNBQVM7QUFFbkM7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNNLE1BQU1DLFVBQVVDLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSztBQUU3RDs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sTUFBTUMsVUFBVSxDQUFDSCxRQUFRO0FBRWhDOzs7O0NBSUMsR0FDTSxNQUFNSSxxQkFBcUIsVUFBVTtBQUU1Qzs7OztDQUlDLEdBQ00sTUFBTUMsb0JBQW9CLFNBQVM7QUFFMUM7Ozs7Q0FJQyxHQUNNLE1BQU1DLHVCQUF1QixNQUFNO0FBRTFDOzs7O0NBSUMsR0FDTSxNQUFNQyxxQkFBcUIsUUFBUTtBQUUxQzs7OztDQUlDLEdBQ00sTUFBTUMsdUJBQXVCLEtBQUs7QUFFekM7Ozs7Q0FJQyxHQUNNLE1BQU1DLGdCQUFnQixPQUFPO0FBRXBDOzs7O0NBSUMsR0FDTSxNQUFNQyxpQkFBaUIsTUFBTTtBQUVwQzs7OztDQUlDLEdBQ00sTUFBTUMsZUFBZSxLQUFLO0FBRWpDOzs7O0NBSUMsR0FDTSxNQUFNQyxnQkFBZ0IsR0FBRztBQUVoQzs7OztDQUlDLEdBQ00sTUFBTUMsa0JBQWtCLEVBQUU7QUFFakM7Ozs7Q0FJQyxHQUNNLE1BQU1DLGVBQWUsR0FBRztBQUUvQjs7OztDQUlDLEdBQ00sTUFBTUMsaUJBQWlCLEVBQUU7QUFFaEM7Ozs7Q0FJQyxHQUNNLE1BQU1DLGdCQUFnQixLQUFLO0FBRWxDOzs7O0NBSUMsR0FDTSxNQUFNQyxrQkFBa0IsR0FBRztBQUVsQzs7OztDQUlDLEdBQ00sTUFBTUMsZUFBZUYsZ0JBQWdCLEdBQUc7QUFFL0M7Ozs7Q0FJQyxHQUNNLE1BQU1HLGdCQUFnQkQsZUFBZSxFQUFFO0FBRTlDOzs7O0NBSUMsR0FDTSxNQUFNRSxnQkFBZ0JGLGVBQWVuQixXQUFXO0FBRXZEOzs7O0NBSUMsR0FDTSxNQUFNc0IsaUJBQWlCRCxnQkFBZ0IsR0FBRztBQUVqRDs7OztDQUlDLEdBQ00sTUFBTUUsbUJBQW1CRCxpQkFBaUIsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvY29uc3RhbnRzLm1qcz8zODdiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBjb25zdGFudHNcbiAqIEBzdW1tYXJ5IFVzZWZ1bCBjb25zdGFudHNcbiAqIEBkZXNjcmlwdGlvblxuICogQ29sbGVjdGlvbiBvZiB1c2VmdWwgZGF0ZSBjb25zdGFudHMuXG4gKlxuICogVGhlIGNvbnN0YW50cyBjb3VsZCBiZSBpbXBvcnRlZCBmcm9tIGBkYXRlLWZucy9jb25zdGFudHNgOlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBtYXhUaW1lLCBtaW5UaW1lIH0gZnJvbSBcIi4vY29uc3RhbnRzL2RhdGUtZm5zL2NvbnN0YW50c1wiO1xuICpcbiAqIGZ1bmN0aW9uIGlzQWxsb3dlZFRpbWUodGltZSkge1xuICogICByZXR1cm4gdGltZSA8PSBtYXhUaW1lICYmIHRpbWUgPj0gbWluVGltZTtcbiAqIH1cbiAqIGBgYFxuICovXG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBkYXlzSW5XZWVrXG4gKiBAc3VtbWFyeSBEYXlzIGluIDEgd2Vlay5cbiAqL1xuZXhwb3J0IGNvbnN0IGRheXNJbldlZWsgPSA3O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgZGF5c0luWWVhclxuICogQHN1bW1hcnkgRGF5cyBpbiAxIHllYXIuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBIb3cgbWFueSBkYXlzIGluIGEgeWVhci5cbiAqXG4gKiBPbmUgeWVhcnMgZXF1YWxzIDM2NS4yNDI1IGRheXMgYWNjb3JkaW5nIHRvIHRoZSBmb3JtdWxhOlxuICpcbiAqID4gTGVhcCB5ZWFyIG9jY3VyZXMgZXZlcnkgNCB5ZWFycywgZXhjZXB0IGZvciB5ZWFycyB0aGF0IGFyZSBkaXZpc2FibGUgYnkgMTAwIGFuZCBub3QgZGl2aXNhYmxlIGJ5IDQwMC5cbiAqID4gMSBtZWFuIHllYXIgPSAoMzY1KzEvNC0xLzEwMCsxLzQwMCkgZGF5cyA9IDM2NS4yNDI1IGRheXNcbiAqL1xuZXhwb3J0IGNvbnN0IGRheXNJblllYXIgPSAzNjUuMjQyNTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIG1heFRpbWVcbiAqIEBzdW1tYXJ5IE1heGltdW0gYWxsb3dlZCB0aW1lLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBtYXhUaW1lIH0gZnJvbSBcIi4vY29uc3RhbnRzL2RhdGUtZm5zL2NvbnN0YW50c1wiO1xuICpcbiAqIGNvbnN0IGlzVmFsaWQgPSA4NjQwMDAwMDAwMDAwMDAxIDw9IG1heFRpbWU7XG4gKiAvLz0+IGZhbHNlXG4gKlxuICogbmV3IERhdGUoODY0MDAwMDAwMDAwMDAwMSk7XG4gKiAvLz0+IEludmFsaWQgRGF0ZVxuICovXG5leHBvcnQgY29uc3QgbWF4VGltZSA9IE1hdGgucG93KDEwLCA4KSAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBtaW5UaW1lXG4gKiBAc3VtbWFyeSBNaW5pbXVtIGFsbG93ZWQgdGltZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgbWluVGltZSB9IGZyb20gXCIuL2NvbnN0YW50cy9kYXRlLWZucy9jb25zdGFudHNcIjtcbiAqXG4gKiBjb25zdCBpc1ZhbGlkID0gLTg2NDAwMDAwMDAwMDAwMDEgPj0gbWluVGltZTtcbiAqIC8vPT4gZmFsc2VcbiAqXG4gKiBuZXcgRGF0ZSgtODY0MDAwMDAwMDAwMDAwMSlcbiAqIC8vPT4gSW52YWxpZCBEYXRlXG4gKi9cbmV4cG9ydCBjb25zdCBtaW5UaW1lID0gLW1heFRpbWU7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBtaWxsaXNlY29uZHNJbldlZWtcbiAqIEBzdW1tYXJ5IE1pbGxpc2Vjb25kcyBpbiAxIHdlZWsuXG4gKi9cbmV4cG9ydCBjb25zdCBtaWxsaXNlY29uZHNJbldlZWsgPSA2MDQ4MDAwMDA7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBtaWxsaXNlY29uZHNJbkRheVxuICogQHN1bW1hcnkgTWlsbGlzZWNvbmRzIGluIDEgZGF5LlxuICovXG5leHBvcnQgY29uc3QgbWlsbGlzZWNvbmRzSW5EYXkgPSA4NjQwMDAwMDtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIG1pbGxpc2Vjb25kc0luTWludXRlXG4gKiBAc3VtbWFyeSBNaWxsaXNlY29uZHMgaW4gMSBtaW51dGVcbiAqL1xuZXhwb3J0IGNvbnN0IG1pbGxpc2Vjb25kc0luTWludXRlID0gNjAwMDA7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBtaWxsaXNlY29uZHNJbkhvdXJcbiAqIEBzdW1tYXJ5IE1pbGxpc2Vjb25kcyBpbiAxIGhvdXJcbiAqL1xuZXhwb3J0IGNvbnN0IG1pbGxpc2Vjb25kc0luSG91ciA9IDM2MDAwMDA7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBtaWxsaXNlY29uZHNJblNlY29uZFxuICogQHN1bW1hcnkgTWlsbGlzZWNvbmRzIGluIDEgc2Vjb25kXG4gKi9cbmV4cG9ydCBjb25zdCBtaWxsaXNlY29uZHNJblNlY29uZCA9IDEwMDA7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBtaW51dGVzSW5ZZWFyXG4gKiBAc3VtbWFyeSBNaW51dGVzIGluIDEgeWVhci5cbiAqL1xuZXhwb3J0IGNvbnN0IG1pbnV0ZXNJblllYXIgPSA1MjU2MDA7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBtaW51dGVzSW5Nb250aFxuICogQHN1bW1hcnkgTWludXRlcyBpbiAxIG1vbnRoLlxuICovXG5leHBvcnQgY29uc3QgbWludXRlc0luTW9udGggPSA0MzIwMDtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIG1pbnV0ZXNJbkRheVxuICogQHN1bW1hcnkgTWludXRlcyBpbiAxIGRheS5cbiAqL1xuZXhwb3J0IGNvbnN0IG1pbnV0ZXNJbkRheSA9IDE0NDA7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBtaW51dGVzSW5Ib3VyXG4gKiBAc3VtbWFyeSBNaW51dGVzIGluIDEgaG91ci5cbiAqL1xuZXhwb3J0IGNvbnN0IG1pbnV0ZXNJbkhvdXIgPSA2MDtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIG1vbnRoc0luUXVhcnRlclxuICogQHN1bW1hcnkgTW9udGhzIGluIDEgcXVhcnRlci5cbiAqL1xuZXhwb3J0IGNvbnN0IG1vbnRoc0luUXVhcnRlciA9IDM7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBtb250aHNJblllYXJcbiAqIEBzdW1tYXJ5IE1vbnRocyBpbiAxIHllYXIuXG4gKi9cbmV4cG9ydCBjb25zdCBtb250aHNJblllYXIgPSAxMjtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIHF1YXJ0ZXJzSW5ZZWFyXG4gKiBAc3VtbWFyeSBRdWFydGVycyBpbiAxIHllYXJcbiAqL1xuZXhwb3J0IGNvbnN0IHF1YXJ0ZXJzSW5ZZWFyID0gNDtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIHNlY29uZHNJbkhvdXJcbiAqIEBzdW1tYXJ5IFNlY29uZHMgaW4gMSBob3VyLlxuICovXG5leHBvcnQgY29uc3Qgc2Vjb25kc0luSG91ciA9IDM2MDA7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBzZWNvbmRzSW5NaW51dGVcbiAqIEBzdW1tYXJ5IFNlY29uZHMgaW4gMSBtaW51dGUuXG4gKi9cbmV4cG9ydCBjb25zdCBzZWNvbmRzSW5NaW51dGUgPSA2MDtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIHNlY29uZHNJbkRheVxuICogQHN1bW1hcnkgU2Vjb25kcyBpbiAxIGRheS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNlY29uZHNJbkRheSA9IHNlY29uZHNJbkhvdXIgKiAyNDtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEBuYW1lIHNlY29uZHNJbldlZWtcbiAqIEBzdW1tYXJ5IFNlY29uZHMgaW4gMSB3ZWVrLlxuICovXG5leHBvcnQgY29uc3Qgc2Vjb25kc0luV2VlayA9IHNlY29uZHNJbkRheSAqIDc7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBzZWNvbmRzSW5ZZWFyXG4gKiBAc3VtbWFyeSBTZWNvbmRzIGluIDEgeWVhci5cbiAqL1xuZXhwb3J0IGNvbnN0IHNlY29uZHNJblllYXIgPSBzZWNvbmRzSW5EYXkgKiBkYXlzSW5ZZWFyO1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQG5hbWUgc2Vjb25kc0luTW9udGhcbiAqIEBzdW1tYXJ5IFNlY29uZHMgaW4gMSBtb250aFxuICovXG5leHBvcnQgY29uc3Qgc2Vjb25kc0luTW9udGggPSBzZWNvbmRzSW5ZZWFyIC8gMTI7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAbmFtZSBzZWNvbmRzSW5RdWFydGVyXG4gKiBAc3VtbWFyeSBTZWNvbmRzIGluIDEgcXVhcnRlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHNlY29uZHNJblF1YXJ0ZXIgPSBzZWNvbmRzSW5Nb250aCAqIDM7XG4iXSwibmFtZXMiOlsiZGF5c0luV2VlayIsImRheXNJblllYXIiLCJtYXhUaW1lIiwiTWF0aCIsInBvdyIsIm1pblRpbWUiLCJtaWxsaXNlY29uZHNJbldlZWsiLCJtaWxsaXNlY29uZHNJbkRheSIsIm1pbGxpc2Vjb25kc0luTWludXRlIiwibWlsbGlzZWNvbmRzSW5Ib3VyIiwibWlsbGlzZWNvbmRzSW5TZWNvbmQiLCJtaW51dGVzSW5ZZWFyIiwibWludXRlc0luTW9udGgiLCJtaW51dGVzSW5EYXkiLCJtaW51dGVzSW5Ib3VyIiwibW9udGhzSW5RdWFydGVyIiwibW9udGhzSW5ZZWFyIiwicXVhcnRlcnNJblllYXIiLCJzZWNvbmRzSW5Ib3VyIiwic2Vjb25kc0luTWludXRlIiwic2Vjb25kc0luRGF5Iiwic2Vjb25kc0luV2VlayIsInNlY29uZHNJblllYXIiLCJzZWNvbmRzSW5Nb250aCIsInNlY29uZHNJblF1YXJ0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/constants.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/constructFrom.mjs":
/*!*************************************************!*\
  !*** ./node_modules/date-fns/constructFrom.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   constructFrom: function() { return /* binding */ constructFrom; }\n/* harmony export */ });\n/**\n * @name constructFrom\n * @category Generic Helpers\n * @summary Constructs a date using the reference date and the value\n *\n * @description\n * The function constructs a new date using the constructor from the reference\n * date and the given value. It helps to build generic functions that accept\n * date extensions.\n *\n * It defaults to `Date` if the passed reference date is a number or a string.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The reference date to take constructor from\n * @param value - The value to create the date\n *\n * @returns Date initialized using the given date and value\n *\n * @example\n * import { constructFrom } from 'date-fns'\n *\n * // A function that clones a date preserving the original type\n * function cloneDate<DateType extends Date(date: DateType): DateType {\n *   return constructFrom(\n *     date, // Use contrustor from the given date\n *     date.getTime() // Use the date value to create a new date\n *   )\n * }\n */ function constructFrom(date, value) {\n    if (date instanceof Date) {\n        return new date.constructor(value);\n    } else {\n        return new Date(value);\n    }\n}\n// Fallback for modularized imports:\n/* harmony default export */ __webpack_exports__[\"default\"] = (constructFrom);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9jb25zdHJ1Y3RGcm9tLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkJDLEdBQ00sU0FBU0EsY0FBY0MsSUFBSSxFQUFFQyxLQUFLO0lBQ3ZDLElBQUlELGdCQUFnQkUsTUFBTTtRQUN4QixPQUFPLElBQUlGLEtBQUtHLFdBQVcsQ0FBQ0Y7SUFDOUIsT0FBTztRQUNMLE9BQU8sSUFBSUMsS0FBS0Q7SUFDbEI7QUFDRjtBQUVBLG9DQUFvQztBQUNwQywrREFBZUYsYUFBYUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvY29uc3RydWN0RnJvbS5tanM/Y2EzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBuYW1lIGNvbnN0cnVjdEZyb21cbiAqIEBjYXRlZ29yeSBHZW5lcmljIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IENvbnN0cnVjdHMgYSBkYXRlIHVzaW5nIHRoZSByZWZlcmVuY2UgZGF0ZSBhbmQgdGhlIHZhbHVlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgZnVuY3Rpb24gY29uc3RydWN0cyBhIG5ldyBkYXRlIHVzaW5nIHRoZSBjb25zdHJ1Y3RvciBmcm9tIHRoZSByZWZlcmVuY2VcbiAqIGRhdGUgYW5kIHRoZSBnaXZlbiB2YWx1ZS4gSXQgaGVscHMgdG8gYnVpbGQgZ2VuZXJpYyBmdW5jdGlvbnMgdGhhdCBhY2NlcHRcbiAqIGRhdGUgZXh0ZW5zaW9ucy5cbiAqXG4gKiBJdCBkZWZhdWx0cyB0byBgRGF0ZWAgaWYgdGhlIHBhc3NlZCByZWZlcmVuY2UgZGF0ZSBpcyBhIG51bWJlciBvciBhIHN0cmluZy5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSByZWZlcmVuY2UgZGF0ZSB0byB0YWtlIGNvbnN0cnVjdG9yIGZyb21cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBEYXRlIGluaXRpYWxpemVkIHVzaW5nIHRoZSBnaXZlbiBkYXRlIGFuZCB2YWx1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBjb25zdHJ1Y3RGcm9tIH0gZnJvbSAnZGF0ZS1mbnMnXG4gKlxuICogLy8gQSBmdW5jdGlvbiB0aGF0IGNsb25lcyBhIGRhdGUgcHJlc2VydmluZyB0aGUgb3JpZ2luYWwgdHlwZVxuICogZnVuY3Rpb24gY2xvbmVEYXRlPERhdGVUeXBlIGV4dGVuZHMgRGF0ZShkYXRlOiBEYXRlVHlwZSk6IERhdGVUeXBlIHtcbiAqICAgcmV0dXJuIGNvbnN0cnVjdEZyb20oXG4gKiAgICAgZGF0ZSwgLy8gVXNlIGNvbnRydXN0b3IgZnJvbSB0aGUgZ2l2ZW4gZGF0ZVxuICogICAgIGRhdGUuZ2V0VGltZSgpIC8vIFVzZSB0aGUgZGF0ZSB2YWx1ZSB0byBjcmVhdGUgYSBuZXcgZGF0ZVxuICogICApXG4gKiB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3RGcm9tKGRhdGUsIHZhbHVlKSB7XG4gIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBuZXcgZGF0ZS5jb25zdHJ1Y3Rvcih2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgfVxufVxuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IGNvbnN0cnVjdEZyb207XG4iXSwibmFtZXMiOlsiY29uc3RydWN0RnJvbSIsImRhdGUiLCJ2YWx1ZSIsIkRhdGUiLCJjb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/constructFrom.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/differenceInCalendarDays.mjs":
/*!************************************************************!*\
  !*** ./node_modules/date-fns/differenceInCalendarDays.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   differenceInCalendarDays: function() { return /* binding */ differenceInCalendarDays; }\n/* harmony export */ });\n/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.mjs */ \"(app-pages-browser)/./node_modules/date-fns/constants.mjs\");\n/* harmony import */ var _startOfDay_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./startOfDay.mjs */ \"(app-pages-browser)/./node_modules/date-fns/startOfDay.mjs\");\n/* harmony import */ var _lib_getTimezoneOffsetInMilliseconds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_lib/getTimezoneOffsetInMilliseconds.mjs */ \"(app-pages-browser)/./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.mjs\");\n\n\n\n/**\n * @name differenceInCalendarDays\n * @category Day Helpers\n * @summary Get the number of calendar days between the given dates.\n *\n * @description\n * Get the number of calendar days between the given dates. This means that the times are removed\n * from the dates and then the difference in days is calculated.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param dateLeft - The later date\n * @param dateRight - The earlier date\n *\n * @returns The number of calendar days\n *\n * @example\n * // How many calendar days are between\n * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?\n * const result = differenceInCalendarDays(\n *   new Date(2012, 6, 2, 0, 0),\n *   new Date(2011, 6, 2, 23, 0)\n * )\n * //=> 366\n * // How many calendar days are between\n * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?\n * const result = differenceInCalendarDays(\n *   new Date(2011, 6, 3, 0, 1),\n *   new Date(2011, 6, 2, 23, 59)\n * )\n * //=> 1\n */ function differenceInCalendarDays(dateLeft, dateRight) {\n    const startOfDayLeft = (0,_startOfDay_mjs__WEBPACK_IMPORTED_MODULE_0__.startOfDay)(dateLeft);\n    const startOfDayRight = (0,_startOfDay_mjs__WEBPACK_IMPORTED_MODULE_0__.startOfDay)(dateRight);\n    const timestampLeft = +startOfDayLeft - (0,_lib_getTimezoneOffsetInMilliseconds_mjs__WEBPACK_IMPORTED_MODULE_1__.getTimezoneOffsetInMilliseconds)(startOfDayLeft);\n    const timestampRight = +startOfDayRight - (0,_lib_getTimezoneOffsetInMilliseconds_mjs__WEBPACK_IMPORTED_MODULE_1__.getTimezoneOffsetInMilliseconds)(startOfDayRight);\n    // Round the number of days to the nearest integer because the number of\n    // milliseconds in a day is not constant (e.g. it's different in the week of\n    // the daylight saving time clock shift).\n    return Math.round((timestampLeft - timestampRight) / _constants_mjs__WEBPACK_IMPORTED_MODULE_2__.millisecondsInDay);\n}\n// Fallback for modularized imports:\n/* harmony default export */ __webpack_exports__[\"default\"] = (differenceInCalendarDays);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9kaWZmZXJlbmNlSW5DYWxlbmRhckRheXMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBb0Q7QUFDTjtBQUMrQztBQUU3Rjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQStCQyxHQUNNLFNBQVNHLHlCQUF5QkMsUUFBUSxFQUFFQyxTQUFTO0lBQzFELE1BQU1DLGlCQUFpQkwsMkRBQVVBLENBQUNHO0lBQ2xDLE1BQU1HLGtCQUFrQk4sMkRBQVVBLENBQUNJO0lBRW5DLE1BQU1HLGdCQUNKLENBQUNGLGlCQUFpQkoseUdBQStCQSxDQUFDSTtJQUNwRCxNQUFNRyxpQkFDSixDQUFDRixrQkFBa0JMLHlHQUErQkEsQ0FBQ0s7SUFFckQsd0VBQXdFO0lBQ3hFLDRFQUE0RTtJQUM1RSx5Q0FBeUM7SUFDekMsT0FBT0csS0FBS0MsS0FBSyxDQUFDLENBQUNILGdCQUFnQkMsY0FBYSxJQUFLVCw2REFBaUJBO0FBQ3hFO0FBRUEsb0NBQW9DO0FBQ3BDLCtEQUFlRyx3QkFBd0JBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2RpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cy5tanM/ZWRjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtaWxsaXNlY29uZHNJbkRheSB9IGZyb20gXCIuL2NvbnN0YW50cy5tanNcIjtcbmltcG9ydCB7IHN0YXJ0T2ZEYXkgfSBmcm9tIFwiLi9zdGFydE9mRGF5Lm1qc1wiO1xuaW1wb3J0IHsgZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyB9IGZyb20gXCIuL19saWIvZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcy5tanNcIjtcblxuLyoqXG4gKiBAbmFtZSBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXNcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBudW1iZXIgb2YgY2FsZW5kYXIgZGF5cyBiZXR3ZWVuIHRoZSBnaXZlbiBkYXRlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgbnVtYmVyIG9mIGNhbGVuZGFyIGRheXMgYmV0d2VlbiB0aGUgZ2l2ZW4gZGF0ZXMuIFRoaXMgbWVhbnMgdGhhdCB0aGUgdGltZXMgYXJlIHJlbW92ZWRcbiAqIGZyb20gdGhlIGRhdGVzIGFuZCB0aGVuIHRoZSBkaWZmZXJlbmNlIGluIGRheXMgaXMgY2FsY3VsYXRlZC5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZUxlZnQgLSBUaGUgbGF0ZXIgZGF0ZVxuICogQHBhcmFtIGRhdGVSaWdodCAtIFRoZSBlYXJsaWVyIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGNhbGVuZGFyIGRheXNcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSG93IG1hbnkgY2FsZW5kYXIgZGF5cyBhcmUgYmV0d2VlblxuICogLy8gMiBKdWx5IDIwMTEgMjM6MDA6MDAgYW5kIDIgSnVseSAyMDEyIDAwOjAwOjAwP1xuICogY29uc3QgcmVzdWx0ID0gZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKFxuICogICBuZXcgRGF0ZSgyMDEyLCA2LCAyLCAwLCAwKSxcbiAqICAgbmV3IERhdGUoMjAxMSwgNiwgMiwgMjMsIDApXG4gKiApXG4gKiAvLz0+IDM2NlxuICogLy8gSG93IG1hbnkgY2FsZW5kYXIgZGF5cyBhcmUgYmV0d2VlblxuICogLy8gMiBKdWx5IDIwMTEgMjM6NTk6MDAgYW5kIDMgSnVseSAyMDExIDAwOjAxOjAwP1xuICogY29uc3QgcmVzdWx0ID0gZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKFxuICogICBuZXcgRGF0ZSgyMDExLCA2LCAzLCAwLCAxKSxcbiAqICAgbmV3IERhdGUoMjAxMSwgNiwgMiwgMjMsIDU5KVxuICogKVxuICogLy89PiAxXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMoZGF0ZUxlZnQsIGRhdGVSaWdodCkge1xuICBjb25zdCBzdGFydE9mRGF5TGVmdCA9IHN0YXJ0T2ZEYXkoZGF0ZUxlZnQpO1xuICBjb25zdCBzdGFydE9mRGF5UmlnaHQgPSBzdGFydE9mRGF5KGRhdGVSaWdodCk7XG5cbiAgY29uc3QgdGltZXN0YW1wTGVmdCA9XG4gICAgK3N0YXJ0T2ZEYXlMZWZ0IC0gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhzdGFydE9mRGF5TGVmdCk7XG4gIGNvbnN0IHRpbWVzdGFtcFJpZ2h0ID1cbiAgICArc3RhcnRPZkRheVJpZ2h0IC0gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhzdGFydE9mRGF5UmlnaHQpO1xuXG4gIC8vIFJvdW5kIHRoZSBudW1iZXIgb2YgZGF5cyB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyIGJlY2F1c2UgdGhlIG51bWJlciBvZlxuICAvLyBtaWxsaXNlY29uZHMgaW4gYSBkYXkgaXMgbm90IGNvbnN0YW50IChlLmcuIGl0J3MgZGlmZmVyZW50IGluIHRoZSB3ZWVrIG9mXG4gIC8vIHRoZSBkYXlsaWdodCBzYXZpbmcgdGltZSBjbG9jayBzaGlmdCkuXG4gIHJldHVybiBNYXRoLnJvdW5kKCh0aW1lc3RhbXBMZWZ0IC0gdGltZXN0YW1wUmlnaHQpIC8gbWlsbGlzZWNvbmRzSW5EYXkpO1xufVxuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cztcbiJdLCJuYW1lcyI6WyJtaWxsaXNlY29uZHNJbkRheSIsInN0YXJ0T2ZEYXkiLCJnZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzIiwiZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzIiwiZGF0ZUxlZnQiLCJkYXRlUmlnaHQiLCJzdGFydE9mRGF5TGVmdCIsInN0YXJ0T2ZEYXlSaWdodCIsInRpbWVzdGFtcExlZnQiLCJ0aW1lc3RhbXBSaWdodCIsIk1hdGgiLCJyb3VuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/differenceInCalendarDays.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/format.mjs":
/*!******************************************!*\
  !*** ./node_modules/date-fns/format.mjs ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   format: function() { return /* binding */ format; },\n/* harmony export */   formatDate: function() { return /* binding */ format; },\n/* harmony export */   formatters: function() { return /* reexport safe */ _lib_format_formatters_mjs__WEBPACK_IMPORTED_MODULE_0__.formatters; },\n/* harmony export */   longFormatters: function() { return /* reexport safe */ _lib_format_longFormatters_mjs__WEBPACK_IMPORTED_MODULE_1__.longFormatters; }\n/* harmony export */ });\n/* harmony import */ var _lib_defaultLocale_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_lib/defaultLocale.mjs */ \"(app-pages-browser)/./node_modules/date-fns/locale/en-US.mjs\");\n/* harmony import */ var _lib_defaultOptions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_lib/defaultOptions.mjs */ \"(app-pages-browser)/./node_modules/date-fns/_lib/defaultOptions.mjs\");\n/* harmony import */ var _lib_format_formatters_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_lib/format/formatters.mjs */ \"(app-pages-browser)/./node_modules/date-fns/_lib/format/formatters.mjs\");\n/* harmony import */ var _lib_format_longFormatters_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_lib/format/longFormatters.mjs */ \"(app-pages-browser)/./node_modules/date-fns/_lib/format/longFormatters.mjs\");\n/* harmony import */ var _lib_protectedTokens_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_lib/protectedTokens.mjs */ \"(app-pages-browser)/./node_modules/date-fns/_lib/protectedTokens.mjs\");\n/* harmony import */ var _isValid_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isValid.mjs */ \"(app-pages-browser)/./node_modules/date-fns/isValid.mjs\");\n/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./toDate.mjs */ \"(app-pages-browser)/./node_modules/date-fns/toDate.mjs\");\n\n\n\n\n\n\n\n// Rexports of internal for libraries to use.\n// See: https://github.com/date-fns/date-fns/issues/3638#issuecomment-1877082874\n\n// This RegExp consists of three parts separated by `|`:\n// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token\n//   (one of the certain letters followed by `o`)\n// - (\\w)\\1* matches any sequences of the same letter\n// - '' matches two quote characters in a row\n// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),\n//   except a single quote symbol, which ends the sequence.\n//   Two quote characters do not end the sequence.\n//   If there is no matching single quote\n//   then the sequence will continue until the end of the string.\n// - . matches any single character unmatched by previous parts of the RegExps\nconst formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\\w)\\1*|''|'(''|[^'])+('|$)|./g;\n// This RegExp catches symbols escaped by quotes, and also\n// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`\nconst longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;\nconst escapedStringRegExp = /^'([^]*?)'?$/;\nconst doubleQuoteRegExp = /''/g;\nconst unescapedLatinCharacterRegExp = /[a-zA-Z]/;\n\n/**\n * The {@link format} function options.\n */ /**\n * @name format\n * @alias formatDate\n * @category Common Helpers\n * @summary Format the date.\n *\n * @description\n * Return the formatted date string in the given format. The result may vary by locale.\n *\n * >  Please note that the `format` tokens differ from Moment.js and other libraries.\n * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md\n *\n * The characters wrapped between two single quotes characters (') are escaped.\n * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.\n * (see the last example)\n *\n * Format of the string is based on Unicode Technical Standard #35:\n * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n * with a few additions (see note 7 below the table).\n *\n * Accepted patterns:\n * | Unit                            | Pattern | Result examples                   | Notes |\n * |---------------------------------|---------|-----------------------------------|-------|\n * | Era                             | G..GGG  | AD, BC                            |       |\n * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |\n * |                                 | GGGGG   | A, B                              |       |\n * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |\n * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |\n * |                                 | yy      | 44, 01, 00, 17                    | 5     |\n * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |\n * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |\n * |                                 | yyyyy   | ...                               | 3,5   |\n * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |\n * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |\n * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |\n * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |\n * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |\n * |                                 | YYYYY   | ...                               | 3,5   |\n * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |\n * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |\n * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |\n * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |\n * |                                 | RRRRR   | ...                               | 3,5,7 |\n * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |\n * |                                 | uu      | -43, 01, 1900, 2017               | 5     |\n * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |\n * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |\n * |                                 | uuuuu   | ...                               | 3,5   |\n * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |\n * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |\n * |                                 | QQ      | 01, 02, 03, 04                    |       |\n * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |\n * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |\n * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |\n * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |\n * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |\n * |                                 | qq      | 01, 02, 03, 04                    |       |\n * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |\n * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |\n * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |\n * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |\n * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |\n * |                                 | MM      | 01, 02, ..., 12                   |       |\n * |                                 | MMM     | Jan, Feb, ..., Dec                |       |\n * |                                 | MMMM    | January, February, ..., December  | 2     |\n * |                                 | MMMMM   | J, F, ..., D                      |       |\n * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |\n * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |\n * |                                 | LL      | 01, 02, ..., 12                   |       |\n * |                                 | LLL     | Jan, Feb, ..., Dec                |       |\n * |                                 | LLLL    | January, February, ..., December  | 2     |\n * |                                 | LLLLL   | J, F, ..., D                      |       |\n * | Local week of year              | w       | 1, 2, ..., 53                     |       |\n * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |\n * |                                 | ww      | 01, 02, ..., 53                   |       |\n * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |\n * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |\n * |                                 | II      | 01, 02, ..., 53                   | 7     |\n * | Day of month                    | d       | 1, 2, ..., 31                     |       |\n * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |\n * |                                 | dd      | 01, 02, ..., 31                   |       |\n * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |\n * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |\n * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |\n * |                                 | DDD     | 001, 002, ..., 365, 366           |       |\n * |                                 | DDDD    | ...                               | 3     |\n * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |\n * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |\n * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |\n * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |\n * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |\n * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |\n * |                                 | ii      | 01, 02, ..., 07                   | 7     |\n * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |\n * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |\n * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |\n * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |\n * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |\n * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |\n * |                                 | ee      | 02, 03, ..., 01                   |       |\n * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |\n * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |\n * |                                 | eeeee   | M, T, W, T, F, S, S               |       |\n * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |\n * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |\n * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |\n * |                                 | cc      | 02, 03, ..., 01                   |       |\n * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |\n * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |\n * |                                 | ccccc   | M, T, W, T, F, S, S               |       |\n * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |\n * | AM, PM                          | a..aa   | AM, PM                            |       |\n * |                                 | aaa     | am, pm                            |       |\n * |                                 | aaaa    | a.m., p.m.                        | 2     |\n * |                                 | aaaaa   | a, p                              |       |\n * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |\n * |                                 | bbb     | am, pm, noon, midnight            |       |\n * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |\n * |                                 | bbbbb   | a, p, n, mi                       |       |\n * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |\n * |                                 | BBBB    | at night, in the morning, ...     | 2     |\n * |                                 | BBBBB   | at night, in the morning, ...     |       |\n * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |\n * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |\n * |                                 | hh      | 01, 02, ..., 11, 12               |       |\n * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |\n * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |\n * |                                 | HH      | 00, 01, 02, ..., 23               |       |\n * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |\n * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |\n * |                                 | KK      | 01, 02, ..., 11, 00               |       |\n * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |\n * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |\n * |                                 | kk      | 24, 01, 02, ..., 23               |       |\n * | Minute                          | m       | 0, 1, ..., 59                     |       |\n * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |\n * |                                 | mm      | 00, 01, ..., 59                   |       |\n * | Second                          | s       | 0, 1, ..., 59                     |       |\n * |                                 | so      | 0th, 1st, ..., 59th               | 7     |\n * |                                 | ss      | 00, 01, ..., 59                   |       |\n * | Fraction of second              | S       | 0, 1, ..., 9                      |       |\n * |                                 | SS      | 00, 01, ..., 99                   |       |\n * |                                 | SSS     | 000, 001, ..., 999                |       |\n * |                                 | SSSS    | ...                               | 3     |\n * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |\n * |                                 | XX      | -0800, +0530, Z                   |       |\n * |                                 | XXX     | -08:00, +05:30, Z                 |       |\n * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |\n * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |\n * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |\n * |                                 | xx      | -0800, +0530, +0000               |       |\n * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |\n * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |\n * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |\n * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |\n * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |\n * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |\n * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |\n * | Seconds timestamp               | t       | 512969520                         | 7     |\n * |                                 | tt      | ...                               | 3,7   |\n * | Milliseconds timestamp          | T       | 512969520900                      | 7     |\n * |                                 | TT      | ...                               | 3,7   |\n * | Long localized date             | P       | 04/29/1453                        | 7     |\n * |                                 | PP      | Apr 29, 1453                      | 7     |\n * |                                 | PPP     | April 29th, 1453                  | 7     |\n * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |\n * | Long localized time             | p       | 12:00 AM                          | 7     |\n * |                                 | pp      | 12:00:00 AM                       | 7     |\n * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |\n * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |\n * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |\n * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |\n * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |\n * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |\n * Notes:\n * 1. \"Formatting\" units (e.g. formatting quarter) in the default en-US locale\n *    are the same as \"stand-alone\" units, but are different in some languages.\n *    \"Formatting\" units are declined according to the rules of the language\n *    in the context of a date. \"Stand-alone\" units are always nominative singular:\n *\n *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`\n *\n *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`\n *\n * 2. Any sequence of the identical letters is a pattern, unless it is escaped by\n *    the single quote characters (see below).\n *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)\n *    the output will be the same as default pattern for this unit, usually\n *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units\n *    are marked with \"2\" in the last column of the table.\n *\n *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`\n *\n *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`\n *\n *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`\n *\n *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`\n *\n *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`\n *\n * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).\n *    The output will be padded with zeros to match the length of the pattern.\n *\n *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`\n *\n * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.\n *    These tokens represent the shortest form of the quarter.\n *\n * 5. The main difference between `y` and `u` patterns are B.C. years:\n *\n *    | Year | `y` | `u` |\n *    |------|-----|-----|\n *    | AC 1 |   1 |   1 |\n *    | BC 1 |   1 |   0 |\n *    | BC 2 |   2 |  -1 |\n *\n *    Also `yy` always returns the last two digits of a year,\n *    while `uu` pads single digit years to 2 characters and returns other years unchanged:\n *\n *    | Year | `yy` | `uu` |\n *    |------|------|------|\n *    | 1    |   01 |   01 |\n *    | 14   |   14 |   14 |\n *    | 376  |   76 |  376 |\n *    | 1453 |   53 | 1453 |\n *\n *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),\n *    except local week-numbering years are dependent on `options.weekStartsOn`\n *    and `options.firstWeekContainsDate` (compare [getISOWeekYear](https://date-fns.org/docs/getISOWeekYear)\n *    and [getWeekYear](https://date-fns.org/docs/getWeekYear)).\n *\n * 6. Specific non-location timezones are currently unavailable in `date-fns`,\n *    so right now these tokens fall back to GMT timezones.\n *\n * 7. These patterns are not in the Unicode Technical Standard #35:\n *    - `i`: ISO day of week\n *    - `I`: ISO week of year\n *    - `R`: ISO week-numbering year\n *    - `t`: seconds timestamp\n *    - `T`: milliseconds timestamp\n *    - `o`: ordinal number modifier\n *    - `P`: long localized date\n *    - `p`: long localized time\n *\n * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.\n *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md\n *\n * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.\n *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n * @param format - The string of tokens\n * @param options - An object with options\n *\n * @returns The formatted date string\n *\n * @throws `date` must not be Invalid Date\n * @throws `options.locale` must contain `localize` property\n * @throws `options.locale` must contain `formatLong` property\n * @throws use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md\n * @throws use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md\n * @throws use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md\n * @throws use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md\n * @throws format string contains an unescaped latin alphabet character\n *\n * @example\n * // Represent 11 February 2014 in middle-endian format:\n * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')\n * //=> '02/11/2014'\n *\n * @example\n * // Represent 2 July 2014 in Esperanto:\n * import { eoLocale } from 'date-fns/locale/eo'\n * const result = format(new Date(2014, 6, 2), \"do 'de' MMMM yyyy\", {\n *   locale: eoLocale\n * })\n * //=> '2-a de julio 2014'\n *\n * @example\n * // Escape string by single quote characters:\n * const result = format(new Date(2014, 6, 2, 15), \"h 'o''clock'\")\n * //=> \"3 o'clock\"\n */ function format(date, formatStr, options) {\n    var _options_locale_options, _options_locale, _defaultOptions_locale_options, _defaultOptions_locale, _options_locale_options1, _options_locale1, _defaultOptions_locale_options1, _defaultOptions_locale1;\n    const defaultOptions = (0,_lib_defaultOptions_mjs__WEBPACK_IMPORTED_MODULE_2__.getDefaultOptions)();\n    var _options_locale2, _ref;\n    const locale = (_ref = (_options_locale2 = options === null || options === void 0 ? void 0 : options.locale) !== null && _options_locale2 !== void 0 ? _options_locale2 : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : _lib_defaultLocale_mjs__WEBPACK_IMPORTED_MODULE_3__.enUS;\n    var _options_firstWeekContainsDate, _ref1, _ref2, _ref3;\n    const firstWeekContainsDate = (_ref3 = (_ref2 = (_ref1 = (_options_firstWeekContainsDate = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options_firstWeekContainsDate !== void 0 ? _options_firstWeekContainsDate : options === null || options === void 0 ? void 0 : (_options_locale = options.locale) === null || _options_locale === void 0 ? void 0 : (_options_locale_options = _options_locale.options) === null || _options_locale_options === void 0 ? void 0 : _options_locale_options.firstWeekContainsDate) !== null && _ref1 !== void 0 ? _ref1 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions_locale = defaultOptions.locale) === null || _defaultOptions_locale === void 0 ? void 0 : (_defaultOptions_locale_options = _defaultOptions_locale.options) === null || _defaultOptions_locale_options === void 0 ? void 0 : _defaultOptions_locale_options.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : 1;\n    var _options_weekStartsOn, _ref4, _ref5, _ref6;\n    const weekStartsOn = (_ref6 = (_ref5 = (_ref4 = (_options_weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options_weekStartsOn !== void 0 ? _options_weekStartsOn : options === null || options === void 0 ? void 0 : (_options_locale1 = options.locale) === null || _options_locale1 === void 0 ? void 0 : (_options_locale_options1 = _options_locale1.options) === null || _options_locale_options1 === void 0 ? void 0 : _options_locale_options1.weekStartsOn) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : (_defaultOptions_locale1 = defaultOptions.locale) === null || _defaultOptions_locale1 === void 0 ? void 0 : (_defaultOptions_locale_options1 = _defaultOptions_locale1.options) === null || _defaultOptions_locale_options1 === void 0 ? void 0 : _defaultOptions_locale_options1.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : 0;\n    const originalDate = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_4__.toDate)(date);\n    if (!(0,_isValid_mjs__WEBPACK_IMPORTED_MODULE_5__.isValid)(originalDate)) {\n        throw new RangeError(\"Invalid time value\");\n    }\n    let parts = formatStr.match(longFormattingTokensRegExp).map((substring)=>{\n        const firstCharacter = substring[0];\n        if (firstCharacter === \"p\" || firstCharacter === \"P\") {\n            const longFormatter = _lib_format_longFormatters_mjs__WEBPACK_IMPORTED_MODULE_1__.longFormatters[firstCharacter];\n            return longFormatter(substring, locale.formatLong);\n        }\n        return substring;\n    }).join(\"\").match(formattingTokensRegExp).map((substring)=>{\n        // Replace two single quote characters with one single quote character\n        if (substring === \"''\") {\n            return {\n                isToken: false,\n                value: \"'\"\n            };\n        }\n        const firstCharacter = substring[0];\n        if (firstCharacter === \"'\") {\n            return {\n                isToken: false,\n                value: cleanEscapedString(substring)\n            };\n        }\n        if (_lib_format_formatters_mjs__WEBPACK_IMPORTED_MODULE_0__.formatters[firstCharacter]) {\n            return {\n                isToken: true,\n                value: substring\n            };\n        }\n        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {\n            throw new RangeError(\"Format string contains an unescaped latin alphabet character `\" + firstCharacter + \"`\");\n        }\n        return {\n            isToken: false,\n            value: substring\n        };\n    });\n    // invoke localize preprocessor (only for french locales at the moment)\n    if (locale.localize.preprocessor) {\n        parts = locale.localize.preprocessor(originalDate, parts);\n    }\n    const formatterOptions = {\n        firstWeekContainsDate,\n        weekStartsOn,\n        locale\n    };\n    return parts.map((part)=>{\n        if (!part.isToken) return part.value;\n        const token = part.value;\n        if (!(options === null || options === void 0 ? void 0 : options.useAdditionalWeekYearTokens) && (0,_lib_protectedTokens_mjs__WEBPACK_IMPORTED_MODULE_6__.isProtectedWeekYearToken)(token) || !(options === null || options === void 0 ? void 0 : options.useAdditionalDayOfYearTokens) && (0,_lib_protectedTokens_mjs__WEBPACK_IMPORTED_MODULE_6__.isProtectedDayOfYearToken)(token)) {\n            (0,_lib_protectedTokens_mjs__WEBPACK_IMPORTED_MODULE_6__.warnOrThrowProtectedError)(token, formatStr, String(date));\n        }\n        const formatter = _lib_format_formatters_mjs__WEBPACK_IMPORTED_MODULE_0__.formatters[token[0]];\n        return formatter(originalDate, token, locale.localize, formatterOptions);\n    }).join(\"\");\n}\nfunction cleanEscapedString(input) {\n    const matched = input.match(escapedStringRegExp);\n    if (!matched) {\n        return input;\n    }\n    return matched[1].replace(doubleQuoteRegExp, \"'\");\n}\n// Fallback for modularized imports:\n/* harmony default export */ __webpack_exports__[\"default\"] = (format);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9mb3JtYXQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXlEO0FBQ0s7QUFDSjtBQUNRO0FBSzlCO0FBQ0k7QUFDRjtBQUV0Qyw2Q0FBNkM7QUFDN0MsZ0ZBQWdGO0FBQzFDO0FBRXRDLHdEQUF3RDtBQUN4RCxzRUFBc0U7QUFDdEUsaURBQWlEO0FBQ2pELHFEQUFxRDtBQUNyRCw2Q0FBNkM7QUFDN0MsOEVBQThFO0FBQzlFLDJEQUEyRDtBQUMzRCxrREFBa0Q7QUFDbEQseUNBQXlDO0FBQ3pDLGlFQUFpRTtBQUNqRSw4RUFBOEU7QUFDOUUsTUFBTVMseUJBQ0o7QUFFRiwwREFBMEQ7QUFDMUQsc0VBQXNFO0FBQ3RFLE1BQU1DLDZCQUE2QjtBQUVuQyxNQUFNQyxzQkFBc0I7QUFDNUIsTUFBTUMsb0JBQW9CO0FBQzFCLE1BQU1DLGdDQUFnQztBQUVOO0FBRWhDOztDQUVDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTZSQyxHQUNNLFNBQVNDLE9BQU9FLElBQUksRUFBRUMsU0FBUyxFQUFFQyxPQUFPO1FBTTNDQSx5QkFBQUEsaUJBRUFDLGdDQUFBQSx3QkFLQUQsMEJBQUFBLGtCQUVBQyxpQ0FBQUE7SUFkRixNQUFNQSxpQkFBaUJsQiwwRUFBaUJBO1FBQ3pCaUIsa0JBQUFBO0lBQWYsTUFBTUUs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SUFDRjtJQUVBLE9BQU9LLE1BQ0pFLEdBQUcsQ0FBQyxDQUFDWTtRQUNKLElBQUksQ0FBQ0EsS0FBS04sT0FBTyxFQUFFLE9BQU9NLEtBQUtMLEtBQUs7UUFFcEMsTUFBTU0sUUFBUUQsS0FBS0wsS0FBSztRQUV4QixJQUNFLEVBQUVoQixvQkFBQUEsOEJBQUFBLFFBQVN1QiwyQkFBMkIsS0FDcENwQyxrRkFBd0JBLENBQUNtQyxVQUMxQixFQUFDdEIsb0JBQUFBLDhCQUFBQSxRQUFTd0IsNEJBQTRCLEtBQ3JDdEMsbUZBQXlCQSxDQUFDb0MsUUFDNUI7WUFDQWxDLG1GQUF5QkEsQ0FBQ2tDLE9BQU92QixXQUFXMEIsT0FBTzNCO1FBQ3JEO1FBRUEsTUFBTTRCLFlBQVkxQyxrRUFBVSxDQUFDc0MsS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUN0QyxPQUFPSSxVQUFVckIsY0FBY2lCLE9BQU9wQixPQUFPZ0IsUUFBUSxFQUFFRTtJQUN6RCxHQUNDTixJQUFJLENBQUM7QUFDVjtBQUVBLFNBQVNHLG1CQUFtQlUsS0FBSztJQUMvQixNQUFNQyxVQUFVRCxNQUFNbkIsS0FBSyxDQUFDZjtJQUU1QixJQUFJLENBQUNtQyxTQUFTO1FBQ1osT0FBT0Q7SUFDVDtJQUVBLE9BQU9DLE9BQU8sQ0FBQyxFQUFFLENBQUNDLE9BQU8sQ0FBQ25DLG1CQUFtQjtBQUMvQztBQUVBLG9DQUFvQztBQUNwQywrREFBZUUsTUFBTUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZm9ybWF0Lm1qcz9jYTEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlZmF1bHRMb2NhbGUgfSBmcm9tIFwiLi9fbGliL2RlZmF1bHRMb2NhbGUubWpzXCI7XG5pbXBvcnQgeyBnZXREZWZhdWx0T3B0aW9ucyB9IGZyb20gXCIuL19saWIvZGVmYXVsdE9wdGlvbnMubWpzXCI7XG5pbXBvcnQgeyBmb3JtYXR0ZXJzIH0gZnJvbSBcIi4vX2xpYi9mb3JtYXQvZm9ybWF0dGVycy5tanNcIjtcbmltcG9ydCB7IGxvbmdGb3JtYXR0ZXJzIH0gZnJvbSBcIi4vX2xpYi9mb3JtYXQvbG9uZ0Zvcm1hdHRlcnMubWpzXCI7XG5pbXBvcnQge1xuICBpc1Byb3RlY3RlZERheU9mWWVhclRva2VuLFxuICBpc1Byb3RlY3RlZFdlZWtZZWFyVG9rZW4sXG4gIHdhcm5PclRocm93UHJvdGVjdGVkRXJyb3IsXG59IGZyb20gXCIuL19saWIvcHJvdGVjdGVkVG9rZW5zLm1qc1wiO1xuaW1wb3J0IHsgaXNWYWxpZCB9IGZyb20gXCIuL2lzVmFsaWQubWpzXCI7XG5pbXBvcnQgeyB0b0RhdGUgfSBmcm9tIFwiLi90b0RhdGUubWpzXCI7XG5cbi8vIFJleHBvcnRzIG9mIGludGVybmFsIGZvciBsaWJyYXJpZXMgdG8gdXNlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM2MzgjaXNzdWVjb21tZW50LTE4NzcwODI4NzRcbmV4cG9ydCB7IGZvcm1hdHRlcnMsIGxvbmdGb3JtYXR0ZXJzIH07XG5cbi8vIFRoaXMgUmVnRXhwIGNvbnNpc3RzIG9mIHRocmVlIHBhcnRzIHNlcGFyYXRlZCBieSBgfGA6XG4vLyAtIFt5WVFxTUx3SWREZWNpaEhLa21zXW8gbWF0Y2hlcyBhbnkgYXZhaWxhYmxlIG9yZGluYWwgbnVtYmVyIHRva2VuXG4vLyAgIChvbmUgb2YgdGhlIGNlcnRhaW4gbGV0dGVycyBmb2xsb3dlZCBieSBgb2ApXG4vLyAtIChcXHcpXFwxKiBtYXRjaGVzIGFueSBzZXF1ZW5jZXMgb2YgdGhlIHNhbWUgbGV0dGVyXG4vLyAtICcnIG1hdGNoZXMgdHdvIHF1b3RlIGNoYXJhY3RlcnMgaW4gYSByb3dcbi8vIC0gJygnJ3xbXiddKSsoJ3wkKSBtYXRjaGVzIGFueXRoaW5nIHN1cnJvdW5kZWQgYnkgdHdvIHF1b3RlIGNoYXJhY3RlcnMgKCcpLFxuLy8gICBleGNlcHQgYSBzaW5nbGUgcXVvdGUgc3ltYm9sLCB3aGljaCBlbmRzIHRoZSBzZXF1ZW5jZS5cbi8vICAgVHdvIHF1b3RlIGNoYXJhY3RlcnMgZG8gbm90IGVuZCB0aGUgc2VxdWVuY2UuXG4vLyAgIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHNpbmdsZSBxdW90ZVxuLy8gICB0aGVuIHRoZSBzZXF1ZW5jZSB3aWxsIGNvbnRpbnVlIHVudGlsIHRoZSBlbmQgb2YgdGhlIHN0cmluZy5cbi8vIC0gLiBtYXRjaGVzIGFueSBzaW5nbGUgY2hhcmFjdGVyIHVubWF0Y2hlZCBieSBwcmV2aW91cyBwYXJ0cyBvZiB0aGUgUmVnRXhwc1xuY29uc3QgZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCA9XG4gIC9beVlRcU1Md0lkRGVjaWhIS2ttc11vfChcXHcpXFwxKnwnJ3wnKCcnfFteJ10pKygnfCQpfC4vZztcblxuLy8gVGhpcyBSZWdFeHAgY2F0Y2hlcyBzeW1ib2xzIGVzY2FwZWQgYnkgcXVvdGVzLCBhbmQgYWxzb1xuLy8gc2VxdWVuY2VzIG9mIHN5bWJvbHMgUCwgcCwgYW5kIHRoZSBjb21iaW5hdGlvbnMgbGlrZSBgUFBQUFBQUHBwcHBwYFxuY29uc3QgbG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAgPSAvUCtwK3xQK3xwK3wnJ3wnKCcnfFteJ10pKygnfCQpfC4vZztcblxuY29uc3QgZXNjYXBlZFN0cmluZ1JlZ0V4cCA9IC9eJyhbXl0qPyknPyQvO1xuY29uc3QgZG91YmxlUXVvdGVSZWdFeHAgPSAvJycvZztcbmNvbnN0IHVuZXNjYXBlZExhdGluQ2hhcmFjdGVyUmVnRXhwID0gL1thLXpBLVpdLztcblxuZXhwb3J0IHsgZm9ybWF0IGFzIGZvcm1hdERhdGUgfTtcblxuLyoqXG4gKiBUaGUge0BsaW5rIGZvcm1hdH0gZnVuY3Rpb24gb3B0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEBuYW1lIGZvcm1hdFxuICogQGFsaWFzIGZvcm1hdERhdGVcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgRm9ybWF0IHRoZSBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcgaW4gdGhlIGdpdmVuIGZvcm1hdC4gVGhlIHJlc3VsdCBtYXkgdmFyeSBieSBsb2NhbGUuXG4gKlxuICogPiDimqDvuI8gUGxlYXNlIG5vdGUgdGhhdCB0aGUgYGZvcm1hdGAgdG9rZW5zIGRpZmZlciBmcm9tIE1vbWVudC5qcyBhbmQgb3RoZXIgbGlicmFyaWVzLlxuICogPiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VuaWNvZGVUb2tlbnMubWRcbiAqXG4gKiBUaGUgY2hhcmFjdGVycyB3cmFwcGVkIGJldHdlZW4gdHdvIHNpbmdsZSBxdW90ZXMgY2hhcmFjdGVycyAoJykgYXJlIGVzY2FwZWQuXG4gKiBUd28gc2luZ2xlIHF1b3RlcyBpbiBhIHJvdywgd2hldGhlciBpbnNpZGUgb3Igb3V0c2lkZSBhIHF1b3RlZCBzZXF1ZW5jZSwgcmVwcmVzZW50IGEgJ3JlYWwnIHNpbmdsZSBxdW90ZS5cbiAqIChzZWUgdGhlIGxhc3QgZXhhbXBsZSlcbiAqXG4gKiBGb3JtYXQgb2YgdGhlIHN0cmluZyBpcyBiYXNlZCBvbiBVbmljb2RlIFRlY2huaWNhbCBTdGFuZGFyZCAjMzU6XG4gKiBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRmllbGRfU3ltYm9sX1RhYmxlXG4gKiB3aXRoIGEgZmV3IGFkZGl0aW9ucyAoc2VlIG5vdGUgNyBiZWxvdyB0aGUgdGFibGUpLlxuICpcbiAqIEFjY2VwdGVkIHBhdHRlcm5zOlxuICogfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUGF0dGVybiB8IFJlc3VsdCBleGFtcGxlcyAgICAgICAgICAgICAgICAgICB8IE5vdGVzIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS18XG4gKiB8IEVyYSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBHLi5HR0cgIHwgQUQsIEJDICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgR0dHRyAgICB8IEFubm8gRG9taW5pLCBCZWZvcmUgQ2hyaXN0ICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEdHR0dHICAgfCBBLCBCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IENhbGVuZGFyIHllYXIgICAgICAgICAgICAgICAgICAgfCB5ICAgICAgIHwgNDQsIDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeW8gICAgICB8IDQ0dGgsIDFzdCwgMHRoLCAxN3RoICAgICAgICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHl5ICAgICAgfCA0NCwgMDEsIDAwLCAxNyAgICAgICAgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB5eXkgICAgIHwgMDQ0LCAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeXl5eSAgICB8IDAwNDQsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHl5eXl5ICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDUgICB8XG4gKiB8IExvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICAgfCBZICAgICAgIHwgNDQsIDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWW8gICAgICB8IDQ0dGgsIDFzdCwgMTkwMHRoLCAyMDE3dGggICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFlZICAgICAgfCA0NCwgMDEsIDAwLCAxNyAgICAgICAgICAgICAgICAgICAgfCA1LDggICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBZWVkgICAgIHwgMDQ0LCAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWVlZWSAgICB8IDAwNDQsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICB8IDUsOCAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFlZWVlZICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDUgICB8XG4gKiB8IElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgICAgfCBSICAgICAgIHwgLTQzLCAwLCAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgIHwgNSw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUlIgICAgICB8IC00MywgMDAsIDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICB8IDUsNyAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFJSUiAgICAgfCAtMDQzLCAwMDAsIDAwMSwgMTkwMCwgMjAxNyAgICAgICAgfCA1LDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBSUlJSICAgIHwgLTAwNDMsIDAwMDAsIDAwMDEsIDE5MDAsIDIwMTcgICAgIHwgNSw3ICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUlJSUlIgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNSw3IHxcbiAqIHwgRXh0ZW5kZWQgeWVhciAgICAgICAgICAgICAgICAgICB8IHUgICAgICAgfCAtNDMsIDAsIDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB1dSAgICAgIHwgLTQzLCAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICAgIHwgNSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdXV1ICAgICB8IC0wNDMsIDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICB8IDUgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHV1dXUgICAgfCAtMDA0MywgMDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgfCA1ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB1dXV1dSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw1ICAgfFxuICogfCBRdWFydGVyIChmb3JtYXR0aW5nKSAgICAgICAgICAgIHwgUSAgICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFFvICAgICAgfCAxc3QsIDJuZCwgM3JkLCA0dGggICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRUSAgICAgIHwgMDEsIDAyLCAwMywgMDQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUVFRICAgICB8IFExLCBRMiwgUTMsIFE0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFFRUVEgICAgfCAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRUVFRUSAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCBRdWFydGVyIChzdGFuZC1hbG9uZSkgICAgICAgICAgIHwgcSAgICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHFvICAgICAgfCAxc3QsIDJuZCwgM3JkLCA0dGggICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxcSAgICAgIHwgMDEsIDAyLCAwMywgMDQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcXFxICAgICB8IFExLCBRMiwgUTMsIFE0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHFxcXEgICAgfCAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLiAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxcXFxcSAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgNCAgICAgfFxuICogfCBNb250aCAoZm9ybWF0dGluZykgICAgICAgICAgICAgIHwgTSAgICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1vICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMnRoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTSAgICAgIHwgMDEsIDAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTU1NICAgICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1NTU0gICAgfCBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlciAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTU1NTSAgIHwgSiwgRiwgLi4uLCBEICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBNb250aCAoc3RhbmQtYWxvbmUpICAgICAgICAgICAgIHwgTCAgICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IExvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMnRoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTCAgICAgIHwgMDEsIDAyLCAuLi4sIDEyICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTExMICAgICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IExMTEwgICAgfCBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlciAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTExMTCAgIHwgSiwgRiwgLi4uLCBEICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBMb2NhbCB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgIHwgdyAgICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHdvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA1M3RoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB3dyAgICAgIHwgMDEsIDAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBJU08gd2VlayBvZiB5ZWFyICAgICAgICAgICAgICAgIHwgSSAgICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IElvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA1M3RoICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBJSSAgICAgIHwgMDEsIDAyLCAuLi4sIDUzICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCBEYXkgb2YgbW9udGggICAgICAgICAgICAgICAgICAgIHwgZCAgICAgICB8IDEsIDIsIC4uLiwgMzEgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGRvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAzMXN0ICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBkZCAgICAgIHwgMDEsIDAyLCAuLi4sIDMxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCBEYXkgb2YgeWVhciAgICAgICAgICAgICAgICAgICAgIHwgRCAgICAgICB8IDEsIDIsIC4uLiwgMzY1LCAzNjYgICAgICAgICAgICAgICB8IDkgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IERvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAzNjV0aCwgMzY2dGggICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBERCAgICAgIHwgMDEsIDAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICAgIHwgOSAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgREREICAgICB8IDAwMSwgMDAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEREREQgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzICAgICB8XG4gKiB8IERheSBvZiB3ZWVrIChmb3JtYXR0aW5nKSAgICAgICAgfCBFLi5FRUUgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdW4gICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRUVFRSAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEVFRUVFICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBFRUVFRUUgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTYSwgU3UgICAgICAgIHwgICAgICAgfFxuICogfCBJU08gZGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICAgIHwgaSAgICAgICB8IDEsIDIsIDMsIC4uLiwgNyAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA3dGggICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpaSAgICAgIHwgMDEsIDAyLCAuLi4sIDA3ICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWlpICAgICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3VuICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlpaWkgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyLDcgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpaWlpaSAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWlpaWlpICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU2EsIFN1ICAgICAgICB8IDcgICAgIHxcbiAqIHwgTG9jYWwgZGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICB8IGUgICAgICAgfCAyLCAzLCA0LCAuLi4sIDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlbyAgICAgIHwgMm5kLCAzcmQsIC4uLiwgMXN0ICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWUgICAgICB8IDAyLCAwMywgLi4uLCAwMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVlZSAgICAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1biAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlZWVlICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWVlZWUgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVlZWVlZSAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFNhLCBTdSAgICAgICAgfCAgICAgICB8XG4gKiB8IExvY2FsIGRheSBvZiB3ZWVrIChzdGFuZC1hbG9uZSkgfCBjICAgICAgIHwgMiwgMywgNCwgLi4uLCAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY28gICAgICB8IDJuZCwgM3JkLCAuLi4sIDFzdCAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNjICAgICAgfCAwMiwgMDMsIC4uLiwgMDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjY2MgICAgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdW4gICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2NjYyAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNjY2NjICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjY2NjY2MgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTYSwgU3UgICAgICAgIHwgICAgICAgfFxuICogfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgIHwgYS4uYWEgICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGFhYSAgICAgfCBhbSwgcG0gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBhYWFhICAgIHwgYS5tLiwgcC5tLiAgICAgICAgICAgICAgICAgICAgICAgIHwgMiAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWFhYWEgICB8IGEsIHAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgICB8IGIuLmJiICAgfCBBTSwgUE0sIG5vb24sIG1pZG5pZ2h0ICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBiYmIgICAgIHwgYW0sIHBtLCBub29uLCBtaWRuaWdodCAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYmJiYiAgICB8IGEubS4sIHAubS4sIG5vb24sIG1pZG5pZ2h0ICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGJiYmJiICAgfCBhLCBwLCBuLCBtaSAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEZsZXhpYmxlIGRheSBwZXJpb2QgICAgICAgICAgICAgfCBCLi5CQkIgIHwgYXQgbmlnaHQsIGluIHRoZSBtb3JuaW5nLCAuLi4gICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQkJCQiAgICB8IGF0IG5pZ2h0LCBpbiB0aGUgbW9ybmluZywgLi4uICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEJCQkJCICAgfCBhdCBuaWdodCwgaW4gdGhlIG1vcm5pbmcsIC4uLiAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzEtMTJdICAgICAgICAgICAgICAgICAgICAgfCBoICAgICAgIHwgMSwgMiwgLi4uLCAxMSwgMTIgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaG8gICAgICB8IDFzdCwgMm5kLCAuLi4sIDExdGgsIDEydGggICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGhoICAgICAgfCAwMSwgMDIsIC4uLiwgMTEsIDEyICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzAtMjNdICAgICAgICAgICAgICAgICAgICAgfCBIICAgICAgIHwgMCwgMSwgMiwgLi4uLCAyMyAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgSG8gICAgICB8IDB0aCwgMXN0LCAybmQsIC4uLiwgMjNyZCAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEhIICAgICAgfCAwMCwgMDEsIDAyLCAuLi4sIDIzICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzAtMTFdICAgICAgICAgICAgICAgICAgICAgfCBLICAgICAgIHwgMSwgMiwgLi4uLCAxMSwgMCAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgS28gICAgICB8IDFzdCwgMm5kLCAuLi4sIDExdGgsIDB0aCAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEtLICAgICAgfCAwMSwgMDIsIC4uLiwgMTEsIDAwICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEhvdXIgWzEtMjRdICAgICAgICAgICAgICAgICAgICAgfCBrICAgICAgIHwgMjQsIDEsIDIsIC4uLiwgMjMgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwga28gICAgICB8IDI0dGgsIDFzdCwgMm5kLCAuLi4sIDIzcmQgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGtrICAgICAgfCAyNCwgMDEsIDAyLCAuLi4sIDIzICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IE1pbnV0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgfCBtICAgICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbW8gICAgICB8IDB0aCwgMXN0LCAuLi4sIDU5dGggICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG1tICAgICAgfCAwMCwgMDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IFNlY29uZCAgICAgICAgICAgICAgICAgICAgICAgICAgfCBzICAgICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgc28gICAgICB8IDB0aCwgMXN0LCAuLi4sIDU5dGggICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHNzICAgICAgfCAwMCwgMDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8IEZyYWN0aW9uIG9mIHNlY29uZCAgICAgICAgICAgICAgfCBTICAgICAgIHwgMCwgMSwgLi4uLCA5ICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU1MgICAgICB8IDAwLCAwMSwgLi4uLCA5OSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNTUyAgICAgfCAwMDAsIDAwMSwgLi4uLCA5OTkgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTU1NTICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyAgICAgfFxuICogfCBUaW1lem9uZSAoSVNPLTg2MDEgdy8gWikgICAgICAgIHwgWCAgICAgICB8IC0wOCwgKzA1MzAsIFogICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFhYICAgICAgfCAtMDgwMCwgKzA1MzAsIFogICAgICAgICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBYWFggICAgIHwgLTA4OjAwLCArMDU6MzAsIFogICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWFhYWCAgICB8IC0wODAwLCArMDUzMCwgWiwgKzEyMzQ1NiAgICAgICAgICB8IDIgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFhYWFhYICAgfCAtMDg6MDAsICswNTozMCwgWiwgKzEyOjM0OjU2ICAgICAgfCAgICAgICB8XG4gKiB8IFRpbWV6b25lIChJU08tODYwMSB3L28gWikgICAgICAgfCB4ICAgICAgIHwgLTA4LCArMDUzMCwgKzAwICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeHggICAgICB8IC0wODAwLCArMDUzMCwgKzAwMDAgICAgICAgICAgICAgICB8ICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHh4eCAgICAgfCAtMDg6MDAsICswNTozMCwgKzAwOjAwICAgICAgICAgICAgfCAyICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB4eHh4ICAgIHwgLTA4MDAsICswNTMwLCArMDAwMCwgKzEyMzQ1NiAgICAgIHwgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeHh4eHggICB8IC0wODowMCwgKzA1OjMwLCArMDA6MDAsICsxMjozNDo1NiB8ICAgICAgIHxcbiAqIHwgVGltZXpvbmUgKEdNVCkgICAgICAgICAgICAgICAgICB8IE8uLi5PT08gfCBHTVQtOCwgR01UKzU6MzAsIEdNVCswICAgICAgICAgICAgfCAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBPT09PICAgIHwgR01ULTA4OjAwLCBHTVQrMDU6MzAsIEdNVCswMDowMCAgIHwgMiAgICAgfFxuICogfCBUaW1lem9uZSAoc3BlY2lmaWMgbm9uLWxvY2F0LikgIHwgei4uLnp6eiB8IEdNVC04LCBHTVQrNTozMCwgR01UKzAgICAgICAgICAgICB8IDYgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHp6enogICAgfCBHTVQtMDg6MDAsIEdNVCswNTozMCwgR01UKzAwOjAwICAgfCAyLDYgICB8XG4gKiB8IFNlY29uZHMgdGltZXN0YW1wICAgICAgICAgICAgICAgfCB0ICAgICAgIHwgNTEyOTY5NTIwICAgICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdHQgICAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNyAgIHxcbiAqIHwgTWlsbGlzZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICB8IFQgICAgICAgfCA1MTI5Njk1MjA5MDAgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBUVCAgICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw3ICAgfFxuICogfCBMb25nIGxvY2FsaXplZCBkYXRlICAgICAgICAgICAgIHwgUCAgICAgICB8IDA0LzI5LzE0NTMgICAgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQICAgICAgfCBBcHIgMjksIDE0NTMgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUFAgICAgIHwgQXByaWwgMjl0aCwgMTQ1MyAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBQUCAgICB8IEZyaWRheSwgQXByaWwgMjl0aCwgMTQ1MyAgICAgICAgICB8IDIsNyAgIHxcbiAqIHwgTG9uZyBsb2NhbGl6ZWQgdGltZSAgICAgICAgICAgICB8IHAgICAgICAgfCAxMjowMCBBTSAgICAgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBwcCAgICAgIHwgMTI6MDA6MDAgQU0gICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcHBwICAgICB8IDEyOjAwOjAwIEFNIEdNVCsyICAgICAgICAgICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHBwcHAgICAgfCAxMjowMDowMCBBTSBHTVQrMDI6MDAgICAgICAgICAgICAgfCAyLDcgICB8XG4gKiB8IENvbWJpbmF0aW9uIG9mIGRhdGUgYW5kIHRpbWUgICAgfCBQcCAgICAgIHwgMDQvMjkvMTQ1MywgMTI6MDAgQU0gICAgICAgICAgICAgIHwgNyAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBwcCAgICB8IEFwciAyOSwgMTQ1MywgMTI6MDA6MDAgQU0gICAgICAgICB8IDcgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQUHBwcCAgfCBBcHJpbCAyOXRoLCAxNDUzIGF0IC4uLiAgICAgICAgICAgfCA3ICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUFBQcHBwcHwgRnJpZGF5LCBBcHJpbCAyOXRoLCAxNDUzIGF0IC4uLiAgIHwgMiw3ICAgfFxuICogTm90ZXM6XG4gKiAxLiBcIkZvcm1hdHRpbmdcIiB1bml0cyAoZS5nLiBmb3JtYXR0aW5nIHF1YXJ0ZXIpIGluIHRoZSBkZWZhdWx0IGVuLVVTIGxvY2FsZVxuICogICAgYXJlIHRoZSBzYW1lIGFzIFwic3RhbmQtYWxvbmVcIiB1bml0cywgYnV0IGFyZSBkaWZmZXJlbnQgaW4gc29tZSBsYW5ndWFnZXMuXG4gKiAgICBcIkZvcm1hdHRpbmdcIiB1bml0cyBhcmUgZGVjbGluZWQgYWNjb3JkaW5nIHRvIHRoZSBydWxlcyBvZiB0aGUgbGFuZ3VhZ2VcbiAqICAgIGluIHRoZSBjb250ZXh0IG9mIGEgZGF0ZS4gXCJTdGFuZC1hbG9uZVwiIHVuaXRzIGFyZSBhbHdheXMgbm9taW5hdGl2ZSBzaW5ndWxhcjpcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ2RvIExMTEwnLCB7bG9jYWxlOiBjc30pIC8vPT4gJzYuIGxpc3RvcGFkJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ2RvIE1NTU0nLCB7bG9jYWxlOiBjc30pIC8vPT4gJzYuIGxpc3RvcGFkdSdgXG4gKlxuICogMi4gQW55IHNlcXVlbmNlIG9mIHRoZSBpZGVudGljYWwgbGV0dGVycyBpcyBhIHBhdHRlcm4sIHVubGVzcyBpdCBpcyBlc2NhcGVkIGJ5XG4gKiAgICB0aGUgc2luZ2xlIHF1b3RlIGNoYXJhY3RlcnMgKHNlZSBiZWxvdykuXG4gKiAgICBJZiB0aGUgc2VxdWVuY2UgaXMgbG9uZ2VyIHRoYW4gbGlzdGVkIGluIHRhYmxlIChlLmcuIGBFRUVFRUVFRUVFRWApXG4gKiAgICB0aGUgb3V0cHV0IHdpbGwgYmUgdGhlIHNhbWUgYXMgZGVmYXVsdCBwYXR0ZXJuIGZvciB0aGlzIHVuaXQsIHVzdWFsbHlcbiAqICAgIHRoZSBsb25nZXN0IG9uZSAoaW4gY2FzZSBvZiBJU08gd2Vla2RheXMsIGBFRUVFYCkuIERlZmF1bHQgcGF0dGVybnMgZm9yIHVuaXRzXG4gKiAgICBhcmUgbWFya2VkIHdpdGggXCIyXCIgaW4gdGhlIGxhc3QgY29sdW1uIG9mIHRoZSB0YWJsZS5cbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTScpIC8vPT4gJ05vdidgXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICdNTU1NJykgLy89PiAnTm92ZW1iZXInYFxuICpcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnTU1NTU0nKSAvLz0+ICdOJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTU1NTScpIC8vPT4gJ05vdmVtYmVyJ2BcbiAqXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTU1NTU0nKSAvLz0+ICdOb3ZlbWJlcidgXG4gKlxuICogMy4gU29tZSBwYXR0ZXJucyBjb3VsZCBiZSB1bmxpbWl0ZWQgbGVuZ3RoIChzdWNoIGFzIGB5eXl5eXl5eWApLlxuICogICAgVGhlIG91dHB1dCB3aWxsIGJlIHBhZGRlZCB3aXRoIHplcm9zIHRvIG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIHBhdHRlcm4uXG4gKlxuICogICAgYGZvcm1hdChuZXcgRGF0ZSgyMDE3LCAxMCwgNiksICd5eXl5eXl5eScpIC8vPT4gJzAwMDAyMDE3J2BcbiAqXG4gKiA0LiBgUVFRUVFgIGFuZCBgcXFxcXFgIGNvdWxkIGJlIG5vdCBzdHJpY3RseSBudW1lcmljYWwgaW4gc29tZSBsb2NhbGVzLlxuICogICAgVGhlc2UgdG9rZW5zIHJlcHJlc2VudCB0aGUgc2hvcnRlc3QgZm9ybSBvZiB0aGUgcXVhcnRlci5cbiAqXG4gKiA1LiBUaGUgbWFpbiBkaWZmZXJlbmNlIGJldHdlZW4gYHlgIGFuZCBgdWAgcGF0dGVybnMgYXJlIEIuQy4geWVhcnM6XG4gKlxuICogICAgfCBZZWFyIHwgYHlgIHwgYHVgIHxcbiAqICAgIHwtLS0tLS18LS0tLS18LS0tLS18XG4gKiAgICB8IEFDIDEgfCAgIDEgfCAgIDEgfFxuICogICAgfCBCQyAxIHwgICAxIHwgICAwIHxcbiAqICAgIHwgQkMgMiB8ICAgMiB8ICAtMSB8XG4gKlxuICogICAgQWxzbyBgeXlgIGFsd2F5cyByZXR1cm5zIHRoZSBsYXN0IHR3byBkaWdpdHMgb2YgYSB5ZWFyLFxuICogICAgd2hpbGUgYHV1YCBwYWRzIHNpbmdsZSBkaWdpdCB5ZWFycyB0byAyIGNoYXJhY3RlcnMgYW5kIHJldHVybnMgb3RoZXIgeWVhcnMgdW5jaGFuZ2VkOlxuICpcbiAqICAgIHwgWWVhciB8IGB5eWAgfCBgdXVgIHxcbiAqICAgIHwtLS0tLS18LS0tLS0tfC0tLS0tLXxcbiAqICAgIHwgMSAgICB8ICAgMDEgfCAgIDAxIHxcbiAqICAgIHwgMTQgICB8ICAgMTQgfCAgIDE0IHxcbiAqICAgIHwgMzc2ICB8ICAgNzYgfCAgMzc2IHxcbiAqICAgIHwgMTQ1MyB8ICAgNTMgfCAxNDUzIHxcbiAqXG4gKiAgICBUaGUgc2FtZSBkaWZmZXJlbmNlIGlzIHRydWUgZm9yIGxvY2FsIGFuZCBJU08gd2Vlay1udW1iZXJpbmcgeWVhcnMgKGBZYCBhbmQgYFJgKSxcbiAqICAgIGV4Y2VwdCBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFycyBhcmUgZGVwZW5kZW50IG9uIGBvcHRpb25zLndlZWtTdGFydHNPbmBcbiAqICAgIGFuZCBgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGVgIChjb21wYXJlIFtnZXRJU09XZWVrWWVhcl0oaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9nZXRJU09XZWVrWWVhcilcbiAqICAgIGFuZCBbZ2V0V2Vla1llYXJdKGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvZ2V0V2Vla1llYXIpKS5cbiAqXG4gKiA2LiBTcGVjaWZpYyBub24tbG9jYXRpb24gdGltZXpvbmVzIGFyZSBjdXJyZW50bHkgdW5hdmFpbGFibGUgaW4gYGRhdGUtZm5zYCxcbiAqICAgIHNvIHJpZ2h0IG5vdyB0aGVzZSB0b2tlbnMgZmFsbCBiYWNrIHRvIEdNVCB0aW1lem9uZXMuXG4gKlxuICogNy4gVGhlc2UgcGF0dGVybnMgYXJlIG5vdCBpbiB0aGUgVW5pY29kZSBUZWNobmljYWwgU3RhbmRhcmQgIzM1OlxuICogICAgLSBgaWA6IElTTyBkYXkgb2Ygd2Vla1xuICogICAgLSBgSWA6IElTTyB3ZWVrIG9mIHllYXJcbiAqICAgIC0gYFJgOiBJU08gd2Vlay1udW1iZXJpbmcgeWVhclxuICogICAgLSBgdGA6IHNlY29uZHMgdGltZXN0YW1wXG4gKiAgICAtIGBUYDogbWlsbGlzZWNvbmRzIHRpbWVzdGFtcFxuICogICAgLSBgb2A6IG9yZGluYWwgbnVtYmVyIG1vZGlmaWVyXG4gKiAgICAtIGBQYDogbG9uZyBsb2NhbGl6ZWQgZGF0ZVxuICogICAgLSBgcGA6IGxvbmcgbG9jYWxpemVkIHRpbWVcbiAqXG4gKiA4LiBgWVlgIGFuZCBgWVlZWWAgdG9rZW5zIHJlcHJlc2VudCB3ZWVrLW51bWJlcmluZyB5ZWFycyBidXQgdGhleSBhcmUgb2Z0ZW4gY29uZnVzZWQgd2l0aCB5ZWFycy5cbiAqICAgIFlvdSBzaG91bGQgZW5hYmxlIGBvcHRpb25zLnVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2Vuc2AgdG8gdXNlIHRoZW0uIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdW5pY29kZVRva2Vucy5tZFxuICpcbiAqIDkuIGBEYCBhbmQgYEREYCB0b2tlbnMgcmVwcmVzZW50IGRheXMgb2YgdGhlIHllYXIgYnV0IHRoZXkgYXJlIG9mdGVuIGNvbmZ1c2VkIHdpdGggZGF5cyBvZiB0aGUgbW9udGguXG4gKiAgICBZb3Ugc2hvdWxkIGVuYWJsZSBgb3B0aW9ucy51c2VBZGRpdGlvbmFsRGF5T2ZZZWFyVG9rZW5zYCB0byB1c2UgdGhlbS4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91bmljb2RlVG9rZW5zLm1kXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgb3JpZ2luYWwgZGF0ZVxuICogQHBhcmFtIGZvcm1hdCAtIFRoZSBzdHJpbmcgb2YgdG9rZW5zXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIGRhdGUgc3RyaW5nXG4gKlxuICogQHRocm93cyBgZGF0ZWAgbXVzdCBub3QgYmUgSW52YWxpZCBEYXRlXG4gKiBAdGhyb3dzIGBvcHRpb25zLmxvY2FsZWAgbXVzdCBjb250YWluIGBsb2NhbGl6ZWAgcHJvcGVydHlcbiAqIEB0aHJvd3MgYG9wdGlvbnMubG9jYWxlYCBtdXN0IGNvbnRhaW4gYGZvcm1hdExvbmdgIHByb3BlcnR5XG4gKiBAdGhyb3dzIHVzZSBgeXl5eWAgaW5zdGVhZCBvZiBgWVlZWWAgZm9yIGZvcm1hdHRpbmcgeWVhcnMgdXNpbmcgW2Zvcm1hdCBwcm92aWRlZF0gdG8gdGhlIGlucHV0IFtpbnB1dCBwcm92aWRlZF07IHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdW5pY29kZVRva2Vucy5tZFxuICogQHRocm93cyB1c2UgYHl5YCBpbnN0ZWFkIG9mIGBZWWAgZm9yIGZvcm1hdHRpbmcgeWVhcnMgdXNpbmcgW2Zvcm1hdCBwcm92aWRlZF0gdG8gdGhlIGlucHV0IFtpbnB1dCBwcm92aWRlZF07IHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdW5pY29kZVRva2Vucy5tZFxuICogQHRocm93cyB1c2UgYGRgIGluc3RlYWQgb2YgYERgIGZvciBmb3JtYXR0aW5nIGRheXMgb2YgdGhlIG1vbnRoIHVzaW5nIFtmb3JtYXQgcHJvdmlkZWRdIHRvIHRoZSBpbnB1dCBbaW5wdXQgcHJvdmlkZWRdOyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VuaWNvZGVUb2tlbnMubWRcbiAqIEB0aHJvd3MgdXNlIGBkZGAgaW5zdGVhZCBvZiBgRERgIGZvciBmb3JtYXR0aW5nIGRheXMgb2YgdGhlIG1vbnRoIHVzaW5nIFtmb3JtYXQgcHJvdmlkZWRdIHRvIHRoZSBpbnB1dCBbaW5wdXQgcHJvdmlkZWRdOyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VuaWNvZGVUb2tlbnMubWRcbiAqIEB0aHJvd3MgZm9ybWF0IHN0cmluZyBjb250YWlucyBhbiB1bmVzY2FwZWQgbGF0aW4gYWxwaGFiZXQgY2hhcmFjdGVyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlcHJlc2VudCAxMSBGZWJydWFyeSAyMDE0IGluIG1pZGRsZS1lbmRpYW4gZm9ybWF0OlxuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0KG5ldyBEYXRlKDIwMTQsIDEsIDExKSwgJ01NL2RkL3l5eXknKVxuICogLy89PiAnMDIvMTEvMjAxNCdcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUmVwcmVzZW50IDIgSnVseSAyMDE0IGluIEVzcGVyYW50bzpcbiAqIGltcG9ydCB7IGVvTG9jYWxlIH0gZnJvbSAnZGF0ZS1mbnMvbG9jYWxlL2VvJ1xuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0KG5ldyBEYXRlKDIwMTQsIDYsIDIpLCBcImRvICdkZScgTU1NTSB5eXl5XCIsIHtcbiAqICAgbG9jYWxlOiBlb0xvY2FsZVxuICogfSlcbiAqIC8vPT4gJzItYSBkZSBqdWxpbyAyMDE0J1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBFc2NhcGUgc3RyaW5nIGJ5IHNpbmdsZSBxdW90ZSBjaGFyYWN0ZXJzOlxuICogY29uc3QgcmVzdWx0ID0gZm9ybWF0KG5ldyBEYXRlKDIwMTQsIDYsIDIsIDE1KSwgXCJoICdvJydjbG9jaydcIilcbiAqIC8vPT4gXCIzIG8nY2xvY2tcIlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGRhdGUsIGZvcm1hdFN0ciwgb3B0aW9ucykge1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IGdldERlZmF1bHRPcHRpb25zKCk7XG4gIGNvbnN0IGxvY2FsZSA9IG9wdGlvbnM/LmxvY2FsZSA/PyBkZWZhdWx0T3B0aW9ucy5sb2NhbGUgPz8gZGVmYXVsdExvY2FsZTtcblxuICBjb25zdCBmaXJzdFdlZWtDb250YWluc0RhdGUgPVxuICAgIG9wdGlvbnM/LmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA/P1xuICAgIG9wdGlvbnM/LmxvY2FsZT8ub3B0aW9ucz8uZmlyc3RXZWVrQ29udGFpbnNEYXRlID8/XG4gICAgZGVmYXVsdE9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlID8/XG4gICAgZGVmYXVsdE9wdGlvbnMubG9jYWxlPy5vcHRpb25zPy5maXJzdFdlZWtDb250YWluc0RhdGUgPz9cbiAgICAxO1xuXG4gIGNvbnN0IHdlZWtTdGFydHNPbiA9XG4gICAgb3B0aW9ucz8ud2Vla1N0YXJ0c09uID8/XG4gICAgb3B0aW9ucz8ubG9jYWxlPy5vcHRpb25zPy53ZWVrU3RhcnRzT24gPz9cbiAgICBkZWZhdWx0T3B0aW9ucy53ZWVrU3RhcnRzT24gPz9cbiAgICBkZWZhdWx0T3B0aW9ucy5sb2NhbGU/Lm9wdGlvbnM/LndlZWtTdGFydHNPbiA/P1xuICAgIDA7XG5cbiAgY29uc3Qgb3JpZ2luYWxEYXRlID0gdG9EYXRlKGRhdGUpO1xuXG4gIGlmICghaXNWYWxpZChvcmlnaW5hbERhdGUpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHRpbWUgdmFsdWVcIik7XG4gIH1cblxuICBsZXQgcGFydHMgPSBmb3JtYXRTdHJcbiAgICAubWF0Y2gobG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHApXG4gICAgLm1hcCgoc3Vic3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdENoYXJhY3RlciA9IHN1YnN0cmluZ1swXTtcbiAgICAgIGlmIChmaXJzdENoYXJhY3RlciA9PT0gXCJwXCIgfHwgZmlyc3RDaGFyYWN0ZXIgPT09IFwiUFwiKSB7XG4gICAgICAgIGNvbnN0IGxvbmdGb3JtYXR0ZXIgPSBsb25nRm9ybWF0dGVyc1tmaXJzdENoYXJhY3Rlcl07XG4gICAgICAgIHJldHVybiBsb25nRm9ybWF0dGVyKHN1YnN0cmluZywgbG9jYWxlLmZvcm1hdExvbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1YnN0cmluZztcbiAgICB9KVxuICAgIC5qb2luKFwiXCIpXG4gICAgLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnNSZWdFeHApXG4gICAgLm1hcCgoc3Vic3RyaW5nKSA9PiB7XG4gICAgICAvLyBSZXBsYWNlIHR3byBzaW5nbGUgcXVvdGUgY2hhcmFjdGVycyB3aXRoIG9uZSBzaW5nbGUgcXVvdGUgY2hhcmFjdGVyXG4gICAgICBpZiAoc3Vic3RyaW5nID09PSBcIicnXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgaXNUb2tlbjogZmFsc2UsIHZhbHVlOiBcIidcIiB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaXJzdENoYXJhY3RlciA9IHN1YnN0cmluZ1swXTtcbiAgICAgIGlmIChmaXJzdENoYXJhY3RlciA9PT0gXCInXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgaXNUb2tlbjogZmFsc2UsIHZhbHVlOiBjbGVhbkVzY2FwZWRTdHJpbmcoc3Vic3RyaW5nKSB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9ybWF0dGVyc1tmaXJzdENoYXJhY3Rlcl0pIHtcbiAgICAgICAgcmV0dXJuIHsgaXNUb2tlbjogdHJ1ZSwgdmFsdWU6IHN1YnN0cmluZyB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3RDaGFyYWN0ZXIubWF0Y2godW5lc2NhcGVkTGF0aW5DaGFyYWN0ZXJSZWdFeHApKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICAgIFwiRm9ybWF0IHN0cmluZyBjb250YWlucyBhbiB1bmVzY2FwZWQgbGF0aW4gYWxwaGFiZXQgY2hhcmFjdGVyIGBcIiArXG4gICAgICAgICAgICBmaXJzdENoYXJhY3RlciArXG4gICAgICAgICAgICBcImBcIixcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgaXNUb2tlbjogZmFsc2UsIHZhbHVlOiBzdWJzdHJpbmcgfTtcbiAgICB9KTtcblxuICAvLyBpbnZva2UgbG9jYWxpemUgcHJlcHJvY2Vzc29yIChvbmx5IGZvciBmcmVuY2ggbG9jYWxlcyBhdCB0aGUgbW9tZW50KVxuICBpZiAobG9jYWxlLmxvY2FsaXplLnByZXByb2Nlc3Nvcikge1xuICAgIHBhcnRzID0gbG9jYWxlLmxvY2FsaXplLnByZXByb2Nlc3NvcihvcmlnaW5hbERhdGUsIHBhcnRzKTtcbiAgfVxuXG4gIGNvbnN0IGZvcm1hdHRlck9wdGlvbnMgPSB7XG4gICAgZmlyc3RXZWVrQ29udGFpbnNEYXRlLFxuICAgIHdlZWtTdGFydHNPbixcbiAgICBsb2NhbGUsXG4gIH07XG5cbiAgcmV0dXJuIHBhcnRzXG4gICAgLm1hcCgocGFydCkgPT4ge1xuICAgICAgaWYgKCFwYXJ0LmlzVG9rZW4pIHJldHVybiBwYXJ0LnZhbHVlO1xuXG4gICAgICBjb25zdCB0b2tlbiA9IHBhcnQudmFsdWU7XG5cbiAgICAgIGlmIChcbiAgICAgICAgKCFvcHRpb25zPy51c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnMgJiZcbiAgICAgICAgICBpc1Byb3RlY3RlZFdlZWtZZWFyVG9rZW4odG9rZW4pKSB8fFxuICAgICAgICAoIW9wdGlvbnM/LnVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnMgJiZcbiAgICAgICAgICBpc1Byb3RlY3RlZERheU9mWWVhclRva2VuKHRva2VuKSlcbiAgICAgICkge1xuICAgICAgICB3YXJuT3JUaHJvd1Byb3RlY3RlZEVycm9yKHRva2VuLCBmb3JtYXRTdHIsIFN0cmluZyhkYXRlKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvcm1hdHRlciA9IGZvcm1hdHRlcnNbdG9rZW5bMF1dO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcihvcmlnaW5hbERhdGUsIHRva2VuLCBsb2NhbGUubG9jYWxpemUsIGZvcm1hdHRlck9wdGlvbnMpO1xuICAgIH0pXG4gICAgLmpvaW4oXCJcIik7XG59XG5cbmZ1bmN0aW9uIGNsZWFuRXNjYXBlZFN0cmluZyhpbnB1dCkge1xuICBjb25zdCBtYXRjaGVkID0gaW5wdXQubWF0Y2goZXNjYXBlZFN0cmluZ1JlZ0V4cCk7XG5cbiAgaWYgKCFtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZWRbMV0ucmVwbGFjZShkb3VibGVRdW90ZVJlZ0V4cCwgXCInXCIpO1xufVxuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IGZvcm1hdDtcbiJdLCJuYW1lcyI6WyJkZWZhdWx0TG9jYWxlIiwiZ2V0RGVmYXVsdE9wdGlvbnMiLCJmb3JtYXR0ZXJzIiwibG9uZ0Zvcm1hdHRlcnMiLCJpc1Byb3RlY3RlZERheU9mWWVhclRva2VuIiwiaXNQcm90ZWN0ZWRXZWVrWWVhclRva2VuIiwid2Fybk9yVGhyb3dQcm90ZWN0ZWRFcnJvciIsImlzVmFsaWQiLCJ0b0RhdGUiLCJmb3JtYXR0aW5nVG9rZW5zUmVnRXhwIiwibG9uZ0Zvcm1hdHRpbmdUb2tlbnNSZWdFeHAiLCJlc2NhcGVkU3RyaW5nUmVnRXhwIiwiZG91YmxlUXVvdGVSZWdFeHAiLCJ1bmVzY2FwZWRMYXRpbkNoYXJhY3RlclJlZ0V4cCIsImZvcm1hdCIsImZvcm1hdERhdGUiLCJkYXRlIiwiZm9ybWF0U3RyIiwib3B0aW9ucyIsImRlZmF1bHRPcHRpb25zIiwibG9jYWxlIiwiZmlyc3RXZWVrQ29udGFpbnNEYXRlIiwid2Vla1N0YXJ0c09uIiwib3JpZ2luYWxEYXRlIiwiUmFuZ2VFcnJvciIsInBhcnRzIiwibWF0Y2giLCJtYXAiLCJzdWJzdHJpbmciLCJmaXJzdENoYXJhY3RlciIsImxvbmdGb3JtYXR0ZXIiLCJmb3JtYXRMb25nIiwiam9pbiIsImlzVG9rZW4iLCJ2YWx1ZSIsImNsZWFuRXNjYXBlZFN0cmluZyIsImxvY2FsaXplIiwicHJlcHJvY2Vzc29yIiwiZm9ybWF0dGVyT3B0aW9ucyIsInBhcnQiLCJ0b2tlbiIsInVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2VucyIsInVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnMiLCJTdHJpbmciLCJmb3JtYXR0ZXIiLCJpbnB1dCIsIm1hdGNoZWQiLCJyZXBsYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/format.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/getDayOfYear.mjs":
/*!************************************************!*\
  !*** ./node_modules/date-fns/getDayOfYear.mjs ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDayOfYear: function() { return /* binding */ getDayOfYear; }\n/* harmony export */ });\n/* harmony import */ var _differenceInCalendarDays_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./differenceInCalendarDays.mjs */ \"(app-pages-browser)/./node_modules/date-fns/differenceInCalendarDays.mjs\");\n/* harmony import */ var _startOfYear_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./startOfYear.mjs */ \"(app-pages-browser)/./node_modules/date-fns/startOfYear.mjs\");\n/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toDate.mjs */ \"(app-pages-browser)/./node_modules/date-fns/toDate.mjs\");\n\n\n\n/**\n * @name getDayOfYear\n * @category Day Helpers\n * @summary Get the day of the year of the given date.\n *\n * @description\n * Get the day of the year of the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The given date\n *\n * @returns The day of year\n *\n * @example\n * // Which day of the year is 2 July 2014?\n * const result = getDayOfYear(new Date(2014, 6, 2))\n * //=> 183\n */ function getDayOfYear(date) {\n    const _date = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_0__.toDate)(date);\n    const diff = (0,_differenceInCalendarDays_mjs__WEBPACK_IMPORTED_MODULE_1__.differenceInCalendarDays)(_date, (0,_startOfYear_mjs__WEBPACK_IMPORTED_MODULE_2__.startOfYear)(_date));\n    const dayOfYear = diff + 1;\n    return dayOfYear;\n}\n// Fallback for modularized imports:\n/* harmony default export */ __webpack_exports__[\"default\"] = (getDayOfYear);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9nZXREYXlPZlllYXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEU7QUFDMUI7QUFDVjtBQUV0Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ00sU0FBU0csYUFBYUMsSUFBSTtJQUMvQixNQUFNQyxRQUFRSCxtREFBTUEsQ0FBQ0U7SUFDckIsTUFBTUUsT0FBT04sdUZBQXdCQSxDQUFDSyxPQUFPSiw2REFBV0EsQ0FBQ0k7SUFDekQsTUFBTUUsWUFBWUQsT0FBTztJQUN6QixPQUFPQztBQUNUO0FBRUEsb0NBQW9DO0FBQ3BDLCtEQUFlSixZQUFZQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9nZXREYXlPZlllYXIubWpzPzE5ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzIH0gZnJvbSBcIi4vZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzLm1qc1wiO1xuaW1wb3J0IHsgc3RhcnRPZlllYXIgfSBmcm9tIFwiLi9zdGFydE9mWWVhci5tanNcIjtcbmltcG9ydCB7IHRvRGF0ZSB9IGZyb20gXCIuL3RvRGF0ZS5tanNcIjtcblxuLyoqXG4gKiBAbmFtZSBnZXREYXlPZlllYXJcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBkYXkgb2YgdGhlIHllYXIgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIGRheSBvZiB0aGUgeWVhciBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBnaXZlbiBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIGRheSBvZiB5ZWFyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIGRheSBvZiB0aGUgeWVhciBpcyAyIEp1bHkgMjAxND9cbiAqIGNvbnN0IHJlc3VsdCA9IGdldERheU9mWWVhcihuZXcgRGF0ZSgyMDE0LCA2LCAyKSlcbiAqIC8vPT4gMTgzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXlPZlllYXIoZGF0ZSkge1xuICBjb25zdCBfZGF0ZSA9IHRvRGF0ZShkYXRlKTtcbiAgY29uc3QgZGlmZiA9IGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyhfZGF0ZSwgc3RhcnRPZlllYXIoX2RhdGUpKTtcbiAgY29uc3QgZGF5T2ZZZWFyID0gZGlmZiArIDE7XG4gIHJldHVybiBkYXlPZlllYXI7XG59XG5cbi8vIEZhbGxiYWNrIGZvciBtb2R1bGFyaXplZCBpbXBvcnRzOlxuZXhwb3J0IGRlZmF1bHQgZ2V0RGF5T2ZZZWFyO1xuIl0sIm5hbWVzIjpbImRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyIsInN0YXJ0T2ZZZWFyIiwidG9EYXRlIiwiZ2V0RGF5T2ZZZWFyIiwiZGF0ZSIsIl9kYXRlIiwiZGlmZiIsImRheU9mWWVhciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/getDayOfYear.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/getISOWeek.mjs":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/getISOWeek.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getISOWeek: function() { return /* binding */ getISOWeek; }\n/* harmony export */ });\n/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.mjs */ \"(app-pages-browser)/./node_modules/date-fns/constants.mjs\");\n/* harmony import */ var _startOfISOWeek_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./startOfISOWeek.mjs */ \"(app-pages-browser)/./node_modules/date-fns/startOfISOWeek.mjs\");\n/* harmony import */ var _startOfISOWeekYear_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./startOfISOWeekYear.mjs */ \"(app-pages-browser)/./node_modules/date-fns/startOfISOWeekYear.mjs\");\n/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toDate.mjs */ \"(app-pages-browser)/./node_modules/date-fns/toDate.mjs\");\n\n\n\n\n/**\n * @name getISOWeek\n * @category ISO Week Helpers\n * @summary Get the ISO week of the given date.\n *\n * @description\n * Get the ISO week of the given date.\n *\n * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The given date\n *\n * @returns The ISO week\n *\n * @example\n * // Which week of the ISO-week numbering year is 2 January 2005?\n * const result = getISOWeek(new Date(2005, 0, 2))\n * //=> 53\n */ function getISOWeek(date) {\n    const _date = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_0__.toDate)(date);\n    const diff = +(0,_startOfISOWeek_mjs__WEBPACK_IMPORTED_MODULE_1__.startOfISOWeek)(_date) - +(0,_startOfISOWeekYear_mjs__WEBPACK_IMPORTED_MODULE_2__.startOfISOWeekYear)(_date);\n    // Round the number of weeks to the nearest integer because the number of\n    // milliseconds in a week is not constant (e.g. it's different in the week of\n    // the daylight saving time clock shift).\n    return Math.round(diff / _constants_mjs__WEBPACK_IMPORTED_MODULE_3__.millisecondsInWeek) + 1;\n}\n// Fallback for modularized imports:\n/* harmony default export */ __webpack_exports__[\"default\"] = (getISOWeek);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9nZXRJU09XZWVrLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxRDtBQUNDO0FBQ1E7QUFDeEI7QUFFdEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBQ00sU0FBU0ksV0FBV0MsSUFBSTtJQUM3QixNQUFNQyxRQUFRSCxtREFBTUEsQ0FBQ0U7SUFDckIsTUFBTUUsT0FBTyxDQUFDTixtRUFBY0EsQ0FBQ0ssU0FBUyxDQUFDSiwyRUFBa0JBLENBQUNJO0lBRTFELHlFQUF5RTtJQUN6RSw2RUFBNkU7SUFDN0UseUNBQXlDO0lBQ3pDLE9BQU9FLEtBQUtDLEtBQUssQ0FBQ0YsT0FBT1AsOERBQWtCQSxJQUFJO0FBQ2pEO0FBRUEsb0NBQW9DO0FBQ3BDLCtEQUFlSSxVQUFVQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9nZXRJU09XZWVrLm1qcz83NjQzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1pbGxpc2Vjb25kc0luV2VlayB9IGZyb20gXCIuL2NvbnN0YW50cy5tanNcIjtcbmltcG9ydCB7IHN0YXJ0T2ZJU09XZWVrIH0gZnJvbSBcIi4vc3RhcnRPZklTT1dlZWsubWpzXCI7XG5pbXBvcnQgeyBzdGFydE9mSVNPV2Vla1llYXIgfSBmcm9tIFwiLi9zdGFydE9mSVNPV2Vla1llYXIubWpzXCI7XG5pbXBvcnQgeyB0b0RhdGUgfSBmcm9tIFwiLi90b0RhdGUubWpzXCI7XG5cbi8qKlxuICogQG5hbWUgZ2V0SVNPV2Vla1xuICogQGNhdGVnb3J5IElTTyBXZWVrIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgSVNPIHdlZWsgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIElTTyB3ZWVrIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBnaXZlbiBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIElTTyB3ZWVrXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIHdlZWsgb2YgdGhlIElTTy13ZWVrIG51bWJlcmluZyB5ZWFyIGlzIDIgSmFudWFyeSAyMDA1P1xuICogY29uc3QgcmVzdWx0ID0gZ2V0SVNPV2VlayhuZXcgRGF0ZSgyMDA1LCAwLCAyKSlcbiAqIC8vPT4gNTNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldElTT1dlZWsoZGF0ZSkge1xuICBjb25zdCBfZGF0ZSA9IHRvRGF0ZShkYXRlKTtcbiAgY29uc3QgZGlmZiA9ICtzdGFydE9mSVNPV2VlayhfZGF0ZSkgLSArc3RhcnRPZklTT1dlZWtZZWFyKF9kYXRlKTtcblxuICAvLyBSb3VuZCB0aGUgbnVtYmVyIG9mIHdlZWtzIHRvIHRoZSBuZWFyZXN0IGludGVnZXIgYmVjYXVzZSB0aGUgbnVtYmVyIG9mXG4gIC8vIG1pbGxpc2Vjb25kcyBpbiBhIHdlZWsgaXMgbm90IGNvbnN0YW50IChlLmcuIGl0J3MgZGlmZmVyZW50IGluIHRoZSB3ZWVrIG9mXG4gIC8vIHRoZSBkYXlsaWdodCBzYXZpbmcgdGltZSBjbG9jayBzaGlmdCkuXG4gIHJldHVybiBNYXRoLnJvdW5kKGRpZmYgLyBtaWxsaXNlY29uZHNJbldlZWspICsgMTtcbn1cblxuLy8gRmFsbGJhY2sgZm9yIG1vZHVsYXJpemVkIGltcG9ydHM6XG5leHBvcnQgZGVmYXVsdCBnZXRJU09XZWVrO1xuIl0sIm5hbWVzIjpbIm1pbGxpc2Vjb25kc0luV2VlayIsInN0YXJ0T2ZJU09XZWVrIiwic3RhcnRPZklTT1dlZWtZZWFyIiwidG9EYXRlIiwiZ2V0SVNPV2VlayIsImRhdGUiLCJfZGF0ZSIsImRpZmYiLCJNYXRoIiwicm91bmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/getISOWeek.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/getISOWeekYear.mjs":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/getISOWeekYear.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getISOWeekYear: function() { return /* binding */ getISOWeekYear; }\n/* harmony export */ });\n/* harmony import */ var _constructFrom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constructFrom.mjs */ \"(app-pages-browser)/./node_modules/date-fns/constructFrom.mjs\");\n/* harmony import */ var _startOfISOWeek_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./startOfISOWeek.mjs */ \"(app-pages-browser)/./node_modules/date-fns/startOfISOWeek.mjs\");\n/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toDate.mjs */ \"(app-pages-browser)/./node_modules/date-fns/toDate.mjs\");\n\n\n\n/**\n * @name getISOWeekYear\n * @category ISO Week-Numbering Year Helpers\n * @summary Get the ISO week-numbering year of the given date.\n *\n * @description\n * Get the ISO week-numbering year of the given date,\n * which always starts 3 days before the year's first Thursday.\n *\n * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The given date\n *\n * @returns The ISO week-numbering year\n *\n * @example\n * // Which ISO-week numbering year is 2 January 2005?\n * const result = getISOWeekYear(new Date(2005, 0, 2))\n * //=> 2004\n */ function getISOWeekYear(date) {\n    const _date = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_0__.toDate)(date);\n    const year = _date.getFullYear();\n    const fourthOfJanuaryOfNextYear = (0,_constructFrom_mjs__WEBPACK_IMPORTED_MODULE_1__.constructFrom)(date, 0);\n    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);\n    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);\n    const startOfNextYear = (0,_startOfISOWeek_mjs__WEBPACK_IMPORTED_MODULE_2__.startOfISOWeek)(fourthOfJanuaryOfNextYear);\n    const fourthOfJanuaryOfThisYear = (0,_constructFrom_mjs__WEBPACK_IMPORTED_MODULE_1__.constructFrom)(date, 0);\n    fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);\n    fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);\n    const startOfThisYear = (0,_startOfISOWeek_mjs__WEBPACK_IMPORTED_MODULE_2__.startOfISOWeek)(fourthOfJanuaryOfThisYear);\n    if (_date.getTime() >= startOfNextYear.getTime()) {\n        return year + 1;\n    } else if (_date.getTime() >= startOfThisYear.getTime()) {\n        return year;\n    } else {\n        return year - 1;\n    }\n}\n// Fallback for modularized imports:\n/* harmony default export */ __webpack_exports__[\"default\"] = (getISOWeekYear);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9nZXRJU09XZWVrWWVhci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRDtBQUNFO0FBQ2hCO0FBRXRDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQkMsR0FDTSxTQUFTRyxlQUFlQyxJQUFJO0lBQ2pDLE1BQU1DLFFBQVFILG1EQUFNQSxDQUFDRTtJQUNyQixNQUFNRSxPQUFPRCxNQUFNRSxXQUFXO0lBRTlCLE1BQU1DLDRCQUE0QlIsaUVBQWFBLENBQUNJLE1BQU07SUFDdERJLDBCQUEwQkMsV0FBVyxDQUFDSCxPQUFPLEdBQUcsR0FBRztJQUNuREUsMEJBQTBCRSxRQUFRLENBQUMsR0FBRyxHQUFHLEdBQUc7SUFDNUMsTUFBTUMsa0JBQWtCVixtRUFBY0EsQ0FBQ087SUFFdkMsTUFBTUksNEJBQTRCWixpRUFBYUEsQ0FBQ0ksTUFBTTtJQUN0RFEsMEJBQTBCSCxXQUFXLENBQUNILE1BQU0sR0FBRztJQUMvQ00sMEJBQTBCRixRQUFRLENBQUMsR0FBRyxHQUFHLEdBQUc7SUFDNUMsTUFBTUcsa0JBQWtCWixtRUFBY0EsQ0FBQ1c7SUFFdkMsSUFBSVAsTUFBTVMsT0FBTyxNQUFNSCxnQkFBZ0JHLE9BQU8sSUFBSTtRQUNoRCxPQUFPUixPQUFPO0lBQ2hCLE9BQU8sSUFBSUQsTUFBTVMsT0FBTyxNQUFNRCxnQkFBZ0JDLE9BQU8sSUFBSTtRQUN2RCxPQUFPUjtJQUNULE9BQU87UUFDTCxPQUFPQSxPQUFPO0lBQ2hCO0FBQ0Y7QUFFQSxvQ0FBb0M7QUFDcEMsK0RBQWVILGNBQWNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2dldElTT1dlZWtZZWFyLm1qcz81YTY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbnN0cnVjdEZyb20gfSBmcm9tIFwiLi9jb25zdHJ1Y3RGcm9tLm1qc1wiO1xuaW1wb3J0IHsgc3RhcnRPZklTT1dlZWsgfSBmcm9tIFwiLi9zdGFydE9mSVNPV2Vlay5tanNcIjtcbmltcG9ydCB7IHRvRGF0ZSB9IGZyb20gXCIuL3RvRGF0ZS5tanNcIjtcblxuLyoqXG4gKiBAbmFtZSBnZXRJU09XZWVrWWVhclxuICogQGNhdGVnb3J5IElTTyBXZWVrLU51bWJlcmluZyBZZWFyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyIG9mIHRoZSBnaXZlbiBkYXRlLFxuICogd2hpY2ggYWx3YXlzIHN0YXJ0cyAzIGRheXMgYmVmb3JlIHRoZSB5ZWFyJ3MgZmlyc3QgVGh1cnNkYXkuXG4gKlxuICogSVNPIHdlZWstbnVtYmVyaW5nIHllYXI6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGdpdmVuIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgSVNPIHdlZWstbnVtYmVyaW5nIHllYXJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hpY2ggSVNPLXdlZWsgbnVtYmVyaW5nIHllYXIgaXMgMiBKYW51YXJ5IDIwMDU/XG4gKiBjb25zdCByZXN1bHQgPSBnZXRJU09XZWVrWWVhcihuZXcgRGF0ZSgyMDA1LCAwLCAyKSlcbiAqIC8vPT4gMjAwNFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SVNPV2Vla1llYXIoZGF0ZSkge1xuICBjb25zdCBfZGF0ZSA9IHRvRGF0ZShkYXRlKTtcbiAgY29uc3QgeWVhciA9IF9kYXRlLmdldEZ1bGxZZWFyKCk7XG5cbiAgY29uc3QgZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhciA9IGNvbnN0cnVjdEZyb20oZGF0ZSwgMCk7XG4gIGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIuc2V0RnVsbFllYXIoeWVhciArIDEsIDAsIDQpO1xuICBmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBjb25zdCBzdGFydE9mTmV4dFllYXIgPSBzdGFydE9mSVNPV2Vlayhmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyKTtcblxuICBjb25zdCBmb3VydGhPZkphbnVhcnlPZlRoaXNZZWFyID0gY29uc3RydWN0RnJvbShkYXRlLCAwKTtcbiAgZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhci5zZXRGdWxsWWVhcih5ZWFyLCAwLCA0KTtcbiAgZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhci5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgY29uc3Qgc3RhcnRPZlRoaXNZZWFyID0gc3RhcnRPZklTT1dlZWsoZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhcik7XG5cbiAgaWYgKF9kYXRlLmdldFRpbWUoKSA+PSBzdGFydE9mTmV4dFllYXIuZ2V0VGltZSgpKSB7XG4gICAgcmV0dXJuIHllYXIgKyAxO1xuICB9IGVsc2UgaWYgKF9kYXRlLmdldFRpbWUoKSA+PSBzdGFydE9mVGhpc1llYXIuZ2V0VGltZSgpKSB7XG4gICAgcmV0dXJuIHllYXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHllYXIgLSAxO1xuICB9XG59XG5cbi8vIEZhbGxiYWNrIGZvciBtb2R1bGFyaXplZCBpbXBvcnRzOlxuZXhwb3J0IGRlZmF1bHQgZ2V0SVNPV2Vla1llYXI7XG4iXSwibmFtZXMiOlsiY29uc3RydWN0RnJvbSIsInN0YXJ0T2ZJU09XZWVrIiwidG9EYXRlIiwiZ2V0SVNPV2Vla1llYXIiLCJkYXRlIiwiX2RhdGUiLCJ5ZWFyIiwiZ2V0RnVsbFllYXIiLCJmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyIiwic2V0RnVsbFllYXIiLCJzZXRIb3VycyIsInN0YXJ0T2ZOZXh0WWVhciIsImZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIiLCJzdGFydE9mVGhpc1llYXIiLCJnZXRUaW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/getISOWeekYear.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/getWeek.mjs":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/getWeek.mjs ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWeek: function() { return /* binding */ getWeek; }\n/* harmony export */ });\n/* harmony import */ var _constants_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.mjs */ \"(app-pages-browser)/./node_modules/date-fns/constants.mjs\");\n/* harmony import */ var _startOfWeek_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./startOfWeek.mjs */ \"(app-pages-browser)/./node_modules/date-fns/startOfWeek.mjs\");\n/* harmony import */ var _startOfWeekYear_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./startOfWeekYear.mjs */ \"(app-pages-browser)/./node_modules/date-fns/startOfWeekYear.mjs\");\n/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toDate.mjs */ \"(app-pages-browser)/./node_modules/date-fns/toDate.mjs\");\n\n\n\n\n/**\n * The {@link getWeek} function options.\n */ /**\n * @name getWeek\n * @category Week Helpers\n * @summary Get the local week index of the given date.\n *\n * @description\n * Get the local week index of the given date.\n * The exact calculation depends on the values of\n * `options.weekStartsOn` (which is the index of the first day of the week)\n * and `options.firstWeekContainsDate` (which is the day of January, which is always in\n * the first week of the week-numbering year)\n *\n * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The given date\n * @param options - An object with options\n *\n * @returns The week\n *\n * @example\n * // Which week of the local week numbering year is 2 January 2005 with default options?\n * const result = getWeek(new Date(2005, 0, 2))\n * //=> 2\n *\n * @example\n * // Which week of the local week numbering year is 2 January 2005,\n * // if Monday is the first day of the week,\n * // and the first week of the year always contains 4 January?\n * const result = getWeek(new Date(2005, 0, 2), {\n *   weekStartsOn: 1,\n *   firstWeekContainsDate: 4\n * })\n * //=> 53\n */ function getWeek(date, options) {\n    const _date = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_0__.toDate)(date);\n    const diff = +(0,_startOfWeek_mjs__WEBPACK_IMPORTED_MODULE_1__.startOfWeek)(_date, options) - +(0,_startOfWeekYear_mjs__WEBPACK_IMPORTED_MODULE_2__.startOfWeekYear)(_date, options);\n    // Round the number of weeks to the nearest integer because the number of\n    // milliseconds in a week is not constant (e.g. it's different in the week of\n    // the daylight saving time clock shift).\n    return Math.round(diff / _constants_mjs__WEBPACK_IMPORTED_MODULE_3__.millisecondsInWeek) + 1;\n}\n// Fallback for modularized imports:\n/* harmony default export */ __webpack_exports__[\"default\"] = (getWeek);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9nZXRXZWVrLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxRDtBQUNMO0FBQ1E7QUFDbEI7QUFFdEM7O0NBRUMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQ0MsR0FFTSxTQUFTSSxRQUFRQyxJQUFJLEVBQUVDLE9BQU87SUFDbkMsTUFBTUMsUUFBUUosbURBQU1BLENBQUNFO0lBQ3JCLE1BQU1HLE9BQU8sQ0FBQ1AsNkRBQVdBLENBQUNNLE9BQU9ELFdBQVcsQ0FBQ0oscUVBQWVBLENBQUNLLE9BQU9EO0lBRXBFLHlFQUF5RTtJQUN6RSw2RUFBNkU7SUFDN0UseUNBQXlDO0lBQ3pDLE9BQU9HLEtBQUtDLEtBQUssQ0FBQ0YsT0FBT1IsOERBQWtCQSxJQUFJO0FBQ2pEO0FBRUEsb0NBQW9DO0FBQ3BDLCtEQUFlSSxPQUFPQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9nZXRXZWVrLm1qcz85MzgyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1pbGxpc2Vjb25kc0luV2VlayB9IGZyb20gXCIuL2NvbnN0YW50cy5tanNcIjtcbmltcG9ydCB7IHN0YXJ0T2ZXZWVrIH0gZnJvbSBcIi4vc3RhcnRPZldlZWsubWpzXCI7XG5pbXBvcnQgeyBzdGFydE9mV2Vla1llYXIgfSBmcm9tIFwiLi9zdGFydE9mV2Vla1llYXIubWpzXCI7XG5pbXBvcnQgeyB0b0RhdGUgfSBmcm9tIFwiLi90b0RhdGUubWpzXCI7XG5cbi8qKlxuICogVGhlIHtAbGluayBnZXRXZWVrfSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgZ2V0V2Vla1xuICogQGNhdGVnb3J5IFdlZWsgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBsb2NhbCB3ZWVrIGluZGV4IG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBsb2NhbCB3ZWVrIGluZGV4IG9mIHRoZSBnaXZlbiBkYXRlLlxuICogVGhlIGV4YWN0IGNhbGN1bGF0aW9uIGRlcGVuZHMgb24gdGhlIHZhbHVlcyBvZlxuICogYG9wdGlvbnMud2Vla1N0YXJ0c09uYCAod2hpY2ggaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWspXG4gKiBhbmQgYG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlYCAod2hpY2ggaXMgdGhlIGRheSBvZiBKYW51YXJ5LCB3aGljaCBpcyBhbHdheXMgaW5cbiAqIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB3ZWVrLW51bWJlcmluZyB5ZWFyKVxuICpcbiAqIFdlZWsgbnVtYmVyaW5nOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWVrI1RoZV9JU09fd2Vla19kYXRlX3N5c3RlbVxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGdpdmVuIGRhdGVcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IHdpdGggb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIFRoZSB3ZWVrXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIHdlZWsgb2YgdGhlIGxvY2FsIHdlZWsgbnVtYmVyaW5nIHllYXIgaXMgMiBKYW51YXJ5IDIwMDUgd2l0aCBkZWZhdWx0IG9wdGlvbnM/XG4gKiBjb25zdCByZXN1bHQgPSBnZXRXZWVrKG5ldyBEYXRlKDIwMDUsIDAsIDIpKVxuICogLy89PiAyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIHdlZWsgb2YgdGhlIGxvY2FsIHdlZWsgbnVtYmVyaW5nIHllYXIgaXMgMiBKYW51YXJ5IDIwMDUsXG4gKiAvLyBpZiBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayxcbiAqIC8vIGFuZCB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhciBhbHdheXMgY29udGFpbnMgNCBKYW51YXJ5P1xuICogY29uc3QgcmVzdWx0ID0gZ2V0V2VlayhuZXcgRGF0ZSgyMDA1LCAwLCAyKSwge1xuICogICB3ZWVrU3RhcnRzT246IDEsXG4gKiAgIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZTogNFxuICogfSlcbiAqIC8vPT4gNTNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2VlayhkYXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IF9kYXRlID0gdG9EYXRlKGRhdGUpO1xuICBjb25zdCBkaWZmID0gK3N0YXJ0T2ZXZWVrKF9kYXRlLCBvcHRpb25zKSAtICtzdGFydE9mV2Vla1llYXIoX2RhdGUsIG9wdGlvbnMpO1xuXG4gIC8vIFJvdW5kIHRoZSBudW1iZXIgb2Ygd2Vla3MgdG8gdGhlIG5lYXJlc3QgaW50ZWdlciBiZWNhdXNlIHRoZSBudW1iZXIgb2ZcbiAgLy8gbWlsbGlzZWNvbmRzIGluIGEgd2VlayBpcyBub3QgY29uc3RhbnQgKGUuZy4gaXQncyBkaWZmZXJlbnQgaW4gdGhlIHdlZWsgb2ZcbiAgLy8gdGhlIGRheWxpZ2h0IHNhdmluZyB0aW1lIGNsb2NrIHNoaWZ0KS5cbiAgcmV0dXJuIE1hdGgucm91bmQoZGlmZiAvIG1pbGxpc2Vjb25kc0luV2VlaykgKyAxO1xufVxuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IGdldFdlZWs7XG4iXSwibmFtZXMiOlsibWlsbGlzZWNvbmRzSW5XZWVrIiwic3RhcnRPZldlZWsiLCJzdGFydE9mV2Vla1llYXIiLCJ0b0RhdGUiLCJnZXRXZWVrIiwiZGF0ZSIsIm9wdGlvbnMiLCJfZGF0ZSIsImRpZmYiLCJNYXRoIiwicm91bmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/getWeek.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/getWeekYear.mjs":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/getWeekYear.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWeekYear: function() { return /* binding */ getWeekYear; }\n/* harmony export */ });\n/* harmony import */ var _constructFrom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constructFrom.mjs */ \"(app-pages-browser)/./node_modules/date-fns/constructFrom.mjs\");\n/* harmony import */ var _startOfWeek_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./startOfWeek.mjs */ \"(app-pages-browser)/./node_modules/date-fns/startOfWeek.mjs\");\n/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toDate.mjs */ \"(app-pages-browser)/./node_modules/date-fns/toDate.mjs\");\n/* harmony import */ var _lib_defaultOptions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_lib/defaultOptions.mjs */ \"(app-pages-browser)/./node_modules/date-fns/_lib/defaultOptions.mjs\");\n\n\n\n\n/**\n * The {@link getWeekYear} function options.\n */ /**\n * @name getWeekYear\n * @category Week-Numbering Year Helpers\n * @summary Get the local week-numbering year of the given date.\n *\n * @description\n * Get the local week-numbering year of the given date.\n * The exact calculation depends on the values of\n * `options.weekStartsOn` (which is the index of the first day of the week)\n * and `options.firstWeekContainsDate` (which is the day of January, which is always in\n * the first week of the week-numbering year)\n *\n * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The given date\n * @param options - An object with options.\n *\n * @returns The local week-numbering year\n *\n * @example\n * // Which week numbering year is 26 December 2004 with the default settings?\n * const result = getWeekYear(new Date(2004, 11, 26))\n * //=> 2005\n *\n * @example\n * // Which week numbering year is 26 December 2004 if week starts on Saturday?\n * const result = getWeekYear(new Date(2004, 11, 26), { weekStartsOn: 6 })\n * //=> 2004\n *\n * @example\n * // Which week numbering year is 26 December 2004 if the first week contains 4 January?\n * const result = getWeekYear(new Date(2004, 11, 26), { firstWeekContainsDate: 4 })\n * //=> 2004\n */ function getWeekYear(date, options) {\n    var _options_locale_options, _options_locale, _defaultOptions_locale_options, _defaultOptions_locale;\n    const _date = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_0__.toDate)(date);\n    const year = _date.getFullYear();\n    const defaultOptions = (0,_lib_defaultOptions_mjs__WEBPACK_IMPORTED_MODULE_1__.getDefaultOptions)();\n    var _options_firstWeekContainsDate, _ref, _ref1, _ref2;\n    const firstWeekContainsDate = (_ref2 = (_ref1 = (_ref = (_options_firstWeekContainsDate = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options_firstWeekContainsDate !== void 0 ? _options_firstWeekContainsDate : options === null || options === void 0 ? void 0 : (_options_locale = options.locale) === null || _options_locale === void 0 ? void 0 : (_options_locale_options = _options_locale.options) === null || _options_locale_options === void 0 ? void 0 : _options_locale_options.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : defaultOptions.firstWeekContainsDate) !== null && _ref1 !== void 0 ? _ref1 : (_defaultOptions_locale = defaultOptions.locale) === null || _defaultOptions_locale === void 0 ? void 0 : (_defaultOptions_locale_options = _defaultOptions_locale.options) === null || _defaultOptions_locale_options === void 0 ? void 0 : _defaultOptions_locale_options.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1;\n    const firstWeekOfNextYear = (0,_constructFrom_mjs__WEBPACK_IMPORTED_MODULE_2__.constructFrom)(date, 0);\n    firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);\n    firstWeekOfNextYear.setHours(0, 0, 0, 0);\n    const startOfNextYear = (0,_startOfWeek_mjs__WEBPACK_IMPORTED_MODULE_3__.startOfWeek)(firstWeekOfNextYear, options);\n    const firstWeekOfThisYear = (0,_constructFrom_mjs__WEBPACK_IMPORTED_MODULE_2__.constructFrom)(date, 0);\n    firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);\n    firstWeekOfThisYear.setHours(0, 0, 0, 0);\n    const startOfThisYear = (0,_startOfWeek_mjs__WEBPACK_IMPORTED_MODULE_3__.startOfWeek)(firstWeekOfThisYear, options);\n    if (_date.getTime() >= startOfNextYear.getTime()) {\n        return year + 1;\n    } else if (_date.getTime() >= startOfThisYear.getTime()) {\n        return year;\n    } else {\n        return year - 1;\n    }\n}\n// Fallback for modularized imports:\n/* harmony default export */ __webpack_exports__[\"default\"] = (getWeekYear);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9nZXRXZWVrWWVhci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBb0Q7QUFDSjtBQUNWO0FBQ3dCO0FBRTlEOztDQUVDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUNDLEdBQ00sU0FBU0ksWUFBWUMsSUFBSSxFQUFFQyxPQUFPO1FBT3JDQSx5QkFBQUEsaUJBRUFDLGdDQUFBQTtJQVJGLE1BQU1DLFFBQVFOLG1EQUFNQSxDQUFDRztJQUNyQixNQUFNSSxPQUFPRCxNQUFNRSxXQUFXO0lBRTlCLE1BQU1ILGlCQUFpQkosMEVBQWlCQTtRQUV0Q0csZ0NBQUFBLE1BQUFBLE9BQUFBO0lBREYsTUFBTUssd0JBQ0pMLENBQUFBLFFBQUFBLENBQUFBLFFBQUFBLENBQUFBLE9BQUFBLENBQUFBLGlDQUFBQSxvQkFBQUEsOEJBQUFBLFFBQVNLLHFCQUFxQixjQUE5QkwsNENBQUFBLGlDQUNBQSxvQkFBQUEsK0JBQUFBLGtCQUFBQSxRQUFTTSxNQUFNLGNBQWZOLHVDQUFBQSwwQkFBQUEsZ0JBQWlCQSxPQUFPLGNBQXhCQSw4Q0FBQUEsd0JBQTBCSyxxQkFBcUIsY0FEL0NMLGtCQUFBQSxPQUVBQyxlQUFlSSxxQkFBcUIsY0FGcENMLG1CQUFBQSxTQUdBQyx5QkFBQUEsZUFBZUssTUFBTSxjQUFyQkwsOENBQUFBLGlDQUFBQSx1QkFBdUJELE9BQU8sY0FBOUJDLHFEQUFBQSwrQkFBZ0NJLHFCQUFxQixjQUhyREwsbUJBQUFBLFFBSUE7SUFFRixNQUFNTyxzQkFBc0JiLGlFQUFhQSxDQUFDSyxNQUFNO0lBQ2hEUSxvQkFBb0JDLFdBQVcsQ0FBQ0wsT0FBTyxHQUFHLEdBQUdFO0lBQzdDRSxvQkFBb0JFLFFBQVEsQ0FBQyxHQUFHLEdBQUcsR0FBRztJQUN0QyxNQUFNQyxrQkFBa0JmLDZEQUFXQSxDQUFDWSxxQkFBcUJQO0lBRXpELE1BQU1XLHNCQUFzQmpCLGlFQUFhQSxDQUFDSyxNQUFNO0lBQ2hEWSxvQkFBb0JILFdBQVcsQ0FBQ0wsTUFBTSxHQUFHRTtJQUN6Q00sb0JBQW9CRixRQUFRLENBQUMsR0FBRyxHQUFHLEdBQUc7SUFDdEMsTUFBTUcsa0JBQWtCakIsNkRBQVdBLENBQUNnQixxQkFBcUJYO0lBRXpELElBQUlFLE1BQU1XLE9BQU8sTUFBTUgsZ0JBQWdCRyxPQUFPLElBQUk7UUFDaEQsT0FBT1YsT0FBTztJQUNoQixPQUFPLElBQUlELE1BQU1XLE9BQU8sTUFBTUQsZ0JBQWdCQyxPQUFPLElBQUk7UUFDdkQsT0FBT1Y7SUFDVCxPQUFPO1FBQ0wsT0FBT0EsT0FBTztJQUNoQjtBQUNGO0FBRUEsb0NBQW9DO0FBQ3BDLCtEQUFlTCxXQUFXQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9nZXRXZWVrWWVhci5tanM/YTBkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb25zdHJ1Y3RGcm9tIH0gZnJvbSBcIi4vY29uc3RydWN0RnJvbS5tanNcIjtcbmltcG9ydCB7IHN0YXJ0T2ZXZWVrIH0gZnJvbSBcIi4vc3RhcnRPZldlZWsubWpzXCI7XG5pbXBvcnQgeyB0b0RhdGUgfSBmcm9tIFwiLi90b0RhdGUubWpzXCI7XG5pbXBvcnQgeyBnZXREZWZhdWx0T3B0aW9ucyB9IGZyb20gXCIuL19saWIvZGVmYXVsdE9wdGlvbnMubWpzXCI7XG5cbi8qKlxuICogVGhlIHtAbGluayBnZXRXZWVrWWVhcn0gZnVuY3Rpb24gb3B0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEBuYW1lIGdldFdlZWtZZWFyXG4gKiBAY2F0ZWdvcnkgV2Vlay1OdW1iZXJpbmcgWWVhciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIGxvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIGxvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgZXhhY3QgY2FsY3VsYXRpb24gZGVwZW5kcyBvbiB0aGUgdmFsdWVzIG9mXG4gKiBgb3B0aW9ucy53ZWVrU3RhcnRzT25gICh3aGljaCBpcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlaylcbiAqIGFuZCBgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGVgICh3aGljaCBpcyB0aGUgZGF5IG9mIEphbnVhcnksIHdoaWNoIGlzIGFsd2F5cyBpblxuICogdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHdlZWstbnVtYmVyaW5nIHllYXIpXG4gKlxuICogV2VlayBudW1iZXJpbmc6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlZWsjVGhlX0lTT193ZWVrX2RhdGVfc3lzdGVtXG4gKlxuICogQHR5cGVQYXJhbSBEYXRlVHlwZSAtIFRoZSBgRGF0ZWAgdHlwZSwgdGhlIGZ1bmN0aW9uIG9wZXJhdGVzIG9uLiBHZXRzIGluZmVycmVkIGZyb20gcGFzc2VkIGFyZ3VtZW50cy4gQWxsb3dzIHRvIHVzZSBleHRlbnNpb25zIGxpa2UgW2BVVENEYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL3V0YykuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZ2l2ZW4gZGF0ZVxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICpcbiAqIEByZXR1cm5zIFRoZSBsb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIHdlZWsgbnVtYmVyaW5nIHllYXIgaXMgMjYgRGVjZW1iZXIgMjAwNCB3aXRoIHRoZSBkZWZhdWx0IHNldHRpbmdzP1xuICogY29uc3QgcmVzdWx0ID0gZ2V0V2Vla1llYXIobmV3IERhdGUoMjAwNCwgMTEsIDI2KSlcbiAqIC8vPT4gMjAwNVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGljaCB3ZWVrIG51bWJlcmluZyB5ZWFyIGlzIDI2IERlY2VtYmVyIDIwMDQgaWYgd2VlayBzdGFydHMgb24gU2F0dXJkYXk/XG4gKiBjb25zdCByZXN1bHQgPSBnZXRXZWVrWWVhcihuZXcgRGF0ZSgyMDA0LCAxMSwgMjYpLCB7IHdlZWtTdGFydHNPbjogNiB9KVxuICogLy89PiAyMDA0XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIHdlZWsgbnVtYmVyaW5nIHllYXIgaXMgMjYgRGVjZW1iZXIgMjAwNCBpZiB0aGUgZmlyc3Qgd2VlayBjb250YWlucyA0IEphbnVhcnk/XG4gKiBjb25zdCByZXN1bHQgPSBnZXRXZWVrWWVhcihuZXcgRGF0ZSgyMDA0LCAxMSwgMjYpLCB7IGZpcnN0V2Vla0NvbnRhaW5zRGF0ZTogNCB9KVxuICogLy89PiAyMDA0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXZWVrWWVhcihkYXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IF9kYXRlID0gdG9EYXRlKGRhdGUpO1xuICBjb25zdCB5ZWFyID0gX2RhdGUuZ2V0RnVsbFllYXIoKTtcblxuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IGdldERlZmF1bHRPcHRpb25zKCk7XG4gIGNvbnN0IGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9XG4gICAgb3B0aW9ucz8uZmlyc3RXZWVrQ29udGFpbnNEYXRlID8/XG4gICAgb3B0aW9ucz8ubG9jYWxlPy5vcHRpb25zPy5maXJzdFdlZWtDb250YWluc0RhdGUgPz9cbiAgICBkZWZhdWx0T3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUgPz9cbiAgICBkZWZhdWx0T3B0aW9ucy5sb2NhbGU/Lm9wdGlvbnM/LmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA/P1xuICAgIDE7XG5cbiAgY29uc3QgZmlyc3RXZWVrT2ZOZXh0WWVhciA9IGNvbnN0cnVjdEZyb20oZGF0ZSwgMCk7XG4gIGZpcnN0V2Vla09mTmV4dFllYXIuc2V0RnVsbFllYXIoeWVhciArIDEsIDAsIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIGZpcnN0V2Vla09mTmV4dFllYXIuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIGNvbnN0IHN0YXJ0T2ZOZXh0WWVhciA9IHN0YXJ0T2ZXZWVrKGZpcnN0V2Vla09mTmV4dFllYXIsIG9wdGlvbnMpO1xuXG4gIGNvbnN0IGZpcnN0V2Vla09mVGhpc1llYXIgPSBjb25zdHJ1Y3RGcm9tKGRhdGUsIDApO1xuICBmaXJzdFdlZWtPZlRoaXNZZWFyLnNldEZ1bGxZZWFyKHllYXIsIDAsIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XG4gIGZpcnN0V2Vla09mVGhpc1llYXIuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIGNvbnN0IHN0YXJ0T2ZUaGlzWWVhciA9IHN0YXJ0T2ZXZWVrKGZpcnN0V2Vla09mVGhpc1llYXIsIG9wdGlvbnMpO1xuXG4gIGlmIChfZGF0ZS5nZXRUaW1lKCkgPj0gc3RhcnRPZk5leHRZZWFyLmdldFRpbWUoKSkge1xuICAgIHJldHVybiB5ZWFyICsgMTtcbiAgfSBlbHNlIGlmIChfZGF0ZS5nZXRUaW1lKCkgPj0gc3RhcnRPZlRoaXNZZWFyLmdldFRpbWUoKSkge1xuICAgIHJldHVybiB5ZWFyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB5ZWFyIC0gMTtcbiAgfVxufVxuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IGdldFdlZWtZZWFyO1xuIl0sIm5hbWVzIjpbImNvbnN0cnVjdEZyb20iLCJzdGFydE9mV2VlayIsInRvRGF0ZSIsImdldERlZmF1bHRPcHRpb25zIiwiZ2V0V2Vla1llYXIiLCJkYXRlIiwib3B0aW9ucyIsImRlZmF1bHRPcHRpb25zIiwiX2RhdGUiLCJ5ZWFyIiwiZ2V0RnVsbFllYXIiLCJmaXJzdFdlZWtDb250YWluc0RhdGUiLCJsb2NhbGUiLCJmaXJzdFdlZWtPZk5leHRZZWFyIiwic2V0RnVsbFllYXIiLCJzZXRIb3VycyIsInN0YXJ0T2ZOZXh0WWVhciIsImZpcnN0V2Vla09mVGhpc1llYXIiLCJzdGFydE9mVGhpc1llYXIiLCJnZXRUaW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/getWeekYear.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/isDate.mjs":
/*!******************************************!*\
  !*** ./node_modules/date-fns/isDate.mjs ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isDate: function() { return /* binding */ isDate; }\n/* harmony export */ });\n/**\n * @name isDate\n * @category Common Helpers\n * @summary Is the given value a date?\n *\n * @description\n * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.\n *\n * @param value - The value to check\n *\n * @returns True if the given value is a date\n *\n * @example\n * // For a valid date:\n * const result = isDate(new Date())\n * //=> true\n *\n * @example\n * // For an invalid date:\n * const result = isDate(new Date(NaN))\n * //=> true\n *\n * @example\n * // For some value:\n * const result = isDate('2014-02-31')\n * //=> false\n *\n * @example\n * // For an object:\n * const result = isDate({})\n * //=> false\n */ function isDate(value) {\n    return value instanceof Date || typeof value === \"object\" && Object.prototype.toString.call(value) === \"[object Date]\";\n}\n// Fallback for modularized imports:\n/* harmony default export */ __webpack_exports__[\"default\"] = (isDate);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9pc0RhdGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQStCQyxHQUNNLFNBQVNBLE9BQU9DLEtBQUs7SUFDMUIsT0FDRUEsaUJBQWlCQyxRQUNoQixPQUFPRCxVQUFVLFlBQ2hCRSxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDTCxXQUFXO0FBRWhEO0FBRUEsb0NBQW9DO0FBQ3BDLCtEQUFlRCxNQUFNQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9pc0RhdGUubWpzPzY5MzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbmFtZSBpc0RhdGVcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgSXMgdGhlIGdpdmVuIHZhbHVlIGEgZGF0ZT9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZS4gVGhlIGZ1bmN0aW9uIHdvcmtzIGZvciBkYXRlcyB0cmFuc2ZlcnJlZCBhY3Jvc3MgaWZyYW1lcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGRhdGVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIGEgdmFsaWQgZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IGlzRGF0ZShuZXcgRGF0ZSgpKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciBhbiBpbnZhbGlkIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSBpc0RhdGUobmV3IERhdGUoTmFOKSlcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3Igc29tZSB2YWx1ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IGlzRGF0ZSgnMjAxNC0wMi0zMScpXG4gKiAvLz0+IGZhbHNlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciBhbiBvYmplY3Q6XG4gKiBjb25zdCByZXN1bHQgPSBpc0RhdGUoe30pXG4gKiAvLz0+IGZhbHNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgRGF0ZV1cIilcbiAgKTtcbn1cblxuLy8gRmFsbGJhY2sgZm9yIG1vZHVsYXJpemVkIGltcG9ydHM6XG5leHBvcnQgZGVmYXVsdCBpc0RhdGU7XG4iXSwibmFtZXMiOlsiaXNEYXRlIiwidmFsdWUiLCJEYXRlIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/isDate.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/isValid.mjs":
/*!*******************************************!*\
  !*** ./node_modules/date-fns/isValid.mjs ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isValid: function() { return /* binding */ isValid; }\n/* harmony export */ });\n/* harmony import */ var _isDate_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isDate.mjs */ \"(app-pages-browser)/./node_modules/date-fns/isDate.mjs\");\n/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toDate.mjs */ \"(app-pages-browser)/./node_modules/date-fns/toDate.mjs\");\n\n\n/**\n * @name isValid\n * @category Common Helpers\n * @summary Is the given date valid?\n *\n * @description\n * Returns false if argument is Invalid Date and true otherwise.\n * Argument is converted to Date using `toDate`. See [toDate](https://date-fns.org/docs/toDate)\n * Invalid Date is a Date, whose time value is NaN.\n *\n * Time value of Date: http://es5.github.io/#x15.9.1.1\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The date to check\n *\n * @returns The date is valid\n *\n * @example\n * // For the valid date:\n * const result = isValid(new Date(2014, 1, 31))\n * //=> true\n *\n * @example\n * // For the value, convertable into a date:\n * const result = isValid(1393804800000)\n * //=> true\n *\n * @example\n * // For the invalid date:\n * const result = isValid(new Date(''))\n * //=> false\n */ function isValid(date) {\n    if (!(0,_isDate_mjs__WEBPACK_IMPORTED_MODULE_0__.isDate)(date) && typeof date !== \"number\") {\n        return false;\n    }\n    const _date = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_1__.toDate)(date);\n    return !isNaN(Number(_date));\n}\n// Fallback for modularized imports:\n/* harmony default export */ __webpack_exports__[\"default\"] = (isValid);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9pc1ZhbGlkLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBc0M7QUFDQTtBQUV0Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQ0MsR0FDTSxTQUFTRSxRQUFRQyxJQUFJO0lBQzFCLElBQUksQ0FBQ0gsbURBQU1BLENBQUNHLFNBQVMsT0FBT0EsU0FBUyxVQUFVO1FBQzdDLE9BQU87SUFDVDtJQUNBLE1BQU1DLFFBQVFILG1EQUFNQSxDQUFDRTtJQUNyQixPQUFPLENBQUNFLE1BQU1DLE9BQU9GO0FBQ3ZCO0FBRUEsb0NBQW9DO0FBQ3BDLCtEQUFlRixPQUFPQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9pc1ZhbGlkLm1qcz9lMzM1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzRGF0ZSB9IGZyb20gXCIuL2lzRGF0ZS5tanNcIjtcbmltcG9ydCB7IHRvRGF0ZSB9IGZyb20gXCIuL3RvRGF0ZS5tanNcIjtcblxuLyoqXG4gKiBAbmFtZSBpc1ZhbGlkXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IElzIHRoZSBnaXZlbiBkYXRlIHZhbGlkP1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJucyBmYWxzZSBpZiBhcmd1bWVudCBpcyBJbnZhbGlkIERhdGUgYW5kIHRydWUgb3RoZXJ3aXNlLlxuICogQXJndW1lbnQgaXMgY29udmVydGVkIHRvIERhdGUgdXNpbmcgYHRvRGF0ZWAuIFNlZSBbdG9EYXRlXShodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3RvRGF0ZSlcbiAqIEludmFsaWQgRGF0ZSBpcyBhIERhdGUsIHdob3NlIHRpbWUgdmFsdWUgaXMgTmFOLlxuICpcbiAqIFRpbWUgdmFsdWUgb2YgRGF0ZTogaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS45LjEuMVxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGF0ZSBpcyB2YWxpZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3IgdGhlIHZhbGlkIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSBpc1ZhbGlkKG5ldyBEYXRlKDIwMTQsIDEsIDMxKSlcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3IgdGhlIHZhbHVlLCBjb252ZXJ0YWJsZSBpbnRvIGEgZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IGlzVmFsaWQoMTM5MzgwNDgwMDAwMClcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBGb3IgdGhlIGludmFsaWQgZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IGlzVmFsaWQobmV3IERhdGUoJycpKVxuICogLy89PiBmYWxzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZChkYXRlKSB7XG4gIGlmICghaXNEYXRlKGRhdGUpICYmIHR5cGVvZiBkYXRlICE9PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IF9kYXRlID0gdG9EYXRlKGRhdGUpO1xuICByZXR1cm4gIWlzTmFOKE51bWJlcihfZGF0ZSkpO1xufVxuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IGlzVmFsaWQ7XG4iXSwibmFtZXMiOlsiaXNEYXRlIiwidG9EYXRlIiwiaXNWYWxpZCIsImRhdGUiLCJfZGF0ZSIsImlzTmFOIiwiTnVtYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/isValid.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/locale/_lib/buildFormatLongFn.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/date-fns/locale/_lib/buildFormatLongFn.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildFormatLongFn: function() { return /* binding */ buildFormatLongFn; }\n/* harmony export */ });\nfunction buildFormatLongFn(args) {\n    return function() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        // TODO: Remove String()\n        const width = options.width ? String(options.width) : args.defaultWidth;\n        const format = args.formats[width] || args.formats[args.defaultWidth];\n        return format;\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9sb2NhbGUvX2xpYi9idWlsZEZvcm1hdExvbmdGbi5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLFNBQVNBLGtCQUFrQkMsSUFBSTtJQUNwQyxPQUFPO1lBQUNDLDJFQUFVLENBQUM7UUFDakIsd0JBQXdCO1FBQ3hCLE1BQU1DLFFBQVFELFFBQVFDLEtBQUssR0FBR0MsT0FBT0YsUUFBUUMsS0FBSyxJQUFJRixLQUFLSSxZQUFZO1FBQ3ZFLE1BQU1DLFNBQVNMLEtBQUtNLE9BQU8sQ0FBQ0osTUFBTSxJQUFJRixLQUFLTSxPQUFPLENBQUNOLEtBQUtJLFlBQVksQ0FBQztRQUNyRSxPQUFPQztJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2xvY2FsZS9fbGliL2J1aWxkRm9ybWF0TG9uZ0ZuLm1qcz8xYzFkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBidWlsZEZvcm1hdExvbmdGbihhcmdzKSB7XG4gIHJldHVybiAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgLy8gVE9ETzogUmVtb3ZlIFN0cmluZygpXG4gICAgY29uc3Qgd2lkdGggPSBvcHRpb25zLndpZHRoID8gU3RyaW5nKG9wdGlvbnMud2lkdGgpIDogYXJncy5kZWZhdWx0V2lkdGg7XG4gICAgY29uc3QgZm9ybWF0ID0gYXJncy5mb3JtYXRzW3dpZHRoXSB8fCBhcmdzLmZvcm1hdHNbYXJncy5kZWZhdWx0V2lkdGhdO1xuICAgIHJldHVybiBmb3JtYXQ7XG4gIH07XG59XG4iXSwibmFtZXMiOlsiYnVpbGRGb3JtYXRMb25nRm4iLCJhcmdzIiwib3B0aW9ucyIsIndpZHRoIiwiU3RyaW5nIiwiZGVmYXVsdFdpZHRoIiwiZm9ybWF0IiwiZm9ybWF0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/locale/_lib/buildFormatLongFn.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/locale/_lib/buildLocalizeFn.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/date-fns/locale/_lib/buildLocalizeFn.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildLocalizeFn: function() { return /* binding */ buildLocalizeFn; }\n/* harmony export */ });\n/* eslint-disable no-unused-vars */ /**\n * The localize function argument callback which allows to convert raw value to\n * the actual type.\n *\n * @param value - The value to convert\n *\n * @returns The converted value\n */ /**\n * The map of localized values for each width.\n */ /**\n * The index type of the locale unit value. It types conversion of units of\n * values that don't start at 0 (i.e. quarters).\n */ /**\n * Converts the unit value to the tuple of values.\n */ /**\n * The tuple of localized era values. The first element represents BC,\n * the second element represents AD.\n */ /**\n * The tuple of localized quarter values. The first element represents Q1.\n */ /**\n * The tuple of localized day values. The first element represents Sunday.\n */ /**\n * The tuple of localized month values. The first element represents January.\n */ function buildLocalizeFn(args) {\n    return (value, options)=>{\n        const context = (options === null || options === void 0 ? void 0 : options.context) ? String(options.context) : \"standalone\";\n        let valuesArray;\n        if (context === \"formatting\" && args.formattingValues) {\n            const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;\n            const width = (options === null || options === void 0 ? void 0 : options.width) ? String(options.width) : defaultWidth;\n            valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];\n        } else {\n            const defaultWidth = args.defaultWidth;\n            const width = (options === null || options === void 0 ? void 0 : options.width) ? String(options.width) : args.defaultWidth;\n            valuesArray = args.values[width] || args.values[defaultWidth];\n        }\n        const index = args.argumentCallback ? args.argumentCallback(value) : value;\n        // @ts-expect-error - For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!\n        return valuesArray[index];\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9sb2NhbGUvX2xpYi9idWlsZExvY2FsaXplRm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpQ0FBaUMsR0FFakM7Ozs7Ozs7Q0FPQyxHQUVEOztDQUVDLEdBRUQ7OztDQUdDLEdBRUQ7O0NBRUMsR0FFRDs7O0NBR0MsR0FFRDs7Q0FFQyxHQUVEOztDQUVDLEdBRUQ7O0NBRUMsR0FFTSxTQUFTQSxnQkFBZ0JDLElBQUk7SUFDbEMsT0FBTyxDQUFDQyxPQUFPQztRQUNiLE1BQU1DLFVBQVVELENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0MsT0FBTyxJQUFHQyxPQUFPRixRQUFRQyxPQUFPLElBQUk7UUFFN0QsSUFBSUU7UUFDSixJQUFJRixZQUFZLGdCQUFnQkgsS0FBS00sZ0JBQWdCLEVBQUU7WUFDckQsTUFBTUMsZUFBZVAsS0FBS1Esc0JBQXNCLElBQUlSLEtBQUtPLFlBQVk7WUFDckUsTUFBTUUsUUFBUVAsQ0FBQUEsb0JBQUFBLDhCQUFBQSxRQUFTTyxLQUFLLElBQUdMLE9BQU9GLFFBQVFPLEtBQUssSUFBSUY7WUFFdkRGLGNBQ0VMLEtBQUtNLGdCQUFnQixDQUFDRyxNQUFNLElBQUlULEtBQUtNLGdCQUFnQixDQUFDQyxhQUFhO1FBQ3ZFLE9BQU87WUFDTCxNQUFNQSxlQUFlUCxLQUFLTyxZQUFZO1lBQ3RDLE1BQU1FLFFBQVFQLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU08sS0FBSyxJQUFHTCxPQUFPRixRQUFRTyxLQUFLLElBQUlULEtBQUtPLFlBQVk7WUFFeEVGLGNBQWNMLEtBQUtVLE1BQU0sQ0FBQ0QsTUFBTSxJQUFJVCxLQUFLVSxNQUFNLENBQUNILGFBQWE7UUFDL0Q7UUFDQSxNQUFNSSxRQUFRWCxLQUFLWSxnQkFBZ0IsR0FBR1osS0FBS1ksZ0JBQWdCLENBQUNYLFNBQVNBO1FBRXJFLDZJQUE2STtRQUM3SSxPQUFPSSxXQUFXLENBQUNNLE1BQU07SUFDM0I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbG9jYWxlL19saWIvYnVpbGRMb2NhbGl6ZUZuLm1qcz9kYWU2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogVGhlIGxvY2FsaXplIGZ1bmN0aW9uIGFyZ3VtZW50IGNhbGxiYWNrIHdoaWNoIGFsbG93cyB0byBjb252ZXJ0IHJhdyB2YWx1ZSB0b1xuICogdGhlIGFjdHVhbCB0eXBlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0XG4gKlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB2YWx1ZVxuICovXG5cbi8qKlxuICogVGhlIG1hcCBvZiBsb2NhbGl6ZWQgdmFsdWVzIGZvciBlYWNoIHdpZHRoLlxuICovXG5cbi8qKlxuICogVGhlIGluZGV4IHR5cGUgb2YgdGhlIGxvY2FsZSB1bml0IHZhbHVlLiBJdCB0eXBlcyBjb252ZXJzaW9uIG9mIHVuaXRzIG9mXG4gKiB2YWx1ZXMgdGhhdCBkb24ndCBzdGFydCBhdCAwIChpLmUuIHF1YXJ0ZXJzKS5cbiAqL1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSB1bml0IHZhbHVlIHRvIHRoZSB0dXBsZSBvZiB2YWx1ZXMuXG4gKi9cblxuLyoqXG4gKiBUaGUgdHVwbGUgb2YgbG9jYWxpemVkIGVyYSB2YWx1ZXMuIFRoZSBmaXJzdCBlbGVtZW50IHJlcHJlc2VudHMgQkMsXG4gKiB0aGUgc2Vjb25kIGVsZW1lbnQgcmVwcmVzZW50cyBBRC5cbiAqL1xuXG4vKipcbiAqIFRoZSB0dXBsZSBvZiBsb2NhbGl6ZWQgcXVhcnRlciB2YWx1ZXMuIFRoZSBmaXJzdCBlbGVtZW50IHJlcHJlc2VudHMgUTEuXG4gKi9cblxuLyoqXG4gKiBUaGUgdHVwbGUgb2YgbG9jYWxpemVkIGRheSB2YWx1ZXMuIFRoZSBmaXJzdCBlbGVtZW50IHJlcHJlc2VudHMgU3VuZGF5LlxuICovXG5cbi8qKlxuICogVGhlIHR1cGxlIG9mIGxvY2FsaXplZCBtb250aCB2YWx1ZXMuIFRoZSBmaXJzdCBlbGVtZW50IHJlcHJlc2VudHMgSmFudWFyeS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRMb2NhbGl6ZUZuKGFyZ3MpIHtcbiAgcmV0dXJuICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSBvcHRpb25zPy5jb250ZXh0ID8gU3RyaW5nKG9wdGlvbnMuY29udGV4dCkgOiBcInN0YW5kYWxvbmVcIjtcblxuICAgIGxldCB2YWx1ZXNBcnJheTtcbiAgICBpZiAoY29udGV4dCA9PT0gXCJmb3JtYXR0aW5nXCIgJiYgYXJncy5mb3JtYXR0aW5nVmFsdWVzKSB7XG4gICAgICBjb25zdCBkZWZhdWx0V2lkdGggPSBhcmdzLmRlZmF1bHRGb3JtYXR0aW5nV2lkdGggfHwgYXJncy5kZWZhdWx0V2lkdGg7XG4gICAgICBjb25zdCB3aWR0aCA9IG9wdGlvbnM/LndpZHRoID8gU3RyaW5nKG9wdGlvbnMud2lkdGgpIDogZGVmYXVsdFdpZHRoO1xuXG4gICAgICB2YWx1ZXNBcnJheSA9XG4gICAgICAgIGFyZ3MuZm9ybWF0dGluZ1ZhbHVlc1t3aWR0aF0gfHwgYXJncy5mb3JtYXR0aW5nVmFsdWVzW2RlZmF1bHRXaWR0aF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRXaWR0aCA9IGFyZ3MuZGVmYXVsdFdpZHRoO1xuICAgICAgY29uc3Qgd2lkdGggPSBvcHRpb25zPy53aWR0aCA/IFN0cmluZyhvcHRpb25zLndpZHRoKSA6IGFyZ3MuZGVmYXVsdFdpZHRoO1xuXG4gICAgICB2YWx1ZXNBcnJheSA9IGFyZ3MudmFsdWVzW3dpZHRoXSB8fCBhcmdzLnZhbHVlc1tkZWZhdWx0V2lkdGhdO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IGFyZ3MuYXJndW1lbnRDYWxsYmFjayA/IGFyZ3MuYXJndW1lbnRDYWxsYmFjayh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBGb3Igc29tZSByZWFzb24gVHlwZVNjcmlwdCBqdXN0IGRvbid0IHdhbnQgdG8gbWF0Y2ggaXQsIG5vIG1hdHRlciBob3cgaGFyZCB3ZSB0cnkuIEkgY2hhbGxlbmdlIHlvdSB0byB0cnkgdG8gcmVtb3ZlIGl0IVxuICAgIHJldHVybiB2YWx1ZXNBcnJheVtpbmRleF07XG4gIH07XG59XG4iXSwibmFtZXMiOlsiYnVpbGRMb2NhbGl6ZUZuIiwiYXJncyIsInZhbHVlIiwib3B0aW9ucyIsImNvbnRleHQiLCJTdHJpbmciLCJ2YWx1ZXNBcnJheSIsImZvcm1hdHRpbmdWYWx1ZXMiLCJkZWZhdWx0V2lkdGgiLCJkZWZhdWx0Rm9ybWF0dGluZ1dpZHRoIiwid2lkdGgiLCJ2YWx1ZXMiLCJpbmRleCIsImFyZ3VtZW50Q2FsbGJhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/locale/_lib/buildLocalizeFn.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/locale/_lib/buildMatchFn.mjs":
/*!************************************************************!*\
  !*** ./node_modules/date-fns/locale/_lib/buildMatchFn.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildMatchFn: function() { return /* binding */ buildMatchFn; }\n/* harmony export */ });\nfunction buildMatchFn(args) {\n    return function(string) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const width = options.width;\n        const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];\n        const matchResult = string.match(matchPattern);\n        if (!matchResult) {\n            return null;\n        }\n        const matchedString = matchResult[0];\n        const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];\n        const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern)=>pattern.test(matchedString)) : findKey(parsePatterns, (pattern)=>pattern.test(matchedString));\n        let value;\n        value = args.valueCallback ? args.valueCallback(key) : key;\n        value = options.valueCallback ? options.valueCallback(value) : value;\n        const rest = string.slice(matchedString.length);\n        return {\n            value,\n            rest\n        };\n    };\n}\nfunction findKey(object, predicate) {\n    for(const key in object){\n        if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {\n            return key;\n        }\n    }\n    return undefined;\n}\nfunction findIndex(array, predicate) {\n    for(let key = 0; key < array.length; key++){\n        if (predicate(array[key])) {\n            return key;\n        }\n    }\n    return undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9sb2NhbGUvX2xpYi9idWlsZE1hdGNoRm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxTQUFTQSxhQUFhQyxJQUFJO0lBQy9CLE9BQU8sU0FBQ0M7WUFBUUMsMkVBQVUsQ0FBQztRQUN6QixNQUFNQyxRQUFRRCxRQUFRQyxLQUFLO1FBRTNCLE1BQU1DLGVBQ0osU0FBVUosS0FBS0ssYUFBYSxDQUFDRixNQUFNLElBQ25DSCxLQUFLSyxhQUFhLENBQUNMLEtBQUtNLGlCQUFpQixDQUFDO1FBQzVDLE1BQU1DLGNBQWNOLE9BQU9PLEtBQUssQ0FBQ0o7UUFFakMsSUFBSSxDQUFDRyxhQUFhO1lBQ2hCLE9BQU87UUFDVDtRQUNBLE1BQU1FLGdCQUFnQkYsV0FBVyxDQUFDLEVBQUU7UUFFcEMsTUFBTUcsZ0JBQ0osU0FBVVYsS0FBS1UsYUFBYSxDQUFDUCxNQUFNLElBQ25DSCxLQUFLVSxhQUFhLENBQUNWLEtBQUtXLGlCQUFpQixDQUFDO1FBRTVDLE1BQU1DLE1BQU1DLE1BQU1DLE9BQU8sQ0FBQ0osaUJBQ3RCSyxVQUFVTCxlQUFlLENBQUNNLFVBQVlBLFFBQVFDLElBQUksQ0FBQ1Isa0JBRW5EUyxRQUFRUixlQUFlLENBQUNNLFVBQVlBLFFBQVFDLElBQUksQ0FBQ1I7UUFFckQsSUFBSVU7UUFFSkEsUUFBUW5CLEtBQUtvQixhQUFhLEdBQUdwQixLQUFLb0IsYUFBYSxDQUFDUixPQUFPQTtRQUN2RE8sUUFBUWpCLFFBQVFrQixhQUFhLEdBRXpCbEIsUUFBUWtCLGFBQWEsQ0FBQ0QsU0FDdEJBO1FBRUosTUFBTUUsT0FBT3BCLE9BQU9xQixLQUFLLENBQUNiLGNBQWNjLE1BQU07UUFFOUMsT0FBTztZQUFFSjtZQUFPRTtRQUFLO0lBQ3ZCO0FBQ0Y7QUFFQSxTQUFTSCxRQUFRTSxNQUFNLEVBQUVDLFNBQVM7SUFDaEMsSUFBSyxNQUFNYixPQUFPWSxPQUFRO1FBQ3hCLElBQ0VFLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNMLFFBQVFaLFFBQzdDYSxVQUFVRCxNQUFNLENBQUNaLElBQUksR0FDckI7WUFDQSxPQUFPQTtRQUNUO0lBQ0Y7SUFDQSxPQUFPa0I7QUFDVDtBQUVBLFNBQVNmLFVBQVVnQixLQUFLLEVBQUVOLFNBQVM7SUFDakMsSUFBSyxJQUFJYixNQUFNLEdBQUdBLE1BQU1tQixNQUFNUixNQUFNLEVBQUVYLE1BQU87UUFDM0MsSUFBSWEsVUFBVU0sS0FBSyxDQUFDbkIsSUFBSSxHQUFHO1lBQ3pCLE9BQU9BO1FBQ1Q7SUFDRjtJQUNBLE9BQU9rQjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9sb2NhbGUvX2xpYi9idWlsZE1hdGNoRm4ubWpzP2U2MTgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTWF0Y2hGbihhcmdzKSB7XG4gIHJldHVybiAoc3RyaW5nLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCB3aWR0aCA9IG9wdGlvbnMud2lkdGg7XG5cbiAgICBjb25zdCBtYXRjaFBhdHRlcm4gPVxuICAgICAgKHdpZHRoICYmIGFyZ3MubWF0Y2hQYXR0ZXJuc1t3aWR0aF0pIHx8XG4gICAgICBhcmdzLm1hdGNoUGF0dGVybnNbYXJncy5kZWZhdWx0TWF0Y2hXaWR0aF07XG4gICAgY29uc3QgbWF0Y2hSZXN1bHQgPSBzdHJpbmcubWF0Y2gobWF0Y2hQYXR0ZXJuKTtcblxuICAgIGlmICghbWF0Y2hSZXN1bHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVkU3RyaW5nID0gbWF0Y2hSZXN1bHRbMF07XG5cbiAgICBjb25zdCBwYXJzZVBhdHRlcm5zID1cbiAgICAgICh3aWR0aCAmJiBhcmdzLnBhcnNlUGF0dGVybnNbd2lkdGhdKSB8fFxuICAgICAgYXJncy5wYXJzZVBhdHRlcm5zW2FyZ3MuZGVmYXVsdFBhcnNlV2lkdGhdO1xuXG4gICAgY29uc3Qga2V5ID0gQXJyYXkuaXNBcnJheShwYXJzZVBhdHRlcm5zKVxuICAgICAgPyBmaW5kSW5kZXgocGFyc2VQYXR0ZXJucywgKHBhdHRlcm4pID0+IHBhdHRlcm4udGVzdChtYXRjaGVkU3RyaW5nKSlcbiAgICAgIDogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgLS0gSSBjaGFsbGFuZ2UgeW91IHRvIGZpeCB0aGUgdHlwZVxuICAgICAgICBmaW5kS2V5KHBhcnNlUGF0dGVybnMsIChwYXR0ZXJuKSA9PiBwYXR0ZXJuLnRlc3QobWF0Y2hlZFN0cmluZykpO1xuXG4gICAgbGV0IHZhbHVlO1xuXG4gICAgdmFsdWUgPSBhcmdzLnZhbHVlQ2FsbGJhY2sgPyBhcmdzLnZhbHVlQ2FsbGJhY2soa2V5KSA6IGtleTtcbiAgICB2YWx1ZSA9IG9wdGlvbnMudmFsdWVDYWxsYmFja1xuICAgICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBJIGNoYWxsYW5nZSB5b3UgdG8gZml4IHRoZSB0eXBlXG4gICAgICAgIG9wdGlvbnMudmFsdWVDYWxsYmFjayh2YWx1ZSlcbiAgICAgIDogdmFsdWU7XG5cbiAgICBjb25zdCByZXN0ID0gc3RyaW5nLnNsaWNlKG1hdGNoZWRTdHJpbmcubGVuZ3RoKTtcblxuICAgIHJldHVybiB7IHZhbHVlLCByZXN0IH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKFxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJlxuICAgICAgcHJlZGljYXRlKG9iamVjdFtrZXldKVxuICAgICkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgZm9yIChsZXQga2V5ID0gMDsga2V5IDwgYXJyYXkubGVuZ3RoOyBrZXkrKykge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlba2V5XSkpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iXSwibmFtZXMiOlsiYnVpbGRNYXRjaEZuIiwiYXJncyIsInN0cmluZyIsIm9wdGlvbnMiLCJ3aWR0aCIsIm1hdGNoUGF0dGVybiIsIm1hdGNoUGF0dGVybnMiLCJkZWZhdWx0TWF0Y2hXaWR0aCIsIm1hdGNoUmVzdWx0IiwibWF0Y2giLCJtYXRjaGVkU3RyaW5nIiwicGFyc2VQYXR0ZXJucyIsImRlZmF1bHRQYXJzZVdpZHRoIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5IiwiZmluZEluZGV4IiwicGF0dGVybiIsInRlc3QiLCJmaW5kS2V5IiwidmFsdWUiLCJ2YWx1ZUNhbGxiYWNrIiwicmVzdCIsInNsaWNlIiwibGVuZ3RoIiwib2JqZWN0IiwicHJlZGljYXRlIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidW5kZWZpbmVkIiwiYXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/locale/_lib/buildMatchFn.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/locale/_lib/buildMatchPatternFn.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/date-fns/locale/_lib/buildMatchPatternFn.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildMatchPatternFn: function() { return /* binding */ buildMatchPatternFn; }\n/* harmony export */ });\nfunction buildMatchPatternFn(args) {\n    return function(string) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const matchResult = string.match(args.matchPattern);\n        if (!matchResult) return null;\n        const matchedString = matchResult[0];\n        const parseResult = string.match(args.parsePattern);\n        if (!parseResult) return null;\n        let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type\n        value = options.valueCallback ? options.valueCallback(value) : value;\n        const rest = string.slice(matchedString.length);\n        return {\n            value,\n            rest\n        };\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9sb2NhbGUvX2xpYi9idWlsZE1hdGNoUGF0dGVybkZuLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sU0FBU0Esb0JBQW9CQyxJQUFJO0lBQ3RDLE9BQU8sU0FBQ0M7WUFBUUMsMkVBQVUsQ0FBQztRQUN6QixNQUFNQyxjQUFjRixPQUFPRyxLQUFLLENBQUNKLEtBQUtLLFlBQVk7UUFDbEQsSUFBSSxDQUFDRixhQUFhLE9BQU87UUFDekIsTUFBTUcsZ0JBQWdCSCxXQUFXLENBQUMsRUFBRTtRQUVwQyxNQUFNSSxjQUFjTixPQUFPRyxLQUFLLENBQUNKLEtBQUtRLFlBQVk7UUFDbEQsSUFBSSxDQUFDRCxhQUFhLE9BQU87UUFDekIsSUFBSUUsUUFBUVQsS0FBS1UsYUFBYSxHQUMxQlYsS0FBS1UsYUFBYSxDQUFDSCxXQUFXLENBQUMsRUFBRSxJQUNqQ0EsV0FBVyxDQUFDLEVBQUU7UUFFbEIsaUdBQWlHO1FBQ2pHRSxRQUFRUCxRQUFRUSxhQUFhLEdBQUdSLFFBQVFRLGFBQWEsQ0FBQ0QsU0FBU0E7UUFFL0QsTUFBTUUsT0FBT1YsT0FBT1csS0FBSyxDQUFDTixjQUFjTyxNQUFNO1FBRTlDLE9BQU87WUFBRUo7WUFBT0U7UUFBSztJQUN2QjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9sb2NhbGUvX2xpYi9idWlsZE1hdGNoUGF0dGVybkZuLm1qcz8zMjJiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBidWlsZE1hdGNoUGF0dGVybkZuKGFyZ3MpIHtcbiAgcmV0dXJuIChzdHJpbmcsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG1hdGNoUmVzdWx0ID0gc3RyaW5nLm1hdGNoKGFyZ3MubWF0Y2hQYXR0ZXJuKTtcbiAgICBpZiAoIW1hdGNoUmVzdWx0KSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBtYXRjaGVkU3RyaW5nID0gbWF0Y2hSZXN1bHRbMF07XG5cbiAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHN0cmluZy5tYXRjaChhcmdzLnBhcnNlUGF0dGVybik7XG4gICAgaWYgKCFwYXJzZVJlc3VsdCkgcmV0dXJuIG51bGw7XG4gICAgbGV0IHZhbHVlID0gYXJncy52YWx1ZUNhbGxiYWNrXG4gICAgICA/IGFyZ3MudmFsdWVDYWxsYmFjayhwYXJzZVJlc3VsdFswXSlcbiAgICAgIDogcGFyc2VSZXN1bHRbMF07XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBJIGNoYWxsYW5nZSB5b3UgdG8gZml4IHRoZSB0eXBlXG4gICAgdmFsdWUgPSBvcHRpb25zLnZhbHVlQ2FsbGJhY2sgPyBvcHRpb25zLnZhbHVlQ2FsbGJhY2sodmFsdWUpIDogdmFsdWU7XG5cbiAgICBjb25zdCByZXN0ID0gc3RyaW5nLnNsaWNlKG1hdGNoZWRTdHJpbmcubGVuZ3RoKTtcblxuICAgIHJldHVybiB7IHZhbHVlLCByZXN0IH07XG4gIH07XG59XG4iXSwibmFtZXMiOlsiYnVpbGRNYXRjaFBhdHRlcm5GbiIsImFyZ3MiLCJzdHJpbmciLCJvcHRpb25zIiwibWF0Y2hSZXN1bHQiLCJtYXRjaCIsIm1hdGNoUGF0dGVybiIsIm1hdGNoZWRTdHJpbmciLCJwYXJzZVJlc3VsdCIsInBhcnNlUGF0dGVybiIsInZhbHVlIiwidmFsdWVDYWxsYmFjayIsInJlc3QiLCJzbGljZSIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/locale/_lib/buildMatchPatternFn.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/locale/en-US.mjs":
/*!************************************************!*\
  !*** ./node_modules/date-fns/locale/en-US.mjs ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   enUS: function() { return /* binding */ enUS; }\n/* harmony export */ });\n/* harmony import */ var _en_US_lib_formatDistance_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./en-US/_lib/formatDistance.mjs */ \"(app-pages-browser)/./node_modules/date-fns/locale/en-US/_lib/formatDistance.mjs\");\n/* harmony import */ var _en_US_lib_formatLong_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./en-US/_lib/formatLong.mjs */ \"(app-pages-browser)/./node_modules/date-fns/locale/en-US/_lib/formatLong.mjs\");\n/* harmony import */ var _en_US_lib_formatRelative_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./en-US/_lib/formatRelative.mjs */ \"(app-pages-browser)/./node_modules/date-fns/locale/en-US/_lib/formatRelative.mjs\");\n/* harmony import */ var _en_US_lib_localize_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./en-US/_lib/localize.mjs */ \"(app-pages-browser)/./node_modules/date-fns/locale/en-US/_lib/localize.mjs\");\n/* harmony import */ var _en_US_lib_match_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./en-US/_lib/match.mjs */ \"(app-pages-browser)/./node_modules/date-fns/locale/en-US/_lib/match.mjs\");\n\n\n\n\n\n/**\n * @category Locales\n * @summary English locale (United States).\n * @language English\n * @iso-639-2 eng\n * @author Sasha Koss [@kossnocorp](https://github.com/kossnocorp)\n * @author Lesha Koss [@leshakoss](https://github.com/leshakoss)\n */ const enUS = {\n    code: \"en-US\",\n    formatDistance: _en_US_lib_formatDistance_mjs__WEBPACK_IMPORTED_MODULE_0__.formatDistance,\n    formatLong: _en_US_lib_formatLong_mjs__WEBPACK_IMPORTED_MODULE_1__.formatLong,\n    formatRelative: _en_US_lib_formatRelative_mjs__WEBPACK_IMPORTED_MODULE_2__.formatRelative,\n    localize: _en_US_lib_localize_mjs__WEBPACK_IMPORTED_MODULE_3__.localize,\n    match: _en_US_lib_match_mjs__WEBPACK_IMPORTED_MODULE_4__.match,\n    options: {\n        weekStartsOn: 0 /* Sunday */ ,\n        firstWeekContainsDate: 1\n    }\n};\n// Fallback for modularized imports:\n/* harmony default export */ __webpack_exports__[\"default\"] = (enUS);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9sb2NhbGUvZW4tVVMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFpRTtBQUNSO0FBQ1E7QUFDWjtBQUNOO0FBRS9DOzs7Ozs7O0NBT0MsR0FDTSxNQUFNSyxPQUFPO0lBQ2xCQyxNQUFNO0lBQ05OLGdCQUFnQkEseUVBQWNBO0lBQzlCQyxZQUFZQSxpRUFBVUE7SUFDdEJDLGdCQUFnQkEseUVBQWNBO0lBQzlCQyxVQUFVQSw2REFBUUE7SUFDbEJDLE9BQU9BLHVEQUFLQTtJQUNaRyxTQUFTO1FBQ1BDLGNBQWMsRUFBRSxVQUFVO1FBQzFCQyx1QkFBdUI7SUFDekI7QUFDRixFQUFFO0FBRUYsb0NBQW9DO0FBQ3BDLCtEQUFlSixJQUFJQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9sb2NhbGUvZW4tVVMubWpzPzU5ZWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0RGlzdGFuY2UgfSBmcm9tIFwiLi9lbi1VUy9fbGliL2Zvcm1hdERpc3RhbmNlLm1qc1wiO1xuaW1wb3J0IHsgZm9ybWF0TG9uZyB9IGZyb20gXCIuL2VuLVVTL19saWIvZm9ybWF0TG9uZy5tanNcIjtcbmltcG9ydCB7IGZvcm1hdFJlbGF0aXZlIH0gZnJvbSBcIi4vZW4tVVMvX2xpYi9mb3JtYXRSZWxhdGl2ZS5tanNcIjtcbmltcG9ydCB7IGxvY2FsaXplIH0gZnJvbSBcIi4vZW4tVVMvX2xpYi9sb2NhbGl6ZS5tanNcIjtcbmltcG9ydCB7IG1hdGNoIH0gZnJvbSBcIi4vZW4tVVMvX2xpYi9tYXRjaC5tanNcIjtcblxuLyoqXG4gKiBAY2F0ZWdvcnkgTG9jYWxlc1xuICogQHN1bW1hcnkgRW5nbGlzaCBsb2NhbGUgKFVuaXRlZCBTdGF0ZXMpLlxuICogQGxhbmd1YWdlIEVuZ2xpc2hcbiAqIEBpc28tNjM5LTIgZW5nXG4gKiBAYXV0aG9yIFNhc2hhIEtvc3MgW0Brb3Nzbm9jb3JwXShodHRwczovL2dpdGh1Yi5jb20va29zc25vY29ycClcbiAqIEBhdXRob3IgTGVzaGEgS29zcyBbQGxlc2hha29zc10oaHR0cHM6Ly9naXRodWIuY29tL2xlc2hha29zcylcbiAqL1xuZXhwb3J0IGNvbnN0IGVuVVMgPSB7XG4gIGNvZGU6IFwiZW4tVVNcIixcbiAgZm9ybWF0RGlzdGFuY2U6IGZvcm1hdERpc3RhbmNlLFxuICBmb3JtYXRMb25nOiBmb3JtYXRMb25nLFxuICBmb3JtYXRSZWxhdGl2ZTogZm9ybWF0UmVsYXRpdmUsXG4gIGxvY2FsaXplOiBsb2NhbGl6ZSxcbiAgbWF0Y2g6IG1hdGNoLFxuICBvcHRpb25zOiB7XG4gICAgd2Vla1N0YXJ0c09uOiAwIC8qIFN1bmRheSAqLyxcbiAgICBmaXJzdFdlZWtDb250YWluc0RhdGU6IDEsXG4gIH0sXG59O1xuXG4vLyBGYWxsYmFjayBmb3IgbW9kdWxhcml6ZWQgaW1wb3J0czpcbmV4cG9ydCBkZWZhdWx0IGVuVVM7XG4iXSwibmFtZXMiOlsiZm9ybWF0RGlzdGFuY2UiLCJmb3JtYXRMb25nIiwiZm9ybWF0UmVsYXRpdmUiLCJsb2NhbGl6ZSIsIm1hdGNoIiwiZW5VUyIsImNvZGUiLCJvcHRpb25zIiwid2Vla1N0YXJ0c09uIiwiZmlyc3RXZWVrQ29udGFpbnNEYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/locale/en-US.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/locale/en-US/_lib/formatDistance.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/date-fns/locale/en-US/_lib/formatDistance.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatDistance: function() { return /* binding */ formatDistance; }\n/* harmony export */ });\nconst formatDistanceLocale = {\n    lessThanXSeconds: {\n        one: \"less than a second\",\n        other: \"less than {{count}} seconds\"\n    },\n    xSeconds: {\n        one: \"1 second\",\n        other: \"{{count}} seconds\"\n    },\n    halfAMinute: \"half a minute\",\n    lessThanXMinutes: {\n        one: \"less than a minute\",\n        other: \"less than {{count}} minutes\"\n    },\n    xMinutes: {\n        one: \"1 minute\",\n        other: \"{{count}} minutes\"\n    },\n    aboutXHours: {\n        one: \"about 1 hour\",\n        other: \"about {{count}} hours\"\n    },\n    xHours: {\n        one: \"1 hour\",\n        other: \"{{count}} hours\"\n    },\n    xDays: {\n        one: \"1 day\",\n        other: \"{{count}} days\"\n    },\n    aboutXWeeks: {\n        one: \"about 1 week\",\n        other: \"about {{count}} weeks\"\n    },\n    xWeeks: {\n        one: \"1 week\",\n        other: \"{{count}} weeks\"\n    },\n    aboutXMonths: {\n        one: \"about 1 month\",\n        other: \"about {{count}} months\"\n    },\n    xMonths: {\n        one: \"1 month\",\n        other: \"{{count}} months\"\n    },\n    aboutXYears: {\n        one: \"about 1 year\",\n        other: \"about {{count}} years\"\n    },\n    xYears: {\n        one: \"1 year\",\n        other: \"{{count}} years\"\n    },\n    overXYears: {\n        one: \"over 1 year\",\n        other: \"over {{count}} years\"\n    },\n    almostXYears: {\n        one: \"almost 1 year\",\n        other: \"almost {{count}} years\"\n    }\n};\nconst formatDistance = (token, count, options)=>{\n    let result;\n    const tokenValue = formatDistanceLocale[token];\n    if (typeof tokenValue === \"string\") {\n        result = tokenValue;\n    } else if (count === 1) {\n        result = tokenValue.one;\n    } else {\n        result = tokenValue.other.replace(\"{{count}}\", count.toString());\n    }\n    if (options === null || options === void 0 ? void 0 : options.addSuffix) {\n        if (options.comparison && options.comparison > 0) {\n            return \"in \" + result;\n        } else {\n            return result + \" ago\";\n        }\n    }\n    return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9sb2NhbGUvZW4tVVMvX2xpYi9mb3JtYXREaXN0YW5jZS5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLHVCQUF1QjtJQUMzQkMsa0JBQWtCO1FBQ2hCQyxLQUFLO1FBQ0xDLE9BQU87SUFDVDtJQUVBQyxVQUFVO1FBQ1JGLEtBQUs7UUFDTEMsT0FBTztJQUNUO0lBRUFFLGFBQWE7SUFFYkMsa0JBQWtCO1FBQ2hCSixLQUFLO1FBQ0xDLE9BQU87SUFDVDtJQUVBSSxVQUFVO1FBQ1JMLEtBQUs7UUFDTEMsT0FBTztJQUNUO0lBRUFLLGFBQWE7UUFDWE4sS0FBSztRQUNMQyxPQUFPO0lBQ1Q7SUFFQU0sUUFBUTtRQUNOUCxLQUFLO1FBQ0xDLE9BQU87SUFDVDtJQUVBTyxPQUFPO1FBQ0xSLEtBQUs7UUFDTEMsT0FBTztJQUNUO0lBRUFRLGFBQWE7UUFDWFQsS0FBSztRQUNMQyxPQUFPO0lBQ1Q7SUFFQVMsUUFBUTtRQUNOVixLQUFLO1FBQ0xDLE9BQU87SUFDVDtJQUVBVSxjQUFjO1FBQ1pYLEtBQUs7UUFDTEMsT0FBTztJQUNUO0lBRUFXLFNBQVM7UUFDUFosS0FBSztRQUNMQyxPQUFPO0lBQ1Q7SUFFQVksYUFBYTtRQUNYYixLQUFLO1FBQ0xDLE9BQU87SUFDVDtJQUVBYSxRQUFRO1FBQ05kLEtBQUs7UUFDTEMsT0FBTztJQUNUO0lBRUFjLFlBQVk7UUFDVmYsS0FBSztRQUNMQyxPQUFPO0lBQ1Q7SUFFQWUsY0FBYztRQUNaaEIsS0FBSztRQUNMQyxPQUFPO0lBQ1Q7QUFDRjtBQUVPLE1BQU1nQixpQkFBaUIsQ0FBQ0MsT0FBT0MsT0FBT0M7SUFDM0MsSUFBSUM7SUFFSixNQUFNQyxhQUFheEIsb0JBQW9CLENBQUNvQixNQUFNO0lBQzlDLElBQUksT0FBT0ksZUFBZSxVQUFVO1FBQ2xDRCxTQUFTQztJQUNYLE9BQU8sSUFBSUgsVUFBVSxHQUFHO1FBQ3RCRSxTQUFTQyxXQUFXdEIsR0FBRztJQUN6QixPQUFPO1FBQ0xxQixTQUFTQyxXQUFXckIsS0FBSyxDQUFDc0IsT0FBTyxDQUFDLGFBQWFKLE1BQU1LLFFBQVE7SUFDL0Q7SUFFQSxJQUFJSixvQkFBQUEsOEJBQUFBLFFBQVNLLFNBQVMsRUFBRTtRQUN0QixJQUFJTCxRQUFRTSxVQUFVLElBQUlOLFFBQVFNLFVBQVUsR0FBRyxHQUFHO1lBQ2hELE9BQU8sUUFBUUw7UUFDakIsT0FBTztZQUNMLE9BQU9BLFNBQVM7UUFDbEI7SUFDRjtJQUVBLE9BQU9BO0FBQ1QsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbG9jYWxlL2VuLVVTL19saWIvZm9ybWF0RGlzdGFuY2UubWpzPzJkMWMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZm9ybWF0RGlzdGFuY2VMb2NhbGUgPSB7XG4gIGxlc3NUaGFuWFNlY29uZHM6IHtcbiAgICBvbmU6IFwibGVzcyB0aGFuIGEgc2Vjb25kXCIsXG4gICAgb3RoZXI6IFwibGVzcyB0aGFuIHt7Y291bnR9fSBzZWNvbmRzXCIsXG4gIH0sXG5cbiAgeFNlY29uZHM6IHtcbiAgICBvbmU6IFwiMSBzZWNvbmRcIixcbiAgICBvdGhlcjogXCJ7e2NvdW50fX0gc2Vjb25kc1wiLFxuICB9LFxuXG4gIGhhbGZBTWludXRlOiBcImhhbGYgYSBtaW51dGVcIixcblxuICBsZXNzVGhhblhNaW51dGVzOiB7XG4gICAgb25lOiBcImxlc3MgdGhhbiBhIG1pbnV0ZVwiLFxuICAgIG90aGVyOiBcImxlc3MgdGhhbiB7e2NvdW50fX0gbWludXRlc1wiLFxuICB9LFxuXG4gIHhNaW51dGVzOiB7XG4gICAgb25lOiBcIjEgbWludXRlXCIsXG4gICAgb3RoZXI6IFwie3tjb3VudH19IG1pbnV0ZXNcIixcbiAgfSxcblxuICBhYm91dFhIb3Vyczoge1xuICAgIG9uZTogXCJhYm91dCAxIGhvdXJcIixcbiAgICBvdGhlcjogXCJhYm91dCB7e2NvdW50fX0gaG91cnNcIixcbiAgfSxcblxuICB4SG91cnM6IHtcbiAgICBvbmU6IFwiMSBob3VyXCIsXG4gICAgb3RoZXI6IFwie3tjb3VudH19IGhvdXJzXCIsXG4gIH0sXG5cbiAgeERheXM6IHtcbiAgICBvbmU6IFwiMSBkYXlcIixcbiAgICBvdGhlcjogXCJ7e2NvdW50fX0gZGF5c1wiLFxuICB9LFxuXG4gIGFib3V0WFdlZWtzOiB7XG4gICAgb25lOiBcImFib3V0IDEgd2Vla1wiLFxuICAgIG90aGVyOiBcImFib3V0IHt7Y291bnR9fSB3ZWVrc1wiLFxuICB9LFxuXG4gIHhXZWVrczoge1xuICAgIG9uZTogXCIxIHdlZWtcIixcbiAgICBvdGhlcjogXCJ7e2NvdW50fX0gd2Vla3NcIixcbiAgfSxcblxuICBhYm91dFhNb250aHM6IHtcbiAgICBvbmU6IFwiYWJvdXQgMSBtb250aFwiLFxuICAgIG90aGVyOiBcImFib3V0IHt7Y291bnR9fSBtb250aHNcIixcbiAgfSxcblxuICB4TW9udGhzOiB7XG4gICAgb25lOiBcIjEgbW9udGhcIixcbiAgICBvdGhlcjogXCJ7e2NvdW50fX0gbW9udGhzXCIsXG4gIH0sXG5cbiAgYWJvdXRYWWVhcnM6IHtcbiAgICBvbmU6IFwiYWJvdXQgMSB5ZWFyXCIsXG4gICAgb3RoZXI6IFwiYWJvdXQge3tjb3VudH19IHllYXJzXCIsXG4gIH0sXG5cbiAgeFllYXJzOiB7XG4gICAgb25lOiBcIjEgeWVhclwiLFxuICAgIG90aGVyOiBcInt7Y291bnR9fSB5ZWFyc1wiLFxuICB9LFxuXG4gIG92ZXJYWWVhcnM6IHtcbiAgICBvbmU6IFwib3ZlciAxIHllYXJcIixcbiAgICBvdGhlcjogXCJvdmVyIHt7Y291bnR9fSB5ZWFyc1wiLFxuICB9LFxuXG4gIGFsbW9zdFhZZWFyczoge1xuICAgIG9uZTogXCJhbG1vc3QgMSB5ZWFyXCIsXG4gICAgb3RoZXI6IFwiYWxtb3N0IHt7Y291bnR9fSB5ZWFyc1wiLFxuICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IGZvcm1hdERpc3RhbmNlID0gKHRva2VuLCBjb3VudCwgb3B0aW9ucykgPT4ge1xuICBsZXQgcmVzdWx0O1xuXG4gIGNvbnN0IHRva2VuVmFsdWUgPSBmb3JtYXREaXN0YW5jZUxvY2FsZVt0b2tlbl07XG4gIGlmICh0eXBlb2YgdG9rZW5WYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJlc3VsdCA9IHRva2VuVmFsdWU7XG4gIH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICByZXN1bHQgPSB0b2tlblZhbHVlLm9uZTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB0b2tlblZhbHVlLm90aGVyLnJlcGxhY2UoXCJ7e2NvdW50fX1cIiwgY291bnQudG9TdHJpbmcoKSk7XG4gIH1cblxuICBpZiAob3B0aW9ucz8uYWRkU3VmZml4KSB7XG4gICAgaWYgKG9wdGlvbnMuY29tcGFyaXNvbiAmJiBvcHRpb25zLmNvbXBhcmlzb24gPiAwKSB7XG4gICAgICByZXR1cm4gXCJpbiBcIiArIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIFwiIGFnb1wiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuIl0sIm5hbWVzIjpbImZvcm1hdERpc3RhbmNlTG9jYWxlIiwibGVzc1RoYW5YU2Vjb25kcyIsIm9uZSIsIm90aGVyIiwieFNlY29uZHMiLCJoYWxmQU1pbnV0ZSIsImxlc3NUaGFuWE1pbnV0ZXMiLCJ4TWludXRlcyIsImFib3V0WEhvdXJzIiwieEhvdXJzIiwieERheXMiLCJhYm91dFhXZWVrcyIsInhXZWVrcyIsImFib3V0WE1vbnRocyIsInhNb250aHMiLCJhYm91dFhZZWFycyIsInhZZWFycyIsIm92ZXJYWWVhcnMiLCJhbG1vc3RYWWVhcnMiLCJmb3JtYXREaXN0YW5jZSIsInRva2VuIiwiY291bnQiLCJvcHRpb25zIiwicmVzdWx0IiwidG9rZW5WYWx1ZSIsInJlcGxhY2UiLCJ0b1N0cmluZyIsImFkZFN1ZmZpeCIsImNvbXBhcmlzb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/locale/en-US/_lib/formatDistance.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/locale/en-US/_lib/formatLong.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/date-fns/locale/en-US/_lib/formatLong.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatLong: function() { return /* binding */ formatLong; }\n/* harmony export */ });\n/* harmony import */ var _lib_buildFormatLongFn_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_lib/buildFormatLongFn.mjs */ \"(app-pages-browser)/./node_modules/date-fns/locale/_lib/buildFormatLongFn.mjs\");\n\nconst dateFormats = {\n    full: \"EEEE, MMMM do, y\",\n    long: \"MMMM do, y\",\n    medium: \"MMM d, y\",\n    short: \"MM/dd/yyyy\"\n};\nconst timeFormats = {\n    full: \"h:mm:ss a zzzz\",\n    long: \"h:mm:ss a z\",\n    medium: \"h:mm:ss a\",\n    short: \"h:mm a\"\n};\nconst dateTimeFormats = {\n    full: \"{{date}} 'at' {{time}}\",\n    long: \"{{date}} 'at' {{time}}\",\n    medium: \"{{date}}, {{time}}\",\n    short: \"{{date}}, {{time}}\"\n};\nconst formatLong = {\n    date: (0,_lib_buildFormatLongFn_mjs__WEBPACK_IMPORTED_MODULE_0__.buildFormatLongFn)({\n        formats: dateFormats,\n        defaultWidth: \"full\"\n    }),\n    time: (0,_lib_buildFormatLongFn_mjs__WEBPACK_IMPORTED_MODULE_0__.buildFormatLongFn)({\n        formats: timeFormats,\n        defaultWidth: \"full\"\n    }),\n    dateTime: (0,_lib_buildFormatLongFn_mjs__WEBPACK_IMPORTED_MODULE_0__.buildFormatLongFn)({\n        formats: dateTimeFormats,\n        defaultWidth: \"full\"\n    })\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9sb2NhbGUvZW4tVVMvX2xpYi9mb3JtYXRMb25nLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxRTtBQUVyRSxNQUFNQyxjQUFjO0lBQ2xCQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxPQUFPO0FBQ1Q7QUFFQSxNQUFNQyxjQUFjO0lBQ2xCSixNQUFNO0lBQ05DLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxPQUFPO0FBQ1Q7QUFFQSxNQUFNRSxrQkFBa0I7SUFDdEJMLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLE9BQU87QUFDVDtBQUVPLE1BQU1HLGFBQWE7SUFDeEJDLE1BQU1ULDZFQUFpQkEsQ0FBQztRQUN0QlUsU0FBU1Q7UUFDVFUsY0FBYztJQUNoQjtJQUVBQyxNQUFNWiw2RUFBaUJBLENBQUM7UUFDdEJVLFNBQVNKO1FBQ1RLLGNBQWM7SUFDaEI7SUFFQUUsVUFBVWIsNkVBQWlCQSxDQUFDO1FBQzFCVSxTQUFTSDtRQUNUSSxjQUFjO0lBQ2hCO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbG9jYWxlL2VuLVVTL19saWIvZm9ybWF0TG9uZy5tanM/ZmE2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBidWlsZEZvcm1hdExvbmdGbiB9IGZyb20gXCIuLi8uLi9fbGliL2J1aWxkRm9ybWF0TG9uZ0ZuLm1qc1wiO1xuXG5jb25zdCBkYXRlRm9ybWF0cyA9IHtcbiAgZnVsbDogXCJFRUVFLCBNTU1NIGRvLCB5XCIsXG4gIGxvbmc6IFwiTU1NTSBkbywgeVwiLFxuICBtZWRpdW06IFwiTU1NIGQsIHlcIixcbiAgc2hvcnQ6IFwiTU0vZGQveXl5eVwiLFxufTtcblxuY29uc3QgdGltZUZvcm1hdHMgPSB7XG4gIGZ1bGw6IFwiaDptbTpzcyBhIHp6enpcIixcbiAgbG9uZzogXCJoOm1tOnNzIGEgelwiLFxuICBtZWRpdW06IFwiaDptbTpzcyBhXCIsXG4gIHNob3J0OiBcImg6bW0gYVwiLFxufTtcblxuY29uc3QgZGF0ZVRpbWVGb3JtYXRzID0ge1xuICBmdWxsOiBcInt7ZGF0ZX19ICdhdCcge3t0aW1lfX1cIixcbiAgbG9uZzogXCJ7e2RhdGV9fSAnYXQnIHt7dGltZX19XCIsXG4gIG1lZGl1bTogXCJ7e2RhdGV9fSwge3t0aW1lfX1cIixcbiAgc2hvcnQ6IFwie3tkYXRlfX0sIHt7dGltZX19XCIsXG59O1xuXG5leHBvcnQgY29uc3QgZm9ybWF0TG9uZyA9IHtcbiAgZGF0ZTogYnVpbGRGb3JtYXRMb25nRm4oe1xuICAgIGZvcm1hdHM6IGRhdGVGb3JtYXRzLFxuICAgIGRlZmF1bHRXaWR0aDogXCJmdWxsXCIsXG4gIH0pLFxuXG4gIHRpbWU6IGJ1aWxkRm9ybWF0TG9uZ0ZuKHtcbiAgICBmb3JtYXRzOiB0aW1lRm9ybWF0cyxcbiAgICBkZWZhdWx0V2lkdGg6IFwiZnVsbFwiLFxuICB9KSxcblxuICBkYXRlVGltZTogYnVpbGRGb3JtYXRMb25nRm4oe1xuICAgIGZvcm1hdHM6IGRhdGVUaW1lRm9ybWF0cyxcbiAgICBkZWZhdWx0V2lkdGg6IFwiZnVsbFwiLFxuICB9KSxcbn07XG4iXSwibmFtZXMiOlsiYnVpbGRGb3JtYXRMb25nRm4iLCJkYXRlRm9ybWF0cyIsImZ1bGwiLCJsb25nIiwibWVkaXVtIiwic2hvcnQiLCJ0aW1lRm9ybWF0cyIsImRhdGVUaW1lRm9ybWF0cyIsImZvcm1hdExvbmciLCJkYXRlIiwiZm9ybWF0cyIsImRlZmF1bHRXaWR0aCIsInRpbWUiLCJkYXRlVGltZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/locale/en-US/_lib/formatLong.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/locale/en-US/_lib/formatRelative.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/date-fns/locale/en-US/_lib/formatRelative.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatRelative: function() { return /* binding */ formatRelative; }\n/* harmony export */ });\nconst formatRelativeLocale = {\n    lastWeek: \"'last' eeee 'at' p\",\n    yesterday: \"'yesterday at' p\",\n    today: \"'today at' p\",\n    tomorrow: \"'tomorrow at' p\",\n    nextWeek: \"eeee 'at' p\",\n    other: \"P\"\n};\nconst formatRelative = (token, _date, _baseDate, _options)=>formatRelativeLocale[token];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9sb2NhbGUvZW4tVVMvX2xpYi9mb3JtYXRSZWxhdGl2ZS5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLHVCQUF1QjtJQUMzQkMsVUFBVTtJQUNWQyxXQUFXO0lBQ1hDLE9BQU87SUFDUEMsVUFBVTtJQUNWQyxVQUFVO0lBQ1ZDLE9BQU87QUFDVDtBQUVPLE1BQU1DLGlCQUFpQixDQUFDQyxPQUFPQyxPQUFPQyxXQUFXQyxXQUN0RFgsb0JBQW9CLENBQUNRLE1BQU0sQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbG9jYWxlL2VuLVVTL19saWIvZm9ybWF0UmVsYXRpdmUubWpzP2NhNGQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZm9ybWF0UmVsYXRpdmVMb2NhbGUgPSB7XG4gIGxhc3RXZWVrOiBcIidsYXN0JyBlZWVlICdhdCcgcFwiLFxuICB5ZXN0ZXJkYXk6IFwiJ3llc3RlcmRheSBhdCcgcFwiLFxuICB0b2RheTogXCIndG9kYXkgYXQnIHBcIixcbiAgdG9tb3Jyb3c6IFwiJ3RvbW9ycm93IGF0JyBwXCIsXG4gIG5leHRXZWVrOiBcImVlZWUgJ2F0JyBwXCIsXG4gIG90aGVyOiBcIlBcIixcbn07XG5cbmV4cG9ydCBjb25zdCBmb3JtYXRSZWxhdGl2ZSA9ICh0b2tlbiwgX2RhdGUsIF9iYXNlRGF0ZSwgX29wdGlvbnMpID0+XG4gIGZvcm1hdFJlbGF0aXZlTG9jYWxlW3Rva2VuXTtcbiJdLCJuYW1lcyI6WyJmb3JtYXRSZWxhdGl2ZUxvY2FsZSIsImxhc3RXZWVrIiwieWVzdGVyZGF5IiwidG9kYXkiLCJ0b21vcnJvdyIsIm5leHRXZWVrIiwib3RoZXIiLCJmb3JtYXRSZWxhdGl2ZSIsInRva2VuIiwiX2RhdGUiLCJfYmFzZURhdGUiLCJfb3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/locale/en-US/_lib/formatRelative.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/locale/en-US/_lib/localize.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/date-fns/locale/en-US/_lib/localize.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   localize: function() { return /* binding */ localize; }\n/* harmony export */ });\n/* harmony import */ var _lib_buildLocalizeFn_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_lib/buildLocalizeFn.mjs */ \"(app-pages-browser)/./node_modules/date-fns/locale/_lib/buildLocalizeFn.mjs\");\n\nconst eraValues = {\n    narrow: [\n        \"B\",\n        \"A\"\n    ],\n    abbreviated: [\n        \"BC\",\n        \"AD\"\n    ],\n    wide: [\n        \"Before Christ\",\n        \"Anno Domini\"\n    ]\n};\nconst quarterValues = {\n    narrow: [\n        \"1\",\n        \"2\",\n        \"3\",\n        \"4\"\n    ],\n    abbreviated: [\n        \"Q1\",\n        \"Q2\",\n        \"Q3\",\n        \"Q4\"\n    ],\n    wide: [\n        \"1st quarter\",\n        \"2nd quarter\",\n        \"3rd quarter\",\n        \"4th quarter\"\n    ]\n};\n// Note: in English, the names of days of the week and months are capitalized.\n// If you are making a new locale based on this one, check if the same is true for the language you're working on.\n// Generally, formatted dates should look like they are in the middle of a sentence,\n// e.g. in Spanish language the weekdays and months should be in the lowercase.\nconst monthValues = {\n    narrow: [\n        \"J\",\n        \"F\",\n        \"M\",\n        \"A\",\n        \"M\",\n        \"J\",\n        \"J\",\n        \"A\",\n        \"S\",\n        \"O\",\n        \"N\",\n        \"D\"\n    ],\n    abbreviated: [\n        \"Jan\",\n        \"Feb\",\n        \"Mar\",\n        \"Apr\",\n        \"May\",\n        \"Jun\",\n        \"Jul\",\n        \"Aug\",\n        \"Sep\",\n        \"Oct\",\n        \"Nov\",\n        \"Dec\"\n    ],\n    wide: [\n        \"January\",\n        \"February\",\n        \"March\",\n        \"April\",\n        \"May\",\n        \"June\",\n        \"July\",\n        \"August\",\n        \"September\",\n        \"October\",\n        \"November\",\n        \"December\"\n    ]\n};\nconst dayValues = {\n    narrow: [\n        \"S\",\n        \"M\",\n        \"T\",\n        \"W\",\n        \"T\",\n        \"F\",\n        \"S\"\n    ],\n    short: [\n        \"Su\",\n        \"Mo\",\n        \"Tu\",\n        \"We\",\n        \"Th\",\n        \"Fr\",\n        \"Sa\"\n    ],\n    abbreviated: [\n        \"Sun\",\n        \"Mon\",\n        \"Tue\",\n        \"Wed\",\n        \"Thu\",\n        \"Fri\",\n        \"Sat\"\n    ],\n    wide: [\n        \"Sunday\",\n        \"Monday\",\n        \"Tuesday\",\n        \"Wednesday\",\n        \"Thursday\",\n        \"Friday\",\n        \"Saturday\"\n    ]\n};\nconst dayPeriodValues = {\n    narrow: {\n        am: \"a\",\n        pm: \"p\",\n        midnight: \"mi\",\n        noon: \"n\",\n        morning: \"morning\",\n        afternoon: \"afternoon\",\n        evening: \"evening\",\n        night: \"night\"\n    },\n    abbreviated: {\n        am: \"AM\",\n        pm: \"PM\",\n        midnight: \"midnight\",\n        noon: \"noon\",\n        morning: \"morning\",\n        afternoon: \"afternoon\",\n        evening: \"evening\",\n        night: \"night\"\n    },\n    wide: {\n        am: \"a.m.\",\n        pm: \"p.m.\",\n        midnight: \"midnight\",\n        noon: \"noon\",\n        morning: \"morning\",\n        afternoon: \"afternoon\",\n        evening: \"evening\",\n        night: \"night\"\n    }\n};\nconst formattingDayPeriodValues = {\n    narrow: {\n        am: \"a\",\n        pm: \"p\",\n        midnight: \"mi\",\n        noon: \"n\",\n        morning: \"in the morning\",\n        afternoon: \"in the afternoon\",\n        evening: \"in the evening\",\n        night: \"at night\"\n    },\n    abbreviated: {\n        am: \"AM\",\n        pm: \"PM\",\n        midnight: \"midnight\",\n        noon: \"noon\",\n        morning: \"in the morning\",\n        afternoon: \"in the afternoon\",\n        evening: \"in the evening\",\n        night: \"at night\"\n    },\n    wide: {\n        am: \"a.m.\",\n        pm: \"p.m.\",\n        midnight: \"midnight\",\n        noon: \"noon\",\n        morning: \"in the morning\",\n        afternoon: \"in the afternoon\",\n        evening: \"in the evening\",\n        night: \"at night\"\n    }\n};\nconst ordinalNumber = (dirtyNumber, _options)=>{\n    const number = Number(dirtyNumber);\n    // If ordinal numbers depend on context, for example,\n    // if they are different for different grammatical genders,\n    // use `options.unit`.\n    //\n    // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',\n    // 'day', 'hour', 'minute', 'second'.\n    const rem100 = number % 100;\n    if (rem100 > 20 || rem100 < 10) {\n        switch(rem100 % 10){\n            case 1:\n                return number + \"st\";\n            case 2:\n                return number + \"nd\";\n            case 3:\n                return number + \"rd\";\n        }\n    }\n    return number + \"th\";\n};\nconst localize = {\n    ordinalNumber,\n    era: (0,_lib_buildLocalizeFn_mjs__WEBPACK_IMPORTED_MODULE_0__.buildLocalizeFn)({\n        values: eraValues,\n        defaultWidth: \"wide\"\n    }),\n    quarter: (0,_lib_buildLocalizeFn_mjs__WEBPACK_IMPORTED_MODULE_0__.buildLocalizeFn)({\n        values: quarterValues,\n        defaultWidth: \"wide\",\n        argumentCallback: (quarter)=>quarter - 1\n    }),\n    month: (0,_lib_buildLocalizeFn_mjs__WEBPACK_IMPORTED_MODULE_0__.buildLocalizeFn)({\n        values: monthValues,\n        defaultWidth: \"wide\"\n    }),\n    day: (0,_lib_buildLocalizeFn_mjs__WEBPACK_IMPORTED_MODULE_0__.buildLocalizeFn)({\n        values: dayValues,\n        defaultWidth: \"wide\"\n    }),\n    dayPeriod: (0,_lib_buildLocalizeFn_mjs__WEBPACK_IMPORTED_MODULE_0__.buildLocalizeFn)({\n        values: dayPeriodValues,\n        defaultWidth: \"wide\",\n        formattingValues: formattingDayPeriodValues,\n        defaultFormattingWidth: \"wide\"\n    })\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9sb2NhbGUvZW4tVVMvX2xpYi9sb2NhbGl6ZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUU7QUFFakUsTUFBTUMsWUFBWTtJQUNoQkMsUUFBUTtRQUFDO1FBQUs7S0FBSTtJQUNsQkMsYUFBYTtRQUFDO1FBQU07S0FBSztJQUN6QkMsTUFBTTtRQUFDO1FBQWlCO0tBQWM7QUFDeEM7QUFFQSxNQUFNQyxnQkFBZ0I7SUFDcEJILFFBQVE7UUFBQztRQUFLO1FBQUs7UUFBSztLQUFJO0lBQzVCQyxhQUFhO1FBQUM7UUFBTTtRQUFNO1FBQU07S0FBSztJQUNyQ0MsTUFBTTtRQUFDO1FBQWU7UUFBZTtRQUFlO0tBQWM7QUFDcEU7QUFFQSw4RUFBOEU7QUFDOUUsa0hBQWtIO0FBQ2xILG9GQUFvRjtBQUNwRiwrRUFBK0U7QUFDL0UsTUFBTUUsY0FBYztJQUNsQkosUUFBUTtRQUFDO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBSztLQUFJO0lBQ3BFQyxhQUFhO1FBQ1g7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFFREMsTUFBTTtRQUNKO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0FBQ0g7QUFFQSxNQUFNRyxZQUFZO0lBQ2hCTCxRQUFRO1FBQUM7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFLO1FBQUs7S0FBSTtJQUMzQ00sT0FBTztRQUFDO1FBQU07UUFBTTtRQUFNO1FBQU07UUFBTTtRQUFNO0tBQUs7SUFDakRMLGFBQWE7UUFBQztRQUFPO1FBQU87UUFBTztRQUFPO1FBQU87UUFBTztLQUFNO0lBQzlEQyxNQUFNO1FBQ0o7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDRDtBQUNIO0FBRUEsTUFBTUssa0JBQWtCO0lBQ3RCUCxRQUFRO1FBQ05RLElBQUk7UUFDSkMsSUFBSTtRQUNKQyxVQUFVO1FBQ1ZDLE1BQU07UUFDTkMsU0FBUztRQUNUQyxXQUFXO1FBQ1hDLFNBQVM7UUFDVEMsT0FBTztJQUNUO0lBQ0FkLGFBQWE7UUFDWE8sSUFBSTtRQUNKQyxJQUFJO1FBQ0pDLFVBQVU7UUFDVkMsTUFBTTtRQUNOQyxTQUFTO1FBQ1RDLFdBQVc7UUFDWEMsU0FBUztRQUNUQyxPQUFPO0lBQ1Q7SUFDQWIsTUFBTTtRQUNKTSxJQUFJO1FBQ0pDLElBQUk7UUFDSkMsVUFBVTtRQUNWQyxNQUFNO1FBQ05DLFNBQVM7UUFDVEMsV0FBVztRQUNYQyxTQUFTO1FBQ1RDLE9BQU87SUFDVDtBQUNGO0FBRUEsTUFBTUMsNEJBQTRCO0lBQ2hDaEIsUUFBUTtRQUNOUSxJQUFJO1FBQ0pDLElBQUk7UUFDSkMsVUFBVTtRQUNWQyxNQUFNO1FBQ05DLFNBQVM7UUFDVEMsV0FBVztRQUNYQyxTQUFTO1FBQ1RDLE9BQU87SUFDVDtJQUNBZCxhQUFhO1FBQ1hPLElBQUk7UUFDSkMsSUFBSTtRQUNKQyxVQUFVO1FBQ1ZDLE1BQU07UUFDTkMsU0FBUztRQUNUQyxXQUFXO1FBQ1hDLFNBQVM7UUFDVEMsT0FBTztJQUNUO0lBQ0FiLE1BQU07UUFDSk0sSUFBSTtRQUNKQyxJQUFJO1FBQ0pDLFVBQVU7UUFDVkMsTUFBTTtRQUNOQyxTQUFTO1FBQ1RDLFdBQVc7UUFDWEMsU0FBUztRQUNUQyxPQUFPO0lBQ1Q7QUFDRjtBQUVBLE1BQU1FLGdCQUFnQixDQUFDQyxhQUFhQztJQUNsQyxNQUFNQyxTQUFTQyxPQUFPSDtJQUV0QixxREFBcUQ7SUFDckQsMkRBQTJEO0lBQzNELHNCQUFzQjtJQUN0QixFQUFFO0lBQ0YseUVBQXlFO0lBQ3pFLHFDQUFxQztJQUVyQyxNQUFNSSxTQUFTRixTQUFTO0lBQ3hCLElBQUlFLFNBQVMsTUFBTUEsU0FBUyxJQUFJO1FBQzlCLE9BQVFBLFNBQVM7WUFDZixLQUFLO2dCQUNILE9BQU9GLFNBQVM7WUFDbEIsS0FBSztnQkFDSCxPQUFPQSxTQUFTO1lBQ2xCLEtBQUs7Z0JBQ0gsT0FBT0EsU0FBUztRQUNwQjtJQUNGO0lBQ0EsT0FBT0EsU0FBUztBQUNsQjtBQUVPLE1BQU1HLFdBQVc7SUFDdEJOO0lBRUFPLEtBQUsxQix5RUFBZUEsQ0FBQztRQUNuQjJCLFFBQVExQjtRQUNSMkIsY0FBYztJQUNoQjtJQUVBQyxTQUFTN0IseUVBQWVBLENBQUM7UUFDdkIyQixRQUFRdEI7UUFDUnVCLGNBQWM7UUFDZEUsa0JBQWtCLENBQUNELFVBQVlBLFVBQVU7SUFDM0M7SUFFQUUsT0FBTy9CLHlFQUFlQSxDQUFDO1FBQ3JCMkIsUUFBUXJCO1FBQ1JzQixjQUFjO0lBQ2hCO0lBRUFJLEtBQUtoQyx5RUFBZUEsQ0FBQztRQUNuQjJCLFFBQVFwQjtRQUNScUIsY0FBYztJQUNoQjtJQUVBSyxXQUFXakMseUVBQWVBLENBQUM7UUFDekIyQixRQUFRbEI7UUFDUm1CLGNBQWM7UUFDZE0sa0JBQWtCaEI7UUFDbEJpQix3QkFBd0I7SUFDMUI7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9sb2NhbGUvZW4tVVMvX2xpYi9sb2NhbGl6ZS5tanM/Yzk3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBidWlsZExvY2FsaXplRm4gfSBmcm9tIFwiLi4vLi4vX2xpYi9idWlsZExvY2FsaXplRm4ubWpzXCI7XG5cbmNvbnN0IGVyYVZhbHVlcyA9IHtcbiAgbmFycm93OiBbXCJCXCIsIFwiQVwiXSxcbiAgYWJicmV2aWF0ZWQ6IFtcIkJDXCIsIFwiQURcIl0sXG4gIHdpZGU6IFtcIkJlZm9yZSBDaHJpc3RcIiwgXCJBbm5vIERvbWluaVwiXSxcbn07XG5cbmNvbnN0IHF1YXJ0ZXJWYWx1ZXMgPSB7XG4gIG5hcnJvdzogW1wiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiXSxcbiAgYWJicmV2aWF0ZWQ6IFtcIlExXCIsIFwiUTJcIiwgXCJRM1wiLCBcIlE0XCJdLFxuICB3aWRlOiBbXCIxc3QgcXVhcnRlclwiLCBcIjJuZCBxdWFydGVyXCIsIFwiM3JkIHF1YXJ0ZXJcIiwgXCI0dGggcXVhcnRlclwiXSxcbn07XG5cbi8vIE5vdGU6IGluIEVuZ2xpc2gsIHRoZSBuYW1lcyBvZiBkYXlzIG9mIHRoZSB3ZWVrIGFuZCBtb250aHMgYXJlIGNhcGl0YWxpemVkLlxuLy8gSWYgeW91IGFyZSBtYWtpbmcgYSBuZXcgbG9jYWxlIGJhc2VkIG9uIHRoaXMgb25lLCBjaGVjayBpZiB0aGUgc2FtZSBpcyB0cnVlIGZvciB0aGUgbGFuZ3VhZ2UgeW91J3JlIHdvcmtpbmcgb24uXG4vLyBHZW5lcmFsbHksIGZvcm1hdHRlZCBkYXRlcyBzaG91bGQgbG9vayBsaWtlIHRoZXkgYXJlIGluIHRoZSBtaWRkbGUgb2YgYSBzZW50ZW5jZSxcbi8vIGUuZy4gaW4gU3BhbmlzaCBsYW5ndWFnZSB0aGUgd2Vla2RheXMgYW5kIG1vbnRocyBzaG91bGQgYmUgaW4gdGhlIGxvd2VyY2FzZS5cbmNvbnN0IG1vbnRoVmFsdWVzID0ge1xuICBuYXJyb3c6IFtcIkpcIiwgXCJGXCIsIFwiTVwiLCBcIkFcIiwgXCJNXCIsIFwiSlwiLCBcIkpcIiwgXCJBXCIsIFwiU1wiLCBcIk9cIiwgXCJOXCIsIFwiRFwiXSxcbiAgYWJicmV2aWF0ZWQ6IFtcbiAgICBcIkphblwiLFxuICAgIFwiRmViXCIsXG4gICAgXCJNYXJcIixcbiAgICBcIkFwclwiLFxuICAgIFwiTWF5XCIsXG4gICAgXCJKdW5cIixcbiAgICBcIkp1bFwiLFxuICAgIFwiQXVnXCIsXG4gICAgXCJTZXBcIixcbiAgICBcIk9jdFwiLFxuICAgIFwiTm92XCIsXG4gICAgXCJEZWNcIixcbiAgXSxcblxuICB3aWRlOiBbXG4gICAgXCJKYW51YXJ5XCIsXG4gICAgXCJGZWJydWFyeVwiLFxuICAgIFwiTWFyY2hcIixcbiAgICBcIkFwcmlsXCIsXG4gICAgXCJNYXlcIixcbiAgICBcIkp1bmVcIixcbiAgICBcIkp1bHlcIixcbiAgICBcIkF1Z3VzdFwiLFxuICAgIFwiU2VwdGVtYmVyXCIsXG4gICAgXCJPY3RvYmVyXCIsXG4gICAgXCJOb3ZlbWJlclwiLFxuICAgIFwiRGVjZW1iZXJcIixcbiAgXSxcbn07XG5cbmNvbnN0IGRheVZhbHVlcyA9IHtcbiAgbmFycm93OiBbXCJTXCIsIFwiTVwiLCBcIlRcIiwgXCJXXCIsIFwiVFwiLCBcIkZcIiwgXCJTXCJdLFxuICBzaG9ydDogW1wiU3VcIiwgXCJNb1wiLCBcIlR1XCIsIFwiV2VcIiwgXCJUaFwiLCBcIkZyXCIsIFwiU2FcIl0sXG4gIGFiYnJldmlhdGVkOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gIHdpZGU6IFtcbiAgICBcIlN1bmRheVwiLFxuICAgIFwiTW9uZGF5XCIsXG4gICAgXCJUdWVzZGF5XCIsXG4gICAgXCJXZWRuZXNkYXlcIixcbiAgICBcIlRodXJzZGF5XCIsXG4gICAgXCJGcmlkYXlcIixcbiAgICBcIlNhdHVyZGF5XCIsXG4gIF0sXG59O1xuXG5jb25zdCBkYXlQZXJpb2RWYWx1ZXMgPSB7XG4gIG5hcnJvdzoge1xuICAgIGFtOiBcImFcIixcbiAgICBwbTogXCJwXCIsXG4gICAgbWlkbmlnaHQ6IFwibWlcIixcbiAgICBub29uOiBcIm5cIixcbiAgICBtb3JuaW5nOiBcIm1vcm5pbmdcIixcbiAgICBhZnRlcm5vb246IFwiYWZ0ZXJub29uXCIsXG4gICAgZXZlbmluZzogXCJldmVuaW5nXCIsXG4gICAgbmlnaHQ6IFwibmlnaHRcIixcbiAgfSxcbiAgYWJicmV2aWF0ZWQ6IHtcbiAgICBhbTogXCJBTVwiLFxuICAgIHBtOiBcIlBNXCIsXG4gICAgbWlkbmlnaHQ6IFwibWlkbmlnaHRcIixcbiAgICBub29uOiBcIm5vb25cIixcbiAgICBtb3JuaW5nOiBcIm1vcm5pbmdcIixcbiAgICBhZnRlcm5vb246IFwiYWZ0ZXJub29uXCIsXG4gICAgZXZlbmluZzogXCJldmVuaW5nXCIsXG4gICAgbmlnaHQ6IFwibmlnaHRcIixcbiAgfSxcbiAgd2lkZToge1xuICAgIGFtOiBcImEubS5cIixcbiAgICBwbTogXCJwLm0uXCIsXG4gICAgbWlkbmlnaHQ6IFwibWlkbmlnaHRcIixcbiAgICBub29uOiBcIm5vb25cIixcbiAgICBtb3JuaW5nOiBcIm1vcm5pbmdcIixcbiAgICBhZnRlcm5vb246IFwiYWZ0ZXJub29uXCIsXG4gICAgZXZlbmluZzogXCJldmVuaW5nXCIsXG4gICAgbmlnaHQ6IFwibmlnaHRcIixcbiAgfSxcbn07XG5cbmNvbnN0IGZvcm1hdHRpbmdEYXlQZXJpb2RWYWx1ZXMgPSB7XG4gIG5hcnJvdzoge1xuICAgIGFtOiBcImFcIixcbiAgICBwbTogXCJwXCIsXG4gICAgbWlkbmlnaHQ6IFwibWlcIixcbiAgICBub29uOiBcIm5cIixcbiAgICBtb3JuaW5nOiBcImluIHRoZSBtb3JuaW5nXCIsXG4gICAgYWZ0ZXJub29uOiBcImluIHRoZSBhZnRlcm5vb25cIixcbiAgICBldmVuaW5nOiBcImluIHRoZSBldmVuaW5nXCIsXG4gICAgbmlnaHQ6IFwiYXQgbmlnaHRcIixcbiAgfSxcbiAgYWJicmV2aWF0ZWQ6IHtcbiAgICBhbTogXCJBTVwiLFxuICAgIHBtOiBcIlBNXCIsXG4gICAgbWlkbmlnaHQ6IFwibWlkbmlnaHRcIixcbiAgICBub29uOiBcIm5vb25cIixcbiAgICBtb3JuaW5nOiBcImluIHRoZSBtb3JuaW5nXCIsXG4gICAgYWZ0ZXJub29uOiBcImluIHRoZSBhZnRlcm5vb25cIixcbiAgICBldmVuaW5nOiBcImluIHRoZSBldmVuaW5nXCIsXG4gICAgbmlnaHQ6IFwiYXQgbmlnaHRcIixcbiAgfSxcbiAgd2lkZToge1xuICAgIGFtOiBcImEubS5cIixcbiAgICBwbTogXCJwLm0uXCIsXG4gICAgbWlkbmlnaHQ6IFwibWlkbmlnaHRcIixcbiAgICBub29uOiBcIm5vb25cIixcbiAgICBtb3JuaW5nOiBcImluIHRoZSBtb3JuaW5nXCIsXG4gICAgYWZ0ZXJub29uOiBcImluIHRoZSBhZnRlcm5vb25cIixcbiAgICBldmVuaW5nOiBcImluIHRoZSBldmVuaW5nXCIsXG4gICAgbmlnaHQ6IFwiYXQgbmlnaHRcIixcbiAgfSxcbn07XG5cbmNvbnN0IG9yZGluYWxOdW1iZXIgPSAoZGlydHlOdW1iZXIsIF9vcHRpb25zKSA9PiB7XG4gIGNvbnN0IG51bWJlciA9IE51bWJlcihkaXJ0eU51bWJlcik7XG5cbiAgLy8gSWYgb3JkaW5hbCBudW1iZXJzIGRlcGVuZCBvbiBjb250ZXh0LCBmb3IgZXhhbXBsZSxcbiAgLy8gaWYgdGhleSBhcmUgZGlmZmVyZW50IGZvciBkaWZmZXJlbnQgZ3JhbW1hdGljYWwgZ2VuZGVycyxcbiAgLy8gdXNlIGBvcHRpb25zLnVuaXRgLlxuICAvL1xuICAvLyBgdW5pdGAgY2FuIGJlICd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXRlJywgJ2RheU9mWWVhcicsXG4gIC8vICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJy5cblxuICBjb25zdCByZW0xMDAgPSBudW1iZXIgJSAxMDA7XG4gIGlmIChyZW0xMDAgPiAyMCB8fCByZW0xMDAgPCAxMCkge1xuICAgIHN3aXRjaCAocmVtMTAwICUgMTApIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIG51bWJlciArIFwic3RcIjtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIG51bWJlciArIFwibmRcIjtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIG51bWJlciArIFwicmRcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bWJlciArIFwidGhcIjtcbn07XG5cbmV4cG9ydCBjb25zdCBsb2NhbGl6ZSA9IHtcbiAgb3JkaW5hbE51bWJlcixcblxuICBlcmE6IGJ1aWxkTG9jYWxpemVGbih7XG4gICAgdmFsdWVzOiBlcmFWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiBcIndpZGVcIixcbiAgfSksXG5cbiAgcXVhcnRlcjogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IHF1YXJ0ZXJWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiBcIndpZGVcIixcbiAgICBhcmd1bWVudENhbGxiYWNrOiAocXVhcnRlcikgPT4gcXVhcnRlciAtIDEsXG4gIH0pLFxuXG4gIG1vbnRoOiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogbW9udGhWYWx1ZXMsXG4gICAgZGVmYXVsdFdpZHRoOiBcIndpZGVcIixcbiAgfSksXG5cbiAgZGF5OiBidWlsZExvY2FsaXplRm4oe1xuICAgIHZhbHVlczogZGF5VmFsdWVzLFxuICAgIGRlZmF1bHRXaWR0aDogXCJ3aWRlXCIsXG4gIH0pLFxuXG4gIGRheVBlcmlvZDogYnVpbGRMb2NhbGl6ZUZuKHtcbiAgICB2YWx1ZXM6IGRheVBlcmlvZFZhbHVlcyxcbiAgICBkZWZhdWx0V2lkdGg6IFwid2lkZVwiLFxuICAgIGZvcm1hdHRpbmdWYWx1ZXM6IGZvcm1hdHRpbmdEYXlQZXJpb2RWYWx1ZXMsXG4gICAgZGVmYXVsdEZvcm1hdHRpbmdXaWR0aDogXCJ3aWRlXCIsXG4gIH0pLFxufTtcbiJdLCJuYW1lcyI6WyJidWlsZExvY2FsaXplRm4iLCJlcmFWYWx1ZXMiLCJuYXJyb3ciLCJhYmJyZXZpYXRlZCIsIndpZGUiLCJxdWFydGVyVmFsdWVzIiwibW9udGhWYWx1ZXMiLCJkYXlWYWx1ZXMiLCJzaG9ydCIsImRheVBlcmlvZFZhbHVlcyIsImFtIiwicG0iLCJtaWRuaWdodCIsIm5vb24iLCJtb3JuaW5nIiwiYWZ0ZXJub29uIiwiZXZlbmluZyIsIm5pZ2h0IiwiZm9ybWF0dGluZ0RheVBlcmlvZFZhbHVlcyIsIm9yZGluYWxOdW1iZXIiLCJkaXJ0eU51bWJlciIsIl9vcHRpb25zIiwibnVtYmVyIiwiTnVtYmVyIiwicmVtMTAwIiwibG9jYWxpemUiLCJlcmEiLCJ2YWx1ZXMiLCJkZWZhdWx0V2lkdGgiLCJxdWFydGVyIiwiYXJndW1lbnRDYWxsYmFjayIsIm1vbnRoIiwiZGF5IiwiZGF5UGVyaW9kIiwiZm9ybWF0dGluZ1ZhbHVlcyIsImRlZmF1bHRGb3JtYXR0aW5nV2lkdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/locale/en-US/_lib/localize.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/locale/en-US/_lib/match.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/date-fns/locale/en-US/_lib/match.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   match: function() { return /* binding */ match; }\n/* harmony export */ });\n/* harmony import */ var _lib_buildMatchFn_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../_lib/buildMatchFn.mjs */ \"(app-pages-browser)/./node_modules/date-fns/locale/_lib/buildMatchFn.mjs\");\n/* harmony import */ var _lib_buildMatchPatternFn_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_lib/buildMatchPatternFn.mjs */ \"(app-pages-browser)/./node_modules/date-fns/locale/_lib/buildMatchPatternFn.mjs\");\n\n\nconst matchOrdinalNumberPattern = /^(\\d+)(th|st|nd|rd)?/i;\nconst parseOrdinalNumberPattern = /\\d+/i;\nconst matchEraPatterns = {\n    narrow: /^(b|a)/i,\n    abbreviated: /^(b\\.?\\s?c\\.?|b\\.?\\s?c\\.?\\s?e\\.?|a\\.?\\s?d\\.?|c\\.?\\s?e\\.?)/i,\n    wide: /^(before christ|before common era|anno domini|common era)/i\n};\nconst parseEraPatterns = {\n    any: [\n        /^b/i,\n        /^(a|c)/i\n    ]\n};\nconst matchQuarterPatterns = {\n    narrow: /^[1234]/i,\n    abbreviated: /^q[1234]/i,\n    wide: /^[1234](th|st|nd|rd)? quarter/i\n};\nconst parseQuarterPatterns = {\n    any: [\n        /1/i,\n        /2/i,\n        /3/i,\n        /4/i\n    ]\n};\nconst matchMonthPatterns = {\n    narrow: /^[jfmasond]/i,\n    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,\n    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i\n};\nconst parseMonthPatterns = {\n    narrow: [\n        /^j/i,\n        /^f/i,\n        /^m/i,\n        /^a/i,\n        /^m/i,\n        /^j/i,\n        /^j/i,\n        /^a/i,\n        /^s/i,\n        /^o/i,\n        /^n/i,\n        /^d/i\n    ],\n    any: [\n        /^ja/i,\n        /^f/i,\n        /^mar/i,\n        /^ap/i,\n        /^may/i,\n        /^jun/i,\n        /^jul/i,\n        /^au/i,\n        /^s/i,\n        /^o/i,\n        /^n/i,\n        /^d/i\n    ]\n};\nconst matchDayPatterns = {\n    narrow: /^[smtwf]/i,\n    short: /^(su|mo|tu|we|th|fr|sa)/i,\n    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,\n    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i\n};\nconst parseDayPatterns = {\n    narrow: [\n        /^s/i,\n        /^m/i,\n        /^t/i,\n        /^w/i,\n        /^t/i,\n        /^f/i,\n        /^s/i\n    ],\n    any: [\n        /^su/i,\n        /^m/i,\n        /^tu/i,\n        /^w/i,\n        /^th/i,\n        /^f/i,\n        /^sa/i\n    ]\n};\nconst matchDayPeriodPatterns = {\n    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,\n    any: /^([ap]\\.?\\s?m\\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i\n};\nconst parseDayPeriodPatterns = {\n    any: {\n        am: /^a/i,\n        pm: /^p/i,\n        midnight: /^mi/i,\n        noon: /^no/i,\n        morning: /morning/i,\n        afternoon: /afternoon/i,\n        evening: /evening/i,\n        night: /night/i\n    }\n};\nconst match = {\n    ordinalNumber: (0,_lib_buildMatchPatternFn_mjs__WEBPACK_IMPORTED_MODULE_0__.buildMatchPatternFn)({\n        matchPattern: matchOrdinalNumberPattern,\n        parsePattern: parseOrdinalNumberPattern,\n        valueCallback: (value)=>parseInt(value, 10)\n    }),\n    era: (0,_lib_buildMatchFn_mjs__WEBPACK_IMPORTED_MODULE_1__.buildMatchFn)({\n        matchPatterns: matchEraPatterns,\n        defaultMatchWidth: \"wide\",\n        parsePatterns: parseEraPatterns,\n        defaultParseWidth: \"any\"\n    }),\n    quarter: (0,_lib_buildMatchFn_mjs__WEBPACK_IMPORTED_MODULE_1__.buildMatchFn)({\n        matchPatterns: matchQuarterPatterns,\n        defaultMatchWidth: \"wide\",\n        parsePatterns: parseQuarterPatterns,\n        defaultParseWidth: \"any\",\n        valueCallback: (index)=>index + 1\n    }),\n    month: (0,_lib_buildMatchFn_mjs__WEBPACK_IMPORTED_MODULE_1__.buildMatchFn)({\n        matchPatterns: matchMonthPatterns,\n        defaultMatchWidth: \"wide\",\n        parsePatterns: parseMonthPatterns,\n        defaultParseWidth: \"any\"\n    }),\n    day: (0,_lib_buildMatchFn_mjs__WEBPACK_IMPORTED_MODULE_1__.buildMatchFn)({\n        matchPatterns: matchDayPatterns,\n        defaultMatchWidth: \"wide\",\n        parsePatterns: parseDayPatterns,\n        defaultParseWidth: \"any\"\n    }),\n    dayPeriod: (0,_lib_buildMatchFn_mjs__WEBPACK_IMPORTED_MODULE_1__.buildMatchFn)({\n        matchPatterns: matchDayPeriodPatterns,\n        defaultMatchWidth: \"any\",\n        parsePatterns: parseDayPeriodPatterns,\n        defaultParseWidth: \"any\"\n    })\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9sb2NhbGUvZW4tVVMvX2xpYi9tYXRjaC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJEO0FBQ2M7QUFFekUsTUFBTUUsNEJBQTRCO0FBQ2xDLE1BQU1DLDRCQUE0QjtBQUVsQyxNQUFNQyxtQkFBbUI7SUFDdkJDLFFBQVE7SUFDUkMsYUFBYTtJQUNiQyxNQUFNO0FBQ1I7QUFDQSxNQUFNQyxtQkFBbUI7SUFDdkJDLEtBQUs7UUFBQztRQUFPO0tBQVU7QUFDekI7QUFFQSxNQUFNQyx1QkFBdUI7SUFDM0JMLFFBQVE7SUFDUkMsYUFBYTtJQUNiQyxNQUFNO0FBQ1I7QUFDQSxNQUFNSSx1QkFBdUI7SUFDM0JGLEtBQUs7UUFBQztRQUFNO1FBQU07UUFBTTtLQUFLO0FBQy9CO0FBRUEsTUFBTUcscUJBQXFCO0lBQ3pCUCxRQUFRO0lBQ1JDLGFBQWE7SUFDYkMsTUFBTTtBQUNSO0FBQ0EsTUFBTU0scUJBQXFCO0lBQ3pCUixRQUFRO1FBQ047UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFFREksS0FBSztRQUNIO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0FBQ0g7QUFFQSxNQUFNSyxtQkFBbUI7SUFDdkJULFFBQVE7SUFDUlUsT0FBTztJQUNQVCxhQUFhO0lBQ2JDLE1BQU07QUFDUjtBQUNBLE1BQU1TLG1CQUFtQjtJQUN2QlgsUUFBUTtRQUFDO1FBQU87UUFBTztRQUFPO1FBQU87UUFBTztRQUFPO0tBQU07SUFDekRJLEtBQUs7UUFBQztRQUFRO1FBQU87UUFBUTtRQUFPO1FBQVE7UUFBTztLQUFPO0FBQzVEO0FBRUEsTUFBTVEseUJBQXlCO0lBQzdCWixRQUFRO0lBQ1JJLEtBQUs7QUFDUDtBQUNBLE1BQU1TLHlCQUF5QjtJQUM3QlQsS0FBSztRQUNIVSxJQUFJO1FBQ0pDLElBQUk7UUFDSkMsVUFBVTtRQUNWQyxNQUFNO1FBQ05DLFNBQVM7UUFDVEMsV0FBVztRQUNYQyxTQUFTO1FBQ1RDLE9BQU87SUFDVDtBQUNGO0FBRU8sTUFBTUMsUUFBUTtJQUNuQkMsZUFBZTNCLGlGQUFtQkEsQ0FBQztRQUNqQzRCLGNBQWMzQjtRQUNkNEIsY0FBYzNCO1FBQ2Q0QixlQUFlLENBQUNDLFFBQVVDLFNBQVNELE9BQU87SUFDNUM7SUFFQUUsS0FBS2xDLG1FQUFZQSxDQUFDO1FBQ2hCbUMsZUFBZS9CO1FBQ2ZnQyxtQkFBbUI7UUFDbkJDLGVBQWU3QjtRQUNmOEIsbUJBQW1CO0lBQ3JCO0lBRUFDLFNBQVN2QyxtRUFBWUEsQ0FBQztRQUNwQm1DLGVBQWV6QjtRQUNmMEIsbUJBQW1CO1FBQ25CQyxlQUFlMUI7UUFDZjJCLG1CQUFtQjtRQUNuQlAsZUFBZSxDQUFDUyxRQUFVQSxRQUFRO0lBQ3BDO0lBRUFDLE9BQU96QyxtRUFBWUEsQ0FBQztRQUNsQm1DLGVBQWV2QjtRQUNmd0IsbUJBQW1CO1FBQ25CQyxlQUFleEI7UUFDZnlCLG1CQUFtQjtJQUNyQjtJQUVBSSxLQUFLMUMsbUVBQVlBLENBQUM7UUFDaEJtQyxlQUFlckI7UUFDZnNCLG1CQUFtQjtRQUNuQkMsZUFBZXJCO1FBQ2ZzQixtQkFBbUI7SUFDckI7SUFFQUssV0FBVzNDLG1FQUFZQSxDQUFDO1FBQ3RCbUMsZUFBZWxCO1FBQ2ZtQixtQkFBbUI7UUFDbkJDLGVBQWVuQjtRQUNmb0IsbUJBQW1CO0lBQ3JCO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvbG9jYWxlL2VuLVVTL19saWIvbWF0Y2gubWpzPzVjZDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnVpbGRNYXRjaEZuIH0gZnJvbSBcIi4uLy4uL19saWIvYnVpbGRNYXRjaEZuLm1qc1wiO1xuaW1wb3J0IHsgYnVpbGRNYXRjaFBhdHRlcm5GbiB9IGZyb20gXCIuLi8uLi9fbGliL2J1aWxkTWF0Y2hQYXR0ZXJuRm4ubWpzXCI7XG5cbmNvbnN0IG1hdGNoT3JkaW5hbE51bWJlclBhdHRlcm4gPSAvXihcXGQrKSh0aHxzdHxuZHxyZCk/L2k7XG5jb25zdCBwYXJzZU9yZGluYWxOdW1iZXJQYXR0ZXJuID0gL1xcZCsvaTtcblxuY29uc3QgbWF0Y2hFcmFQYXR0ZXJucyA9IHtcbiAgbmFycm93OiAvXihifGEpL2ksXG4gIGFiYnJldmlhdGVkOiAvXihiXFwuP1xccz9jXFwuP3xiXFwuP1xccz9jXFwuP1xccz9lXFwuP3xhXFwuP1xccz9kXFwuP3xjXFwuP1xccz9lXFwuPykvaSxcbiAgd2lkZTogL14oYmVmb3JlIGNocmlzdHxiZWZvcmUgY29tbW9uIGVyYXxhbm5vIGRvbWluaXxjb21tb24gZXJhKS9pLFxufTtcbmNvbnN0IHBhcnNlRXJhUGF0dGVybnMgPSB7XG4gIGFueTogWy9eYi9pLCAvXihhfGMpL2ldLFxufTtcblxuY29uc3QgbWF0Y2hRdWFydGVyUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL15bMTIzNF0vaSxcbiAgYWJicmV2aWF0ZWQ6IC9ecVsxMjM0XS9pLFxuICB3aWRlOiAvXlsxMjM0XSh0aHxzdHxuZHxyZCk/IHF1YXJ0ZXIvaSxcbn07XG5jb25zdCBwYXJzZVF1YXJ0ZXJQYXR0ZXJucyA9IHtcbiAgYW55OiBbLzEvaSwgLzIvaSwgLzMvaSwgLzQvaV0sXG59O1xuXG5jb25zdCBtYXRjaE1vbnRoUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL15bamZtYXNvbmRdL2ksXG4gIGFiYnJldmlhdGVkOiAvXihqYW58ZmVifG1hcnxhcHJ8bWF5fGp1bnxqdWx8YXVnfHNlcHxvY3R8bm92fGRlYykvaSxcbiAgd2lkZTogL14oamFudWFyeXxmZWJydWFyeXxtYXJjaHxhcHJpbHxtYXl8anVuZXxqdWx5fGF1Z3VzdHxzZXB0ZW1iZXJ8b2N0b2Jlcnxub3ZlbWJlcnxkZWNlbWJlcikvaSxcbn07XG5jb25zdCBwYXJzZU1vbnRoUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogW1xuICAgIC9eai9pLFxuICAgIC9eZi9pLFxuICAgIC9ebS9pLFxuICAgIC9eYS9pLFxuICAgIC9ebS9pLFxuICAgIC9eai9pLFxuICAgIC9eai9pLFxuICAgIC9eYS9pLFxuICAgIC9ecy9pLFxuICAgIC9eby9pLFxuICAgIC9ebi9pLFxuICAgIC9eZC9pLFxuICBdLFxuXG4gIGFueTogW1xuICAgIC9eamEvaSxcbiAgICAvXmYvaSxcbiAgICAvXm1hci9pLFxuICAgIC9eYXAvaSxcbiAgICAvXm1heS9pLFxuICAgIC9eanVuL2ksXG4gICAgL15qdWwvaSxcbiAgICAvXmF1L2ksXG4gICAgL15zL2ksXG4gICAgL15vL2ksXG4gICAgL15uL2ksXG4gICAgL15kL2ksXG4gIF0sXG59O1xuXG5jb25zdCBtYXRjaERheVBhdHRlcm5zID0ge1xuICBuYXJyb3c6IC9eW3NtdHdmXS9pLFxuICBzaG9ydDogL14oc3V8bW98dHV8d2V8dGh8ZnJ8c2EpL2ksXG4gIGFiYnJldmlhdGVkOiAvXihzdW58bW9ufHR1ZXx3ZWR8dGh1fGZyaXxzYXQpL2ksXG4gIHdpZGU6IC9eKHN1bmRheXxtb25kYXl8dHVlc2RheXx3ZWRuZXNkYXl8dGh1cnNkYXl8ZnJpZGF5fHNhdHVyZGF5KS9pLFxufTtcbmNvbnN0IHBhcnNlRGF5UGF0dGVybnMgPSB7XG4gIG5hcnJvdzogWy9ecy9pLCAvXm0vaSwgL150L2ksIC9edy9pLCAvXnQvaSwgL15mL2ksIC9ecy9pXSxcbiAgYW55OiBbL15zdS9pLCAvXm0vaSwgL150dS9pLCAvXncvaSwgL150aC9pLCAvXmYvaSwgL15zYS9pXSxcbn07XG5cbmNvbnN0IG1hdGNoRGF5UGVyaW9kUGF0dGVybnMgPSB7XG4gIG5hcnJvdzogL14oYXxwfG1pfG58KGluIHRoZXxhdCkgKG1vcm5pbmd8YWZ0ZXJub29ufGV2ZW5pbmd8bmlnaHQpKS9pLFxuICBhbnk6IC9eKFthcF1cXC4/XFxzP21cXC4/fG1pZG5pZ2h0fG5vb258KGluIHRoZXxhdCkgKG1vcm5pbmd8YWZ0ZXJub29ufGV2ZW5pbmd8bmlnaHQpKS9pLFxufTtcbmNvbnN0IHBhcnNlRGF5UGVyaW9kUGF0dGVybnMgPSB7XG4gIGFueToge1xuICAgIGFtOiAvXmEvaSxcbiAgICBwbTogL15wL2ksXG4gICAgbWlkbmlnaHQ6IC9ebWkvaSxcbiAgICBub29uOiAvXm5vL2ksXG4gICAgbW9ybmluZzogL21vcm5pbmcvaSxcbiAgICBhZnRlcm5vb246IC9hZnRlcm5vb24vaSxcbiAgICBldmVuaW5nOiAvZXZlbmluZy9pLFxuICAgIG5pZ2h0OiAvbmlnaHQvaSxcbiAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBtYXRjaCA9IHtcbiAgb3JkaW5hbE51bWJlcjogYnVpbGRNYXRjaFBhdHRlcm5Gbih7XG4gICAgbWF0Y2hQYXR0ZXJuOiBtYXRjaE9yZGluYWxOdW1iZXJQYXR0ZXJuLFxuICAgIHBhcnNlUGF0dGVybjogcGFyc2VPcmRpbmFsTnVtYmVyUGF0dGVybixcbiAgICB2YWx1ZUNhbGxiYWNrOiAodmFsdWUpID0+IHBhcnNlSW50KHZhbHVlLCAxMCksXG4gIH0pLFxuXG4gIGVyYTogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaEVyYVBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiBcIndpZGVcIixcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZUVyYVBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiBcImFueVwiLFxuICB9KSxcblxuICBxdWFydGVyOiBidWlsZE1hdGNoRm4oe1xuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoUXVhcnRlclBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiBcIndpZGVcIixcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZVF1YXJ0ZXJQYXR0ZXJucyxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogXCJhbnlcIixcbiAgICB2YWx1ZUNhbGxiYWNrOiAoaW5kZXgpID0+IGluZGV4ICsgMSxcbiAgfSksXG5cbiAgbW9udGg6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hNb250aFBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiBcIndpZGVcIixcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZU1vbnRoUGF0dGVybnMsXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6IFwiYW55XCIsXG4gIH0pLFxuXG4gIGRheTogYnVpbGRNYXRjaEZuKHtcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaERheVBhdHRlcm5zLFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiBcIndpZGVcIixcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZURheVBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiBcImFueVwiLFxuICB9KSxcblxuICBkYXlQZXJpb2Q6IGJ1aWxkTWF0Y2hGbih7XG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hEYXlQZXJpb2RQYXR0ZXJucyxcbiAgICBkZWZhdWx0TWF0Y2hXaWR0aDogXCJhbnlcIixcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZURheVBlcmlvZFBhdHRlcm5zLFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiBcImFueVwiLFxuICB9KSxcbn07XG4iXSwibmFtZXMiOlsiYnVpbGRNYXRjaEZuIiwiYnVpbGRNYXRjaFBhdHRlcm5GbiIsIm1hdGNoT3JkaW5hbE51bWJlclBhdHRlcm4iLCJwYXJzZU9yZGluYWxOdW1iZXJQYXR0ZXJuIiwibWF0Y2hFcmFQYXR0ZXJucyIsIm5hcnJvdyIsImFiYnJldmlhdGVkIiwid2lkZSIsInBhcnNlRXJhUGF0dGVybnMiLCJhbnkiLCJtYXRjaFF1YXJ0ZXJQYXR0ZXJucyIsInBhcnNlUXVhcnRlclBhdHRlcm5zIiwibWF0Y2hNb250aFBhdHRlcm5zIiwicGFyc2VNb250aFBhdHRlcm5zIiwibWF0Y2hEYXlQYXR0ZXJucyIsInNob3J0IiwicGFyc2VEYXlQYXR0ZXJucyIsIm1hdGNoRGF5UGVyaW9kUGF0dGVybnMiLCJwYXJzZURheVBlcmlvZFBhdHRlcm5zIiwiYW0iLCJwbSIsIm1pZG5pZ2h0Iiwibm9vbiIsIm1vcm5pbmciLCJhZnRlcm5vb24iLCJldmVuaW5nIiwibmlnaHQiLCJtYXRjaCIsIm9yZGluYWxOdW1iZXIiLCJtYXRjaFBhdHRlcm4iLCJwYXJzZVBhdHRlcm4iLCJ2YWx1ZUNhbGxiYWNrIiwidmFsdWUiLCJwYXJzZUludCIsImVyYSIsIm1hdGNoUGF0dGVybnMiLCJkZWZhdWx0TWF0Y2hXaWR0aCIsInBhcnNlUGF0dGVybnMiLCJkZWZhdWx0UGFyc2VXaWR0aCIsInF1YXJ0ZXIiLCJpbmRleCIsIm1vbnRoIiwiZGF5IiwiZGF5UGVyaW9kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/locale/en-US/_lib/match.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/startOfDay.mjs":
/*!**********************************************!*\
  !*** ./node_modules/date-fns/startOfDay.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   startOfDay: function() { return /* binding */ startOfDay; }\n/* harmony export */ });\n/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toDate.mjs */ \"(app-pages-browser)/./node_modules/date-fns/toDate.mjs\");\n\n/**\n * @name startOfDay\n * @category Day Helpers\n * @summary Return the start of a day for the given date.\n *\n * @description\n * Return the start of a day for the given date.\n * The result will be in the local timezone.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n *\n * @returns The start of a day\n *\n * @example\n * // The start of a day for 2 September 2014 11:55:00:\n * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Tue Sep 02 2014 00:00:00\n */ function startOfDay(date) {\n    const _date = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_0__.toDate)(date);\n    _date.setHours(0, 0, 0, 0);\n    return _date;\n}\n// Fallback for modularized imports:\n/* harmony default export */ __webpack_exports__[\"default\"] = (startOfDay);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdGFydE9mRGF5Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFzQztBQUV0Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNNLFNBQVNDLFdBQVdDLElBQUk7SUFDN0IsTUFBTUMsUUFBUUgsbURBQU1BLENBQUNFO0lBQ3JCQyxNQUFNQyxRQUFRLENBQUMsR0FBRyxHQUFHLEdBQUc7SUFDeEIsT0FBT0Q7QUFDVDtBQUVBLG9DQUFvQztBQUNwQywrREFBZUYsVUFBVUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvc3RhcnRPZkRheS5tanM/ZDVhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0b0RhdGUgfSBmcm9tIFwiLi90b0RhdGUubWpzXCI7XG5cbi8qKlxuICogQG5hbWUgc3RhcnRPZkRheVxuICogQGNhdGVnb3J5IERheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgZGF5IGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgc3RhcnQgb2YgYSBkYXkgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICogVGhlIHJlc3VsdCB3aWxsIGJlIGluIHRoZSBsb2NhbCB0aW1lem9uZS5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIHN0YXJ0IG9mIGEgZGF5XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBzdGFydCBvZiBhIGRheSBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IHN0YXJ0T2ZEYXkobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwKSlcbiAqIC8vPT4gVHVlIFNlcCAwMiAyMDE0IDAwOjAwOjAwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydE9mRGF5KGRhdGUpIHtcbiAgY29uc3QgX2RhdGUgPSB0b0RhdGUoZGF0ZSk7XG4gIF9kYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICByZXR1cm4gX2RhdGU7XG59XG5cbi8vIEZhbGxiYWNrIGZvciBtb2R1bGFyaXplZCBpbXBvcnRzOlxuZXhwb3J0IGRlZmF1bHQgc3RhcnRPZkRheTtcbiJdLCJuYW1lcyI6WyJ0b0RhdGUiLCJzdGFydE9mRGF5IiwiZGF0ZSIsIl9kYXRlIiwic2V0SG91cnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/startOfDay.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/startOfISOWeek.mjs":
/*!**************************************************!*\
  !*** ./node_modules/date-fns/startOfISOWeek.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   startOfISOWeek: function() { return /* binding */ startOfISOWeek; }\n/* harmony export */ });\n/* harmony import */ var _startOfWeek_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./startOfWeek.mjs */ \"(app-pages-browser)/./node_modules/date-fns/startOfWeek.mjs\");\n\n/**\n * @name startOfISOWeek\n * @category ISO Week Helpers\n * @summary Return the start of an ISO week for the given date.\n *\n * @description\n * Return the start of an ISO week for the given date.\n * The result will be in the local timezone.\n *\n * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n *\n * @returns The start of an ISO week\n *\n * @example\n * // The start of an ISO week for 2 September 2014 11:55:00:\n * const result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Mon Sep 01 2014 00:00:00\n */ function startOfISOWeek(date) {\n    return (0,_startOfWeek_mjs__WEBPACK_IMPORTED_MODULE_0__.startOfWeek)(date, {\n        weekStartsOn: 1\n    });\n}\n// Fallback for modularized imports:\n/* harmony default export */ __webpack_exports__[\"default\"] = (startOfISOWeek);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdGFydE9mSVNPV2Vlay5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBZ0Q7QUFFaEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFCQyxHQUNNLFNBQVNDLGVBQWVDLElBQUk7SUFDakMsT0FBT0YsNkRBQVdBLENBQUNFLE1BQU07UUFBRUMsY0FBYztJQUFFO0FBQzdDO0FBRUEsb0NBQW9DO0FBQ3BDLCtEQUFlRixjQUFjQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdGFydE9mSVNPV2Vlay5tanM/MDgxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdGFydE9mV2VlayB9IGZyb20gXCIuL3N0YXJ0T2ZXZWVrLm1qc1wiO1xuXG4vKipcbiAqIEBuYW1lIHN0YXJ0T2ZJU09XZWVrXG4gKiBAY2F0ZWdvcnkgSVNPIFdlZWsgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBzdGFydCBvZiBhbiBJU08gd2VlayBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIHN0YXJ0IG9mIGFuIElTTyB3ZWVrIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIFRoZSByZXN1bHQgd2lsbCBiZSBpbiB0aGUgbG9jYWwgdGltZXpvbmUuXG4gKlxuICogSVNPIHdlZWstbnVtYmVyaW5nIHllYXI6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIG9yaWdpbmFsIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgc3RhcnQgb2YgYW4gSVNPIHdlZWtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVGhlIHN0YXJ0IG9mIGFuIElTTyB3ZWVrIGZvciAyIFNlcHRlbWJlciAyMDE0IDExOjU1OjAwOlxuICogY29uc3QgcmVzdWx0ID0gc3RhcnRPZklTT1dlZWsobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwKSlcbiAqIC8vPT4gTW9uIFNlcCAwMSAyMDE0IDAwOjAwOjAwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydE9mSVNPV2VlayhkYXRlKSB7XG4gIHJldHVybiBzdGFydE9mV2VlayhkYXRlLCB7IHdlZWtTdGFydHNPbjogMSB9KTtcbn1cblxuLy8gRmFsbGJhY2sgZm9yIG1vZHVsYXJpemVkIGltcG9ydHM6XG5leHBvcnQgZGVmYXVsdCBzdGFydE9mSVNPV2VlaztcbiJdLCJuYW1lcyI6WyJzdGFydE9mV2VlayIsInN0YXJ0T2ZJU09XZWVrIiwiZGF0ZSIsIndlZWtTdGFydHNPbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/startOfISOWeek.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/startOfISOWeekYear.mjs":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/startOfISOWeekYear.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   startOfISOWeekYear: function() { return /* binding */ startOfISOWeekYear; }\n/* harmony export */ });\n/* harmony import */ var _getISOWeekYear_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getISOWeekYear.mjs */ \"(app-pages-browser)/./node_modules/date-fns/getISOWeekYear.mjs\");\n/* harmony import */ var _startOfISOWeek_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./startOfISOWeek.mjs */ \"(app-pages-browser)/./node_modules/date-fns/startOfISOWeek.mjs\");\n/* harmony import */ var _constructFrom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constructFrom.mjs */ \"(app-pages-browser)/./node_modules/date-fns/constructFrom.mjs\");\n\n\n\n/**\n * @name startOfISOWeekYear\n * @category ISO Week-Numbering Year Helpers\n * @summary Return the start of an ISO week-numbering year for the given date.\n *\n * @description\n * Return the start of an ISO week-numbering year,\n * which always starts 3 days before the year's first Thursday.\n * The result will be in the local timezone.\n *\n * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n *\n * @returns The start of an ISO week-numbering year\n *\n * @example\n * // The start of an ISO week-numbering year for 2 July 2005:\n * const result = startOfISOWeekYear(new Date(2005, 6, 2))\n * //=> Mon Jan 03 2005 00:00:00\n */ function startOfISOWeekYear(date) {\n    const year = (0,_getISOWeekYear_mjs__WEBPACK_IMPORTED_MODULE_0__.getISOWeekYear)(date);\n    const fourthOfJanuary = (0,_constructFrom_mjs__WEBPACK_IMPORTED_MODULE_1__.constructFrom)(date, 0);\n    fourthOfJanuary.setFullYear(year, 0, 4);\n    fourthOfJanuary.setHours(0, 0, 0, 0);\n    return (0,_startOfISOWeek_mjs__WEBPACK_IMPORTED_MODULE_2__.startOfISOWeek)(fourthOfJanuary);\n}\n// Fallback for modularized imports:\n/* harmony default export */ __webpack_exports__[\"default\"] = (startOfISOWeekYear);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdGFydE9mSVNPV2Vla1llYXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0Q7QUFDQTtBQUNGO0FBRXBEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ00sU0FBU0csbUJBQW1CQyxJQUFJO0lBQ3JDLE1BQU1DLE9BQU9MLG1FQUFjQSxDQUFDSTtJQUM1QixNQUFNRSxrQkFBa0JKLGlFQUFhQSxDQUFDRSxNQUFNO0lBQzVDRSxnQkFBZ0JDLFdBQVcsQ0FBQ0YsTUFBTSxHQUFHO0lBQ3JDQyxnQkFBZ0JFLFFBQVEsQ0FBQyxHQUFHLEdBQUcsR0FBRztJQUNsQyxPQUFPUCxtRUFBY0EsQ0FBQ0s7QUFDeEI7QUFFQSxvQ0FBb0M7QUFDcEMsK0RBQWVILGtCQUFrQkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvc3RhcnRPZklTT1dlZWtZZWFyLm1qcz9kN2RjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldElTT1dlZWtZZWFyIH0gZnJvbSBcIi4vZ2V0SVNPV2Vla1llYXIubWpzXCI7XG5pbXBvcnQgeyBzdGFydE9mSVNPV2VlayB9IGZyb20gXCIuL3N0YXJ0T2ZJU09XZWVrLm1qc1wiO1xuaW1wb3J0IHsgY29uc3RydWN0RnJvbSB9IGZyb20gXCIuL2NvbnN0cnVjdEZyb20ubWpzXCI7XG5cbi8qKlxuICogQG5hbWUgc3RhcnRPZklTT1dlZWtZZWFyXG4gKiBAY2F0ZWdvcnkgSVNPIFdlZWstTnVtYmVyaW5nIFllYXIgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBzdGFydCBvZiBhbiBJU08gd2Vlay1udW1iZXJpbmcgeWVhciBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIHN0YXJ0IG9mIGFuIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyLFxuICogd2hpY2ggYWx3YXlzIHN0YXJ0cyAzIGRheXMgYmVmb3JlIHRoZSB5ZWFyJ3MgZmlyc3QgVGh1cnNkYXkuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKlxuICogQHJldHVybnMgVGhlIHN0YXJ0IG9mIGFuIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBzdGFydCBvZiBhbiBJU08gd2Vlay1udW1iZXJpbmcgeWVhciBmb3IgMiBKdWx5IDIwMDU6XG4gKiBjb25zdCByZXN1bHQgPSBzdGFydE9mSVNPV2Vla1llYXIobmV3IERhdGUoMjAwNSwgNiwgMikpXG4gKiAvLz0+IE1vbiBKYW4gMDMgMjAwNSAwMDowMDowMFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRPZklTT1dlZWtZZWFyKGRhdGUpIHtcbiAgY29uc3QgeWVhciA9IGdldElTT1dlZWtZZWFyKGRhdGUpO1xuICBjb25zdCBmb3VydGhPZkphbnVhcnkgPSBjb25zdHJ1Y3RGcm9tKGRhdGUsIDApO1xuICBmb3VydGhPZkphbnVhcnkuc2V0RnVsbFllYXIoeWVhciwgMCwgNCk7XG4gIGZvdXJ0aE9mSmFudWFyeS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIHN0YXJ0T2ZJU09XZWVrKGZvdXJ0aE9mSmFudWFyeSk7XG59XG5cbi8vIEZhbGxiYWNrIGZvciBtb2R1bGFyaXplZCBpbXBvcnRzOlxuZXhwb3J0IGRlZmF1bHQgc3RhcnRPZklTT1dlZWtZZWFyO1xuIl0sIm5hbWVzIjpbImdldElTT1dlZWtZZWFyIiwic3RhcnRPZklTT1dlZWsiLCJjb25zdHJ1Y3RGcm9tIiwic3RhcnRPZklTT1dlZWtZZWFyIiwiZGF0ZSIsInllYXIiLCJmb3VydGhPZkphbnVhcnkiLCJzZXRGdWxsWWVhciIsInNldEhvdXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/startOfISOWeekYear.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/startOfWeek.mjs":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/startOfWeek.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   startOfWeek: function() { return /* binding */ startOfWeek; }\n/* harmony export */ });\n/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toDate.mjs */ \"(app-pages-browser)/./node_modules/date-fns/toDate.mjs\");\n/* harmony import */ var _lib_defaultOptions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_lib/defaultOptions.mjs */ \"(app-pages-browser)/./node_modules/date-fns/_lib/defaultOptions.mjs\");\n\n\n/**\n * The {@link startOfWeek} function options.\n */ /**\n * @name startOfWeek\n * @category Week Helpers\n * @summary Return the start of a week for the given date.\n *\n * @description\n * Return the start of a week for the given date.\n * The result will be in the local timezone.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n * @param options - An object with options\n *\n * @returns The start of a week\n *\n * @example\n * // The start of a week for 2 September 2014 11:55:00:\n * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Sun Aug 31 2014 00:00:00\n *\n * @example\n * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:\n * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })\n * //=> Mon Sep 01 2014 00:00:00\n */ function startOfWeek(date, options) {\n    var _options_locale_options, _options_locale, _defaultOptions_locale_options, _defaultOptions_locale;\n    const defaultOptions = (0,_lib_defaultOptions_mjs__WEBPACK_IMPORTED_MODULE_0__.getDefaultOptions)();\n    var _options_weekStartsOn, _ref, _ref1, _ref2;\n    const weekStartsOn = (_ref2 = (_ref1 = (_ref = (_options_weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options_weekStartsOn !== void 0 ? _options_weekStartsOn : options === null || options === void 0 ? void 0 : (_options_locale = options.locale) === null || _options_locale === void 0 ? void 0 : (_options_locale_options = _options_locale.options) === null || _options_locale_options === void 0 ? void 0 : _options_locale_options.weekStartsOn) !== null && _ref !== void 0 ? _ref : defaultOptions.weekStartsOn) !== null && _ref1 !== void 0 ? _ref1 : (_defaultOptions_locale = defaultOptions.locale) === null || _defaultOptions_locale === void 0 ? void 0 : (_defaultOptions_locale_options = _defaultOptions_locale.options) === null || _defaultOptions_locale_options === void 0 ? void 0 : _defaultOptions_locale_options.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0;\n    const _date = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_1__.toDate)(date);\n    const day = _date.getDay();\n    const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;\n    _date.setDate(_date.getDate() - diff);\n    _date.setHours(0, 0, 0, 0);\n    return _date;\n}\n// Fallback for modularized imports:\n/* harmony default export */ __webpack_exports__[\"default\"] = (startOfWeek);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdGFydE9mV2Vlay5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXNDO0FBQ3dCO0FBRTlEOztDQUVDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5QkMsR0FDTSxTQUFTRSxZQUFZQyxJQUFJLEVBQUVDLE9BQU87UUFJckNBLHlCQUFBQSxpQkFFQUMsZ0NBQUFBO0lBTEYsTUFBTUEsaUJBQWlCSiwwRUFBaUJBO1FBRXRDRyx1QkFBQUEsTUFBQUEsT0FBQUE7SUFERixNQUFNRSxlQUNKRixDQUFBQSxRQUFBQSxDQUFBQSxRQUFBQSxDQUFBQSxPQUFBQSxDQUFBQSx3QkFBQUEsb0JBQUFBLDhCQUFBQSxRQUFTRSxZQUFZLGNBQXJCRixtQ0FBQUEsd0JBQ0FBLG9CQUFBQSwrQkFBQUEsa0JBQUFBLFFBQVNHLE1BQU0sY0FBZkgsdUNBQUFBLDBCQUFBQSxnQkFBaUJBLE9BQU8sY0FBeEJBLDhDQUFBQSx3QkFBMEJFLFlBQVksY0FEdENGLGtCQUFBQSxPQUVBQyxlQUFlQyxZQUFZLGNBRjNCRixtQkFBQUEsU0FHQUMseUJBQUFBLGVBQWVFLE1BQU0sY0FBckJGLDhDQUFBQSxpQ0FBQUEsdUJBQXVCRCxPQUFPLGNBQTlCQyxxREFBQUEsK0JBQWdDQyxZQUFZLGNBSDVDRixtQkFBQUEsUUFJQTtJQUVGLE1BQU1JLFFBQVFSLG1EQUFNQSxDQUFDRztJQUNyQixNQUFNTSxNQUFNRCxNQUFNRSxNQUFNO0lBQ3hCLE1BQU1DLE9BQU8sQ0FBQ0YsTUFBTUgsZUFBZSxJQUFJLEtBQUtHLE1BQU1IO0lBRWxERSxNQUFNSSxPQUFPLENBQUNKLE1BQU1LLE9BQU8sS0FBS0Y7SUFDaENILE1BQU1NLFFBQVEsQ0FBQyxHQUFHLEdBQUcsR0FBRztJQUN4QixPQUFPTjtBQUNUO0FBRUEsb0NBQW9DO0FBQ3BDLCtEQUFlTixXQUFXQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdGFydE9mV2Vlay5tanM/OTk3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0b0RhdGUgfSBmcm9tIFwiLi90b0RhdGUubWpzXCI7XG5pbXBvcnQgeyBnZXREZWZhdWx0T3B0aW9ucyB9IGZyb20gXCIuL19saWIvZGVmYXVsdE9wdGlvbnMubWpzXCI7XG5cbi8qKlxuICogVGhlIHtAbGluayBzdGFydE9mV2Vla30gZnVuY3Rpb24gb3B0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEBuYW1lIHN0YXJ0T2ZXZWVrXG4gKiBAY2F0ZWdvcnkgV2VlayBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgd2VlayBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgd2VlayBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIG9yaWdpbmFsIGRhdGVcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IHdpdGggb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIFRoZSBzdGFydCBvZiBhIHdlZWtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVGhlIHN0YXJ0IG9mIGEgd2VlayBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IHN0YXJ0T2ZXZWVrKG5ldyBEYXRlKDIwMTQsIDgsIDIsIDExLCA1NSwgMCkpXG4gKiAvLz0+IFN1biBBdWcgMzEgMjAxNCAwMDowMDowMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJZiB0aGUgd2VlayBzdGFydHMgb24gTW9uZGF5LCB0aGUgc3RhcnQgb2YgdGhlIHdlZWsgZm9yIDIgU2VwdGVtYmVyIDIwMTQgMTE6NTU6MDA6XG4gKiBjb25zdCByZXN1bHQgPSBzdGFydE9mV2VlayhuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDApLCB7IHdlZWtTdGFydHNPbjogMSB9KVxuICogLy89PiBNb24gU2VwIDAxIDIwMTQgMDA6MDA6MDBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0T2ZXZWVrKGRhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBnZXREZWZhdWx0T3B0aW9ucygpO1xuICBjb25zdCB3ZWVrU3RhcnRzT24gPVxuICAgIG9wdGlvbnM/LndlZWtTdGFydHNPbiA/P1xuICAgIG9wdGlvbnM/LmxvY2FsZT8ub3B0aW9ucz8ud2Vla1N0YXJ0c09uID8/XG4gICAgZGVmYXVsdE9wdGlvbnMud2Vla1N0YXJ0c09uID8/XG4gICAgZGVmYXVsdE9wdGlvbnMubG9jYWxlPy5vcHRpb25zPy53ZWVrU3RhcnRzT24gPz9cbiAgICAwO1xuXG4gIGNvbnN0IF9kYXRlID0gdG9EYXRlKGRhdGUpO1xuICBjb25zdCBkYXkgPSBfZGF0ZS5nZXREYXkoKTtcbiAgY29uc3QgZGlmZiA9IChkYXkgPCB3ZWVrU3RhcnRzT24gPyA3IDogMCkgKyBkYXkgLSB3ZWVrU3RhcnRzT247XG5cbiAgX2RhdGUuc2V0RGF0ZShfZGF0ZS5nZXREYXRlKCkgLSBkaWZmKTtcbiAgX2RhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiBfZGF0ZTtcbn1cblxuLy8gRmFsbGJhY2sgZm9yIG1vZHVsYXJpemVkIGltcG9ydHM6XG5leHBvcnQgZGVmYXVsdCBzdGFydE9mV2VlaztcbiJdLCJuYW1lcyI6WyJ0b0RhdGUiLCJnZXREZWZhdWx0T3B0aW9ucyIsInN0YXJ0T2ZXZWVrIiwiZGF0ZSIsIm9wdGlvbnMiLCJkZWZhdWx0T3B0aW9ucyIsIndlZWtTdGFydHNPbiIsImxvY2FsZSIsIl9kYXRlIiwiZGF5IiwiZ2V0RGF5IiwiZGlmZiIsInNldERhdGUiLCJnZXREYXRlIiwic2V0SG91cnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/startOfWeek.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/startOfWeekYear.mjs":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/startOfWeekYear.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   startOfWeekYear: function() { return /* binding */ startOfWeekYear; }\n/* harmony export */ });\n/* harmony import */ var _constructFrom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constructFrom.mjs */ \"(app-pages-browser)/./node_modules/date-fns/constructFrom.mjs\");\n/* harmony import */ var _getWeekYear_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWeekYear.mjs */ \"(app-pages-browser)/./node_modules/date-fns/getWeekYear.mjs\");\n/* harmony import */ var _startOfWeek_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./startOfWeek.mjs */ \"(app-pages-browser)/./node_modules/date-fns/startOfWeek.mjs\");\n/* harmony import */ var _lib_defaultOptions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_lib/defaultOptions.mjs */ \"(app-pages-browser)/./node_modules/date-fns/_lib/defaultOptions.mjs\");\n\n\n\n\n/**\n * The {@link startOfWeekYear} function options.\n */ /**\n * @name startOfWeekYear\n * @category Week-Numbering Year Helpers\n * @summary Return the start of a local week-numbering year for the given date.\n *\n * @description\n * Return the start of a local week-numbering year.\n * The exact calculation depends on the values of\n * `options.weekStartsOn` (which is the index of the first day of the week)\n * and `options.firstWeekContainsDate` (which is the day of January, which is always in\n * the first week of the week-numbering year)\n *\n * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n * @param options - An object with options\n *\n * @returns The start of a week-numbering year\n *\n * @example\n * // The start of an a week-numbering year for 2 July 2005 with default settings:\n * const result = startOfWeekYear(new Date(2005, 6, 2))\n * //=> Sun Dec 26 2004 00:00:00\n *\n * @example\n * // The start of a week-numbering year for 2 July 2005\n * // if Monday is the first day of week\n * // and 4 January is always in the first week of the year:\n * const result = startOfWeekYear(new Date(2005, 6, 2), {\n *   weekStartsOn: 1,\n *   firstWeekContainsDate: 4\n * })\n * //=> Mon Jan 03 2005 00:00:00\n */ function startOfWeekYear(date, options) {\n    var _options_locale_options, _options_locale, _defaultOptions_locale_options, _defaultOptions_locale;\n    const defaultOptions = (0,_lib_defaultOptions_mjs__WEBPACK_IMPORTED_MODULE_0__.getDefaultOptions)();\n    var _options_firstWeekContainsDate, _ref, _ref1, _ref2;\n    const firstWeekContainsDate = (_ref2 = (_ref1 = (_ref = (_options_firstWeekContainsDate = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options_firstWeekContainsDate !== void 0 ? _options_firstWeekContainsDate : options === null || options === void 0 ? void 0 : (_options_locale = options.locale) === null || _options_locale === void 0 ? void 0 : (_options_locale_options = _options_locale.options) === null || _options_locale_options === void 0 ? void 0 : _options_locale_options.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : defaultOptions.firstWeekContainsDate) !== null && _ref1 !== void 0 ? _ref1 : (_defaultOptions_locale = defaultOptions.locale) === null || _defaultOptions_locale === void 0 ? void 0 : (_defaultOptions_locale_options = _defaultOptions_locale.options) === null || _defaultOptions_locale_options === void 0 ? void 0 : _defaultOptions_locale_options.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1;\n    const year = (0,_getWeekYear_mjs__WEBPACK_IMPORTED_MODULE_1__.getWeekYear)(date, options);\n    const firstWeek = (0,_constructFrom_mjs__WEBPACK_IMPORTED_MODULE_2__.constructFrom)(date, 0);\n    firstWeek.setFullYear(year, 0, firstWeekContainsDate);\n    firstWeek.setHours(0, 0, 0, 0);\n    const _date = (0,_startOfWeek_mjs__WEBPACK_IMPORTED_MODULE_3__.startOfWeek)(firstWeek, options);\n    return _date;\n}\n// Fallback for modularized imports:\n/* harmony default export */ __webpack_exports__[\"default\"] = (startOfWeekYear);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdGFydE9mV2Vla1llYXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW9EO0FBQ0o7QUFDQTtBQUNjO0FBRTlEOztDQUVDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUNDLEdBQ00sU0FBU0ksZ0JBQWdCQyxJQUFJLEVBQUVDLE9BQU87UUFJekNBLHlCQUFBQSxpQkFFQUMsZ0NBQUFBO0lBTEYsTUFBTUEsaUJBQWlCSiwwRUFBaUJBO1FBRXRDRyxnQ0FBQUEsTUFBQUEsT0FBQUE7SUFERixNQUFNRSx3QkFDSkYsQ0FBQUEsUUFBQUEsQ0FBQUEsUUFBQUEsQ0FBQUEsT0FBQUEsQ0FBQUEsaUNBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0UscUJBQXFCLGNBQTlCRiw0Q0FBQUEsaUNBQ0FBLG9CQUFBQSwrQkFBQUEsa0JBQUFBLFFBQVNHLE1BQU0sY0FBZkgsdUNBQUFBLDBCQUFBQSxnQkFBaUJBLE9BQU8sY0FBeEJBLDhDQUFBQSx3QkFBMEJFLHFCQUFxQixjQUQvQ0Ysa0JBQUFBLE9BRUFDLGVBQWVDLHFCQUFxQixjQUZwQ0YsbUJBQUFBLFNBR0FDLHlCQUFBQSxlQUFlRSxNQUFNLGNBQXJCRiw4Q0FBQUEsaUNBQUFBLHVCQUF1QkQsT0FBTyxjQUE5QkMscURBQUFBLCtCQUFnQ0MscUJBQXFCLGNBSHJERixtQkFBQUEsUUFJQTtJQUVGLE1BQU1JLE9BQU9ULDZEQUFXQSxDQUFDSSxNQUFNQztJQUMvQixNQUFNSyxZQUFZWCxpRUFBYUEsQ0FBQ0ssTUFBTTtJQUN0Q00sVUFBVUMsV0FBVyxDQUFDRixNQUFNLEdBQUdGO0lBQy9CRyxVQUFVRSxRQUFRLENBQUMsR0FBRyxHQUFHLEdBQUc7SUFDNUIsTUFBTUMsUUFBUVosNkRBQVdBLENBQUNTLFdBQVdMO0lBQ3JDLE9BQU9RO0FBQ1Q7QUFFQSxvQ0FBb0M7QUFDcEMsK0RBQWVWLGVBQWVBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3N0YXJ0T2ZXZWVrWWVhci5tanM/ZjM0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb25zdHJ1Y3RGcm9tIH0gZnJvbSBcIi4vY29uc3RydWN0RnJvbS5tanNcIjtcbmltcG9ydCB7IGdldFdlZWtZZWFyIH0gZnJvbSBcIi4vZ2V0V2Vla1llYXIubWpzXCI7XG5pbXBvcnQgeyBzdGFydE9mV2VlayB9IGZyb20gXCIuL3N0YXJ0T2ZXZWVrLm1qc1wiO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdE9wdGlvbnMgfSBmcm9tIFwiLi9fbGliL2RlZmF1bHRPcHRpb25zLm1qc1wiO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgc3RhcnRPZldlZWtZZWFyfSBmdW5jdGlvbiBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQG5hbWUgc3RhcnRPZldlZWtZZWFyXG4gKiBAY2F0ZWdvcnkgV2Vlay1OdW1iZXJpbmcgWWVhciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhciBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhci5cbiAqIFRoZSBleGFjdCBjYWxjdWxhdGlvbiBkZXBlbmRzIG9uIHRoZSB2YWx1ZXMgb2ZcbiAqIGBvcHRpb25zLndlZWtTdGFydHNPbmAgKHdoaWNoIGlzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrKVxuICogYW5kIGBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZWAgKHdoaWNoIGlzIHRoZSBkYXkgb2YgSmFudWFyeSwgd2hpY2ggaXMgYWx3YXlzIGluXG4gKiB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgd2Vlay1udW1iZXJpbmcgeWVhcilcbiAqXG4gKiBXZWVrIG51bWJlcmluZzogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2VlayNUaGVfSVNPX3dlZWtfZGF0ZV9zeXN0ZW1cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyBUaGUgc3RhcnQgb2YgYSB3ZWVrLW51bWJlcmluZyB5ZWFyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBzdGFydCBvZiBhbiBhIHdlZWstbnVtYmVyaW5nIHllYXIgZm9yIDIgSnVseSAyMDA1IHdpdGggZGVmYXVsdCBzZXR0aW5nczpcbiAqIGNvbnN0IHJlc3VsdCA9IHN0YXJ0T2ZXZWVrWWVhcihuZXcgRGF0ZSgyMDA1LCA2LCAyKSlcbiAqIC8vPT4gU3VuIERlYyAyNiAyMDA0IDAwOjAwOjAwXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBzdGFydCBvZiBhIHdlZWstbnVtYmVyaW5nIHllYXIgZm9yIDIgSnVseSAyMDA1XG4gKiAvLyBpZiBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB3ZWVrXG4gKiAvLyBhbmQgNCBKYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhcjpcbiAqIGNvbnN0IHJlc3VsdCA9IHN0YXJ0T2ZXZWVrWWVhcihuZXcgRGF0ZSgyMDA1LCA2LCAyKSwge1xuICogICB3ZWVrU3RhcnRzT246IDEsXG4gKiAgIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZTogNFxuICogfSlcbiAqIC8vPT4gTW9uIEphbiAwMyAyMDA1IDAwOjAwOjAwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydE9mV2Vla1llYXIoZGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IGdldERlZmF1bHRPcHRpb25zKCk7XG4gIGNvbnN0IGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9XG4gICAgb3B0aW9ucz8uZmlyc3RXZWVrQ29udGFpbnNEYXRlID8/XG4gICAgb3B0aW9ucz8ubG9jYWxlPy5vcHRpb25zPy5maXJzdFdlZWtDb250YWluc0RhdGUgPz9cbiAgICBkZWZhdWx0T3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUgPz9cbiAgICBkZWZhdWx0T3B0aW9ucy5sb2NhbGU/Lm9wdGlvbnM/LmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA/P1xuICAgIDE7XG5cbiAgY29uc3QgeWVhciA9IGdldFdlZWtZZWFyKGRhdGUsIG9wdGlvbnMpO1xuICBjb25zdCBmaXJzdFdlZWsgPSBjb25zdHJ1Y3RGcm9tKGRhdGUsIDApO1xuICBmaXJzdFdlZWsuc2V0RnVsbFllYXIoeWVhciwgMCwgZmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcbiAgZmlyc3RXZWVrLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBjb25zdCBfZGF0ZSA9IHN0YXJ0T2ZXZWVrKGZpcnN0V2Vlaywgb3B0aW9ucyk7XG4gIHJldHVybiBfZGF0ZTtcbn1cblxuLy8gRmFsbGJhY2sgZm9yIG1vZHVsYXJpemVkIGltcG9ydHM6XG5leHBvcnQgZGVmYXVsdCBzdGFydE9mV2Vla1llYXI7XG4iXSwibmFtZXMiOlsiY29uc3RydWN0RnJvbSIsImdldFdlZWtZZWFyIiwic3RhcnRPZldlZWsiLCJnZXREZWZhdWx0T3B0aW9ucyIsInN0YXJ0T2ZXZWVrWWVhciIsImRhdGUiLCJvcHRpb25zIiwiZGVmYXVsdE9wdGlvbnMiLCJmaXJzdFdlZWtDb250YWluc0RhdGUiLCJsb2NhbGUiLCJ5ZWFyIiwiZmlyc3RXZWVrIiwic2V0RnVsbFllYXIiLCJzZXRIb3VycyIsIl9kYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/startOfWeekYear.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/startOfYear.mjs":
/*!***********************************************!*\
  !*** ./node_modules/date-fns/startOfYear.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   startOfYear: function() { return /* binding */ startOfYear; }\n/* harmony export */ });\n/* harmony import */ var _toDate_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toDate.mjs */ \"(app-pages-browser)/./node_modules/date-fns/toDate.mjs\");\n/* harmony import */ var _constructFrom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constructFrom.mjs */ \"(app-pages-browser)/./node_modules/date-fns/constructFrom.mjs\");\n\n\n/**\n * @name startOfYear\n * @category Year Helpers\n * @summary Return the start of a year for the given date.\n *\n * @description\n * Return the start of a year for the given date.\n * The result will be in the local timezone.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n *\n * @returns The start of a year\n *\n * @example\n * // The start of a year for 2 September 2014 11:55:00:\n * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))\n * //=> Wed Jan 01 2014 00:00:00\n */ function startOfYear(date) {\n    const cleanDate = (0,_toDate_mjs__WEBPACK_IMPORTED_MODULE_0__.toDate)(date);\n    const _date = (0,_constructFrom_mjs__WEBPACK_IMPORTED_MODULE_1__.constructFrom)(date, 0);\n    _date.setFullYear(cleanDate.getFullYear(), 0, 1);\n    _date.setHours(0, 0, 0, 0);\n    return _date;\n}\n// Fallback for modularized imports:\n/* harmony default export */ __webpack_exports__[\"default\"] = (startOfYear);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9zdGFydE9mWWVhci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXNDO0FBQ2M7QUFFcEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDTSxTQUFTRSxZQUFZQyxJQUFJO0lBQzlCLE1BQU1DLFlBQVlKLG1EQUFNQSxDQUFDRztJQUN6QixNQUFNRSxRQUFRSixpRUFBYUEsQ0FBQ0UsTUFBTTtJQUNsQ0UsTUFBTUMsV0FBVyxDQUFDRixVQUFVRyxXQUFXLElBQUksR0FBRztJQUM5Q0YsTUFBTUcsUUFBUSxDQUFDLEdBQUcsR0FBRyxHQUFHO0lBQ3hCLE9BQU9IO0FBQ1Q7QUFFQSxvQ0FBb0M7QUFDcEMsK0RBQWVILFdBQVdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3N0YXJ0T2ZZZWFyLm1qcz9hYTJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvRGF0ZSB9IGZyb20gXCIuL3RvRGF0ZS5tanNcIjtcbmltcG9ydCB7IGNvbnN0cnVjdEZyb20gfSBmcm9tIFwiLi9jb25zdHJ1Y3RGcm9tLm1qc1wiO1xuXG4vKipcbiAqIEBuYW1lIHN0YXJ0T2ZZZWFyXG4gKiBAY2F0ZWdvcnkgWWVhciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgeWVhciBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgeWVhciBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIEB0eXBlUGFyYW0gRGF0ZVR5cGUgLSBUaGUgYERhdGVgIHR5cGUsIHRoZSBmdW5jdGlvbiBvcGVyYXRlcyBvbi4gR2V0cyBpbmZlcnJlZCBmcm9tIHBhc3NlZCBhcmd1bWVudHMuIEFsbG93cyB0byB1c2UgZXh0ZW5zaW9ucyBsaWtlIFtgVVRDRGF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy91dGMpLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIG9yaWdpbmFsIGRhdGVcbiAqXG4gKiBAcmV0dXJucyBUaGUgc3RhcnQgb2YgYSB5ZWFyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBzdGFydCBvZiBhIHllYXIgZm9yIDIgU2VwdGVtYmVyIDIwMTQgMTE6NTU6MDA6XG4gKiBjb25zdCByZXN1bHQgPSBzdGFydE9mWWVhcihuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDAwKSlcbiAqIC8vPT4gV2VkIEphbiAwMSAyMDE0IDAwOjAwOjAwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydE9mWWVhcihkYXRlKSB7XG4gIGNvbnN0IGNsZWFuRGF0ZSA9IHRvRGF0ZShkYXRlKTtcbiAgY29uc3QgX2RhdGUgPSBjb25zdHJ1Y3RGcm9tKGRhdGUsIDApO1xuICBfZGF0ZS5zZXRGdWxsWWVhcihjbGVhbkRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gIF9kYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICByZXR1cm4gX2RhdGU7XG59XG5cbi8vIEZhbGxiYWNrIGZvciBtb2R1bGFyaXplZCBpbXBvcnRzOlxuZXhwb3J0IGRlZmF1bHQgc3RhcnRPZlllYXI7XG4iXSwibmFtZXMiOlsidG9EYXRlIiwiY29uc3RydWN0RnJvbSIsInN0YXJ0T2ZZZWFyIiwiZGF0ZSIsImNsZWFuRGF0ZSIsIl9kYXRlIiwic2V0RnVsbFllYXIiLCJnZXRGdWxsWWVhciIsInNldEhvdXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/startOfYear.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/date-fns/toDate.mjs":
/*!******************************************!*\
  !*** ./node_modules/date-fns/toDate.mjs ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toDate: function() { return /* binding */ toDate; }\n/* harmony export */ });\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param argument - The value to convert\n *\n * @returns The parsed date in the local time zone\n *\n * @example\n * // Clone the date:\n * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert the timestamp to date:\n * const result = toDate(1392098430000)\n * //=> Tue Feb 11 2014 11:30:30\n */ function toDate(argument) {\n    const argStr = Object.prototype.toString.call(argument);\n    // Clone the date\n    if (argument instanceof Date || typeof argument === \"object\" && argStr === \"[object Date]\") {\n        // Prevent the date to lose the milliseconds when passed to new Date() in IE10\n        return new argument.constructor(+argument);\n    } else if (typeof argument === \"number\" || argStr === \"[object Number]\" || typeof argument === \"string\" || argStr === \"[object String]\") {\n        // TODO: Can we get rid of as?\n        return new Date(argument);\n    } else {\n        // TODO: Can we get rid of as?\n        return new Date(NaN);\n    }\n}\n// Fallback for modularized imports:\n/* harmony default export */ __webpack_exports__[\"default\"] = (toDate);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy90b0RhdGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQStCQyxHQUNNLFNBQVNBLE9BQU9DLFFBQVE7SUFDN0IsTUFBTUMsU0FBU0MsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ0w7SUFFOUMsaUJBQWlCO0lBQ2pCLElBQ0VBLG9CQUFvQk0sUUFDbkIsT0FBT04sYUFBYSxZQUFZQyxXQUFXLGlCQUM1QztRQUNBLDhFQUE4RTtRQUM5RSxPQUFPLElBQUlELFNBQVNPLFdBQVcsQ0FBQyxDQUFDUDtJQUNuQyxPQUFPLElBQ0wsT0FBT0EsYUFBYSxZQUNwQkMsV0FBVyxxQkFDWCxPQUFPRCxhQUFhLFlBQ3BCQyxXQUFXLG1CQUNYO1FBQ0EsOEJBQThCO1FBQzlCLE9BQU8sSUFBSUssS0FBS047SUFDbEIsT0FBTztRQUNMLDhCQUE4QjtRQUM5QixPQUFPLElBQUlNLEtBQUtFO0lBQ2xCO0FBQ0Y7QUFFQSxvQ0FBb0M7QUFDcEMsK0RBQWVULE1BQU1BLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL3RvRGF0ZS5tanM/Yzk4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBuYW1lIHRvRGF0ZVxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb252ZXJ0IHRoZSBnaXZlbiBhcmd1bWVudCB0byBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgaXRzIGNsb25lLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhIG51bWJlciwgaXQgaXMgdHJlYXRlZCBhcyBhIHRpbWVzdGFtcC5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgbm9uZSBvZiB0aGUgYWJvdmUsIHRoZSBmdW5jdGlvbiByZXR1cm5zIEludmFsaWQgRGF0ZS5cbiAqXG4gKiAqKk5vdGUqKjogKmFsbCogRGF0ZSBhcmd1bWVudHMgcGFzc2VkIHRvIGFueSAqZGF0ZS1mbnMqIGZ1bmN0aW9uIGlzIHByb2Nlc3NlZCBieSBgdG9EYXRlYC5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGVUeXBlIC0gVGhlIGBEYXRlYCB0eXBlLCB0aGUgZnVuY3Rpb24gb3BlcmF0ZXMgb24uIEdldHMgaW5mZXJyZWQgZnJvbSBwYXNzZWQgYXJndW1lbnRzLiBBbGxvd3MgdG8gdXNlIGV4dGVuc2lvbnMgbGlrZSBbYFVUQ0RhdGVgXShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvdXRjKS5cbiAqXG4gKiBAcGFyYW0gYXJndW1lbnQgLSBUaGUgdmFsdWUgdG8gY29udmVydFxuICpcbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgZGF0ZSBpbiB0aGUgbG9jYWwgdGltZSB6b25lXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENsb25lIHRoZSBkYXRlOlxuICogY29uc3QgcmVzdWx0ID0gdG9EYXRlKG5ldyBEYXRlKDIwMTQsIDEsIDExLCAxMSwgMzAsIDMwKSlcbiAqIC8vPT4gVHVlIEZlYiAxMSAyMDE0IDExOjMwOjMwXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnZlcnQgdGhlIHRpbWVzdGFtcCB0byBkYXRlOlxuICogY29uc3QgcmVzdWx0ID0gdG9EYXRlKDEzOTIwOTg0MzAwMDApXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EYXRlKGFyZ3VtZW50KSB7XG4gIGNvbnN0IGFyZ1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudCk7XG5cbiAgLy8gQ2xvbmUgdGhlIGRhdGVcbiAgaWYgKFxuICAgIGFyZ3VtZW50IGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICh0eXBlb2YgYXJndW1lbnQgPT09IFwib2JqZWN0XCIgJiYgYXJnU3RyID09PSBcIltvYmplY3QgRGF0ZV1cIilcbiAgKSB7XG4gICAgLy8gUHJldmVudCB0aGUgZGF0ZSB0byBsb3NlIHRoZSBtaWxsaXNlY29uZHMgd2hlbiBwYXNzZWQgdG8gbmV3IERhdGUoKSBpbiBJRTEwXG4gICAgcmV0dXJuIG5ldyBhcmd1bWVudC5jb25zdHJ1Y3RvcigrYXJndW1lbnQpO1xuICB9IGVsc2UgaWYgKFxuICAgIHR5cGVvZiBhcmd1bWVudCA9PT0gXCJudW1iZXJcIiB8fFxuICAgIGFyZ1N0ciA9PT0gXCJbb2JqZWN0IE51bWJlcl1cIiB8fFxuICAgIHR5cGVvZiBhcmd1bWVudCA9PT0gXCJzdHJpbmdcIiB8fFxuICAgIGFyZ1N0ciA9PT0gXCJbb2JqZWN0IFN0cmluZ11cIlxuICApIHtcbiAgICAvLyBUT0RPOiBDYW4gd2UgZ2V0IHJpZCBvZiBhcz9cbiAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE86IENhbiB3ZSBnZXQgcmlkIG9mIGFzP1xuICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICB9XG59XG5cbi8vIEZhbGxiYWNrIGZvciBtb2R1bGFyaXplZCBpbXBvcnRzOlxuZXhwb3J0IGRlZmF1bHQgdG9EYXRlO1xuIl0sIm5hbWVzIjpbInRvRGF0ZSIsImFyZ3VtZW50IiwiYXJnU3RyIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiRGF0ZSIsImNvbnN0cnVjdG9yIiwiTmFOIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/date-fns/toDate.mjs\n"));

/***/ })

});